(window.webpackJsonp=window.webpackJsonp||[]).push([[0],[]]);!function(n){function e(e){for(var a,o,s=e[0],l=e[1],c=e[2],d=0,u=[];d<s.length;d++)o=s[d],Object.prototype.hasOwnProperty.call(r,o)&&r[o]&&u.push(r[o][0]),r[o]=0;for(a in l)Object.prototype.hasOwnProperty.call(l,a)&&(n[a]=l[a]);for(p&&p(e);u.length;)u.shift()();return i.push.apply(i,c||[]),t()}function t(){for(var n,e=0;e<i.length;e++){for(var t=i[e],a=!0,s=1;s<t.length;s++){var l=t[s];0!==r[l]&&(a=!1)}a&&(i.splice(e--,1),n=o(o.s=t[0]))}return n}var a={},r={1:0},i=[];function o(e){if(a[e])return a[e].exports;var t=a[e]={i:e,l:!1,exports:{}};return n[e].call(t.exports,t,t.exports,o),t.l=!0,t.exports}o.e=function(n){var e=[],t=r[n];if(0!==t)if(t)e.push(t[2]);else{var a=new Promise((function(e,a){t=r[n]=[e,a]}));e.push(t[2]=a);var i,s=document.createElement("script");s.charset="utf-8",s.timeout=120,o.nc&&s.setAttribute("nonce",o.nc),s.src=function(n){return o.p+"assets/js/"+({}[n]||n)+"."+{2:"b26d2d6f",3:"06d11c12",4:"5017c5ca",5:"9c242416",6:"20f6982a",7:"c22f1339",8:"ae196373",9:"8343be2b",10:"9835140b",11:"a344c44c",12:"6c3779eb",13:"c8c7bdfc",14:"ad7af1a6",15:"8b3c0729",16:"c1c0aecd",17:"af1d3673",18:"0454c454",19:"d4a6d66e",20:"6802ce4f",21:"2ad20985",22:"cd5b0f4c",23:"bf12760c",24:"a97a2586",25:"48031560",26:"6be7ec6d",27:"0c0df986",28:"e9a560ea",29:"cf1113c2",30:"1b388932",31:"081ffab8",32:"6ea862c0",33:"8bd40136",34:"7cee60c6",35:"371d75ef",36:"47833f09",37:"214e2e95",38:"c6722d01",39:"20a3b9cb",40:"86083673",41:"e7e989a2",42:"34f23de4",43:"a7ede29c",44:"45494eb9",45:"6e0eeb95",46:"fefb824e",47:"df699a79",48:"b68ca663",49:"ba202507",50:"a6091dab",51:"b861edbe",52:"6b35c587",53:"5f2a0ebc",54:"b5e26534",55:"613040e2",56:"9ab9c6e2",57:"cc446335",58:"0e242b8b",59:"6aa08481",60:"0557abc0",61:"4427fee6",62:"1f3f715a",63:"4f926569",64:"1912c51e",65:"12fece43",66:"bb0efb3e",67:"f58a99ff",68:"6ab84507",69:"c6ba72df",70:"b1537c5e",71:"b420bd4b",72:"78c4a3c7",73:"8aadaa9c",74:"3469eeaf",75:"b5926b2c",76:"a02a1258",77:"3fba8030",78:"005339c3",79:"249bf1d4",80:"c1c51503",81:"b88a3411",82:"ce2ad3c5",83:"5462e5ab",84:"4ea64a5f",85:"834ddd6e",86:"9f3a037c",87:"e8cf081d",88:"8828c903",89:"d29f7b67",90:"499a669a",91:"bfd28dc1",92:"9a32c16b",93:"37331bfa",94:"a6018404",95:"59c9ede3",96:"8ce488d6",97:"039c6ccf",98:"4f983a7d",99:"f3075957",100:"2f33b907",101:"10644bc7",102:"33f52f92",103:"214c07bb",104:"03df0470",105:"d3726112",106:"075ad0d9"}[n]+".js"}(n);var l=new Error;i=function(e){s.onerror=s.onload=null,clearTimeout(c);var t=r[n];if(0!==t){if(t){var a=e&&("load"===e.type?"missing":e.type),i=e&&e.target&&e.target.src;l.message="Loading chunk "+n+" failed.\n("+a+": "+i+")",l.name="ChunkLoadError",l.type=a,l.request=i,t[1](l)}r[n]=void 0}};var c=setTimeout((function(){i({type:"timeout",target:s})}),12e4);s.onerror=s.onload=i,document.head.appendChild(s)}return Promise.all(e)},o.m=n,o.c=a,o.d=function(n,e,t){o.o(n,e)||Object.defineProperty(n,e,{enumerable:!0,get:t})},o.r=function(n){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},o.t=function(n,e){if(1&e&&(n=o(n)),8&e)return n;if(4&e&&"object"==typeof n&&n&&n.__esModule)return n;var t=Object.create(null);if(o.r(t),Object.defineProperty(t,"default",{enumerable:!0,value:n}),2&e&&"string"!=typeof n)for(var a in n)o.d(t,a,function(e){return n[e]}.bind(null,a));return t},o.n=function(n){var e=n&&n.__esModule?function(){return n.default}:function(){return n};return o.d(e,"a",e),e},o.o=function(n,e){return Object.prototype.hasOwnProperty.call(n,e)},o.p="/",o.oe=function(n){throw console.error(n),n};var s=window.webpackJsonp=window.webpackJsonp||[],l=s.push.bind(s);s.push=e,s=s.slice();for(var c=0;c<s.length;c++)e(s[c]);var p=l;i.push([104,0]),t()}([function(n,e,t){var a=t(56),r=a.all;n.exports=a.IS_HTMLDDA?function(n){return"function"==typeof n||n===r}:function(n){return"function"==typeof n}},function(n,e,t){var a=t(29),r=Function.prototype,i=r.call,o=a&&r.bind.bind(i,i);n.exports=a?o:function(n){return function(){return i.apply(n,arguments)}}},function(n,e){var t=function(n){return n&&n.Math==Math&&n};n.exports=t("object"==typeof globalThis&&globalThis)||t("object"==typeof window&&window)||t("object"==typeof self&&self)||t("object"==typeof global&&global)||function(){return this}()||Function("return this")()},function(n,e){n.exports=function(n){try{return!!n()}catch(n){return!0}}},function(n,e,t){"use strict";function a(n,e,t,a,r,i,o,s){var l,c="function"==typeof n?n.options:n;if(e&&(c.render=e,c.staticRenderFns=t,c._compiled=!0),a&&(c.functional=!0),i&&(c._scopeId="data-v-"+i),o?(l=function(n){(n=n||this.$vnode&&this.$vnode.ssrContext||this.parent&&this.parent.$vnode&&this.parent.$vnode.ssrContext)||"undefined"==typeof __VUE_SSR_CONTEXT__||(n=__VUE_SSR_CONTEXT__),r&&r.call(this,n),n&&n._registeredComponents&&n._registeredComponents.add(o)},c._ssrRegister=l):r&&(l=s?function(){r.call(this,(c.functional?this.parent:this).$root.$options.shadowRoot)}:r),l)if(c.functional){c._injectStyles=l;var p=c.render;c.render=function(n,e){return l.call(e),p(n,e)}}else{var d=c.beforeCreate;c.beforeCreate=d?[].concat(d,l):[l]}return{exports:n,options:c}}t.d(e,"a",(function(){return a}))},function(n,e,t){var a=t(3);n.exports=!a((function(){return 7!=Object.defineProperty({},1,{get:function(){return 7}})[1]}))},function(n,e){var t=Array.isArray;n.exports=t},function(n,e,t){var a=t(1),r=t(33),i=a({}.hasOwnProperty);n.exports=Object.hasOwn||function(n,e){return i(r(n),e)}},function(n,e,t){var a=t(70),r="object"==typeof self&&self&&self.Object===Object&&self,i=a||r||Function("return this")();n.exports=i},function(n,e,t){var a=t(0),r=t(56),i=r.all;n.exports=r.IS_HTMLDDA?function(n){return"object"==typeof n?null!==n:a(n)||n===i}:function(n){return"object"==typeof n?null!==n:a(n)}},function(n,e,t){var a=t(165),r=t(168);n.exports=function(n,e){var t=r(n,e);return a(t)?t:void 0}},function(n,e,t){"use strict";t.d(e,"e",(function(){return a})),t.d(e,"b",(function(){return i})),t.d(e,"j",(function(){return o})),t.d(e,"g",(function(){return l})),t.d(e,"h",(function(){return c})),t.d(e,"i",(function(){return p})),t.d(e,"c",(function(){return d})),t.d(e,"f",(function(){return u})),t.d(e,"l",(function(){return m})),t.d(e,"m",(function(){return g})),t.d(e,"d",(function(){return h})),t.d(e,"k",(function(){return v})),t.d(e,"n",(function(){return f})),t.d(e,"a",(function(){return x}));t(18);const a=/#.*$/,r=/\.(md|html)$/,i=/\/$/,o=/^[a-z]+:/i;function s(n){return decodeURI(n).replace(a,"").replace(r,"")}function l(n){return o.test(n)}function c(n){return/^mailto:/.test(n)}function p(n){return/^tel:/.test(n)}function d(n){if(l(n))return n;if(!n)return"404";const e=n.match(a),t=e?e[0]:"",r=s(n);return i.test(r)?n:r+".html"+t}function u(n,e){const t=n.hash,r=function(n){const e=n&&n.match(a);if(e)return e[0]}(e);if(r&&t!==r)return!1;return s(n.path)===s(e)}function m(n,e,t){if(l(e))return{type:"external",path:e};t&&(e=function(n,e,t){const a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;const r=e.split("/");t&&r[r.length-1]||r.pop();const i=n.replace(/^\//,"").split("/");for(let n=0;n<i.length;n++){const e=i[n];".."===e?r.pop():"."!==e&&r.push(e)}""!==r[0]&&r.unshift("");return r.join("/")}(e,t));const a=s(e);for(let e=0;e<n.length;e++)if(s(n[e].regularPath)===a)return Object.assign({},n[e],{type:"page",path:d(n[e].path)});return console.error(`[vuepress] No matching page found for sidebar item "${e}"`),{}}function g(n,e,t,a){const{pages:r,themeConfig:i}=t,o=a&&i.locales&&i.locales[a]||i;if("auto"===(n.frontmatter.sidebar||o.sidebar||i.sidebar))return b(n);const s=o.sidebar||i.sidebar;if(s){const{base:t,config:a}=function(n,e){if(Array.isArray(e))return{base:"/",config:e};for(const a in e)if(0===(t=n,/(\.html|\/)$/.test(t)?t:t+"/").indexOf(encodeURI(a)))return{base:a,config:e[a]};var t;return{}}(e,s);return"auto"===a?b(n):a?a.map(n=>function n(e,t,a,r=1){if("string"==typeof e)return m(t,e,a);if(Array.isArray(e))return Object.assign(m(t,e[0],a),{title:e[1]});{r>3&&console.error("[vuepress] detected a too deep nested sidebar group.");const i=e.children||[];return 0===i.length&&e.path?Object.assign(m(t,e.path,a),{title:e.title}):{type:"group",path:e.path,title:e.title,sidebarDepth:e.sidebarDepth,initialOpenGroupIndex:e.initialOpenGroupIndex,children:i.map(e=>n(e,t,a,r+1)),collapsable:!1!==e.collapsable}}}(n,r,t)):[]}return[]}function b(n){const e=h(n.headers||[]);return[{type:"group",collapsable:!1,title:n.title,path:null,children:e.map(e=>({type:"auto",title:e.title,basePath:n.path,path:n.path+"#"+e.slug,children:e.children||[]}))}]}function h(n){let e;return(n=n.map(n=>Object.assign({},n))).forEach(n=>{2===n.level?e=n:e&&(e.children||(e.children=[])).push(n)}),n.filter(n=>2===n.level)}function v(n){return Object.assign(n,{type:n.items&&n.items.length?"links":"link"})}function f(n){return Object.prototype.toString.call(n).match(/\[object (.*?)\]/)[1].toLowerCase()}function y(n){let e=n.frontmatter.date||n.lastUpdated||new Date,t=new Date(e);return"Invalid Date"==t&&e&&(t=new Date(e.replace(/-/g,"/"))),t.getTime()}function x(n,e){return y(e)-y(n)}},function(n,e){n.exports=function(n){return null!=n&&"object"==typeof n}},function(n,e,t){var a=t(5),r=t(65),i=t(100),o=t(28),s=t(55),l=TypeError,c=Object.defineProperty,p=Object.getOwnPropertyDescriptor;e.f=a?i?function(n,e,t){if(o(n),e=s(e),o(t),"function"==typeof n&&"prototype"===e&&"value"in t&&"writable"in t&&!t.writable){var a=p(n,e);a&&a.writable&&(n[e]=t.value,t={configurable:"configurable"in t?t.configurable:a.configurable,enumerable:"enumerable"in t?t.enumerable:a.enumerable,writable:!1})}return c(n,e,t)}:c:function(n,e,t){if(o(n),e=s(e),o(t),r)try{return c(n,e,t)}catch(n){}if("get"in t||"set"in t)throw l("Accessors not supported");return"value"in t&&(n[e]=t.value),n}},function(n,e,t){var a=t(16),r=t(150),i=t(151),o=a?a.toStringTag:void 0;n.exports=function(n){return null==n?void 0===n?"[object Undefined]":"[object Null]":o&&o in Object(n)?r(n):i(n)}},function(n,e,t){var a=t(5),r=t(13),i=t(36);n.exports=a?function(n,e,t){return r.f(n,e,i(1,t))}:function(n,e,t){return n[e]=t,n}},function(n,e,t){var a=t(8).Symbol;n.exports=a},function(n){n.exports=JSON.parse('{"name":"vuepress-plugin-vdoing-comment","version":"1.0.7","description":"Comment plugin in vuepress vdoing theme, supports Gitalk, Valine, Artalk...","main":"index.js","scripts":{"test":"echo \\"Error: no test specified\\" && exit 1"},"repository":{"type":"git","url":"git+ssh://git@github.com/terwer/vuepress-plugin-vdoing-comment.git"},"keywords":["vuepress","comment","plugin","vue","gitalk","valine","artalk"],"author":"terwer","license":"MIT","bugs":{"url":"https://github.com/terwer/vuepress-plugin-vdoing-comment/issues"},"homepage":"https://github.com/terwer/vuepress-plugin-vdoing-comment/blob/main/README.md","dependencies":{"ejs":"^3.1.8","gitalk":"^1.5.0","gitalk-fix":"^1.5.2","i":"^0.3.6","npm":"^6.9.0","valine":"^1.3.9","artalk":"^2.4.4"}}')},function(n,e,t){"use strict";var a=t(19),r=t(33),i=t(34),o=t(129),s=t(131);a({target:"Array",proto:!0,arity:1,forced:t(3)((function(){return 4294967297!==[].push.call({length:4294967296},1)}))||!function(){try{Object.defineProperty([],"length",{writable:!1}).push()}catch(n){return n instanceof TypeError}}()},{push:function(n){var e=r(this),t=i(e),a=arguments.length;s(t+a);for(var l=0;l<a;l++)e[t]=arguments[l],t++;return o(e,t),t}})},function(n,e,t){var a=t(2),r=t(52).f,i=t(15),o=t(112),s=t(38),l=t(66),c=t(125);n.exports=function(n,e){var t,p,d,u,m,g=n.target,b=n.global,h=n.stat;if(t=b?a:h?a[g]||s(g,{}):(a[g]||{}).prototype)for(p in e){if(u=e[p],d=n.dontCallGetSet?(m=r(t,p))&&m.value:t[p],!c(b?p:g+(h?".":"#")+p,n.forced)&&void 0!==d){if(typeof u==typeof d)continue;l(u,d)}(n.sham||d&&d.sham)&&i(u,"sham",!0),o(t,p,u,n)}}},function(n,e,t){var a=t(1),r=a({}.toString),i=a("".slice);n.exports=function(n){return i(r(n),8,-1)}},function(n,e,t){var a=t(2),r=t(62),i=t(7),o=t(64),s=t(60),l=t(59),c=a.Symbol,p=r("wks"),d=l?c.for||c:c&&c.withoutSetter||o;n.exports=function(n){return i(p,n)||(p[n]=s&&i(c,n)?c[n]:d("Symbol."+n)),p[n]}},function(n,e,t){var a=t(155),r=t(156),i=t(157),o=t(158),s=t(159);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=r,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var a=t(72);n.exports=function(n,e){for(var t=n.length;t--;)if(a(n[t][0],e))return t;return-1}},function(n,e,t){var a=t(10)(Object,"create");n.exports=a},function(n,e,t){var a=t(177);n.exports=function(n,e){var t=n.__data__;return a(e)?t["string"==typeof e?"string":"hash"]:t.map}},function(n,e,t){var a=t(46);n.exports=function(n){if("string"==typeof n||a(n))return n;var e=n+"";return"0"==e&&1/n==-1/0?"-0":e}},function(n,e,t){var a,r;
/* NProgress, (c) 2013, 2014 Rico Sta. Cruz - http://ricostacruz.com/nprogress
 * @license MIT */void 0===(r="function"==typeof(a=function(){var n,e,t={version:"0.2.0"},a=t.settings={minimum:.08,easing:"ease",positionUsing:"",speed:200,trickle:!0,trickleRate:.02,trickleSpeed:800,showSpinner:!0,barSelector:'[role="bar"]',spinnerSelector:'[role="spinner"]',parent:"body",template:'<div class="bar" role="bar"><div class="peg"></div></div><div class="spinner" role="spinner"><div class="spinner-icon"></div></div>'};function r(n,e,t){return n<e?e:n>t?t:n}function i(n){return 100*(-1+n)}t.configure=function(n){var e,t;for(e in n)void 0!==(t=n[e])&&n.hasOwnProperty(e)&&(a[e]=t);return this},t.status=null,t.set=function(n){var e=t.isStarted();n=r(n,a.minimum,1),t.status=1===n?null:n;var l=t.render(!e),c=l.querySelector(a.barSelector),p=a.speed,d=a.easing;return l.offsetWidth,o((function(e){""===a.positionUsing&&(a.positionUsing=t.getPositioningCSS()),s(c,function(n,e,t){var r;return(r="translate3d"===a.positionUsing?{transform:"translate3d("+i(n)+"%,0,0)"}:"translate"===a.positionUsing?{transform:"translate("+i(n)+"%,0)"}:{"margin-left":i(n)+"%"}).transition="all "+e+"ms "+t,r}(n,p,d)),1===n?(s(l,{transition:"none",opacity:1}),l.offsetWidth,setTimeout((function(){s(l,{transition:"all "+p+"ms linear",opacity:0}),setTimeout((function(){t.remove(),e()}),p)}),p)):setTimeout(e,p)})),this},t.isStarted=function(){return"number"==typeof t.status},t.start=function(){t.status||t.set(0);var n=function(){setTimeout((function(){t.status&&(t.trickle(),n())}),a.trickleSpeed)};return a.trickle&&n(),this},t.done=function(n){return n||t.status?t.inc(.3+.5*Math.random()).set(1):this},t.inc=function(n){var e=t.status;return e?("number"!=typeof n&&(n=(1-e)*r(Math.random()*e,.1,.95)),e=r(e+n,0,.994),t.set(e)):t.start()},t.trickle=function(){return t.inc(Math.random()*a.trickleRate)},n=0,e=0,t.promise=function(a){return a&&"resolved"!==a.state()?(0===e&&t.start(),n++,e++,a.always((function(){0==--e?(n=0,t.done()):t.set((n-e)/n)})),this):this},t.render=function(n){if(t.isRendered())return document.getElementById("nprogress");c(document.documentElement,"nprogress-busy");var e=document.createElement("div");e.id="nprogress",e.innerHTML=a.template;var r,o=e.querySelector(a.barSelector),l=n?"-100":i(t.status||0),p=document.querySelector(a.parent);return s(o,{transition:"all 0 linear",transform:"translate3d("+l+"%,0,0)"}),a.showSpinner||(r=e.querySelector(a.spinnerSelector))&&u(r),p!=document.body&&c(p,"nprogress-custom-parent"),p.appendChild(e),e},t.remove=function(){p(document.documentElement,"nprogress-busy"),p(document.querySelector(a.parent),"nprogress-custom-parent");var n=document.getElementById("nprogress");n&&u(n)},t.isRendered=function(){return!!document.getElementById("nprogress")},t.getPositioningCSS=function(){var n=document.body.style,e="WebkitTransform"in n?"Webkit":"MozTransform"in n?"Moz":"msTransform"in n?"ms":"OTransform"in n?"O":"";return e+"Perspective"in n?"translate3d":e+"Transform"in n?"translate":"margin"};var o=function(){var n=[];function e(){var t=n.shift();t&&t(e)}return function(t){n.push(t),1==n.length&&e()}}(),s=function(){var n=["Webkit","O","Moz","ms"],e={};function t(t){return t=t.replace(/^-ms-/,"ms-").replace(/-([\da-z])/gi,(function(n,e){return e.toUpperCase()})),e[t]||(e[t]=function(e){var t=document.body.style;if(e in t)return e;for(var a,r=n.length,i=e.charAt(0).toUpperCase()+e.slice(1);r--;)if((a=n[r]+i)in t)return a;return e}(t))}function a(n,e,a){e=t(e),n.style[e]=a}return function(n,e){var t,r,i=arguments;if(2==i.length)for(t in e)void 0!==(r=e[t])&&e.hasOwnProperty(t)&&a(n,t,r);else a(n,i[1],i[2])}}();function l(n,e){return("string"==typeof n?n:d(n)).indexOf(" "+e+" ")>=0}function c(n,e){var t=d(n),a=t+e;l(t,e)||(n.className=a.substring(1))}function p(n,e){var t,a=d(n);l(n,e)&&(t=a.replace(" "+e+" "," "),n.className=t.substring(1,t.length-1))}function d(n){return(" "+(n.className||"")+" ").replace(/\s+/gi," ")}function u(n){n&&n.parentNode&&n.parentNode.removeChild(n)}return t})?a.call(e,t,e,n):a)||(n.exports=r)},function(n,e,t){var a=t(9),r=String,i=TypeError;n.exports=function(n){if(a(n))return n;throw i(r(n)+" is not an object")}},function(n,e,t){var a=t(3);n.exports=!a((function(){var n=function(){}.bind();return"function"!=typeof n||n.hasOwnProperty("prototype")}))},function(n,e,t){var a=t(48),r=t(53);n.exports=function(n){return a(r(n))}},function(n,e,t){var a=t(2),r=t(0),i=function(n){return r(n)?n:void 0};n.exports=function(n,e){return arguments.length<2?i(a[n]):a[n]&&a[n][e]}},function(n,e,t){var a=t(0),r=t(110),i=TypeError;n.exports=function(n){if(a(n))return n;throw i(r(n)+" is not a function")}},function(n,e,t){var a=t(53),r=Object;n.exports=function(n){return r(a(n))}},function(n,e,t){var a=t(123);n.exports=function(n){return a(n.length)}},function(n,e,t){var a=t(29),r=Function.prototype.call;n.exports=a?r.bind(r):function(){return r.apply(r,arguments)}},function(n,e){n.exports=function(n,e){return{enumerable:!(1&n),configurable:!(2&n),writable:!(4&n),value:e}}},function(n,e,t){var a=t(2),r=t(38),i=a["__core-js_shared__"]||r("__core-js_shared__",{});n.exports=i},function(n,e,t){var a=t(2),r=Object.defineProperty;n.exports=function(n,e){try{r(a,n,{value:e,configurable:!0,writable:!0})}catch(t){a[n]=e}return e}},function(n,e,t){var a=t(149),r=t(12),i=Object.prototype,o=i.hasOwnProperty,s=i.propertyIsEnumerable,l=a(function(){return arguments}())?a:function(n){return r(n)&&o.call(n,"callee")&&!s.call(n,"callee")};n.exports=l},function(n,e,t){var a=t(10)(t(8),"Map");n.exports=a},function(n,e){n.exports=function(n){var e=typeof n;return null!=n&&("object"==e||"function"==e)}},function(n,e,t){var a=t(169),r=t(176),i=t(178),o=t(179),s=t(180);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=r,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n){t[++e]=n})),t}},function(n,e){n.exports=function(n){return"number"==typeof n&&n>-1&&n%1==0&&n<=9007199254740991}},function(n,e,t){var a=t(6),r=t(46),i=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,o=/^\w*$/;n.exports=function(n,e){if(a(n))return!1;var t=typeof n;return!("number"!=t&&"symbol"!=t&&"boolean"!=t&&null!=n&&!r(n))||(o.test(n)||!i.test(n)||null!=e&&n in Object(e))}},function(n,e,t){var a=t(14),r=t(12);n.exports=function(n){return"symbol"==typeof n||r(n)&&"[object Symbol]"==a(n)}},function(n,e){n.exports=function(n){return n}},function(n,e,t){var a=t(1),r=t(3),i=t(20),o=Object,s=a("".split);n.exports=r((function(){return!o("z").propertyIsEnumerable(0)}))?function(n){return"String"==i(n)?s(n,""):o(n)}:o},function(n,e){n.exports={}},function(n,e){n.exports=function(n){return n.webpackPolyfill||(n.deprecate=function(){},n.paths=[],n.children||(n.children=[]),Object.defineProperty(n,"loaded",{enumerable:!0,get:function(){return n.l}}),Object.defineProperty(n,"id",{enumerable:!0,get:function(){return n.i}}),n.webpackPolyfill=1),n}},function(n,e){var t=/^\s+|\s+$/g,a=/^[-+]0x[0-9a-f]+$/i,r=/^0b[01]+$/i,i=/^0o[0-7]+$/i,o=parseInt,s="object"==typeof global&&global&&global.Object===Object&&global,l="object"==typeof self&&self&&self.Object===Object&&self,c=s||l||Function("return this")(),p=Object.prototype.toString,d=Math.max,u=Math.min,m=function(){return c.Date.now()};function g(n){var e=typeof n;return!!n&&("object"==e||"function"==e)}function b(n){if("number"==typeof n)return n;if(function(n){return"symbol"==typeof n||function(n){return!!n&&"object"==typeof n}(n)&&"[object Symbol]"==p.call(n)}(n))return NaN;if(g(n)){var e="function"==typeof n.valueOf?n.valueOf():n;n=g(e)?e+"":e}if("string"!=typeof n)return 0===n?n:+n;n=n.replace(t,"");var s=r.test(n);return s||i.test(n)?o(n.slice(2),s?2:8):a.test(n)?NaN:+n}n.exports=function(n,e,t){var a,r,i,o,s,l,c=0,p=!1,h=!1,v=!0;if("function"!=typeof n)throw new TypeError("Expected a function");function f(e){var t=a,i=r;return a=r=void 0,c=e,o=n.apply(i,t)}function y(n){return c=n,s=setTimeout(w,e),p?f(n):o}function x(n){var t=n-l;return void 0===l||t>=e||t<0||h&&n-c>=i}function w(){var n=m();if(x(n))return S(n);s=setTimeout(w,function(n){var t=e-(n-l);return h?u(t,i-(n-c)):t}(n))}function S(n){return s=void 0,v&&a?f(n):(a=r=void 0,o)}function j(){var n=m(),t=x(n);if(a=arguments,r=this,l=n,t){if(void 0===s)return y(l);if(h)return s=setTimeout(w,e),f(l)}return void 0===s&&(s=setTimeout(w,e)),o}return e=b(e)||0,g(t)&&(p=!!t.leading,i=(h="maxWait"in t)?d(b(t.maxWait)||0,e):i,v="trailing"in t?!!t.trailing:v),j.cancel=function(){void 0!==s&&clearTimeout(s),c=0,a=l=r=s=void 0},j.flush=function(){return void 0===s?o:S(m())},j}},function(n,e,t){var a=t(5),r=t(35),i=t(106),o=t(36),s=t(30),l=t(55),c=t(7),p=t(65),d=Object.getOwnPropertyDescriptor;e.f=a?d:function(n,e){if(n=s(n),e=l(e),p)try{return d(n,e)}catch(n){}if(c(n,e))return o(!r(i.f,n,e),n[e])}},function(n,e,t){var a=t(54),r=TypeError;n.exports=function(n){if(a(n))throw r("Can't call method on "+n);return n}},function(n,e){n.exports=function(n){return null==n}},function(n,e,t){var a=t(107),r=t(57);n.exports=function(n){var e=a(n,"string");return r(e)?e:e+""}},function(n,e){var t="object"==typeof document&&document.all,a=void 0===t&&void 0!==t;n.exports={all:t,IS_HTMLDDA:a}},function(n,e,t){var a=t(31),r=t(0),i=t(58),o=t(59),s=Object;n.exports=o?function(n){return"symbol"==typeof n}:function(n){var e=a("Symbol");return r(e)&&i(e.prototype,s(n))}},function(n,e,t){var a=t(1);n.exports=a({}.isPrototypeOf)},function(n,e,t){var a=t(60);n.exports=a&&!Symbol.sham&&"symbol"==typeof Symbol.iterator},function(n,e,t){var a=t(61),r=t(3);n.exports=!!Object.getOwnPropertySymbols&&!r((function(){var n=Symbol();return!String(n)||!(Object(n)instanceof Symbol)||!Symbol.sham&&a&&a<41}))},function(n,e,t){var a,r,i=t(2),o=t(108),s=i.process,l=i.Deno,c=s&&s.versions||l&&l.version,p=c&&c.v8;p&&(r=(a=p.split("."))[0]>0&&a[0]<4?1:+(a[0]+a[1])),!r&&o&&(!(a=o.match(/Edge\/(\d+)/))||a[1]>=74)&&(a=o.match(/Chrome\/(\d+)/))&&(r=+a[1]),n.exports=r},function(n,e,t){var a=t(63),r=t(37);(n.exports=function(n,e){return r[n]||(r[n]=void 0!==e?e:{})})("versions",[]).push({version:"3.29.0",mode:a?"pure":"global",copyright:"© 2014-2023 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.29.0/LICENSE",source:"https://github.com/zloirock/core-js"})},function(n,e){n.exports=!1},function(n,e,t){var a=t(1),r=0,i=Math.random(),o=a(1..toString);n.exports=function(n){return"Symbol("+(void 0===n?"":n)+")_"+o(++r+i,36)}},function(n,e,t){var a=t(5),r=t(3),i=t(99);n.exports=!a&&!r((function(){return 7!=Object.defineProperty(i("div"),"a",{get:function(){return 7}}).a}))},function(n,e,t){var a=t(7),r=t(118),i=t(52),o=t(13);n.exports=function(n,e,t){for(var s=r(e),l=o.f,c=i.f,p=0;p<s.length;p++){var d=s[p];a(n,d)||t&&a(t,d)||l(n,d,c(e,d))}}},function(n,e,t){var a=t(122);n.exports=function(n){var e=+n;return e!=e||0===e?0:a(e)}},function(n,e,t){var a=t(135),r=t(28),i=t(136);n.exports=Object.setPrototypeOf||("__proto__"in{}?function(){var n,e=!1,t={};try{(n=a(Object.prototype,"__proto__","set"))(t,[]),e=t instanceof Array}catch(n){}return function(t,a){return r(t),i(a),e?n(t,a):t.__proto__=a,t}}():void 0)},function(n,e){n.exports=function(n,e){for(var t=-1,a=e.length,r=n.length;++t<a;)n[r+t]=e[t];return n}},function(n,e){var t="object"==typeof global&&global&&global.Object===Object&&global;n.exports=t},function(n,e,t){var a=t(22),r=t(160),i=t(161),o=t(162),s=t(163),l=t(164);function c(n){var e=this.__data__=new a(n);this.size=e.size}c.prototype.clear=r,c.prototype.delete=i,c.prototype.get=o,c.prototype.has=s,c.prototype.set=l,n.exports=c},function(n,e){n.exports=function(n,e){return n===e||n!=n&&e!=e}},function(n,e,t){var a=t(14),r=t(41);n.exports=function(n){if(!r(n))return!1;var e=a(n);return"[object Function]"==e||"[object GeneratorFunction]"==e||"[object AsyncFunction]"==e||"[object Proxy]"==e}},function(n,e){var t=Function.prototype.toString;n.exports=function(n){if(null!=n){try{return t.call(n)}catch(n){}try{return n+""}catch(n){}}return""}},function(n,e,t){var a=t(181),r=t(12);n.exports=function n(e,t,i,o,s){return e===t||(null==e||null==t||!r(e)&&!r(t)?e!=e&&t!=t:a(e,t,i,o,n,s))}},function(n,e,t){var a=t(77),r=t(184),i=t(78);n.exports=function(n,e,t,o,s,l){var c=1&t,p=n.length,d=e.length;if(p!=d&&!(c&&d>p))return!1;var u=l.get(n),m=l.get(e);if(u&&m)return u==e&&m==n;var g=-1,b=!0,h=2&t?new a:void 0;for(l.set(n,e),l.set(e,n);++g<p;){var v=n[g],f=e[g];if(o)var y=c?o(f,v,g,e,n,l):o(v,f,g,n,e,l);if(void 0!==y){if(y)continue;b=!1;break}if(h){if(!r(e,(function(n,e){if(!i(h,e)&&(v===n||s(v,n,t,o,l)))return h.push(e)}))){b=!1;break}}else if(v!==f&&!s(v,f,t,o,l)){b=!1;break}}return l.delete(n),l.delete(e),b}},function(n,e,t){var a=t(42),r=t(182),i=t(183);function o(n){var e=-1,t=null==n?0:n.length;for(this.__data__=new a;++e<t;)this.add(n[e])}o.prototype.add=o.prototype.push=r,o.prototype.has=i,n.exports=o},function(n,e){n.exports=function(n,e){return n.has(e)}},function(n,e,t){var a=t(194),r=t(200),i=t(83);n.exports=function(n){return i(n)?a(n):r(n)}},function(n,e,t){(function(n){var a=t(8),r=t(196),i=e&&!e.nodeType&&e,o=i&&"object"==typeof n&&n&&!n.nodeType&&n,s=o&&o.exports===i?a.Buffer:void 0,l=(s?s.isBuffer:void 0)||r;n.exports=l}).call(this,t(50)(n))},function(n,e){var t=/^(?:0|[1-9]\d*)$/;n.exports=function(n,e){var a=typeof n;return!!(e=null==e?9007199254740991:e)&&("number"==a||"symbol"!=a&&t.test(n))&&n>-1&&n%1==0&&n<e}},function(n,e,t){var a=t(197),r=t(198),i=t(199),o=i&&i.isTypedArray,s=o?r(o):a;n.exports=s},function(n,e,t){var a=t(73),r=t(44);n.exports=function(n){return null!=n&&r(n.length)&&!a(n)}},function(n,e,t){var a=t(10)(t(8),"Set");n.exports=a},function(n,e,t){var a=t(41);n.exports=function(n){return n==n&&!a(n)}},function(n,e){n.exports=function(n,e){return function(t){return null!=t&&(t[n]===e&&(void 0!==e||n in Object(t)))}}},function(n,e,t){var a=t(88),r=t(26);n.exports=function(n,e){for(var t=0,i=(e=a(e,n)).length;null!=n&&t<i;)n=n[r(e[t++])];return t&&t==i?n:void 0}},function(n,e,t){var a=t(6),r=t(45),i=t(211),o=t(214);n.exports=function(n,e){return a(n)?n:r(n,e)?[n]:i(o(n))}},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){},function(n,e,t){var a=t(147),r=t(152),i=t(223),o=t(231),s=t(240),l=t(103),c=i((function(n){var e=l(n);return s(e)&&(e=void 0),o(a(n,1,s,!0),r(e,2))}));n.exports=c},function(n,e,t){"use strict";
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */var a=/["'&<>]/;n.exports=function(n){var e,t=""+n,r=a.exec(t);if(!r)return t;var i="",o=0,s=0;for(o=r.index;o<t.length;o++){switch(t.charCodeAt(o)){case 34:e="&quot;";break;case 38:e="&amp;";break;case 39:e="&#39;";break;case 60:e="&lt;";break;case 62:e="&gt;";break;default:continue}s!==o&&(i+=t.substring(s,o)),s=o+1,i+=e}return s!==o?i+t.substring(s,o):i}},function(n,e,t){"use strict";
/**
 * @file Embedded JavaScript templating engine. {@link http://ejs.co}
 * @author Matthew Eernisse <mde@fleegix.org>
 * @author Tiancheng "Timothy" Gu <timothygu99@gmail.com>
 * @project EJS
 * @license {@link http://www.apache.org/licenses/LICENSE-2.0 Apache License, Version 2.0}
 */var a=t(249),r=t(250),i=t(251),o=!1,s=t(252).version,l=["delimiter","scope","context","debug","compileDebug","client","_with","rmWhitespace","strict","filename","async"],c=l.concat("cache"),p=/^\uFEFF/;function d(n,t){var r,i,o=t.views,s=/^[A-Za-z]+:\\|^\//.exec(n);if(s&&s.length)r=e.resolveInclude(n.replace(/^\/*/,""),t.root||"/",!0);else if(t.filename&&(i=e.resolveInclude(n,t.filename),a.existsSync(i)&&(r=i)),r||Array.isArray(o)&&o.some((function(t){return i=e.resolveInclude(n,t,!0),a.existsSync(i)}))&&(r=i),!r)throw new Error('Could not find the include file "'+t.escapeFunction(n)+'"');return r}function u(n,t){var a,r=n.filename,i=arguments.length>1;if(n.cache){if(!r)throw new Error("cache option requires a filename");if(a=e.cache.get(r))return a;i||(t=g(r).toString().replace(p,""))}else if(!i){if(!r)throw new Error("Internal EJS error: no file name or template provided");t=g(r).toString().replace(p,"")}return a=e.compile(t,n),n.cache&&e.cache.set(r,a),a}function m(n,t,a){var r;if(!a){if("function"==typeof e.promiseImpl)return new e.promiseImpl((function(e,a){try{e(r=u(n)(t))}catch(n){a(n)}}));throw new Error("Please provide a callback function")}try{r=u(n)(t)}catch(n){return a(n)}a(null,r)}function g(n){return e.fileLoader(n)}function b(n,e,t,a,r){var i=e.split("\n"),o=Math.max(a-3,0),s=Math.min(i.length,a+3),l=r(t),c=i.slice(o,s).map((function(n,e){var t=e+o+1;return(t==a?" >> ":"    ")+t+"| "+n})).join("\n");throw n.path=l,n.message=(l||"ejs")+":"+a+"\n"+c+"\n\n"+n.message,n}function h(n){return n.replace(/;(\s*$)/,"$1")}function v(n,t){t=t||{};var a={};this.templateText=n,this.mode=null,this.truncate=!1,this.currentLine=1,this.source="",this.dependencies=[],a.client=t.client||!1,a.escapeFunction=t.escape||t.escapeFunction||i.escapeXML,a.compileDebug=!1!==t.compileDebug,a.debug=!!t.debug,a.filename=t.filename,a.openDelimiter=t.openDelimiter||e.openDelimiter||"<",a.closeDelimiter=t.closeDelimiter||e.closeDelimiter||">",a.delimiter=t.delimiter||e.delimiter||"%",a.strict=t.strict||!1,a.context=t.context,a.cache=t.cache||!1,a.rmWhitespace=t.rmWhitespace,a.root=t.root,a.outputFunctionName=t.outputFunctionName,a.localsName=t.localsName||e.localsName||"locals",a.views=t.views,a.async=t.async,a.destructuredLocals=t.destructuredLocals,a.legacyInclude=void 0===t.legacyInclude||!!t.legacyInclude,a.strict?a._with=!1:a._with=void 0===t._with||t._with,this.opts=a,this.regex=this.createRegex()}e.cache=i.cache,e.fileLoader=a.readFileSync,e.localsName="locals",e.promiseImpl=new Function("return this;")().Promise,e.resolveInclude=function(n,e,t){var a=r.dirname,i=r.extname,o=(0,r.resolve)(t?e:a(e),n);return i(n)||(o+=".ejs"),o},e.compile=function(n,e){return e&&e.scope&&(o||(console.warn("`scope` option is deprecated and will be removed in EJS 3"),o=!0),e.context||(e.context=e.scope),delete e.scope),new v(n,e).compile()},e.render=function(n,e,t){var a=e||{},r=t||{};return 2==arguments.length&&i.shallowCopyFromList(r,a,l),u(r,n)(a)},e.renderFile=function(){var n,e,t,a=Array.prototype.slice.call(arguments),r=a.shift(),o={filename:r};return"function"==typeof arguments[arguments.length-1]&&(n=a.pop()),a.length?(e=a.shift(),a.length?i.shallowCopy(o,a.pop()):(e.settings&&(e.settings.views&&(o.views=e.settings.views),e.settings["view cache"]&&(o.cache=!0),(t=e.settings["view options"])&&i.shallowCopy(o,t)),i.shallowCopyFromList(o,e,c)),o.filename=r):e={},m(o,e,n)},e.Template=v,e.clearCache=function(){e.cache.reset()},v.modes={EVAL:"eval",ESCAPED:"escaped",RAW:"raw",COMMENT:"comment",LITERAL:"literal"},v.prototype={createRegex:function(){var n="(<%%|%%>|<%=|<%-|<%_|<%#|<%|%>|-%>|_%>)",e=i.escapeRegExpChars(this.opts.delimiter),t=i.escapeRegExpChars(this.opts.openDelimiter),a=i.escapeRegExpChars(this.opts.closeDelimiter);return n=n.replace(/%/g,e).replace(/</g,t).replace(/>/g,a),new RegExp(n)},compile:function(){var n,e,t,a=this.opts,o="",s="",l=a.escapeFunction;if(!this.source){if(this.generateSource(),o+='  var __output = "";\n  function __append(s) { if (s !== undefined && s !== null) __output += s }\n',a.outputFunctionName&&(o+="  var "+a.outputFunctionName+" = __append;\n"),a.destructuredLocals&&a.destructuredLocals.length){for(var c="  var __locals = ("+a.localsName+" || {}),\n",p=0;p<a.destructuredLocals.length;p++){var m=a.destructuredLocals[p];p>0&&(c+=",\n  "),c+=m+" = __locals."+m}o+=c+";\n"}!1!==a._with&&(o+="  with ("+a.localsName+" || {}) {\n",s+="  }\n"),s+="  return __output;\n",this.source=o+this.source+s}n=a.compileDebug?"var __line = 1\n  , __lines = "+JSON.stringify(this.templateText)+"\n  , __filename = "+(a.filename?JSON.stringify(a.filename):"undefined")+";\ntry {\n"+this.source+"} catch (e) {\n  rethrow(e, __lines, __filename, __line, escapeFn);\n}\n":this.source,a.client&&(n="escapeFn = escapeFn || "+l.toString()+";\n"+n,a.compileDebug&&(n="rethrow = rethrow || "+b.toString()+";\n"+n)),a.strict&&(n='"use strict";\n'+n),a.debug&&console.log(n),a.compileDebug&&a.filename&&(n=n+"\n//# sourceURL="+a.filename+"\n");try{if(a.async)try{t=new Function("return (async function(){}).constructor;")()}catch(n){throw n instanceof SyntaxError?new Error("This environment does not support async/await"):n}else t=Function;e=new t(a.localsName+", escapeFn, include, rethrow",n)}catch(n){throw n instanceof SyntaxError&&(a.filename&&(n.message+=" in "+a.filename),n.message+=" while compiling ejs\n\n",n.message+="If the above error is not helpful, you may want to try EJS-Lint:\n",n.message+="https://github.com/RyanZim/EJS-Lint",a.async||(n.message+="\n",n.message+="Or, if you meant to create an async function, pass `async: true` as an option.")),n}var g=a.client?e:function(n){return e.apply(a.context,[n||{},l,function(e,t){var r=i.shallowCopy({},n);return t&&(r=i.shallowCopy(r,t)),function(n,e){var t=i.shallowCopy({},e);return t.filename=d(n,t),u(t)}(e,a)(r)},b])};if(g.dependencies=this.dependencies,a.filename&&"function"==typeof Object.defineProperty){var h=a.filename,v=r.basename(h,r.extname(h));try{Object.defineProperty(g,"name",{value:v,writable:!1,enumerable:!1,configurable:!0})}catch(n){}}return g},generateSource:function(){var n=this.opts;n.rmWhitespace&&(this.templateText=this.templateText.replace(/[\r\n]+/g,"\n").replace(/^\s+|\s+$/gm,"")),this.templateText=this.templateText.replace(/[ \t]*<%_/gm,"<%_").replace(/_%>[ \t]*/gm,"_%>");var t=this,a=this.parseTemplateText(),r=this.opts.delimiter,o=this.opts.openDelimiter,s=this.opts.closeDelimiter;a&&a.length&&a.forEach((function(l,c){var u,m,b,h,f,y;if(0===l.indexOf(o+r)&&0!==l.indexOf(o+r+r)&&(m=a[c+2])!=r+s&&m!="-"+r+s&&m!="_"+r+s)throw new Error('Could not find matching close tag for "'+l+'".');if(n.legacyInclude&&(b=l.match(/^\s*include\s+(\S+)/))&&(u=a[c-1])&&(u==o+r||u==o+r+"-"||u==o+r+"_"))return h=i.shallowCopy({},t.opts),f=function(n,e){var t,a,r=i.shallowCopy({},e);a=g(t=d(n,r)).toString().replace(p,""),r.filename=t;var o=new v(a,r);return o.generateSource(),{source:o.source,filename:t,template:a}}(b[1],h),y=t.opts.compileDebug?"    ; (function(){\n      var __line = 1\n      , __lines = "+JSON.stringify(f.template)+"\n      , __filename = "+JSON.stringify(f.filename)+";\n      try {\n"+f.source+"      } catch (e) {\n        rethrow(e, __lines, __filename, __line, escapeFn);\n      }\n    ; }).call(this)\n":"    ; (function(){\n"+f.source+"    ; }).call(this)\n",t.source+=y,void t.dependencies.push(e.resolveInclude(b[1],h.filename));t.scanLine(l)}))},parseTemplateText:function(){for(var n,e=this.templateText,t=this.regex,a=t.exec(e),r=[];a;)0!==(n=a.index)&&(r.push(e.substring(0,n)),e=e.slice(n)),r.push(a[0]),e=e.slice(a[0].length),a=t.exec(e);return e&&r.push(e),r},_addOutput:function(n){if(this.truncate&&(n=n.replace(/^(?:\r\n|\r|\n)/,""),this.truncate=!1),!n)return n;n=(n=(n=(n=n.replace(/\\/g,"\\\\")).replace(/\n/g,"\\n")).replace(/\r/g,"\\r")).replace(/"/g,'\\"'),this.source+='    ; __append("'+n+'")\n'},scanLine:function(n){var e,t=this.opts.delimiter,a=this.opts.openDelimiter,r=this.opts.closeDelimiter;switch(e=n.split("\n").length-1,n){case a+t:case a+t+"_":this.mode=v.modes.EVAL;break;case a+t+"=":this.mode=v.modes.ESCAPED;break;case a+t+"-":this.mode=v.modes.RAW;break;case a+t+"#":this.mode=v.modes.COMMENT;break;case a+t+t:this.mode=v.modes.LITERAL,this.source+='    ; __append("'+n.replace(a+t+t,a+t)+'")\n';break;case t+t+r:this.mode=v.modes.LITERAL,this.source+='    ; __append("'+n.replace(t+t+r,t+r)+'")\n';break;case t+r:case"-"+t+r:case"_"+t+r:this.mode==v.modes.LITERAL&&this._addOutput(n),this.mode=null,this.truncate=0===n.indexOf("-")||0===n.indexOf("_");break;default:if(this.mode){switch(this.mode){case v.modes.EVAL:case v.modes.ESCAPED:case v.modes.RAW:n.lastIndexOf("//")>n.lastIndexOf("\n")&&(n+="\n")}switch(this.mode){case v.modes.EVAL:this.source+="    ; "+n+"\n";break;case v.modes.ESCAPED:this.source+="    ; __append(escapeFn("+h(n)+"))\n";break;case v.modes.RAW:this.source+="    ; __append("+h(n)+")\n";break;case v.modes.COMMENT:break;case v.modes.LITERAL:this._addOutput(n)}}else this._addOutput(n)}this.opts.compileDebug&&e&&(this.currentLine+=e,this.source+="    ; __line = "+this.currentLine+"\n")}},e.escapeXML=i.escapeXML,e.__express=e.renderFile,e.VERSION=s,e.name="ejs","undefined"!=typeof window&&(window.ejs=e)},function(n,e,t){"use strict";t.r(e);var a={name:"CodeBlock",props:{title:{type:String,required:!0},active:{type:Boolean,default:!1}}},r=(t(243),t(4)),i=Object(r.a)(a,(function(){return(0,this._self._c)("div",{staticClass:"theme-code-block",class:{"theme-code-block__active":this.active}},[this._t("default")],2)}),[],!1,null,"4f1e9d0c",null);e.default=i.exports},function(n,e,t){"use strict";t.r(e);var a={name:"CodeGroup",data:()=>({codeTabs:[],activeCodeTabIndex:-1}),watch:{activeCodeTabIndex(n){this.codeTabs.forEach(n=>{n.elm.classList.remove("theme-code-block__active")}),this.codeTabs[n].elm.classList.add("theme-code-block__active")}},mounted(){this.codeTabs=(this.$slots.default||[]).filter(n=>Boolean(n.componentOptions)).map((n,e)=>(""===n.componentOptions.propsData.active&&(this.activeCodeTabIndex=e),{title:n.componentOptions.propsData.title,elm:n.elm})),-1===this.activeCodeTabIndex&&this.codeTabs.length>0&&(this.activeCodeTabIndex=0)},methods:{changeCodeTab(n){this.activeCodeTabIndex=n}}},r=(t(244),t(4)),i=Object(r.a)(a,(function(){var n=this,e=n._self._c;return e("div",{staticClass:"theme-code-group"},[e("div",{staticClass:"theme-code-group__nav"},[e("ul",{staticClass:"theme-code-group__ul"},n._l(n.codeTabs,(function(t,a){return e("li",{key:t.title,staticClass:"theme-code-group__li"},[e("button",{staticClass:"theme-code-group__nav-tab",class:{"theme-code-group__nav-tab-active":a===n.activeCodeTabIndex},on:{click:function(e){return n.changeCodeTab(a)}}},[n._v("\n            "+n._s(t.title)+"\n          ")])])})),0)]),n._v(" "),n._t("default"),n._v(" "),n.codeTabs.length<1?e("pre",{staticClass:"pre-blank"},[n._v("// Make sure to add code blocks to your code group")]):n._e()],2)}),[],!1,null,"2f5f1757",null);e.default=i.exports},function(n,e){n.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]},function(n,e,t){var a=t(2),r=t(9),i=a.document,o=r(i)&&r(i.createElement);n.exports=function(n){return o?i.createElement(n):{}}},function(n,e,t){var a=t(5),r=t(3);n.exports=a&&r((function(){return 42!=Object.defineProperty((function(){}),"prototype",{value:42,writable:!1}).prototype}))},function(n,e,t){var a=t(62),r=t(64),i=a("keys");n.exports=function(n){return i[n]||(i[n]=r(n))}},function(n,e,t){var a=t(1),r=t(7),i=t(30),o=t(120).indexOf,s=t(49),l=a([].push);n.exports=function(n,e){var t,a=i(n),c=0,p=[];for(t in a)!r(s,t)&&r(a,t)&&l(p,t);for(;e.length>c;)r(a,t=e[c++])&&(~o(p,t)||l(p,t));return p}},function(n,e){n.exports=function(n){var e=null==n?0:n.length;return e?n[e-1]:void 0}},function(n,e,t){n.exports=t(255)},function(n,e,t){"use strict";var a=t(19),r=t(126).left,i=t(127),o=t(61);a({target:"Array",proto:!0,forced:!t(128)&&o>79&&o<83||!i("reduce")},{reduce:function(n){var e=arguments.length;return r(this,n,e,e>1?arguments[1]:void 0)}})},function(n,e,t){"use strict";var a={}.propertyIsEnumerable,r=Object.getOwnPropertyDescriptor,i=r&&!a.call({1:2},1);e.f=i?function(n){var e=r(this,n);return!!e&&e.enumerable}:a},function(n,e,t){var a=t(35),r=t(9),i=t(57),o=t(109),s=t(111),l=t(21),c=TypeError,p=l("toPrimitive");n.exports=function(n,e){if(!r(n)||i(n))return n;var t,l=o(n,p);if(l){if(void 0===e&&(e="default"),t=a(l,n,e),!r(t)||i(t))return t;throw c("Can't convert object to primitive value")}return void 0===e&&(e="number"),s(n,e)}},function(n,e){n.exports="undefined"!=typeof navigator&&String(navigator.userAgent)||""},function(n,e,t){var a=t(32),r=t(54);n.exports=function(n,e){var t=n[e];return r(t)?void 0:a(t)}},function(n,e){var t=String;n.exports=function(n){try{return t(n)}catch(n){return"Object"}}},function(n,e,t){var a=t(35),r=t(0),i=t(9),o=TypeError;n.exports=function(n,e){var t,s;if("string"===e&&r(t=n.toString)&&!i(s=a(t,n)))return s;if(r(t=n.valueOf)&&!i(s=a(t,n)))return s;if("string"!==e&&r(t=n.toString)&&!i(s=a(t,n)))return s;throw o("Can't convert object to primitive value")}},function(n,e,t){var a=t(0),r=t(13),i=t(113),o=t(38);n.exports=function(n,e,t,s){s||(s={});var l=s.enumerable,c=void 0!==s.name?s.name:e;if(a(t)&&i(t,c,s),s.global)l?n[e]=t:o(e,t);else{try{s.unsafe?n[e]&&(l=!0):delete n[e]}catch(n){}l?n[e]=t:r.f(n,e,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return n}},function(n,e,t){var a=t(1),r=t(3),i=t(0),o=t(7),s=t(5),l=t(114).CONFIGURABLE,c=t(115),p=t(116),d=p.enforce,u=p.get,m=String,g=Object.defineProperty,b=a("".slice),h=a("".replace),v=a([].join),f=s&&!r((function(){return 8!==g((function(){}),"length",{value:8}).length})),y=String(String).split("String"),x=n.exports=function(n,e,t){"Symbol("===b(m(e),0,7)&&(e="["+h(m(e),/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(e="get "+e),t&&t.setter&&(e="set "+e),(!o(n,"name")||l&&n.name!==e)&&(s?g(n,"name",{value:e,configurable:!0}):n.name=e),f&&t&&o(t,"arity")&&n.length!==t.arity&&g(n,"length",{value:t.arity});try{t&&o(t,"constructor")&&t.constructor?s&&g(n,"prototype",{writable:!1}):n.prototype&&(n.prototype=void 0)}catch(n){}var a=d(n);return o(a,"source")||(a.source=v(y,"string"==typeof e?e:"")),n};Function.prototype.toString=x((function(){return i(this)&&u(this).source||c(this)}),"toString")},function(n,e,t){var a=t(5),r=t(7),i=Function.prototype,o=a&&Object.getOwnPropertyDescriptor,s=r(i,"name"),l=s&&"something"===function(){}.name,c=s&&(!a||a&&o(i,"name").configurable);n.exports={EXISTS:s,PROPER:l,CONFIGURABLE:c}},function(n,e,t){var a=t(1),r=t(0),i=t(37),o=a(Function.toString);r(i.inspectSource)||(i.inspectSource=function(n){return o(n)}),n.exports=i.inspectSource},function(n,e,t){var a,r,i,o=t(117),s=t(2),l=t(9),c=t(15),p=t(7),d=t(37),u=t(101),m=t(49),g=s.TypeError,b=s.WeakMap;if(o||d.state){var h=d.state||(d.state=new b);h.get=h.get,h.has=h.has,h.set=h.set,a=function(n,e){if(h.has(n))throw g("Object already initialized");return e.facade=n,h.set(n,e),e},r=function(n){return h.get(n)||{}},i=function(n){return h.has(n)}}else{var v=u("state");m[v]=!0,a=function(n,e){if(p(n,v))throw g("Object already initialized");return e.facade=n,c(n,v,e),e},r=function(n){return p(n,v)?n[v]:{}},i=function(n){return p(n,v)}}n.exports={set:a,get:r,has:i,enforce:function(n){return i(n)?r(n):a(n,{})},getterFor:function(n){return function(e){var t;if(!l(e)||(t=r(e)).type!==n)throw g("Incompatible receiver, "+n+" required");return t}}}},function(n,e,t){var a=t(2),r=t(0),i=a.WeakMap;n.exports=r(i)&&/native code/.test(String(i))},function(n,e,t){var a=t(31),r=t(1),i=t(119),o=t(124),s=t(28),l=r([].concat);n.exports=a("Reflect","ownKeys")||function(n){var e=i.f(s(n)),t=o.f;return t?l(e,t(n)):e}},function(n,e,t){var a=t(102),r=t(98).concat("length","prototype");e.f=Object.getOwnPropertyNames||function(n){return a(n,r)}},function(n,e,t){var a=t(30),r=t(121),i=t(34),o=function(n){return function(e,t,o){var s,l=a(e),c=i(l),p=r(o,c);if(n&&t!=t){for(;c>p;)if((s=l[p++])!=s)return!0}else for(;c>p;p++)if((n||p in l)&&l[p]===t)return n||p||0;return!n&&-1}};n.exports={includes:o(!0),indexOf:o(!1)}},function(n,e,t){var a=t(67),r=Math.max,i=Math.min;n.exports=function(n,e){var t=a(n);return t<0?r(t+e,0):i(t,e)}},function(n,e){var t=Math.ceil,a=Math.floor;n.exports=Math.trunc||function(n){var e=+n;return(e>0?a:t)(e)}},function(n,e,t){var a=t(67),r=Math.min;n.exports=function(n){return n>0?r(a(n),9007199254740991):0}},function(n,e){e.f=Object.getOwnPropertySymbols},function(n,e,t){var a=t(3),r=t(0),i=/#|\.prototype\./,o=function(n,e){var t=l[s(n)];return t==p||t!=c&&(r(e)?a(e):!!e)},s=o.normalize=function(n){return String(n).replace(i,".").toLowerCase()},l=o.data={},c=o.NATIVE="N",p=o.POLYFILL="P";n.exports=o},function(n,e,t){var a=t(32),r=t(33),i=t(48),o=t(34),s=TypeError,l=function(n){return function(e,t,l,c){a(t);var p=r(e),d=i(p),u=o(p),m=n?u-1:0,g=n?-1:1;if(l<2)for(;;){if(m in d){c=d[m],m+=g;break}if(m+=g,n?m<0:u<=m)throw s("Reduce of empty array with no initial value")}for(;n?m>=0:u>m;m+=g)m in d&&(c=t(c,d[m],m,p));return c}};n.exports={left:l(!1),right:l(!0)}},function(n,e,t){"use strict";var a=t(3);n.exports=function(n,e){var t=[][n];return!!t&&a((function(){t.call(null,e||function(){return 1},1)}))}},function(n,e,t){var a=t(20);n.exports="undefined"!=typeof process&&"process"==a(process)},function(n,e,t){"use strict";var a=t(5),r=t(130),i=TypeError,o=Object.getOwnPropertyDescriptor,s=a&&!function(){if(void 0!==this)return!0;try{Object.defineProperty([],"length",{writable:!1}).length=1}catch(n){return n instanceof TypeError}}();n.exports=s?function(n,e){if(r(n)&&!o(n,"length").writable)throw i("Cannot set read only .length");return n.length=e}:function(n,e){return n.length=e}},function(n,e,t){var a=t(20);n.exports=Array.isArray||function(n){return"Array"==a(n)}},function(n,e){var t=TypeError;n.exports=function(n){if(n>9007199254740991)throw t("Maximum allowed index exceeded");return n}},function(n,e,t){var a=t(19),r=t(2),i=t(133),o=t(134),s=r.WebAssembly,l=7!==Error("e",{cause:7}).cause,c=function(n,e){var t={};t[n]=o(n,e,l),a({global:!0,constructor:!0,arity:1,forced:l},t)},p=function(n,e){if(s&&s[n]){var t={};t[n]=o("WebAssembly."+n,e,l),a({target:"WebAssembly",stat:!0,constructor:!0,arity:1,forced:l},t)}};c("Error",(function(n){return function(e){return i(n,this,arguments)}})),c("EvalError",(function(n){return function(e){return i(n,this,arguments)}})),c("RangeError",(function(n){return function(e){return i(n,this,arguments)}})),c("ReferenceError",(function(n){return function(e){return i(n,this,arguments)}})),c("SyntaxError",(function(n){return function(e){return i(n,this,arguments)}})),c("TypeError",(function(n){return function(e){return i(n,this,arguments)}})),c("URIError",(function(n){return function(e){return i(n,this,arguments)}})),p("CompileError",(function(n){return function(e){return i(n,this,arguments)}})),p("LinkError",(function(n){return function(e){return i(n,this,arguments)}})),p("RuntimeError",(function(n){return function(e){return i(n,this,arguments)}}))},function(n,e,t){var a=t(29),r=Function.prototype,i=r.apply,o=r.call;n.exports="object"==typeof Reflect&&Reflect.apply||(a?o.bind(i):function(){return o.apply(i,arguments)})},function(n,e,t){"use strict";var a=t(31),r=t(7),i=t(15),o=t(58),s=t(68),l=t(66),c=t(137),p=t(138),d=t(139),u=t(143),m=t(144),g=t(5),b=t(63);n.exports=function(n,e,t,h){var v=h?2:1,f=n.split("."),y=f[f.length-1],x=a.apply(null,f);if(x){var w=x.prototype;if(!b&&r(w,"cause")&&delete w.cause,!t)return x;var S=a("Error"),j=e((function(n,e){var t=d(h?e:n,void 0),a=h?new x(n):new x;return void 0!==t&&i(a,"message",t),m(a,j,a.stack,2),this&&o(w,this)&&p(a,this,j),arguments.length>v&&u(a,arguments[v]),a}));if(j.prototype=w,"Error"!==y?s?s(j,S):l(j,S,{name:!0}):g&&"stackTraceLimit"in x&&(c(j,x,"stackTraceLimit"),c(j,x,"prepareStackTrace")),l(j,x),!b)try{w.name!==y&&i(w,"name",y),w.constructor=j}catch(n){}return j}}},function(n,e,t){var a=t(1),r=t(32);n.exports=function(n,e,t){try{return a(r(Object.getOwnPropertyDescriptor(n,e)[t]))}catch(n){}}},function(n,e,t){var a=t(0),r=String,i=TypeError;n.exports=function(n){if("object"==typeof n||a(n))return n;throw i("Can't set "+r(n)+" as a prototype")}},function(n,e,t){var a=t(13).f;n.exports=function(n,e,t){t in n||a(n,t,{configurable:!0,get:function(){return e[t]},set:function(n){e[t]=n}})}},function(n,e,t){var a=t(0),r=t(9),i=t(68);n.exports=function(n,e,t){var o,s;return i&&a(o=e.constructor)&&o!==t&&r(s=o.prototype)&&s!==t.prototype&&i(n,s),n}},function(n,e,t){var a=t(140);n.exports=function(n,e){return void 0===n?arguments.length<2?"":e:a(n)}},function(n,e,t){var a=t(141),r=String;n.exports=function(n){if("Symbol"===a(n))throw TypeError("Cannot convert a Symbol value to a string");return r(n)}},function(n,e,t){var a=t(142),r=t(0),i=t(20),o=t(21)("toStringTag"),s=Object,l="Arguments"==i(function(){return arguments}());n.exports=a?i:function(n){var e,t,a;return void 0===n?"Undefined":null===n?"Null":"string"==typeof(t=function(n,e){try{return n[e]}catch(n){}}(e=s(n),o))?t:l?i(e):"Object"==(a=i(e))&&r(e.callee)?"Arguments":a}},function(n,e,t){var a={};a[t(21)("toStringTag")]="z",n.exports="[object z]"===String(a)},function(n,e,t){var a=t(9),r=t(15);n.exports=function(n,e){a(e)&&"cause"in e&&r(n,"cause",e.cause)}},function(n,e,t){var a=t(15),r=t(145),i=t(146),o=Error.captureStackTrace;n.exports=function(n,e,t,s){i&&(o?o(n,e):a(n,"stack",r(t,s)))}},function(n,e,t){var a=t(1),r=Error,i=a("".replace),o=String(r("zxcasd").stack),s=/\n\s*at [^:]*:[^\n]*/,l=s.test(o);n.exports=function(n,e){if(l&&"string"==typeof n&&!r.prepareStackTrace)for(;e--;)n=i(n,s,"");return n}},function(n,e,t){var a=t(3),r=t(36);n.exports=!a((function(){var n=Error("a");return!("stack"in n)||(Object.defineProperty(n,"stack",r(1,7)),7!==n.stack)}))},function(n,e,t){var a=t(69),r=t(148);n.exports=function n(e,t,i,o,s){var l=-1,c=e.length;for(i||(i=r),s||(s=[]);++l<c;){var p=e[l];t>0&&i(p)?t>1?n(p,t-1,i,o,s):a(s,p):o||(s[s.length]=p)}return s}},function(n,e,t){var a=t(16),r=t(39),i=t(6),o=a?a.isConcatSpreadable:void 0;n.exports=function(n){return i(n)||r(n)||!!(o&&n&&n[o])}},function(n,e,t){var a=t(14),r=t(12);n.exports=function(n){return r(n)&&"[object Arguments]"==a(n)}},function(n,e,t){var a=t(16),r=Object.prototype,i=r.hasOwnProperty,o=r.toString,s=a?a.toStringTag:void 0;n.exports=function(n){var e=i.call(n,s),t=n[s];try{n[s]=void 0;var a=!0}catch(n){}var r=o.call(n);return a&&(e?n[s]=t:delete n[s]),r}},function(n,e){var t=Object.prototype.toString;n.exports=function(n){return t.call(n)}},function(n,e,t){var a=t(153),r=t(209),i=t(47),o=t(6),s=t(220);n.exports=function(n){return"function"==typeof n?n:null==n?i:"object"==typeof n?o(n)?r(n[0],n[1]):a(n):s(n)}},function(n,e,t){var a=t(154),r=t(208),i=t(86);n.exports=function(n){var e=r(n);return 1==e.length&&e[0][2]?i(e[0][0],e[0][1]):function(t){return t===n||a(t,n,e)}}},function(n,e,t){var a=t(71),r=t(75);n.exports=function(n,e,t,i){var o=t.length,s=o,l=!i;if(null==n)return!s;for(n=Object(n);o--;){var c=t[o];if(l&&c[2]?c[1]!==n[c[0]]:!(c[0]in n))return!1}for(;++o<s;){var p=(c=t[o])[0],d=n[p],u=c[1];if(l&&c[2]){if(void 0===d&&!(p in n))return!1}else{var m=new a;if(i)var g=i(d,u,p,n,e,m);if(!(void 0===g?r(u,d,3,i,m):g))return!1}}return!0}},function(n,e){n.exports=function(){this.__data__=[],this.size=0}},function(n,e,t){var a=t(23),r=Array.prototype.splice;n.exports=function(n){var e=this.__data__,t=a(e,n);return!(t<0)&&(t==e.length-1?e.pop():r.call(e,t,1),--this.size,!0)}},function(n,e,t){var a=t(23);n.exports=function(n){var e=this.__data__,t=a(e,n);return t<0?void 0:e[t][1]}},function(n,e,t){var a=t(23);n.exports=function(n){return a(this.__data__,n)>-1}},function(n,e,t){var a=t(23);n.exports=function(n,e){var t=this.__data__,r=a(t,n);return r<0?(++this.size,t.push([n,e])):t[r][1]=e,this}},function(n,e,t){var a=t(22);n.exports=function(){this.__data__=new a,this.size=0}},function(n,e){n.exports=function(n){var e=this.__data__,t=e.delete(n);return this.size=e.size,t}},function(n,e){n.exports=function(n){return this.__data__.get(n)}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e,t){var a=t(22),r=t(40),i=t(42);n.exports=function(n,e){var t=this.__data__;if(t instanceof a){var o=t.__data__;if(!r||o.length<199)return o.push([n,e]),this.size=++t.size,this;t=this.__data__=new i(o)}return t.set(n,e),this.size=t.size,this}},function(n,e,t){var a=t(73),r=t(166),i=t(41),o=t(74),s=/^\[object .+?Constructor\]$/,l=Function.prototype,c=Object.prototype,p=l.toString,d=c.hasOwnProperty,u=RegExp("^"+p.call(d).replace(/[\\^$.*+?()[\]{}|]/g,"\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,"$1.*?")+"$");n.exports=function(n){return!(!i(n)||r(n))&&(a(n)?u:s).test(o(n))}},function(n,e,t){var a,r=t(167),i=(a=/[^.]+$/.exec(r&&r.keys&&r.keys.IE_PROTO||""))?"Symbol(src)_1."+a:"";n.exports=function(n){return!!i&&i in n}},function(n,e,t){var a=t(8)["__core-js_shared__"];n.exports=a},function(n,e){n.exports=function(n,e){return null==n?void 0:n[e]}},function(n,e,t){var a=t(170),r=t(22),i=t(40);n.exports=function(){this.size=0,this.__data__={hash:new a,map:new(i||r),string:new a}}},function(n,e,t){var a=t(171),r=t(172),i=t(173),o=t(174),s=t(175);function l(n){var e=-1,t=null==n?0:n.length;for(this.clear();++e<t;){var a=n[e];this.set(a[0],a[1])}}l.prototype.clear=a,l.prototype.delete=r,l.prototype.get=i,l.prototype.has=o,l.prototype.set=s,n.exports=l},function(n,e,t){var a=t(24);n.exports=function(){this.__data__=a?a(null):{},this.size=0}},function(n,e){n.exports=function(n){var e=this.has(n)&&delete this.__data__[n];return this.size-=e?1:0,e}},function(n,e,t){var a=t(24),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;if(a){var t=e[n];return"__lodash_hash_undefined__"===t?void 0:t}return r.call(e,n)?e[n]:void 0}},function(n,e,t){var a=t(24),r=Object.prototype.hasOwnProperty;n.exports=function(n){var e=this.__data__;return a?void 0!==e[n]:r.call(e,n)}},function(n,e,t){var a=t(24);n.exports=function(n,e){var t=this.__data__;return this.size+=this.has(n)?0:1,t[n]=a&&void 0===e?"__lodash_hash_undefined__":e,this}},function(n,e,t){var a=t(25);n.exports=function(n){var e=a(this,n).delete(n);return this.size-=e?1:0,e}},function(n,e){n.exports=function(n){var e=typeof n;return"string"==e||"number"==e||"symbol"==e||"boolean"==e?"__proto__"!==n:null===n}},function(n,e,t){var a=t(25);n.exports=function(n){return a(this,n).get(n)}},function(n,e,t){var a=t(25);n.exports=function(n){return a(this,n).has(n)}},function(n,e,t){var a=t(25);n.exports=function(n,e){var t=a(this,n),r=t.size;return t.set(n,e),this.size+=t.size==r?0:1,this}},function(n,e,t){var a=t(71),r=t(76),i=t(185),o=t(188),s=t(204),l=t(6),c=t(80),p=t(82),d="[object Object]",u=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,m,g,b){var h=l(n),v=l(e),f=h?"[object Array]":s(n),y=v?"[object Array]":s(e),x=(f="[object Arguments]"==f?d:f)==d,w=(y="[object Arguments]"==y?d:y)==d,S=f==y;if(S&&c(n)){if(!c(e))return!1;h=!0,x=!1}if(S&&!x)return b||(b=new a),h||p(n)?r(n,e,t,m,g,b):i(n,e,f,t,m,g,b);if(!(1&t)){var j=x&&u.call(n,"__wrapped__"),k=w&&u.call(e,"__wrapped__");if(j||k){var T=j?n.value():n,E=k?e.value():e;return b||(b=new a),g(T,E,t,m,b)}}return!!S&&(b||(b=new a),o(n,e,t,m,g,b))}},function(n,e){n.exports=function(n){return this.__data__.set(n,"__lodash_hash_undefined__"),this}},function(n,e){n.exports=function(n){return this.__data__.has(n)}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length;++t<a;)if(e(n[t],t,n))return!0;return!1}},function(n,e,t){var a=t(16),r=t(186),i=t(72),o=t(76),s=t(187),l=t(43),c=a?a.prototype:void 0,p=c?c.valueOf:void 0;n.exports=function(n,e,t,a,c,d,u){switch(t){case"[object DataView]":if(n.byteLength!=e.byteLength||n.byteOffset!=e.byteOffset)return!1;n=n.buffer,e=e.buffer;case"[object ArrayBuffer]":return!(n.byteLength!=e.byteLength||!d(new r(n),new r(e)));case"[object Boolean]":case"[object Date]":case"[object Number]":return i(+n,+e);case"[object Error]":return n.name==e.name&&n.message==e.message;case"[object RegExp]":case"[object String]":return n==e+"";case"[object Map]":var m=s;case"[object Set]":var g=1&a;if(m||(m=l),n.size!=e.size&&!g)return!1;var b=u.get(n);if(b)return b==e;a|=2,u.set(n,e);var h=o(m(n),m(e),a,c,d,u);return u.delete(n),h;case"[object Symbol]":if(p)return p.call(n)==p.call(e)}return!1}},function(n,e,t){var a=t(8).Uint8Array;n.exports=a},function(n,e){n.exports=function(n){var e=-1,t=Array(n.size);return n.forEach((function(n,a){t[++e]=[a,n]})),t}},function(n,e,t){var a=t(189),r=Object.prototype.hasOwnProperty;n.exports=function(n,e,t,i,o,s){var l=1&t,c=a(n),p=c.length;if(p!=a(e).length&&!l)return!1;for(var d=p;d--;){var u=c[d];if(!(l?u in e:r.call(e,u)))return!1}var m=s.get(n),g=s.get(e);if(m&&g)return m==e&&g==n;var b=!0;s.set(n,e),s.set(e,n);for(var h=l;++d<p;){var v=n[u=c[d]],f=e[u];if(i)var y=l?i(f,v,u,e,n,s):i(v,f,u,n,e,s);if(!(void 0===y?v===f||o(v,f,t,i,s):y)){b=!1;break}h||(h="constructor"==u)}if(b&&!h){var x=n.constructor,w=e.constructor;x==w||!("constructor"in n)||!("constructor"in e)||"function"==typeof x&&x instanceof x&&"function"==typeof w&&w instanceof w||(b=!1)}return s.delete(n),s.delete(e),b}},function(n,e,t){var a=t(190),r=t(191),i=t(79);n.exports=function(n){return a(n,i,r)}},function(n,e,t){var a=t(69),r=t(6);n.exports=function(n,e,t){var i=e(n);return r(n)?i:a(i,t(n))}},function(n,e,t){var a=t(192),r=t(193),i=Object.prototype.propertyIsEnumerable,o=Object.getOwnPropertySymbols,s=o?function(n){return null==n?[]:(n=Object(n),a(o(n),(function(e){return i.call(n,e)})))}:r;n.exports=s},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,r=0,i=[];++t<a;){var o=n[t];e(o,t,n)&&(i[r++]=o)}return i}},function(n,e){n.exports=function(){return[]}},function(n,e,t){var a=t(195),r=t(39),i=t(6),o=t(80),s=t(81),l=t(82),c=Object.prototype.hasOwnProperty;n.exports=function(n,e){var t=i(n),p=!t&&r(n),d=!t&&!p&&o(n),u=!t&&!p&&!d&&l(n),m=t||p||d||u,g=m?a(n.length,String):[],b=g.length;for(var h in n)!e&&!c.call(n,h)||m&&("length"==h||d&&("offset"==h||"parent"==h)||u&&("buffer"==h||"byteLength"==h||"byteOffset"==h)||s(h,b))||g.push(h);return g}},function(n,e){n.exports=function(n,e){for(var t=-1,a=Array(n);++t<n;)a[t]=e(t);return a}},function(n,e){n.exports=function(){return!1}},function(n,e,t){var a=t(14),r=t(44),i=t(12),o={};o["[object Float32Array]"]=o["[object Float64Array]"]=o["[object Int8Array]"]=o["[object Int16Array]"]=o["[object Int32Array]"]=o["[object Uint8Array]"]=o["[object Uint8ClampedArray]"]=o["[object Uint16Array]"]=o["[object Uint32Array]"]=!0,o["[object Arguments]"]=o["[object Array]"]=o["[object ArrayBuffer]"]=o["[object Boolean]"]=o["[object DataView]"]=o["[object Date]"]=o["[object Error]"]=o["[object Function]"]=o["[object Map]"]=o["[object Number]"]=o["[object Object]"]=o["[object RegExp]"]=o["[object Set]"]=o["[object String]"]=o["[object WeakMap]"]=!1,n.exports=function(n){return i(n)&&r(n.length)&&!!o[a(n)]}},function(n,e){n.exports=function(n){return function(e){return n(e)}}},function(n,e,t){(function(n){var a=t(70),r=e&&!e.nodeType&&e,i=r&&"object"==typeof n&&n&&!n.nodeType&&n,o=i&&i.exports===r&&a.process,s=function(){try{var n=i&&i.require&&i.require("util").types;return n||o&&o.binding&&o.binding("util")}catch(n){}}();n.exports=s}).call(this,t(50)(n))},function(n,e,t){var a=t(201),r=t(202),i=Object.prototype.hasOwnProperty;n.exports=function(n){if(!a(n))return r(n);var e=[];for(var t in Object(n))i.call(n,t)&&"constructor"!=t&&e.push(t);return e}},function(n,e){var t=Object.prototype;n.exports=function(n){var e=n&&n.constructor;return n===("function"==typeof e&&e.prototype||t)}},function(n,e,t){var a=t(203)(Object.keys,Object);n.exports=a},function(n,e){n.exports=function(n,e){return function(t){return n(e(t))}}},function(n,e,t){var a=t(205),r=t(40),i=t(206),o=t(84),s=t(207),l=t(14),c=t(74),p=c(a),d=c(r),u=c(i),m=c(o),g=c(s),b=l;(a&&"[object DataView]"!=b(new a(new ArrayBuffer(1)))||r&&"[object Map]"!=b(new r)||i&&"[object Promise]"!=b(i.resolve())||o&&"[object Set]"!=b(new o)||s&&"[object WeakMap]"!=b(new s))&&(b=function(n){var e=l(n),t="[object Object]"==e?n.constructor:void 0,a=t?c(t):"";if(a)switch(a){case p:return"[object DataView]";case d:return"[object Map]";case u:return"[object Promise]";case m:return"[object Set]";case g:return"[object WeakMap]"}return e}),n.exports=b},function(n,e,t){var a=t(10)(t(8),"DataView");n.exports=a},function(n,e,t){var a=t(10)(t(8),"Promise");n.exports=a},function(n,e,t){var a=t(10)(t(8),"WeakMap");n.exports=a},function(n,e,t){var a=t(85),r=t(79);n.exports=function(n){for(var e=r(n),t=e.length;t--;){var i=e[t],o=n[i];e[t]=[i,o,a(o)]}return e}},function(n,e,t){var a=t(75),r=t(210),i=t(217),o=t(45),s=t(85),l=t(86),c=t(26);n.exports=function(n,e){return o(n)&&s(e)?l(c(n),e):function(t){var o=r(t,n);return void 0===o&&o===e?i(t,n):a(e,o,3)}}},function(n,e,t){var a=t(87);n.exports=function(n,e,t){var r=null==n?void 0:a(n,e);return void 0===r?t:r}},function(n,e,t){var a=t(212),r=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g,i=/\\(\\)?/g,o=a((function(n){var e=[];return 46===n.charCodeAt(0)&&e.push(""),n.replace(r,(function(n,t,a,r){e.push(a?r.replace(i,"$1"):t||n)})),e}));n.exports=o},function(n,e,t){var a=t(213);n.exports=function(n){var e=a(n,(function(n){return 500===t.size&&t.clear(),n})),t=e.cache;return e}},function(n,e,t){var a=t(42);function r(n,e){if("function"!=typeof n||null!=e&&"function"!=typeof e)throw new TypeError("Expected a function");var t=function(){var a=arguments,r=e?e.apply(this,a):a[0],i=t.cache;if(i.has(r))return i.get(r);var o=n.apply(this,a);return t.cache=i.set(r,o)||i,o};return t.cache=new(r.Cache||a),t}r.Cache=a,n.exports=r},function(n,e,t){var a=t(215);n.exports=function(n){return null==n?"":a(n)}},function(n,e,t){var a=t(16),r=t(216),i=t(6),o=t(46),s=a?a.prototype:void 0,l=s?s.toString:void 0;n.exports=function n(e){if("string"==typeof e)return e;if(i(e))return r(e,n)+"";if(o(e))return l?l.call(e):"";var t=e+"";return"0"==t&&1/e==-1/0?"-0":t}},function(n,e){n.exports=function(n,e){for(var t=-1,a=null==n?0:n.length,r=Array(a);++t<a;)r[t]=e(n[t],t,n);return r}},function(n,e,t){var a=t(218),r=t(219);n.exports=function(n,e){return null!=n&&r(n,e,a)}},function(n,e){n.exports=function(n,e){return null!=n&&e in Object(n)}},function(n,e,t){var a=t(88),r=t(39),i=t(6),o=t(81),s=t(44),l=t(26);n.exports=function(n,e,t){for(var c=-1,p=(e=a(e,n)).length,d=!1;++c<p;){var u=l(e[c]);if(!(d=null!=n&&t(n,u)))break;n=n[u]}return d||++c!=p?d:!!(p=null==n?0:n.length)&&s(p)&&o(u,p)&&(i(n)||r(n))}},function(n,e,t){var a=t(221),r=t(222),i=t(45),o=t(26);n.exports=function(n){return i(n)?a(o(n)):r(n)}},function(n,e){n.exports=function(n){return function(e){return null==e?void 0:e[n]}}},function(n,e,t){var a=t(87);n.exports=function(n){return function(e){return a(e,n)}}},function(n,e,t){var a=t(47),r=t(224),i=t(226);n.exports=function(n,e){return i(r(n,e,a),n+"")}},function(n,e,t){var a=t(225),r=Math.max;n.exports=function(n,e,t){return e=r(void 0===e?n.length-1:e,0),function(){for(var i=arguments,o=-1,s=r(i.length-e,0),l=Array(s);++o<s;)l[o]=i[e+o];o=-1;for(var c=Array(e+1);++o<e;)c[o]=i[o];return c[e]=t(l),a(n,this,c)}}},function(n,e){n.exports=function(n,e,t){switch(t.length){case 0:return n.call(e);case 1:return n.call(e,t[0]);case 2:return n.call(e,t[0],t[1]);case 3:return n.call(e,t[0],t[1],t[2])}return n.apply(e,t)}},function(n,e,t){var a=t(227),r=t(230)(a);n.exports=r},function(n,e,t){var a=t(228),r=t(229),i=t(47),o=r?function(n,e){return r(n,"toString",{configurable:!0,enumerable:!1,value:a(e),writable:!0})}:i;n.exports=o},function(n,e){n.exports=function(n){return function(){return n}}},function(n,e,t){var a=t(10),r=function(){try{var n=a(Object,"defineProperty");return n({},"",{}),n}catch(n){}}();n.exports=r},function(n,e){var t=Date.now;n.exports=function(n){var e=0,a=0;return function(){var r=t(),i=16-(r-a);if(a=r,i>0){if(++e>=800)return arguments[0]}else e=0;return n.apply(void 0,arguments)}}},function(n,e,t){var a=t(77),r=t(232),i=t(237),o=t(78),s=t(238),l=t(43);n.exports=function(n,e,t){var c=-1,p=r,d=n.length,u=!0,m=[],g=m;if(t)u=!1,p=i;else if(d>=200){var b=e?null:s(n);if(b)return l(b);u=!1,p=o,g=new a}else g=e?[]:m;n:for(;++c<d;){var h=n[c],v=e?e(h):h;if(h=t||0!==h?h:0,u&&v==v){for(var f=g.length;f--;)if(g[f]===v)continue n;e&&g.push(v),m.push(h)}else p(g,v,t)||(g!==m&&g.push(v),m.push(h))}return m}},function(n,e,t){var a=t(233);n.exports=function(n,e){return!!(null==n?0:n.length)&&a(n,e,0)>-1}},function(n,e,t){var a=t(234),r=t(235),i=t(236);n.exports=function(n,e,t){return e==e?i(n,e,t):a(n,r,t)}},function(n,e){n.exports=function(n,e,t,a){for(var r=n.length,i=t+(a?1:-1);a?i--:++i<r;)if(e(n[i],i,n))return i;return-1}},function(n,e){n.exports=function(n){return n!=n}},function(n,e){n.exports=function(n,e,t){for(var a=t-1,r=n.length;++a<r;)if(n[a]===e)return a;return-1}},function(n,e){n.exports=function(n,e,t){for(var a=-1,r=null==n?0:n.length;++a<r;)if(t(e,n[a]))return!0;return!1}},function(n,e,t){var a=t(84),r=t(239),i=t(43),o=a&&1/i(new a([,-0]))[1]==1/0?function(n){return new a(n)}:r;n.exports=o},function(n,e){n.exports=function(){}},function(n,e,t){var a=t(83),r=t(12);n.exports=function(n){return r(n)&&a(n)}},function(n,e,t){},function(n,e,t){},function(n,e,t){"use strict";t(89)},function(n,e,t){"use strict";t(90)},function(n,e,t){},function(n,e,t){},function(n,e,t){var a=t(19),r=t(2),i=t(248);a({global:!0},{Reflect:{}}),i(r.Reflect,"Reflect",!0)},function(n,e,t){var a=t(13).f,r=t(7),i=t(21)("toStringTag");n.exports=function(n,e,t){n&&!t&&(n=n.prototype),n&&!r(n,i)&&a(n,i,{configurable:!0,value:e})}},function(n,e){},function(n,e){function t(n,e){for(var t=0,a=n.length-1;a>=0;a--){var r=n[a];"."===r?n.splice(a,1):".."===r?(n.splice(a,1),t++):t&&(n.splice(a,1),t--)}if(e)for(;t--;t)n.unshift("..");return n}function a(n,e){if(n.filter)return n.filter(e);for(var t=[],a=0;a<n.length;a++)e(n[a],a,n)&&t.push(n[a]);return t}e.resolve=function(){for(var n="",e=!1,r=arguments.length-1;r>=-1&&!e;r--){var i=r>=0?arguments[r]:process.cwd();if("string"!=typeof i)throw new TypeError("Arguments to path.resolve must be strings");i&&(n=i+"/"+n,e="/"===i.charAt(0))}return(e?"/":"")+(n=t(a(n.split("/"),(function(n){return!!n})),!e).join("/"))||"."},e.normalize=function(n){var i=e.isAbsolute(n),o="/"===r(n,-1);return(n=t(a(n.split("/"),(function(n){return!!n})),!i).join("/"))||i||(n="."),n&&o&&(n+="/"),(i?"/":"")+n},e.isAbsolute=function(n){return"/"===n.charAt(0)},e.join=function(){var n=Array.prototype.slice.call(arguments,0);return e.normalize(a(n,(function(n,e){if("string"!=typeof n)throw new TypeError("Arguments to path.join must be strings");return n})).join("/"))},e.relative=function(n,t){function a(n){for(var e=0;e<n.length&&""===n[e];e++);for(var t=n.length-1;t>=0&&""===n[t];t--);return e>t?[]:n.slice(e,t-e+1)}n=e.resolve(n).substr(1),t=e.resolve(t).substr(1);for(var r=a(n.split("/")),i=a(t.split("/")),o=Math.min(r.length,i.length),s=o,l=0;l<o;l++)if(r[l]!==i[l]){s=l;break}var c=[];for(l=s;l<r.length;l++)c.push("..");return(c=c.concat(i.slice(s))).join("/")},e.sep="/",e.delimiter=":",e.dirname=function(n){if("string"!=typeof n&&(n+=""),0===n.length)return".";for(var e=n.charCodeAt(0),t=47===e,a=-1,r=!0,i=n.length-1;i>=1;--i)if(47===(e=n.charCodeAt(i))){if(!r){a=i;break}}else r=!1;return-1===a?t?"/":".":t&&1===a?"/":n.slice(0,a)},e.basename=function(n,e){var t=function(n){"string"!=typeof n&&(n+="");var e,t=0,a=-1,r=!0;for(e=n.length-1;e>=0;--e)if(47===n.charCodeAt(e)){if(!r){t=e+1;break}}else-1===a&&(r=!1,a=e+1);return-1===a?"":n.slice(t,a)}(n);return e&&t.substr(-1*e.length)===e&&(t=t.substr(0,t.length-e.length)),t},e.extname=function(n){"string"!=typeof n&&(n+="");for(var e=-1,t=0,a=-1,r=!0,i=0,o=n.length-1;o>=0;--o){var s=n.charCodeAt(o);if(47!==s)-1===a&&(r=!1,a=o+1),46===s?-1===e?e=o:1!==i&&(i=1):-1!==e&&(i=-1);else if(!r){t=o+1;break}}return-1===e||-1===a||0===i||1===i&&e===a-1&&e===t+1?"":n.slice(e,a)};var r="b"==="ab".substr(-1)?function(n,e,t){return n.substr(e,t)}:function(n,e,t){return e<0&&(e=n.length+e),n.substr(e,t)}},function(n,e,t){"use strict";var a=/[|\\{}()[\]^$+*?.]/g;e.escapeRegExpChars=function(n){return n?String(n).replace(a,"\\$&"):""};var r={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&#34;","'":"&#39;"},i=/[&<>'"]/g;function o(n){return r[n]||n}e.escapeXML=function(n){return null==n?"":String(n).replace(i,o)},e.escapeXML.toString=function(){return Function.prototype.toString.call(this)+';\nvar _ENCODE_HTML_RULES = {\n      "&": "&amp;"\n    , "<": "&lt;"\n    , ">": "&gt;"\n    , \'"\': "&#34;"\n    , "\'": "&#39;"\n    }\n  , _MATCH_HTML = /[&<>\'"]/g;\nfunction encode_char(c) {\n  return _ENCODE_HTML_RULES[c] || c;\n};\n'},e.shallowCopy=function(n,e){for(var t in e=e||{})n[t]=e[t];return n},e.shallowCopyFromList=function(n,e,t){for(var a=0;a<t.length;a++){var r=t[a];void 0!==e[r]&&(n[r]=e[r])}return n},e.cache={_data:{},set:function(n,e){this._data[n]=e},get:function(n){return this._data[n]},remove:function(n){delete this._data[n]},reset:function(){this._data={}}}},function(n){n.exports=JSON.parse('{"name":"ejs","description":"Embedded JavaScript templates","keywords":["template","engine","ejs"],"version":"2.7.4","author":"Matthew Eernisse <mde@fleegix.org> (http://fleegix.org)","license":"Apache-2.0","main":"./lib/ejs.js","repository":{"type":"git","url":"git://github.com/mde/ejs.git"},"bugs":"https://github.com/mde/ejs/issues","homepage":"https://github.com/mde/ejs","dependencies":{},"devDependencies":{"browserify":"^13.1.1","eslint":"^4.14.0","git-directory-deploy":"^1.5.1","jake":"^10.3.1","jsdoc":"^3.4.0","lru-cache":"^4.0.1","mocha":"^5.0.5","uglify-js":"^3.3.16"},"engines":{"node":">=0.10.0"},"scripts":{"test":"mocha","postinstall":"node ./postinstall.js"}}')},function(n,e,t){"use strict";t(91)},function(n,e,t){"use strict";t(92)},function(n,e,t){"use strict";t.r(e);
/*!
 * Vue.js v2.7.14
 * (c) 2014-2022 Evan You
 * Released under the MIT License.
 */
var a=Object.freeze({}),r=Array.isArray;function i(n){return null==n}function o(n){return null!=n}function s(n){return!0===n}function l(n){return"string"==typeof n||"number"==typeof n||"symbol"==typeof n||"boolean"==typeof n}function c(n){return"function"==typeof n}function p(n){return null!==n&&"object"==typeof n}var d=Object.prototype.toString;function u(n){return"[object Object]"===d.call(n)}function m(n){return"[object RegExp]"===d.call(n)}function g(n){var e=parseFloat(String(n));return e>=0&&Math.floor(e)===e&&isFinite(n)}function b(n){return o(n)&&"function"==typeof n.then&&"function"==typeof n.catch}function h(n){return null==n?"":Array.isArray(n)||u(n)&&n.toString===d?JSON.stringify(n,null,2):String(n)}function v(n){var e=parseFloat(n);return isNaN(e)?n:e}function f(n,e){for(var t=Object.create(null),a=n.split(","),r=0;r<a.length;r++)t[a[r]]=!0;return e?function(n){return t[n.toLowerCase()]}:function(n){return t[n]}}f("slot,component",!0);var y=f("key,ref,slot,slot-scope,is");function x(n,e){var t=n.length;if(t){if(e===n[t-1])return void(n.length=t-1);var a=n.indexOf(e);if(a>-1)return n.splice(a,1)}}var w=Object.prototype.hasOwnProperty;function S(n,e){return w.call(n,e)}function j(n){var e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}var k=/-(\w)/g,T=j((function(n){return n.replace(k,(function(n,e){return e?e.toUpperCase():""}))})),E=j((function(n){return n.charAt(0).toUpperCase()+n.slice(1)})),I=/\B([A-Z])/g,C=j((function(n){return n.replace(I,"-$1").toLowerCase()}));var _=Function.prototype.bind?function(n,e){return n.bind(e)}:function(n,e){function t(t){var a=arguments.length;return a?a>1?n.apply(e,arguments):n.call(e,t):n.call(e)}return t._length=n.length,t};function A(n,e){e=e||0;for(var t=n.length-e,a=new Array(t);t--;)a[t]=n[t+e];return a}function q(n,e){for(var t in e)n[t]=e[t];return n}function L(n){for(var e={},t=0;t<n.length;t++)n[t]&&q(e,n[t]);return e}function M(n,e,t){}var D=function(n,e,t){return!1},O=function(n){return n};function R(n,e){if(n===e)return!0;var t=p(n),a=p(e);if(!t||!a)return!t&&!a&&String(n)===String(e);try{var r=Array.isArray(n),i=Array.isArray(e);if(r&&i)return n.length===e.length&&n.every((function(n,t){return R(n,e[t])}));if(n instanceof Date&&e instanceof Date)return n.getTime()===e.getTime();if(r||i)return!1;var o=Object.keys(n),s=Object.keys(e);return o.length===s.length&&o.every((function(t){return R(n[t],e[t])}))}catch(n){return!1}}function P(n,e){for(var t=0;t<n.length;t++)if(R(n[t],e))return t;return-1}function B(n){var e=!1;return function(){e||(e=!0,n.apply(this,arguments))}}function z(n,e){return n===e?0===n&&1/n!=1/e:n==n||e==e}var N=["component","directive","filter"],U=["beforeCreate","created","beforeMount","mounted","beforeUpdate","updated","beforeDestroy","destroyed","activated","deactivated","errorCaptured","serverPrefetch","renderTracked","renderTriggered"],F={optionMergeStrategies:Object.create(null),silent:!1,productionTip:!1,devtools:!1,performance:!1,errorHandler:null,warnHandler:null,ignoredElements:[],keyCodes:Object.create(null),isReservedTag:D,isReservedAttr:D,isUnknownElement:D,getTagNamespace:M,parsePlatformTagName:O,mustUseProp:D,async:!0,_lifecycleHooks:U},J=/a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/;function $(n){var e=(n+"").charCodeAt(0);return 36===e||95===e}function H(n,e,t,a){Object.defineProperty(n,e,{value:t,enumerable:!!a,writable:!0,configurable:!0})}var G=new RegExp("[^".concat(J.source,".$_\\d]"));var V="__proto__"in{},W="undefined"!=typeof window,Q=W&&window.navigator.userAgent.toLowerCase(),X=Q&&/msie|trident/.test(Q),K=Q&&Q.indexOf("msie 9.0")>0,Y=Q&&Q.indexOf("edge/")>0;Q&&Q.indexOf("android");var Z=Q&&/iphone|ipad|ipod|ios/.test(Q);Q&&/chrome\/\d+/.test(Q),Q&&/phantomjs/.test(Q);var nn,en=Q&&Q.match(/firefox\/(\d+)/),tn={}.watch,an=!1;if(W)try{var rn={};Object.defineProperty(rn,"passive",{get:function(){an=!0}}),window.addEventListener("test-passive",null,rn)}catch(n){}var on=function(){return void 0===nn&&(nn=!W&&"undefined"!=typeof global&&(global.process&&"server"===global.process.env.VUE_ENV)),nn},sn=W&&window.__VUE_DEVTOOLS_GLOBAL_HOOK__;function ln(n){return"function"==typeof n&&/native code/.test(n.toString())}var cn,pn="undefined"!=typeof Symbol&&ln(Symbol)&&"undefined"!=typeof Reflect&&ln(Reflect.ownKeys);cn="undefined"!=typeof Set&&ln(Set)?Set:function(){function n(){this.set=Object.create(null)}return n.prototype.has=function(n){return!0===this.set[n]},n.prototype.add=function(n){this.set[n]=!0},n.prototype.clear=function(){this.set=Object.create(null)},n}();var dn=null;function un(n){void 0===n&&(n=null),n||dn&&dn._scope.off(),dn=n,n&&n._scope.on()}var mn=function(){function n(n,e,t,a,r,i,o,s){this.tag=n,this.data=e,this.children=t,this.text=a,this.elm=r,this.ns=void 0,this.context=i,this.fnContext=void 0,this.fnOptions=void 0,this.fnScopeId=void 0,this.key=e&&e.key,this.componentOptions=o,this.componentInstance=void 0,this.parent=void 0,this.raw=!1,this.isStatic=!1,this.isRootInsert=!0,this.isComment=!1,this.isCloned=!1,this.isOnce=!1,this.asyncFactory=s,this.asyncMeta=void 0,this.isAsyncPlaceholder=!1}return Object.defineProperty(n.prototype,"child",{get:function(){return this.componentInstance},enumerable:!1,configurable:!0}),n}(),gn=function(n){void 0===n&&(n="");var e=new mn;return e.text=n,e.isComment=!0,e};function bn(n){return new mn(void 0,void 0,void 0,String(n))}function hn(n){var e=new mn(n.tag,n.data,n.children&&n.children.slice(),n.text,n.elm,n.context,n.componentOptions,n.asyncFactory);return e.ns=n.ns,e.isStatic=n.isStatic,e.key=n.key,e.isComment=n.isComment,e.fnContext=n.fnContext,e.fnOptions=n.fnOptions,e.fnScopeId=n.fnScopeId,e.asyncMeta=n.asyncMeta,e.isCloned=!0,e}var vn=0,fn=[],yn=function(){function n(){this._pending=!1,this.id=vn++,this.subs=[]}return n.prototype.addSub=function(n){this.subs.push(n)},n.prototype.removeSub=function(n){this.subs[this.subs.indexOf(n)]=null,this._pending||(this._pending=!0,fn.push(this))},n.prototype.depend=function(e){n.target&&n.target.addDep(this)},n.prototype.notify=function(n){var e=this.subs.filter((function(n){return n}));for(var t=0,a=e.length;t<a;t++){0,e[t].update()}},n}();yn.target=null;var xn=[];function wn(n){xn.push(n),yn.target=n}function Sn(){xn.pop(),yn.target=xn[xn.length-1]}var jn=Array.prototype,kn=Object.create(jn);["push","pop","shift","unshift","splice","sort","reverse"].forEach((function(n){var e=jn[n];H(kn,n,(function(){for(var t=[],a=0;a<arguments.length;a++)t[a]=arguments[a];var r,i=e.apply(this,t),o=this.__ob__;switch(n){case"push":case"unshift":r=t;break;case"splice":r=t.slice(2)}return r&&o.observeArray(r),o.dep.notify(),i}))}));var Tn=Object.getOwnPropertyNames(kn),En={},In=!0;function Cn(n){In=n}var _n={notify:M,depend:M,addSub:M,removeSub:M},An=function(){function n(n,e,t){if(void 0===e&&(e=!1),void 0===t&&(t=!1),this.value=n,this.shallow=e,this.mock=t,this.dep=t?_n:new yn,this.vmCount=0,H(n,"__ob__",this),r(n)){if(!t)if(V)n.__proto__=kn;else for(var a=0,i=Tn.length;a<i;a++){H(n,s=Tn[a],kn[s])}e||this.observeArray(n)}else{var o=Object.keys(n);for(a=0;a<o.length;a++){var s;Ln(n,s=o[a],En,void 0,e,t)}}}return n.prototype.observeArray=function(n){for(var e=0,t=n.length;e<t;e++)qn(n[e],!1,this.mock)},n}();function qn(n,e,t){return n&&S(n,"__ob__")&&n.__ob__ instanceof An?n.__ob__:!In||!t&&on()||!r(n)&&!u(n)||!Object.isExtensible(n)||n.__v_skip||zn(n)||n instanceof mn?void 0:new An(n,e,t)}function Ln(n,e,t,a,i,o){var s=new yn,l=Object.getOwnPropertyDescriptor(n,e);if(!l||!1!==l.configurable){var c=l&&l.get,p=l&&l.set;c&&!p||t!==En&&2!==arguments.length||(t=n[e]);var d=!i&&qn(t,!1,o);return Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){var e=c?c.call(n):t;return yn.target&&(s.depend(),d&&(d.dep.depend(),r(e)&&On(e))),zn(e)&&!i?e.value:e},set:function(e){var a=c?c.call(n):t;if(z(a,e)){if(p)p.call(n,e);else{if(c)return;if(!i&&zn(a)&&!zn(e))return void(a.value=e);t=e}d=!i&&qn(e,!1,o),s.notify()}}}),s}}function Mn(n,e,t){if(!Bn(n)){var a=n.__ob__;return r(n)&&g(e)?(n.length=Math.max(n.length,e),n.splice(e,1,t),a&&!a.shallow&&a.mock&&qn(t,!1,!0),t):e in n&&!(e in Object.prototype)?(n[e]=t,t):n._isVue||a&&a.vmCount?t:a?(Ln(a.value,e,t,void 0,a.shallow,a.mock),a.dep.notify(),t):(n[e]=t,t)}}function Dn(n,e){if(r(n)&&g(e))n.splice(e,1);else{var t=n.__ob__;n._isVue||t&&t.vmCount||Bn(n)||S(n,e)&&(delete n[e],t&&t.dep.notify())}}function On(n){for(var e=void 0,t=0,a=n.length;t<a;t++)(e=n[t])&&e.__ob__&&e.__ob__.dep.depend(),r(e)&&On(e)}function Rn(n){return Pn(n,!0),H(n,"__v_isShallow",!0),n}function Pn(n,e){if(!Bn(n)){qn(n,e,on());0}}function Bn(n){return!(!n||!n.__v_isReadonly)}function zn(n){return!(!n||!0!==n.__v_isRef)}function Nn(n,e,t){Object.defineProperty(n,t,{enumerable:!0,configurable:!0,get:function(){var n=e[t];if(zn(n))return n.value;var a=n&&n.__ob__;return a&&a.dep.depend(),n},set:function(n){var a=e[t];zn(a)&&!zn(n)?a.value=n:e[t]=n}})}"".concat("watcher"," callback"),"".concat("watcher"," getter"),"".concat("watcher"," cleanup");var Un;var Fn=function(){function n(n){void 0===n&&(n=!1),this.detached=n,this.active=!0,this.effects=[],this.cleanups=[],this.parent=Un,!n&&Un&&(this.index=(Un.scopes||(Un.scopes=[])).push(this)-1)}return n.prototype.run=function(n){if(this.active){var e=Un;try{return Un=this,n()}finally{Un=e}}else 0},n.prototype.on=function(){Un=this},n.prototype.off=function(){Un=this.parent},n.prototype.stop=function(n){if(this.active){var e=void 0,t=void 0;for(e=0,t=this.effects.length;e<t;e++)this.effects[e].teardown();for(e=0,t=this.cleanups.length;e<t;e++)this.cleanups[e]();if(this.scopes)for(e=0,t=this.scopes.length;e<t;e++)this.scopes[e].stop(!0);if(!this.detached&&this.parent&&!n){var a=this.parent.scopes.pop();a&&a!==this&&(this.parent.scopes[this.index]=a,a.index=this.index)}this.parent=void 0,this.active=!1}},n}();function Jn(n){var e=n._provided,t=n.$parent&&n.$parent._provided;return t===e?n._provided=Object.create(t):e}var $n=j((function(n){var e="&"===n.charAt(0),t="~"===(n=e?n.slice(1):n).charAt(0),a="!"===(n=t?n.slice(1):n).charAt(0);return{name:n=a?n.slice(1):n,once:t,capture:a,passive:e}}));function Hn(n,e){function t(){var n=t.fns;if(!r(n))return Ie(n,null,arguments,e,"v-on handler");for(var a=n.slice(),i=0;i<a.length;i++)Ie(a[i],null,arguments,e,"v-on handler")}return t.fns=n,t}function Gn(n,e,t,a,r,o){var l,c,p,d;for(l in n)c=n[l],p=e[l],d=$n(l),i(c)||(i(p)?(i(c.fns)&&(c=n[l]=Hn(c,o)),s(d.once)&&(c=n[l]=r(d.name,c,d.capture)),t(d.name,c,d.capture,d.passive,d.params)):c!==p&&(p.fns=c,n[l]=p));for(l in e)i(n[l])&&a((d=$n(l)).name,e[l],d.capture)}function Vn(n,e,t){var a;n instanceof mn&&(n=n.data.hook||(n.data.hook={}));var r=n[e];function l(){t.apply(this,arguments),x(a.fns,l)}i(r)?a=Hn([l]):o(r.fns)&&s(r.merged)?(a=r).fns.push(l):a=Hn([r,l]),a.merged=!0,n[e]=a}function Wn(n,e,t,a,r){if(o(e)){if(S(e,t))return n[t]=e[t],r||delete e[t],!0;if(S(e,a))return n[t]=e[a],r||delete e[a],!0}return!1}function Qn(n){return l(n)?[bn(n)]:r(n)?function n(e,t){var a,c,p,d,u=[];for(a=0;a<e.length;a++)i(c=e[a])||"boolean"==typeof c||(p=u.length-1,d=u[p],r(c)?c.length>0&&(Xn((c=n(c,"".concat(t||"","_").concat(a)))[0])&&Xn(d)&&(u[p]=bn(d.text+c[0].text),c.shift()),u.push.apply(u,c)):l(c)?Xn(d)?u[p]=bn(d.text+c):""!==c&&u.push(bn(c)):Xn(c)&&Xn(d)?u[p]=bn(d.text+c.text):(s(e._isVList)&&o(c.tag)&&i(c.key)&&o(t)&&(c.key="__vlist".concat(t,"_").concat(a,"__")),u.push(c)));return u}(n):void 0}function Xn(n){return o(n)&&o(n.text)&&!1===n.isComment}function Kn(n,e){var t,a,i,s,l=null;if(r(n)||"string"==typeof n)for(l=new Array(n.length),t=0,a=n.length;t<a;t++)l[t]=e(n[t],t);else if("number"==typeof n)for(l=new Array(n),t=0;t<n;t++)l[t]=e(t+1,t);else if(p(n))if(pn&&n[Symbol.iterator]){l=[];for(var c=n[Symbol.iterator](),d=c.next();!d.done;)l.push(e(d.value,l.length)),d=c.next()}else for(i=Object.keys(n),l=new Array(i.length),t=0,a=i.length;t<a;t++)s=i[t],l[t]=e(n[s],s,t);return o(l)||(l=[]),l._isVList=!0,l}function Yn(n,e,t,a){var r,i=this.$scopedSlots[n];i?(t=t||{},a&&(t=q(q({},a),t)),r=i(t)||(c(e)?e():e)):r=this.$slots[n]||(c(e)?e():e);var o=t&&t.slot;return o?this.$createElement("template",{slot:o},r):r}function Zn(n){return At(this.$options,"filters",n,!0)||O}function ne(n,e){return r(n)?-1===n.indexOf(e):n!==e}function ee(n,e,t,a,r){var i=F.keyCodes[e]||t;return r&&a&&!F.keyCodes[e]?ne(r,a):i?ne(i,n):a?C(a)!==e:void 0===n}function te(n,e,t,a,i){if(t)if(p(t)){r(t)&&(t=L(t));var o=void 0,s=function(r){if("class"===r||"style"===r||y(r))o=n;else{var s=n.attrs&&n.attrs.type;o=a||F.mustUseProp(e,s,r)?n.domProps||(n.domProps={}):n.attrs||(n.attrs={})}var l=T(r),c=C(r);l in o||c in o||(o[r]=t[r],i&&((n.on||(n.on={}))["update:".concat(r)]=function(n){t[r]=n}))};for(var l in t)s(l)}else;return n}function ae(n,e){var t=this._staticTrees||(this._staticTrees=[]),a=t[n];return a&&!e||ie(a=t[n]=this.$options.staticRenderFns[n].call(this._renderProxy,this._c,this),"__static__".concat(n),!1),a}function re(n,e,t){return ie(n,"__once__".concat(e).concat(t?"_".concat(t):""),!0),n}function ie(n,e,t){if(r(n))for(var a=0;a<n.length;a++)n[a]&&"string"!=typeof n[a]&&oe(n[a],"".concat(e,"_").concat(a),t);else oe(n,e,t)}function oe(n,e,t){n.isStatic=!0,n.key=e,n.isOnce=t}function se(n,e){if(e)if(u(e)){var t=n.on=n.on?q({},n.on):{};for(var a in e){var r=t[a],i=e[a];t[a]=r?[].concat(r,i):i}}else;return n}function le(n,e,t,a){e=e||{$stable:!t};for(var i=0;i<n.length;i++){var o=n[i];r(o)?le(o,e,t):o&&(o.proxy&&(o.fn.proxy=!0),e[o.key]=o.fn)}return a&&(e.$key=a),e}function ce(n,e){for(var t=0;t<e.length;t+=2){var a=e[t];"string"==typeof a&&a&&(n[e[t]]=e[t+1])}return n}function pe(n,e){return"string"==typeof n?e+n:n}function de(n){n._o=re,n._n=v,n._s=h,n._l=Kn,n._t=Yn,n._q=R,n._i=P,n._m=ae,n._f=Zn,n._k=ee,n._b=te,n._v=bn,n._e=gn,n._u=le,n._g=se,n._d=ce,n._p=pe}function ue(n,e){if(!n||!n.length)return{};for(var t={},a=0,r=n.length;a<r;a++){var i=n[a],o=i.data;if(o&&o.attrs&&o.attrs.slot&&delete o.attrs.slot,i.context!==e&&i.fnContext!==e||!o||null==o.slot)(t.default||(t.default=[])).push(i);else{var s=o.slot,l=t[s]||(t[s]=[]);"template"===i.tag?l.push.apply(l,i.children||[]):l.push(i)}}for(var c in t)t[c].every(me)&&delete t[c];return t}function me(n){return n.isComment&&!n.asyncFactory||" "===n.text}function ge(n){return n.isComment&&n.asyncFactory}function be(n,e,t,r){var i,o=Object.keys(t).length>0,s=e?!!e.$stable:!o,l=e&&e.$key;if(e){if(e._normalized)return e._normalized;if(s&&r&&r!==a&&l===r.$key&&!o&&!r.$hasNormal)return r;for(var c in i={},e)e[c]&&"$"!==c[0]&&(i[c]=he(n,t,c,e[c]))}else i={};for(var p in t)p in i||(i[p]=ve(t,p));return e&&Object.isExtensible(e)&&(e._normalized=i),H(i,"$stable",s),H(i,"$key",l),H(i,"$hasNormal",o),i}function he(n,e,t,a){var i=function(){var e=dn;un(n);var t=arguments.length?a.apply(null,arguments):a({}),i=(t=t&&"object"==typeof t&&!r(t)?[t]:Qn(t))&&t[0];return un(e),t&&(!i||1===t.length&&i.isComment&&!ge(i))?void 0:t};return a.proxy&&Object.defineProperty(e,t,{get:i,enumerable:!0,configurable:!0}),i}function ve(n,e){return function(){return n[e]}}function fe(n){return{get attrs(){if(!n._attrsProxy){var e=n._attrsProxy={};H(e,"_v_attr_proxy",!0),ye(e,n.$attrs,a,n,"$attrs")}return n._attrsProxy},get listeners(){n._listenersProxy||ye(n._listenersProxy={},n.$listeners,a,n,"$listeners");return n._listenersProxy},get slots(){return function(n){n._slotsProxy||we(n._slotsProxy={},n.$scopedSlots);return n._slotsProxy}(n)},emit:_(n.$emit,n),expose:function(e){e&&Object.keys(e).forEach((function(t){return Nn(n,e,t)}))}}}function ye(n,e,t,a,r){var i=!1;for(var o in e)o in n?e[o]!==t[o]&&(i=!0):(i=!0,xe(n,o,a,r));for(var o in n)o in e||(i=!0,delete n[o]);return i}function xe(n,e,t,a){Object.defineProperty(n,e,{enumerable:!0,configurable:!0,get:function(){return t[a][e]}})}function we(n,e){for(var t in e)n[t]=e[t];for(var t in n)t in e||delete n[t]}var Se=null;function je(n,e){return(n.__esModule||pn&&"Module"===n[Symbol.toStringTag])&&(n=n.default),p(n)?e.extend(n):n}function ke(n){if(r(n))for(var e=0;e<n.length;e++){var t=n[e];if(o(t)&&(o(t.componentOptions)||ge(t)))return t}}function Te(n,e,t,a,d,u){return(r(t)||l(t))&&(d=a,a=t,t=void 0),s(u)&&(d=2),function(n,e,t,a,l){if(o(t)&&o(t.__ob__))return gn();o(t)&&o(t.is)&&(e=t.is);if(!e)return gn();0;r(a)&&c(a[0])&&((t=t||{}).scopedSlots={default:a[0]},a.length=0);2===l?a=Qn(a):1===l&&(a=function(n){for(var e=0;e<n.length;e++)if(r(n[e]))return Array.prototype.concat.apply([],n);return n}(a));var d,u;if("string"==typeof e){var m=void 0;u=n.$vnode&&n.$vnode.ns||F.getTagNamespace(e),d=F.isReservedTag(e)?new mn(F.parsePlatformTagName(e),t,a,void 0,void 0,n):t&&t.pre||!o(m=At(n.$options,"components",e))?new mn(e,t,a,void 0,void 0,n):xt(m,t,n,a,e)}else d=xt(e,t,n,a);return r(d)?d:o(d)?(o(u)&&function n(e,t,a){e.ns=t,"foreignObject"===e.tag&&(t=void 0,a=!0);if(o(e.children))for(var r=0,l=e.children.length;r<l;r++){var c=e.children[r];o(c.tag)&&(i(c.ns)||s(a)&&"svg"!==c.tag)&&n(c,t,a)}}(d,u),o(t)&&function(n){p(n.style)&&Fe(n.style);p(n.class)&&Fe(n.class)}(t),d):gn()}(n,e,t,a,d)}function Ee(n,e,t){wn();try{if(e)for(var a=e;a=a.$parent;){var r=a.$options.errorCaptured;if(r)for(var i=0;i<r.length;i++)try{if(!1===r[i].call(a,n,e,t))return}catch(n){Ce(n,a,"errorCaptured hook")}}Ce(n,e,t)}finally{Sn()}}function Ie(n,e,t,a,r){var i;try{(i=t?n.apply(e,t):n.call(e))&&!i._isVue&&b(i)&&!i._handled&&(i.catch((function(n){return Ee(n,a,r+" (Promise/async)")})),i._handled=!0)}catch(n){Ee(n,a,r)}return i}function Ce(n,e,t){if(F.errorHandler)try{return F.errorHandler.call(null,n,e,t)}catch(e){e!==n&&_e(e,null,"config.errorHandler")}_e(n,e,t)}function _e(n,e,t){if(!W||"undefined"==typeof console)throw n;console.error(n)}var Ae,qe=!1,Le=[],Me=!1;function De(){Me=!1;var n=Le.slice(0);Le.length=0;for(var e=0;e<n.length;e++)n[e]()}if("undefined"!=typeof Promise&&ln(Promise)){var Oe=Promise.resolve();Ae=function(){Oe.then(De),Z&&setTimeout(M)},qe=!0}else if(X||"undefined"==typeof MutationObserver||!ln(MutationObserver)&&"[object MutationObserverConstructor]"!==MutationObserver.toString())Ae="undefined"!=typeof setImmediate&&ln(setImmediate)?function(){setImmediate(De)}:function(){setTimeout(De,0)};else{var Re=1,Pe=new MutationObserver(De),Be=document.createTextNode(String(Re));Pe.observe(Be,{characterData:!0}),Ae=function(){Re=(Re+1)%2,Be.data=String(Re)},qe=!0}function ze(n,e){var t;if(Le.push((function(){if(n)try{n.call(e)}catch(n){Ee(n,e,"nextTick")}else t&&t(e)})),Me||(Me=!0,Ae()),!n&&"undefined"!=typeof Promise)return new Promise((function(n){t=n}))}function Ne(n){return function(e,t){if(void 0===t&&(t=dn),t)return function(n,e,t){var a=n.$options;a[e]=Et(a[e],t)}(t,n,e)}}Ne("beforeMount"),Ne("mounted"),Ne("beforeUpdate"),Ne("updated"),Ne("beforeDestroy"),Ne("destroyed"),Ne("activated"),Ne("deactivated"),Ne("serverPrefetch"),Ne("renderTracked"),Ne("renderTriggered"),Ne("errorCaptured");var Ue=new cn;function Fe(n){return function n(e,t){var a,i,o=r(e);if(!o&&!p(e)||e.__v_skip||Object.isFrozen(e)||e instanceof mn)return;if(e.__ob__){var s=e.__ob__.dep.id;if(t.has(s))return;t.add(s)}if(o)for(a=e.length;a--;)n(e[a],t);else if(zn(e))n(e.value,t);else for(i=Object.keys(e),a=i.length;a--;)n(e[i[a]],t)}(n,Ue),Ue.clear(),n}var Je,$e=0,He=function(){function n(n,e,t,a,r){var i,o;i=this,void 0===(o=Un&&!Un._vm?Un:n?n._scope:void 0)&&(o=Un),o&&o.active&&o.effects.push(i),(this.vm=n)&&r&&(n._watcher=this),a?(this.deep=!!a.deep,this.user=!!a.user,this.lazy=!!a.lazy,this.sync=!!a.sync,this.before=a.before):this.deep=this.user=this.lazy=this.sync=!1,this.cb=t,this.id=++$e,this.active=!0,this.post=!1,this.dirty=this.lazy,this.deps=[],this.newDeps=[],this.depIds=new cn,this.newDepIds=new cn,this.expression="",c(e)?this.getter=e:(this.getter=function(n){if(!G.test(n)){var e=n.split(".");return function(n){for(var t=0;t<e.length;t++){if(!n)return;n=n[e[t]]}return n}}}(e),this.getter||(this.getter=M)),this.value=this.lazy?void 0:this.get()}return n.prototype.get=function(){var n;wn(this);var e=this.vm;try{n=this.getter.call(e,e)}catch(n){if(!this.user)throw n;Ee(n,e,'getter for watcher "'.concat(this.expression,'"'))}finally{this.deep&&Fe(n),Sn(),this.cleanupDeps()}return n},n.prototype.addDep=function(n){var e=n.id;this.newDepIds.has(e)||(this.newDepIds.add(e),this.newDeps.push(n),this.depIds.has(e)||n.addSub(this))},n.prototype.cleanupDeps=function(){for(var n=this.deps.length;n--;){var e=this.deps[n];this.newDepIds.has(e.id)||e.removeSub(this)}var t=this.depIds;this.depIds=this.newDepIds,this.newDepIds=t,this.newDepIds.clear(),t=this.deps,this.deps=this.newDeps,this.newDeps=t,this.newDeps.length=0},n.prototype.update=function(){this.lazy?this.dirty=!0:this.sync?this.run():ut(this)},n.prototype.run=function(){if(this.active){var n=this.get();if(n!==this.value||p(n)||this.deep){var e=this.value;if(this.value=n,this.user){var t='callback for watcher "'.concat(this.expression,'"');Ie(this.cb,this.vm,[n,e],this.vm,t)}else this.cb.call(this.vm,n,e)}}},n.prototype.evaluate=function(){this.value=this.get(),this.dirty=!1},n.prototype.depend=function(){for(var n=this.deps.length;n--;)this.deps[n].depend()},n.prototype.teardown=function(){if(this.vm&&!this.vm._isBeingDestroyed&&x(this.vm._scope.effects,this),this.active){for(var n=this.deps.length;n--;)this.deps[n].removeSub(this);this.active=!1,this.onStop&&this.onStop()}},n}();function Ge(n,e){Je.$on(n,e)}function Ve(n,e){Je.$off(n,e)}function We(n,e){var t=Je;return function a(){var r=e.apply(null,arguments);null!==r&&t.$off(n,a)}}function Qe(n,e,t){Je=n,Gn(e,t||{},Ge,Ve,We,n),Je=void 0}var Xe=null;function Ke(n){var e=Xe;return Xe=n,function(){Xe=e}}function Ye(n){for(;n&&(n=n.$parent);)if(n._inactive)return!0;return!1}function Ze(n,e){if(e){if(n._directInactive=!1,Ye(n))return}else if(n._directInactive)return;if(n._inactive||null===n._inactive){n._inactive=!1;for(var t=0;t<n.$children.length;t++)Ze(n.$children[t]);nt(n,"activated")}}function nt(n,e,t,a){void 0===a&&(a=!0),wn();var r=dn;a&&un(n);var i=n.$options[e],o="".concat(e," hook");if(i)for(var s=0,l=i.length;s<l;s++)Ie(i[s],n,t||null,n,o);n._hasHookEvent&&n.$emit("hook:"+e),a&&un(r),Sn()}var et=[],tt=[],at={},rt=!1,it=!1,ot=0;var st=0,lt=Date.now;if(W&&!X){var ct=window.performance;ct&&"function"==typeof ct.now&&lt()>document.createEvent("Event").timeStamp&&(lt=function(){return ct.now()})}var pt=function(n,e){if(n.post){if(!e.post)return 1}else if(e.post)return-1;return n.id-e.id};function dt(){var n,e;for(st=lt(),it=!0,et.sort(pt),ot=0;ot<et.length;ot++)(n=et[ot]).before&&n.before(),e=n.id,at[e]=null,n.run();var t=tt.slice(),a=et.slice();ot=et.length=tt.length=0,at={},rt=it=!1,function(n){for(var e=0;e<n.length;e++)n[e]._inactive=!0,Ze(n[e],!0)}(t),function(n){var e=n.length;for(;e--;){var t=n[e],a=t.vm;a&&a._watcher===t&&a._isMounted&&!a._isDestroyed&&nt(a,"updated")}}(a),function(){for(var n=0;n<fn.length;n++){var e=fn[n];e.subs=e.subs.filter((function(n){return n})),e._pending=!1}fn.length=0}(),sn&&F.devtools&&sn.emit("flush")}function ut(n){var e=n.id;if(null==at[e]&&(n!==yn.target||!n.noRecurse)){if(at[e]=!0,it){for(var t=et.length-1;t>ot&&et[t].id>n.id;)t--;et.splice(t+1,0,n)}else et.push(n);rt||(rt=!0,ze(dt))}}function mt(n,e){if(n){for(var t=Object.create(null),a=pn?Reflect.ownKeys(n):Object.keys(n),r=0;r<a.length;r++){var i=a[r];if("__ob__"!==i){var o=n[i].from;if(o in e._provided)t[i]=e._provided[o];else if("default"in n[i]){var s=n[i].default;t[i]=c(s)?s.call(e):s}else 0}}return t}}function gt(n,e,t,i,o){var l,c=this,p=o.options;S(i,"_uid")?(l=Object.create(i))._original=i:(l=i,i=i._original);var d=s(p._compiled),u=!d;this.data=n,this.props=e,this.children=t,this.parent=i,this.listeners=n.on||a,this.injections=mt(p.inject,i),this.slots=function(){return c.$slots||be(i,n.scopedSlots,c.$slots=ue(t,i)),c.$slots},Object.defineProperty(this,"scopedSlots",{enumerable:!0,get:function(){return be(i,n.scopedSlots,this.slots())}}),d&&(this.$options=p,this.$slots=this.slots(),this.$scopedSlots=be(i,n.scopedSlots,this.$slots)),p._scopeId?this._c=function(n,e,t,a){var o=Te(l,n,e,t,a,u);return o&&!r(o)&&(o.fnScopeId=p._scopeId,o.fnContext=i),o}:this._c=function(n,e,t,a){return Te(l,n,e,t,a,u)}}function bt(n,e,t,a,r){var i=hn(n);return i.fnContext=t,i.fnOptions=a,e.slot&&((i.data||(i.data={})).slot=e.slot),i}function ht(n,e){for(var t in e)n[T(t)]=e[t]}function vt(n){return n.name||n.__name||n._componentTag}de(gt.prototype);var ft={init:function(n,e){if(n.componentInstance&&!n.componentInstance._isDestroyed&&n.data.keepAlive){var t=n;ft.prepatch(t,t)}else{(n.componentInstance=function(n,e){var t={_isComponent:!0,_parentVnode:n,parent:e},a=n.data.inlineTemplate;o(a)&&(t.render=a.render,t.staticRenderFns=a.staticRenderFns);return new n.componentOptions.Ctor(t)}(n,Xe)).$mount(e?n.elm:void 0,e)}},prepatch:function(n,e){var t=e.componentOptions;!function(n,e,t,r,i){var o=r.data.scopedSlots,s=n.$scopedSlots,l=!!(o&&!o.$stable||s!==a&&!s.$stable||o&&n.$scopedSlots.$key!==o.$key||!o&&n.$scopedSlots.$key),c=!!(i||n.$options._renderChildren||l),p=n.$vnode;n.$options._parentVnode=r,n.$vnode=r,n._vnode&&(n._vnode.parent=r),n.$options._renderChildren=i;var d=r.data.attrs||a;n._attrsProxy&&ye(n._attrsProxy,d,p.data&&p.data.attrs||a,n,"$attrs")&&(c=!0),n.$attrs=d,t=t||a;var u=n.$options._parentListeners;if(n._listenersProxy&&ye(n._listenersProxy,t,u||a,n,"$listeners"),n.$listeners=n.$options._parentListeners=t,Qe(n,t,u),e&&n.$options.props){Cn(!1);for(var m=n._props,g=n.$options._propKeys||[],b=0;b<g.length;b++){var h=g[b],v=n.$options.props;m[h]=qt(h,v,e,n)}Cn(!0),n.$options.propsData=e}c&&(n.$slots=ue(i,r.context),n.$forceUpdate())}(e.componentInstance=n.componentInstance,t.propsData,t.listeners,e,t.children)},insert:function(n){var e,t=n.context,a=n.componentInstance;a._isMounted||(a._isMounted=!0,nt(a,"mounted")),n.data.keepAlive&&(t._isMounted?((e=a)._inactive=!1,tt.push(e)):Ze(a,!0))},destroy:function(n){var e=n.componentInstance;e._isDestroyed||(n.data.keepAlive?function n(e,t){if(!(t&&(e._directInactive=!0,Ye(e))||e._inactive)){e._inactive=!0;for(var a=0;a<e.$children.length;a++)n(e.$children[a]);nt(e,"deactivated")}}(e,!0):e.$destroy())}},yt=Object.keys(ft);function xt(n,e,t,l,c){if(!i(n)){var d=t.$options._base;if(p(n)&&(n=d.extend(n)),"function"==typeof n){var u;if(i(n.cid)&&void 0===(n=function(n,e){if(s(n.error)&&o(n.errorComp))return n.errorComp;if(o(n.resolved))return n.resolved;var t=Se;if(t&&o(n.owners)&&-1===n.owners.indexOf(t)&&n.owners.push(t),s(n.loading)&&o(n.loadingComp))return n.loadingComp;if(t&&!o(n.owners)){var a=n.owners=[t],r=!0,l=null,c=null;t.$on("hook:destroyed",(function(){return x(a,t)}));var d=function(n){for(var e=0,t=a.length;e<t;e++)a[e].$forceUpdate();n&&(a.length=0,null!==l&&(clearTimeout(l),l=null),null!==c&&(clearTimeout(c),c=null))},u=B((function(t){n.resolved=je(t,e),r?a.length=0:d(!0)})),m=B((function(e){o(n.errorComp)&&(n.error=!0,d(!0))})),g=n(u,m);return p(g)&&(b(g)?i(n.resolved)&&g.then(u,m):b(g.component)&&(g.component.then(u,m),o(g.error)&&(n.errorComp=je(g.error,e)),o(g.loading)&&(n.loadingComp=je(g.loading,e),0===g.delay?n.loading=!0:l=setTimeout((function(){l=null,i(n.resolved)&&i(n.error)&&(n.loading=!0,d(!1))}),g.delay||200)),o(g.timeout)&&(c=setTimeout((function(){c=null,i(n.resolved)&&m(null)}),g.timeout)))),r=!1,n.loading?n.loadingComp:n.resolved}}(u=n,d)))return function(n,e,t,a,r){var i=gn();return i.asyncFactory=n,i.asyncMeta={data:e,context:t,children:a,tag:r},i}(u,e,t,l,c);e=e||{},Ht(n),o(e.model)&&function(n,e){var t=n.model&&n.model.prop||"value",a=n.model&&n.model.event||"input";(e.attrs||(e.attrs={}))[t]=e.model.value;var i=e.on||(e.on={}),s=i[a],l=e.model.callback;o(s)?(r(s)?-1===s.indexOf(l):s!==l)&&(i[a]=[l].concat(s)):i[a]=l}(n.options,e);var m=function(n,e,t){var a=e.options.props;if(!i(a)){var r={},s=n.attrs,l=n.props;if(o(s)||o(l))for(var c in a){var p=C(c);Wn(r,l,c,p,!0)||Wn(r,s,c,p,!1)}return r}}(e,n);if(s(n.options.functional))return function(n,e,t,i,s){var l=n.options,c={},p=l.props;if(o(p))for(var d in p)c[d]=qt(d,p,e||a);else o(t.attrs)&&ht(c,t.attrs),o(t.props)&&ht(c,t.props);var u=new gt(t,c,s,i,n),m=l.render.call(null,u._c,u);if(m instanceof mn)return bt(m,t,u.parent,l,u);if(r(m)){for(var g=Qn(m)||[],b=new Array(g.length),h=0;h<g.length;h++)b[h]=bt(g[h],t,u.parent,l,u);return b}}(n,m,e,t,l);var g=e.on;if(e.on=e.nativeOn,s(n.options.abstract)){var h=e.slot;e={},h&&(e.slot=h)}!function(n){for(var e=n.hook||(n.hook={}),t=0;t<yt.length;t++){var a=yt[t],r=e[a],i=ft[a];r===i||r&&r._merged||(e[a]=r?wt(i,r):i)}}(e);var v=vt(n.options)||c;return new mn("vue-component-".concat(n.cid).concat(v?"-".concat(v):""),e,void 0,void 0,void 0,t,{Ctor:n,propsData:m,listeners:g,tag:c,children:l},u)}}}function wt(n,e){var t=function(t,a){n(t,a),e(t,a)};return t._merged=!0,t}var St=M,jt=F.optionMergeStrategies;function kt(n,e,t){if(void 0===t&&(t=!0),!e)return n;for(var a,r,i,o=pn?Reflect.ownKeys(e):Object.keys(e),s=0;s<o.length;s++)"__ob__"!==(a=o[s])&&(r=n[a],i=e[a],t&&S(n,a)?r!==i&&u(r)&&u(i)&&kt(r,i):Mn(n,a,i));return n}function Tt(n,e,t){return t?function(){var a=c(e)?e.call(t,t):e,r=c(n)?n.call(t,t):n;return a?kt(a,r):r}:e?n?function(){return kt(c(e)?e.call(this,this):e,c(n)?n.call(this,this):n)}:e:n}function Et(n,e){var t=e?n?n.concat(e):r(e)?e:[e]:n;return t?function(n){for(var e=[],t=0;t<n.length;t++)-1===e.indexOf(n[t])&&e.push(n[t]);return e}(t):t}function It(n,e,t,a){var r=Object.create(n||null);return e?q(r,e):r}jt.data=function(n,e,t){return t?Tt(n,e,t):e&&"function"!=typeof e?n:Tt(n,e)},U.forEach((function(n){jt[n]=Et})),N.forEach((function(n){jt[n+"s"]=It})),jt.watch=function(n,e,t,a){if(n===tn&&(n=void 0),e===tn&&(e=void 0),!e)return Object.create(n||null);if(!n)return e;var i={};for(var o in q(i,n),e){var s=i[o],l=e[o];s&&!r(s)&&(s=[s]),i[o]=s?s.concat(l):r(l)?l:[l]}return i},jt.props=jt.methods=jt.inject=jt.computed=function(n,e,t,a){if(!n)return e;var r=Object.create(null);return q(r,n),e&&q(r,e),r},jt.provide=function(n,e){return n?function(){var t=Object.create(null);return kt(t,c(n)?n.call(this):n),e&&kt(t,c(e)?e.call(this):e,!1),t}:e};var Ct=function(n,e){return void 0===e?n:e};function _t(n,e,t){if(c(e)&&(e=e.options),function(n,e){var t=n.props;if(t){var a,i,o={};if(r(t))for(a=t.length;a--;)"string"==typeof(i=t[a])&&(o[T(i)]={type:null});else if(u(t))for(var s in t)i=t[s],o[T(s)]=u(i)?i:{type:i};else 0;n.props=o}}(e),function(n,e){var t=n.inject;if(t){var a=n.inject={};if(r(t))for(var i=0;i<t.length;i++)a[t[i]]={from:t[i]};else if(u(t))for(var o in t){var s=t[o];a[o]=u(s)?q({from:o},s):{from:s}}else 0}}(e),function(n){var e=n.directives;if(e)for(var t in e){var a=e[t];c(a)&&(e[t]={bind:a,update:a})}}(e),!e._base&&(e.extends&&(n=_t(n,e.extends,t)),e.mixins))for(var a=0,i=e.mixins.length;a<i;a++)n=_t(n,e.mixins[a],t);var o,s={};for(o in n)l(o);for(o in e)S(n,o)||l(o);function l(a){var r=jt[a]||Ct;s[a]=r(n[a],e[a],t,a)}return s}function At(n,e,t,a){if("string"==typeof t){var r=n[e];if(S(r,t))return r[t];var i=T(t);if(S(r,i))return r[i];var o=E(i);return S(r,o)?r[o]:r[t]||r[i]||r[o]}}function qt(n,e,t,a){var r=e[n],i=!S(t,n),o=t[n],s=Ot(Boolean,r.type);if(s>-1)if(i&&!S(r,"default"))o=!1;else if(""===o||o===C(n)){var l=Ot(String,r.type);(l<0||s<l)&&(o=!0)}if(void 0===o){o=function(n,e,t){if(!S(e,"default"))return;var a=e.default;0;if(n&&n.$options.propsData&&void 0===n.$options.propsData[t]&&void 0!==n._props[t])return n._props[t];return c(a)&&"Function"!==Mt(e.type)?a.call(n):a}(a,r,n);var p=In;Cn(!0),qn(o),Cn(p)}return o}var Lt=/^\s*function (\w+)/;function Mt(n){var e=n&&n.toString().match(Lt);return e?e[1]:""}function Dt(n,e){return Mt(n)===Mt(e)}function Ot(n,e){if(!r(e))return Dt(e,n)?0:-1;for(var t=0,a=e.length;t<a;t++)if(Dt(e[t],n))return t;return-1}var Rt={enumerable:!0,configurable:!0,get:M,set:M};function Pt(n,e,t){Rt.get=function(){return this[e][t]},Rt.set=function(n){this[e][t]=n},Object.defineProperty(n,t,Rt)}function Bt(n){var e=n.$options;if(e.props&&function(n,e){var t=n.$options.propsData||{},a=n._props=Rn({}),r=n.$options._propKeys=[];n.$parent&&Cn(!1);var i=function(i){r.push(i);var o=qt(i,e,t,n);Ln(a,i,o),i in n||Pt(n,"_props",i)};for(var o in e)i(o);Cn(!0)}(n,e.props),function(n){var e=n.$options,t=e.setup;if(t){var a=n._setupContext=fe(n);un(n),wn();var r=Ie(t,null,[n._props||Rn({}),a],n,"setup");if(Sn(),un(),c(r))e.render=r;else if(p(r))if(n._setupState=r,r.__sfc){var i=n._setupProxy={};for(var o in r)"__sfc"!==o&&Nn(i,r,o)}else for(var o in r)$(o)||Nn(n,r,o);else 0}}(n),e.methods&&function(n,e){n.$options.props;for(var t in e)n[t]="function"!=typeof e[t]?M:_(e[t],n)}(n,e.methods),e.data)!function(n){var e=n.$options.data;u(e=n._data=c(e)?function(n,e){wn();try{return n.call(e,e)}catch(n){return Ee(n,e,"data()"),{}}finally{Sn()}}(e,n):e||{})||(e={});var t=Object.keys(e),a=n.$options.props,r=(n.$options.methods,t.length);for(;r--;){var i=t[r];0,a&&S(a,i)||$(i)||Pt(n,"_data",i)}var o=qn(e);o&&o.vmCount++}(n);else{var t=qn(n._data={});t&&t.vmCount++}e.computed&&function(n,e){var t=n._computedWatchers=Object.create(null),a=on();for(var r in e){var i=e[r],o=c(i)?i:i.get;0,a||(t[r]=new He(n,o||M,M,zt)),r in n||Nt(n,r,i)}}(n,e.computed),e.watch&&e.watch!==tn&&function(n,e){for(var t in e){var a=e[t];if(r(a))for(var i=0;i<a.length;i++)Jt(n,t,a[i]);else Jt(n,t,a)}}(n,e.watch)}var zt={lazy:!0};function Nt(n,e,t){var a=!on();c(t)?(Rt.get=a?Ut(e):Ft(t),Rt.set=M):(Rt.get=t.get?a&&!1!==t.cache?Ut(e):Ft(t.get):M,Rt.set=t.set||M),Object.defineProperty(n,e,Rt)}function Ut(n){return function(){var e=this._computedWatchers&&this._computedWatchers[n];if(e)return e.dirty&&e.evaluate(),yn.target&&e.depend(),e.value}}function Ft(n){return function(){return n.call(this,this)}}function Jt(n,e,t,a){return u(t)&&(a=t,t=t.handler),"string"==typeof t&&(t=n[t]),n.$watch(e,t,a)}var $t=0;function Ht(n){var e=n.options;if(n.super){var t=Ht(n.super);if(t!==n.superOptions){n.superOptions=t;var a=function(n){var e,t=n.options,a=n.sealedOptions;for(var r in t)t[r]!==a[r]&&(e||(e={}),e[r]=t[r]);return e}(n);a&&q(n.extendOptions,a),(e=n.options=_t(t,n.extendOptions)).name&&(e.components[e.name]=n)}}return e}function Gt(n){this._init(n)}function Vt(n){n.cid=0;var e=1;n.extend=function(n){n=n||{};var t=this,a=t.cid,r=n._Ctor||(n._Ctor={});if(r[a])return r[a];var i=vt(n)||vt(t.options);var o=function(n){this._init(n)};return(o.prototype=Object.create(t.prototype)).constructor=o,o.cid=e++,o.options=_t(t.options,n),o.super=t,o.options.props&&function(n){var e=n.options.props;for(var t in e)Pt(n.prototype,"_props",t)}(o),o.options.computed&&function(n){var e=n.options.computed;for(var t in e)Nt(n.prototype,t,e[t])}(o),o.extend=t.extend,o.mixin=t.mixin,o.use=t.use,N.forEach((function(n){o[n]=t[n]})),i&&(o.options.components[i]=o),o.superOptions=t.options,o.extendOptions=n,o.sealedOptions=q({},o.options),r[a]=o,o}}function Wt(n){return n&&(vt(n.Ctor.options)||n.tag)}function Qt(n,e){return r(n)?n.indexOf(e)>-1:"string"==typeof n?n.split(",").indexOf(e)>-1:!!m(n)&&n.test(e)}function Xt(n,e){var t=n.cache,a=n.keys,r=n._vnode;for(var i in t){var o=t[i];if(o){var s=o.name;s&&!e(s)&&Kt(t,i,a,r)}}}function Kt(n,e,t,a){var r=n[e];!r||a&&r.tag===a.tag||r.componentInstance.$destroy(),n[e]=null,x(t,e)}!function(n){n.prototype._init=function(n){var e=this;e._uid=$t++,e._isVue=!0,e.__v_skip=!0,e._scope=new Fn(!0),e._scope._vm=!0,n&&n._isComponent?function(n,e){var t=n.$options=Object.create(n.constructor.options),a=e._parentVnode;t.parent=e.parent,t._parentVnode=a;var r=a.componentOptions;t.propsData=r.propsData,t._parentListeners=r.listeners,t._renderChildren=r.children,t._componentTag=r.tag,e.render&&(t.render=e.render,t.staticRenderFns=e.staticRenderFns)}(e,n):e.$options=_t(Ht(e.constructor),n||{},e),e._renderProxy=e,e._self=e,function(n){var e=n.$options,t=e.parent;if(t&&!e.abstract){for(;t.$options.abstract&&t.$parent;)t=t.$parent;t.$children.push(n)}n.$parent=t,n.$root=t?t.$root:n,n.$children=[],n.$refs={},n._provided=t?t._provided:Object.create(null),n._watcher=null,n._inactive=null,n._directInactive=!1,n._isMounted=!1,n._isDestroyed=!1,n._isBeingDestroyed=!1}(e),function(n){n._events=Object.create(null),n._hasHookEvent=!1;var e=n.$options._parentListeners;e&&Qe(n,e)}(e),function(n){n._vnode=null,n._staticTrees=null;var e=n.$options,t=n.$vnode=e._parentVnode,r=t&&t.context;n.$slots=ue(e._renderChildren,r),n.$scopedSlots=t?be(n.$parent,t.data.scopedSlots,n.$slots):a,n._c=function(e,t,a,r){return Te(n,e,t,a,r,!1)},n.$createElement=function(e,t,a,r){return Te(n,e,t,a,r,!0)};var i=t&&t.data;Ln(n,"$attrs",i&&i.attrs||a,null,!0),Ln(n,"$listeners",e._parentListeners||a,null,!0)}(e),nt(e,"beforeCreate",void 0,!1),function(n){var e=mt(n.$options.inject,n);e&&(Cn(!1),Object.keys(e).forEach((function(t){Ln(n,t,e[t])})),Cn(!0))}(e),Bt(e),function(n){var e=n.$options.provide;if(e){var t=c(e)?e.call(n):e;if(!p(t))return;for(var a=Jn(n),r=pn?Reflect.ownKeys(t):Object.keys(t),i=0;i<r.length;i++){var o=r[i];Object.defineProperty(a,o,Object.getOwnPropertyDescriptor(t,o))}}}(e),nt(e,"created"),e.$options.el&&e.$mount(e.$options.el)}}(Gt),function(n){var e={get:function(){return this._data}},t={get:function(){return this._props}};Object.defineProperty(n.prototype,"$data",e),Object.defineProperty(n.prototype,"$props",t),n.prototype.$set=Mn,n.prototype.$delete=Dn,n.prototype.$watch=function(n,e,t){if(u(e))return Jt(this,n,e,t);(t=t||{}).user=!0;var a=new He(this,n,e,t);if(t.immediate){var r='callback for immediate watcher "'.concat(a.expression,'"');wn(),Ie(e,this,[a.value],this,r),Sn()}return function(){a.teardown()}}}(Gt),function(n){var e=/^hook:/;n.prototype.$on=function(n,t){var a=this;if(r(n))for(var i=0,o=n.length;i<o;i++)a.$on(n[i],t);else(a._events[n]||(a._events[n]=[])).push(t),e.test(n)&&(a._hasHookEvent=!0);return a},n.prototype.$once=function(n,e){var t=this;function a(){t.$off(n,a),e.apply(t,arguments)}return a.fn=e,t.$on(n,a),t},n.prototype.$off=function(n,e){var t=this;if(!arguments.length)return t._events=Object.create(null),t;if(r(n)){for(var a=0,i=n.length;a<i;a++)t.$off(n[a],e);return t}var o,s=t._events[n];if(!s)return t;if(!e)return t._events[n]=null,t;for(var l=s.length;l--;)if((o=s[l])===e||o.fn===e){s.splice(l,1);break}return t},n.prototype.$emit=function(n){var e=this,t=e._events[n];if(t){t=t.length>1?A(t):t;for(var a=A(arguments,1),r='event handler for "'.concat(n,'"'),i=0,o=t.length;i<o;i++)Ie(t[i],e,a,e,r)}return e}}(Gt),function(n){n.prototype._update=function(n,e){var t=this,a=t.$el,r=t._vnode,i=Ke(t);t._vnode=n,t.$el=r?t.__patch__(r,n):t.__patch__(t.$el,n,e,!1),i(),a&&(a.__vue__=null),t.$el&&(t.$el.__vue__=t);for(var o=t;o&&o.$vnode&&o.$parent&&o.$vnode===o.$parent._vnode;)o.$parent.$el=o.$el,o=o.$parent},n.prototype.$forceUpdate=function(){this._watcher&&this._watcher.update()},n.prototype.$destroy=function(){var n=this;if(!n._isBeingDestroyed){nt(n,"beforeDestroy"),n._isBeingDestroyed=!0;var e=n.$parent;!e||e._isBeingDestroyed||n.$options.abstract||x(e.$children,n),n._scope.stop(),n._data.__ob__&&n._data.__ob__.vmCount--,n._isDestroyed=!0,n.__patch__(n._vnode,null),nt(n,"destroyed"),n.$off(),n.$el&&(n.$el.__vue__=null),n.$vnode&&(n.$vnode.parent=null)}}}(Gt),function(n){de(n.prototype),n.prototype.$nextTick=function(n){return ze(n,this)},n.prototype._render=function(){var n,e=this,t=e.$options,a=t.render,i=t._parentVnode;i&&e._isMounted&&(e.$scopedSlots=be(e.$parent,i.data.scopedSlots,e.$slots,e.$scopedSlots),e._slotsProxy&&we(e._slotsProxy,e.$scopedSlots)),e.$vnode=i;try{un(e),Se=e,n=a.call(e._renderProxy,e.$createElement)}catch(t){Ee(t,e,"render"),n=e._vnode}finally{Se=null,un()}return r(n)&&1===n.length&&(n=n[0]),n instanceof mn||(n=gn()),n.parent=i,n}}(Gt);var Yt=[String,RegExp,Array],Zt={KeepAlive:{name:"keep-alive",abstract:!0,props:{include:Yt,exclude:Yt,max:[String,Number]},methods:{cacheVNode:function(){var n=this.cache,e=this.keys,t=this.vnodeToCache,a=this.keyToCache;if(t){var r=t.tag,i=t.componentInstance,o=t.componentOptions;n[a]={name:Wt(o),tag:r,componentInstance:i},e.push(a),this.max&&e.length>parseInt(this.max)&&Kt(n,e[0],e,this._vnode),this.vnodeToCache=null}}},created:function(){this.cache=Object.create(null),this.keys=[]},destroyed:function(){for(var n in this.cache)Kt(this.cache,n,this.keys)},mounted:function(){var n=this;this.cacheVNode(),this.$watch("include",(function(e){Xt(n,(function(n){return Qt(e,n)}))})),this.$watch("exclude",(function(e){Xt(n,(function(n){return!Qt(e,n)}))}))},updated:function(){this.cacheVNode()},render:function(){var n=this.$slots.default,e=ke(n),t=e&&e.componentOptions;if(t){var a=Wt(t),r=this.include,i=this.exclude;if(r&&(!a||!Qt(r,a))||i&&a&&Qt(i,a))return e;var o=this.cache,s=this.keys,l=null==e.key?t.Ctor.cid+(t.tag?"::".concat(t.tag):""):e.key;o[l]?(e.componentInstance=o[l].componentInstance,x(s,l),s.push(l)):(this.vnodeToCache=e,this.keyToCache=l),e.data.keepAlive=!0}return e||n&&n[0]}}};!function(n){var e={get:function(){return F}};Object.defineProperty(n,"config",e),n.util={warn:St,extend:q,mergeOptions:_t,defineReactive:Ln},n.set=Mn,n.delete=Dn,n.nextTick=ze,n.observable=function(n){return qn(n),n},n.options=Object.create(null),N.forEach((function(e){n.options[e+"s"]=Object.create(null)})),n.options._base=n,q(n.options.components,Zt),function(n){n.use=function(n){var e=this._installedPlugins||(this._installedPlugins=[]);if(e.indexOf(n)>-1)return this;var t=A(arguments,1);return t.unshift(this),c(n.install)?n.install.apply(n,t):c(n)&&n.apply(null,t),e.push(n),this}}(n),function(n){n.mixin=function(n){return this.options=_t(this.options,n),this}}(n),Vt(n),function(n){N.forEach((function(e){n[e]=function(n,t){return t?("component"===e&&u(t)&&(t.name=t.name||n,t=this.options._base.extend(t)),"directive"===e&&c(t)&&(t={bind:t,update:t}),this.options[e+"s"][n]=t,t):this.options[e+"s"][n]}}))}(n)}(Gt),Object.defineProperty(Gt.prototype,"$isServer",{get:on}),Object.defineProperty(Gt.prototype,"$ssrContext",{get:function(){return this.$vnode&&this.$vnode.ssrContext}}),Object.defineProperty(Gt,"FunctionalRenderContext",{value:gt}),Gt.version="2.7.14";var na=f("style,class"),ea=f("input,textarea,option,select,progress"),ta=f("contenteditable,draggable,spellcheck"),aa=f("events,caret,typing,plaintext-only"),ra=f("allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,default,defaultchecked,defaultmuted,defaultselected,defer,disabled,enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,required,reversed,scoped,seamless,selected,sortable,truespeed,typemustmatch,visible"),ia="http://www.w3.org/1999/xlink",oa=function(n){return":"===n.charAt(5)&&"xlink"===n.slice(0,5)},sa=function(n){return oa(n)?n.slice(6,n.length):""},la=function(n){return null==n||!1===n};function ca(n){for(var e=n.data,t=n,a=n;o(a.componentInstance);)(a=a.componentInstance._vnode)&&a.data&&(e=pa(a.data,e));for(;o(t=t.parent);)t&&t.data&&(e=pa(e,t.data));return function(n,e){if(o(n)||o(e))return da(n,ua(e));return""}(e.staticClass,e.class)}function pa(n,e){return{staticClass:da(n.staticClass,e.staticClass),class:o(n.class)?[n.class,e.class]:e.class}}function da(n,e){return n?e?n+" "+e:n:e||""}function ua(n){return Array.isArray(n)?function(n){for(var e,t="",a=0,r=n.length;a<r;a++)o(e=ua(n[a]))&&""!==e&&(t&&(t+=" "),t+=e);return t}(n):p(n)?function(n){var e="";for(var t in n)n[t]&&(e&&(e+=" "),e+=t);return e}(n):"string"==typeof n?n:""}var ma={svg:"http://www.w3.org/2000/svg",math:"http://www.w3.org/1998/Math/MathML"},ga=f("html,body,base,head,link,meta,style,title,address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,s,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,embed,object,param,source,canvas,script,noscript,del,ins,caption,col,colgroup,table,thead,tbody,td,th,tr,button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,output,progress,select,textarea,details,dialog,menu,menuitem,summary,content,element,shadow,template,blockquote,iframe,tfoot"),ba=f("svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,foreignobject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view",!0),ha=function(n){return ga(n)||ba(n)};var va=Object.create(null);var fa=f("text,number,password,search,email,tel,url");var ya=Object.freeze({__proto__:null,createElement:function(n,e){var t=document.createElement(n);return"select"!==n||e.data&&e.data.attrs&&void 0!==e.data.attrs.multiple&&t.setAttribute("multiple","multiple"),t},createElementNS:function(n,e){return document.createElementNS(ma[n],e)},createTextNode:function(n){return document.createTextNode(n)},createComment:function(n){return document.createComment(n)},insertBefore:function(n,e,t){n.insertBefore(e,t)},removeChild:function(n,e){n.removeChild(e)},appendChild:function(n,e){n.appendChild(e)},parentNode:function(n){return n.parentNode},nextSibling:function(n){return n.nextSibling},tagName:function(n){return n.tagName},setTextContent:function(n,e){n.textContent=e},setStyleScope:function(n,e){n.setAttribute(e,"")}}),xa={create:function(n,e){wa(e)},update:function(n,e){n.data.ref!==e.data.ref&&(wa(n,!0),wa(e))},destroy:function(n){wa(n,!0)}};function wa(n,e){var t=n.data.ref;if(o(t)){var a=n.context,i=n.componentInstance||n.elm,s=e?null:i,l=e?void 0:i;if(c(t))Ie(t,a,[s],a,"template ref function");else{var p=n.data.refInFor,d="string"==typeof t||"number"==typeof t,u=zn(t),m=a.$refs;if(d||u)if(p){var g=d?m[t]:t.value;e?r(g)&&x(g,i):r(g)?g.includes(i)||g.push(i):d?(m[t]=[i],Sa(a,t,m[t])):t.value=[i]}else if(d){if(e&&m[t]!==i)return;m[t]=l,Sa(a,t,s)}else if(u){if(e&&t.value!==i)return;t.value=s}else 0}}}function Sa(n,e,t){var a=n._setupState;a&&S(a,e)&&(zn(a[e])?a[e].value=t:a[e]=t)}var ja=new mn("",{},[]),ka=["create","activate","update","remove","destroy"];function Ta(n,e){return n.key===e.key&&n.asyncFactory===e.asyncFactory&&(n.tag===e.tag&&n.isComment===e.isComment&&o(n.data)===o(e.data)&&function(n,e){if("input"!==n.tag)return!0;var t,a=o(t=n.data)&&o(t=t.attrs)&&t.type,r=o(t=e.data)&&o(t=t.attrs)&&t.type;return a===r||fa(a)&&fa(r)}(n,e)||s(n.isAsyncPlaceholder)&&i(e.asyncFactory.error))}function Ea(n,e,t){var a,r,i={};for(a=e;a<=t;++a)o(r=n[a].key)&&(i[r]=a);return i}var Ia={create:Ca,update:Ca,destroy:function(n){Ca(n,ja)}};function Ca(n,e){(n.data.directives||e.data.directives)&&function(n,e){var t,a,r,i=n===ja,o=e===ja,s=Aa(n.data.directives,n.context),l=Aa(e.data.directives,e.context),c=[],p=[];for(t in l)a=s[t],r=l[t],a?(r.oldValue=a.value,r.oldArg=a.arg,La(r,"update",e,n),r.def&&r.def.componentUpdated&&p.push(r)):(La(r,"bind",e,n),r.def&&r.def.inserted&&c.push(r));if(c.length){var d=function(){for(var t=0;t<c.length;t++)La(c[t],"inserted",e,n)};i?Vn(e,"insert",d):d()}p.length&&Vn(e,"postpatch",(function(){for(var t=0;t<p.length;t++)La(p[t],"componentUpdated",e,n)}));if(!i)for(t in s)l[t]||La(s[t],"unbind",n,n,o)}(n,e)}var _a=Object.create(null);function Aa(n,e){var t,a,r=Object.create(null);if(!n)return r;for(t=0;t<n.length;t++){if((a=n[t]).modifiers||(a.modifiers=_a),r[qa(a)]=a,e._setupState&&e._setupState.__sfc){var i=a.def||At(e,"_setupState","v-"+a.name);a.def="function"==typeof i?{bind:i,update:i}:i}a.def=a.def||At(e.$options,"directives",a.name)}return r}function qa(n){return n.rawName||"".concat(n.name,".").concat(Object.keys(n.modifiers||{}).join("."))}function La(n,e,t,a,r){var i=n.def&&n.def[e];if(i)try{i(t.elm,n,t,a,r)}catch(a){Ee(a,t.context,"directive ".concat(n.name," ").concat(e," hook"))}}var Ma=[xa,Ia];function Da(n,e){var t=e.componentOptions;if(!(o(t)&&!1===t.Ctor.options.inheritAttrs||i(n.data.attrs)&&i(e.data.attrs))){var a,r,l=e.elm,c=n.data.attrs||{},p=e.data.attrs||{};for(a in(o(p.__ob__)||s(p._v_attr_proxy))&&(p=e.data.attrs=q({},p)),p)r=p[a],c[a]!==r&&Oa(l,a,r,e.data.pre);for(a in(X||Y)&&p.value!==c.value&&Oa(l,"value",p.value),c)i(p[a])&&(oa(a)?l.removeAttributeNS(ia,sa(a)):ta(a)||l.removeAttribute(a))}}function Oa(n,e,t,a){a||n.tagName.indexOf("-")>-1?Ra(n,e,t):ra(e)?la(t)?n.removeAttribute(e):(t="allowfullscreen"===e&&"EMBED"===n.tagName?"true":e,n.setAttribute(e,t)):ta(e)?n.setAttribute(e,function(n,e){return la(e)||"false"===e?"false":"contenteditable"===n&&aa(e)?e:"true"}(e,t)):oa(e)?la(t)?n.removeAttributeNS(ia,sa(e)):n.setAttributeNS(ia,e,t):Ra(n,e,t)}function Ra(n,e,t){if(la(t))n.removeAttribute(e);else{if(X&&!K&&"TEXTAREA"===n.tagName&&"placeholder"===e&&""!==t&&!n.__ieph){var a=function(e){e.stopImmediatePropagation(),n.removeEventListener("input",a)};n.addEventListener("input",a),n.__ieph=!0}n.setAttribute(e,t)}}var Pa={create:Da,update:Da};function Ba(n,e){var t=e.elm,a=e.data,r=n.data;if(!(i(a.staticClass)&&i(a.class)&&(i(r)||i(r.staticClass)&&i(r.class)))){var s=ca(e),l=t._transitionClasses;o(l)&&(s=da(s,ua(l))),s!==t._prevClass&&(t.setAttribute("class",s),t._prevClass=s)}}var za,Na={create:Ba,update:Ba};function Ua(n,e,t){var a=za;return function r(){var i=e.apply(null,arguments);null!==i&&$a(n,r,t,a)}}var Fa=qe&&!(en&&Number(en[1])<=53);function Ja(n,e,t,a){if(Fa){var r=st,i=e;e=i._wrapper=function(n){if(n.target===n.currentTarget||n.timeStamp>=r||n.timeStamp<=0||n.target.ownerDocument!==document)return i.apply(this,arguments)}}za.addEventListener(n,e,an?{capture:t,passive:a}:t)}function $a(n,e,t,a){(a||za).removeEventListener(n,e._wrapper||e,t)}function Ha(n,e){if(!i(n.data.on)||!i(e.data.on)){var t=e.data.on||{},a=n.data.on||{};za=e.elm||n.elm,function(n){if(o(n.__r)){var e=X?"change":"input";n[e]=[].concat(n.__r,n[e]||[]),delete n.__r}o(n.__c)&&(n.change=[].concat(n.__c,n.change||[]),delete n.__c)}(t),Gn(t,a,Ja,$a,Ua,e.context),za=void 0}}var Ga,Va={create:Ha,update:Ha,destroy:function(n){return Ha(n,ja)}};function Wa(n,e){if(!i(n.data.domProps)||!i(e.data.domProps)){var t,a,r=e.elm,l=n.data.domProps||{},c=e.data.domProps||{};for(t in(o(c.__ob__)||s(c._v_attr_proxy))&&(c=e.data.domProps=q({},c)),l)t in c||(r[t]="");for(t in c){if(a=c[t],"textContent"===t||"innerHTML"===t){if(e.children&&(e.children.length=0),a===l[t])continue;1===r.childNodes.length&&r.removeChild(r.childNodes[0])}if("value"===t&&"PROGRESS"!==r.tagName){r._value=a;var p=i(a)?"":String(a);Qa(r,p)&&(r.value=p)}else if("innerHTML"===t&&ba(r.tagName)&&i(r.innerHTML)){(Ga=Ga||document.createElement("div")).innerHTML="<svg>".concat(a,"</svg>");for(var d=Ga.firstChild;r.firstChild;)r.removeChild(r.firstChild);for(;d.firstChild;)r.appendChild(d.firstChild)}else if(a!==l[t])try{r[t]=a}catch(n){}}}}function Qa(n,e){return!n.composing&&("OPTION"===n.tagName||function(n,e){var t=!0;try{t=document.activeElement!==n}catch(n){}return t&&n.value!==e}(n,e)||function(n,e){var t=n.value,a=n._vModifiers;if(o(a)){if(a.number)return v(t)!==v(e);if(a.trim)return t.trim()!==e.trim()}return t!==e}(n,e))}var Xa={create:Wa,update:Wa},Ka=j((function(n){var e={},t=/:(.+)/;return n.split(/;(?![^(]*\))/g).forEach((function(n){if(n){var a=n.split(t);a.length>1&&(e[a[0].trim()]=a[1].trim())}})),e}));function Ya(n){var e=Za(n.style);return n.staticStyle?q(n.staticStyle,e):e}function Za(n){return Array.isArray(n)?L(n):"string"==typeof n?Ka(n):n}var nr,er=/^--/,tr=/\s*!important$/,ar=function(n,e,t){if(er.test(e))n.style.setProperty(e,t);else if(tr.test(t))n.style.setProperty(C(e),t.replace(tr,""),"important");else{var a=ir(e);if(Array.isArray(t))for(var r=0,i=t.length;r<i;r++)n.style[a]=t[r];else n.style[a]=t}},rr=["Webkit","Moz","ms"],ir=j((function(n){if(nr=nr||document.createElement("div").style,"filter"!==(n=T(n))&&n in nr)return n;for(var e=n.charAt(0).toUpperCase()+n.slice(1),t=0;t<rr.length;t++){var a=rr[t]+e;if(a in nr)return a}}));function or(n,e){var t=e.data,a=n.data;if(!(i(t.staticStyle)&&i(t.style)&&i(a.staticStyle)&&i(a.style))){var r,s,l=e.elm,c=a.staticStyle,p=a.normalizedStyle||a.style||{},d=c||p,u=Za(e.data.style)||{};e.data.normalizedStyle=o(u.__ob__)?q({},u):u;var m=function(n,e){var t,a={};if(e)for(var r=n;r.componentInstance;)(r=r.componentInstance._vnode)&&r.data&&(t=Ya(r.data))&&q(a,t);(t=Ya(n.data))&&q(a,t);for(var i=n;i=i.parent;)i.data&&(t=Ya(i.data))&&q(a,t);return a}(e,!0);for(s in d)i(m[s])&&ar(l,s,"");for(s in m)(r=m[s])!==d[s]&&ar(l,s,null==r?"":r)}}var sr={create:or,update:or},lr=/\s+/;function cr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(lr).forEach((function(e){return n.classList.add(e)})):n.classList.add(e);else{var t=" ".concat(n.getAttribute("class")||""," ");t.indexOf(" "+e+" ")<0&&n.setAttribute("class",(t+e).trim())}}function pr(n,e){if(e&&(e=e.trim()))if(n.classList)e.indexOf(" ")>-1?e.split(lr).forEach((function(e){return n.classList.remove(e)})):n.classList.remove(e),n.classList.length||n.removeAttribute("class");else{for(var t=" ".concat(n.getAttribute("class")||""," "),a=" "+e+" ";t.indexOf(a)>=0;)t=t.replace(a," ");(t=t.trim())?n.setAttribute("class",t):n.removeAttribute("class")}}function dr(n){if(n){if("object"==typeof n){var e={};return!1!==n.css&&q(e,ur(n.name||"v")),q(e,n),e}return"string"==typeof n?ur(n):void 0}}var ur=j((function(n){return{enterClass:"".concat(n,"-enter"),enterToClass:"".concat(n,"-enter-to"),enterActiveClass:"".concat(n,"-enter-active"),leaveClass:"".concat(n,"-leave"),leaveToClass:"".concat(n,"-leave-to"),leaveActiveClass:"".concat(n,"-leave-active")}})),mr=W&&!K,gr="transition",br="transitionend",hr="animation",vr="animationend";mr&&(void 0===window.ontransitionend&&void 0!==window.onwebkittransitionend&&(gr="WebkitTransition",br="webkitTransitionEnd"),void 0===window.onanimationend&&void 0!==window.onwebkitanimationend&&(hr="WebkitAnimation",vr="webkitAnimationEnd"));var fr=W?window.requestAnimationFrame?window.requestAnimationFrame.bind(window):setTimeout:function(n){return n()};function yr(n){fr((function(){fr(n)}))}function xr(n,e){var t=n._transitionClasses||(n._transitionClasses=[]);t.indexOf(e)<0&&(t.push(e),cr(n,e))}function wr(n,e){n._transitionClasses&&x(n._transitionClasses,e),pr(n,e)}function Sr(n,e,t){var a=kr(n,e),r=a.type,i=a.timeout,o=a.propCount;if(!r)return t();var s="transition"===r?br:vr,l=0,c=function(){n.removeEventListener(s,p),t()},p=function(e){e.target===n&&++l>=o&&c()};setTimeout((function(){l<o&&c()}),i+1),n.addEventListener(s,p)}var jr=/\b(transform|all)(,|$)/;function kr(n,e){var t,a=window.getComputedStyle(n),r=(a[gr+"Delay"]||"").split(", "),i=(a[gr+"Duration"]||"").split(", "),o=Tr(r,i),s=(a[hr+"Delay"]||"").split(", "),l=(a[hr+"Duration"]||"").split(", "),c=Tr(s,l),p=0,d=0;return"transition"===e?o>0&&(t="transition",p=o,d=i.length):"animation"===e?c>0&&(t="animation",p=c,d=l.length):d=(t=(p=Math.max(o,c))>0?o>c?"transition":"animation":null)?"transition"===t?i.length:l.length:0,{type:t,timeout:p,propCount:d,hasTransform:"transition"===t&&jr.test(a[gr+"Property"])}}function Tr(n,e){for(;n.length<e.length;)n=n.concat(n);return Math.max.apply(null,e.map((function(e,t){return Er(e)+Er(n[t])})))}function Er(n){return 1e3*Number(n.slice(0,-1).replace(",","."))}function Ir(n,e){var t=n.elm;o(t._leaveCb)&&(t._leaveCb.cancelled=!0,t._leaveCb());var a=dr(n.data.transition);if(!i(a)&&!o(t._enterCb)&&1===t.nodeType){for(var r=a.css,s=a.type,l=a.enterClass,d=a.enterToClass,u=a.enterActiveClass,m=a.appearClass,g=a.appearToClass,b=a.appearActiveClass,h=a.beforeEnter,f=a.enter,y=a.afterEnter,x=a.enterCancelled,w=a.beforeAppear,S=a.appear,j=a.afterAppear,k=a.appearCancelled,T=a.duration,E=Xe,I=Xe.$vnode;I&&I.parent;)E=I.context,I=I.parent;var C=!E._isMounted||!n.isRootInsert;if(!C||S||""===S){var _=C&&m?m:l,A=C&&b?b:u,q=C&&g?g:d,L=C&&w||h,M=C&&c(S)?S:f,D=C&&j||y,O=C&&k||x,R=v(p(T)?T.enter:T);0;var P=!1!==r&&!K,z=Ar(M),N=t._enterCb=B((function(){P&&(wr(t,q),wr(t,A)),N.cancelled?(P&&wr(t,_),O&&O(t)):D&&D(t),t._enterCb=null}));n.data.show||Vn(n,"insert",(function(){var e=t.parentNode,a=e&&e._pending&&e._pending[n.key];a&&a.tag===n.tag&&a.elm._leaveCb&&a.elm._leaveCb(),M&&M(t,N)})),L&&L(t),P&&(xr(t,_),xr(t,A),yr((function(){wr(t,_),N.cancelled||(xr(t,q),z||(_r(R)?setTimeout(N,R):Sr(t,s,N)))}))),n.data.show&&(e&&e(),M&&M(t,N)),P||z||N()}}}function Cr(n,e){var t=n.elm;o(t._enterCb)&&(t._enterCb.cancelled=!0,t._enterCb());var a=dr(n.data.transition);if(i(a)||1!==t.nodeType)return e();if(!o(t._leaveCb)){var r=a.css,s=a.type,l=a.leaveClass,c=a.leaveToClass,d=a.leaveActiveClass,u=a.beforeLeave,m=a.leave,g=a.afterLeave,b=a.leaveCancelled,h=a.delayLeave,f=a.duration,y=!1!==r&&!K,x=Ar(m),w=v(p(f)?f.leave:f);0;var S=t._leaveCb=B((function(){t.parentNode&&t.parentNode._pending&&(t.parentNode._pending[n.key]=null),y&&(wr(t,c),wr(t,d)),S.cancelled?(y&&wr(t,l),b&&b(t)):(e(),g&&g(t)),t._leaveCb=null}));h?h(j):j()}function j(){S.cancelled||(!n.data.show&&t.parentNode&&((t.parentNode._pending||(t.parentNode._pending={}))[n.key]=n),u&&u(t),y&&(xr(t,l),xr(t,d),yr((function(){wr(t,l),S.cancelled||(xr(t,c),x||(_r(w)?setTimeout(S,w):Sr(t,s,S)))}))),m&&m(t,S),y||x||S())}}function _r(n){return"number"==typeof n&&!isNaN(n)}function Ar(n){if(i(n))return!1;var e=n.fns;return o(e)?Ar(Array.isArray(e)?e[0]:e):(n._length||n.length)>1}function qr(n,e){!0!==e.data.show&&Ir(e)}var Lr=function(n){var e,t,a={},c=n.modules,p=n.nodeOps;for(e=0;e<ka.length;++e)for(a[ka[e]]=[],t=0;t<c.length;++t)o(c[t][ka[e]])&&a[ka[e]].push(c[t][ka[e]]);function d(n){var e=p.parentNode(n);o(e)&&p.removeChild(e,n)}function u(n,e,t,r,i,l,c){if(o(n.elm)&&o(l)&&(n=l[c]=hn(n)),n.isRootInsert=!i,!function(n,e,t,r){var i=n.data;if(o(i)){var l=o(n.componentInstance)&&i.keepAlive;if(o(i=i.hook)&&o(i=i.init)&&i(n,!1),o(n.componentInstance))return m(n,e),g(t,n.elm,r),s(l)&&function(n,e,t,r){var i,s=n;for(;s.componentInstance;)if(s=s.componentInstance._vnode,o(i=s.data)&&o(i=i.transition)){for(i=0;i<a.activate.length;++i)a.activate[i](ja,s);e.push(s);break}g(t,n.elm,r)}(n,e,t,r),!0}}(n,e,t,r)){var d=n.data,u=n.children,h=n.tag;o(h)?(n.elm=n.ns?p.createElementNS(n.ns,h):p.createElement(h,n),y(n),b(n,u,e),o(d)&&v(n,e),g(t,n.elm,r)):s(n.isComment)?(n.elm=p.createComment(n.text),g(t,n.elm,r)):(n.elm=p.createTextNode(n.text),g(t,n.elm,r))}}function m(n,e){o(n.data.pendingInsert)&&(e.push.apply(e,n.data.pendingInsert),n.data.pendingInsert=null),n.elm=n.componentInstance.$el,h(n)?(v(n,e),y(n)):(wa(n),e.push(n))}function g(n,e,t){o(n)&&(o(t)?p.parentNode(t)===n&&p.insertBefore(n,e,t):p.appendChild(n,e))}function b(n,e,t){if(r(e)){0;for(var a=0;a<e.length;++a)u(e[a],t,n.elm,null,!0,e,a)}else l(n.text)&&p.appendChild(n.elm,p.createTextNode(String(n.text)))}function h(n){for(;n.componentInstance;)n=n.componentInstance._vnode;return o(n.tag)}function v(n,t){for(var r=0;r<a.create.length;++r)a.create[r](ja,n);o(e=n.data.hook)&&(o(e.create)&&e.create(ja,n),o(e.insert)&&t.push(n))}function y(n){var e;if(o(e=n.fnScopeId))p.setStyleScope(n.elm,e);else for(var t=n;t;)o(e=t.context)&&o(e=e.$options._scopeId)&&p.setStyleScope(n.elm,e),t=t.parent;o(e=Xe)&&e!==n.context&&e!==n.fnContext&&o(e=e.$options._scopeId)&&p.setStyleScope(n.elm,e)}function x(n,e,t,a,r,i){for(;a<=r;++a)u(t[a],i,n,e,!1,t,a)}function w(n){var e,t,r=n.data;if(o(r))for(o(e=r.hook)&&o(e=e.destroy)&&e(n),e=0;e<a.destroy.length;++e)a.destroy[e](n);if(o(e=n.children))for(t=0;t<n.children.length;++t)w(n.children[t])}function S(n,e,t){for(;e<=t;++e){var a=n[e];o(a)&&(o(a.tag)?(j(a),w(a)):d(a.elm))}}function j(n,e){if(o(e)||o(n.data)){var t,r=a.remove.length+1;for(o(e)?e.listeners+=r:e=function(n,e){function t(){0==--t.listeners&&d(n)}return t.listeners=e,t}(n.elm,r),o(t=n.componentInstance)&&o(t=t._vnode)&&o(t.data)&&j(t,e),t=0;t<a.remove.length;++t)a.remove[t](n,e);o(t=n.data.hook)&&o(t=t.remove)?t(n,e):e()}else d(n.elm)}function k(n,e,t,a){for(var r=t;r<a;r++){var i=e[r];if(o(i)&&Ta(n,i))return r}}function T(n,e,t,r,l,c){if(n!==e){o(e.elm)&&o(r)&&(e=r[l]=hn(e));var d=e.elm=n.elm;if(s(n.isAsyncPlaceholder))o(e.asyncFactory.resolved)?C(n.elm,e,t):e.isAsyncPlaceholder=!0;else if(s(e.isStatic)&&s(n.isStatic)&&e.key===n.key&&(s(e.isCloned)||s(e.isOnce)))e.componentInstance=n.componentInstance;else{var m,g=e.data;o(g)&&o(m=g.hook)&&o(m=m.prepatch)&&m(n,e);var b=n.children,v=e.children;if(o(g)&&h(e)){for(m=0;m<a.update.length;++m)a.update[m](n,e);o(m=g.hook)&&o(m=m.update)&&m(n,e)}i(e.text)?o(b)&&o(v)?b!==v&&function(n,e,t,a,r){var s,l,c,d=0,m=0,g=e.length-1,b=e[0],h=e[g],v=t.length-1,f=t[0],y=t[v],w=!r;for(0;d<=g&&m<=v;)i(b)?b=e[++d]:i(h)?h=e[--g]:Ta(b,f)?(T(b,f,a,t,m),b=e[++d],f=t[++m]):Ta(h,y)?(T(h,y,a,t,v),h=e[--g],y=t[--v]):Ta(b,y)?(T(b,y,a,t,v),w&&p.insertBefore(n,b.elm,p.nextSibling(h.elm)),b=e[++d],y=t[--v]):Ta(h,f)?(T(h,f,a,t,m),w&&p.insertBefore(n,h.elm,b.elm),h=e[--g],f=t[++m]):(i(s)&&(s=Ea(e,d,g)),i(l=o(f.key)?s[f.key]:k(f,e,d,g))?u(f,a,n,b.elm,!1,t,m):Ta(c=e[l],f)?(T(c,f,a,t,m),e[l]=void 0,w&&p.insertBefore(n,c.elm,b.elm)):u(f,a,n,b.elm,!1,t,m),f=t[++m]);d>g?x(n,i(t[v+1])?null:t[v+1].elm,t,m,v,a):m>v&&S(e,d,g)}(d,b,v,t,c):o(v)?(o(n.text)&&p.setTextContent(d,""),x(d,null,v,0,v.length-1,t)):o(b)?S(b,0,b.length-1):o(n.text)&&p.setTextContent(d,""):n.text!==e.text&&p.setTextContent(d,e.text),o(g)&&o(m=g.hook)&&o(m=m.postpatch)&&m(n,e)}}}function E(n,e,t){if(s(t)&&o(n.parent))n.parent.data.pendingInsert=e;else for(var a=0;a<e.length;++a)e[a].data.hook.insert(e[a])}var I=f("attrs,class,staticClass,staticStyle,key");function C(n,e,t,a){var r,i=e.tag,l=e.data,c=e.children;if(a=a||l&&l.pre,e.elm=n,s(e.isComment)&&o(e.asyncFactory))return e.isAsyncPlaceholder=!0,!0;if(o(l)&&(o(r=l.hook)&&o(r=r.init)&&r(e,!0),o(r=e.componentInstance)))return m(e,t),!0;if(o(i)){if(o(c))if(n.hasChildNodes())if(o(r=l)&&o(r=r.domProps)&&o(r=r.innerHTML)){if(r!==n.innerHTML)return!1}else{for(var p=!0,d=n.firstChild,u=0;u<c.length;u++){if(!d||!C(d,c[u],t,a)){p=!1;break}d=d.nextSibling}if(!p||d)return!1}else b(e,c,t);if(o(l)){var g=!1;for(var h in l)if(!I(h)){g=!0,v(e,t);break}!g&&l.class&&Fe(l.class)}}else n.data!==e.text&&(n.data=e.text);return!0}return function(n,e,t,r){if(!i(e)){var l,c=!1,d=[];if(i(n))c=!0,u(e,d);else{var m=o(n.nodeType);if(!m&&Ta(n,e))T(n,e,d,null,null,r);else{if(m){if(1===n.nodeType&&n.hasAttribute("data-server-rendered")&&(n.removeAttribute("data-server-rendered"),t=!0),s(t)&&C(n,e,d))return E(e,d,!0),n;l=n,n=new mn(p.tagName(l).toLowerCase(),{},[],void 0,l)}var g=n.elm,b=p.parentNode(g);if(u(e,d,g._leaveCb?null:b,p.nextSibling(g)),o(e.parent))for(var v=e.parent,f=h(e);v;){for(var y=0;y<a.destroy.length;++y)a.destroy[y](v);if(v.elm=e.elm,f){for(var x=0;x<a.create.length;++x)a.create[x](ja,v);var j=v.data.hook.insert;if(j.merged)for(var k=1;k<j.fns.length;k++)j.fns[k]()}else wa(v);v=v.parent}o(b)?S([n],0,0):o(n.tag)&&w(n)}}return E(e,d,c),e.elm}o(n)&&w(n)}}({nodeOps:ya,modules:[Pa,Na,Va,Xa,sr,W?{create:qr,activate:qr,remove:function(n,e){!0!==n.data.show?Cr(n,e):e()}}:{}].concat(Ma)});K&&document.addEventListener("selectionchange",(function(){var n=document.activeElement;n&&n.vmodel&&Nr(n,"input")}));var Mr={inserted:function(n,e,t,a){"select"===t.tag?(a.elm&&!a.elm._vOptions?Vn(t,"postpatch",(function(){Mr.componentUpdated(n,e,t)})):Dr(n,e,t.context),n._vOptions=[].map.call(n.options,Pr)):("textarea"===t.tag||fa(n.type))&&(n._vModifiers=e.modifiers,e.modifiers.lazy||(n.addEventListener("compositionstart",Br),n.addEventListener("compositionend",zr),n.addEventListener("change",zr),K&&(n.vmodel=!0)))},componentUpdated:function(n,e,t){if("select"===t.tag){Dr(n,e,t.context);var a=n._vOptions,r=n._vOptions=[].map.call(n.options,Pr);if(r.some((function(n,e){return!R(n,a[e])})))(n.multiple?e.value.some((function(n){return Rr(n,r)})):e.value!==e.oldValue&&Rr(e.value,r))&&Nr(n,"change")}}};function Dr(n,e,t){Or(n,e,t),(X||Y)&&setTimeout((function(){Or(n,e,t)}),0)}function Or(n,e,t){var a=e.value,r=n.multiple;if(!r||Array.isArray(a)){for(var i,o,s=0,l=n.options.length;s<l;s++)if(o=n.options[s],r)i=P(a,Pr(o))>-1,o.selected!==i&&(o.selected=i);else if(R(Pr(o),a))return void(n.selectedIndex!==s&&(n.selectedIndex=s));r||(n.selectedIndex=-1)}}function Rr(n,e){return e.every((function(e){return!R(e,n)}))}function Pr(n){return"_value"in n?n._value:n.value}function Br(n){n.target.composing=!0}function zr(n){n.target.composing&&(n.target.composing=!1,Nr(n.target,"input"))}function Nr(n,e){var t=document.createEvent("HTMLEvents");t.initEvent(e,!0,!0),n.dispatchEvent(t)}function Ur(n){return!n.componentInstance||n.data&&n.data.transition?n:Ur(n.componentInstance._vnode)}var Fr={model:Mr,show:{bind:function(n,e,t){var a=e.value,r=(t=Ur(t)).data&&t.data.transition,i=n.__vOriginalDisplay="none"===n.style.display?"":n.style.display;a&&r?(t.data.show=!0,Ir(t,(function(){n.style.display=i}))):n.style.display=a?i:"none"},update:function(n,e,t){var a=e.value;!a!=!e.oldValue&&((t=Ur(t)).data&&t.data.transition?(t.data.show=!0,a?Ir(t,(function(){n.style.display=n.__vOriginalDisplay})):Cr(t,(function(){n.style.display="none"}))):n.style.display=a?n.__vOriginalDisplay:"none")},unbind:function(n,e,t,a,r){r||(n.style.display=n.__vOriginalDisplay)}}},Jr={name:String,appear:Boolean,css:Boolean,mode:String,type:String,enterClass:String,leaveClass:String,enterToClass:String,leaveToClass:String,enterActiveClass:String,leaveActiveClass:String,appearClass:String,appearActiveClass:String,appearToClass:String,duration:[Number,String,Object]};function $r(n){var e=n&&n.componentOptions;return e&&e.Ctor.options.abstract?$r(ke(e.children)):n}function Hr(n){var e={},t=n.$options;for(var a in t.propsData)e[a]=n[a];var r=t._parentListeners;for(var a in r)e[T(a)]=r[a];return e}function Gr(n,e){if(/\d-keep-alive$/.test(e.tag))return n("keep-alive",{props:e.componentOptions.propsData})}var Vr=function(n){return n.tag||ge(n)},Wr=function(n){return"show"===n.name},Qr={name:"transition",props:Jr,abstract:!0,render:function(n){var e=this,t=this.$slots.default;if(t&&(t=t.filter(Vr)).length){0;var a=this.mode;0;var r=t[0];if(function(n){for(;n=n.parent;)if(n.data.transition)return!0}(this.$vnode))return r;var i=$r(r);if(!i)return r;if(this._leaving)return Gr(n,r);var o="__transition-".concat(this._uid,"-");i.key=null==i.key?i.isComment?o+"comment":o+i.tag:l(i.key)?0===String(i.key).indexOf(o)?i.key:o+i.key:i.key;var s=(i.data||(i.data={})).transition=Hr(this),c=this._vnode,p=$r(c);if(i.data.directives&&i.data.directives.some(Wr)&&(i.data.show=!0),p&&p.data&&!function(n,e){return e.key===n.key&&e.tag===n.tag}(i,p)&&!ge(p)&&(!p.componentInstance||!p.componentInstance._vnode.isComment)){var d=p.data.transition=q({},s);if("out-in"===a)return this._leaving=!0,Vn(d,"afterLeave",(function(){e._leaving=!1,e.$forceUpdate()})),Gr(n,r);if("in-out"===a){if(ge(i))return c;var u,m=function(){u()};Vn(s,"afterEnter",m),Vn(s,"enterCancelled",m),Vn(d,"delayLeave",(function(n){u=n}))}}return r}}},Xr=q({tag:String,moveClass:String},Jr);function Kr(n){n.elm._moveCb&&n.elm._moveCb(),n.elm._enterCb&&n.elm._enterCb()}function Yr(n){n.data.newPos=n.elm.getBoundingClientRect()}function Zr(n){var e=n.data.pos,t=n.data.newPos,a=e.left-t.left,r=e.top-t.top;if(a||r){n.data.moved=!0;var i=n.elm.style;i.transform=i.WebkitTransform="translate(".concat(a,"px,").concat(r,"px)"),i.transitionDuration="0s"}}delete Xr.mode;var ni={Transition:Qr,TransitionGroup:{props:Xr,beforeMount:function(){var n=this,e=this._update;this._update=function(t,a){var r=Ke(n);n.__patch__(n._vnode,n.kept,!1,!0),n._vnode=n.kept,r(),e.call(n,t,a)}},render:function(n){for(var e=this.tag||this.$vnode.data.tag||"span",t=Object.create(null),a=this.prevChildren=this.children,r=this.$slots.default||[],i=this.children=[],o=Hr(this),s=0;s<r.length;s++){if((p=r[s]).tag)if(null!=p.key&&0!==String(p.key).indexOf("__vlist"))i.push(p),t[p.key]=p,(p.data||(p.data={})).transition=o;else;}if(a){var l=[],c=[];for(s=0;s<a.length;s++){var p;(p=a[s]).data.transition=o,p.data.pos=p.elm.getBoundingClientRect(),t[p.key]?l.push(p):c.push(p)}this.kept=n(e,null,l),this.removed=c}return n(e,null,i)},updated:function(){var n=this.prevChildren,e=this.moveClass||(this.name||"v")+"-move";n.length&&this.hasMove(n[0].elm,e)&&(n.forEach(Kr),n.forEach(Yr),n.forEach(Zr),this._reflow=document.body.offsetHeight,n.forEach((function(n){if(n.data.moved){var t=n.elm,a=t.style;xr(t,e),a.transform=a.WebkitTransform=a.transitionDuration="",t.addEventListener(br,t._moveCb=function n(a){a&&a.target!==t||a&&!/transform$/.test(a.propertyName)||(t.removeEventListener(br,n),t._moveCb=null,wr(t,e))})}})))},methods:{hasMove:function(n,e){if(!mr)return!1;if(this._hasMove)return this._hasMove;var t=n.cloneNode();n._transitionClasses&&n._transitionClasses.forEach((function(n){pr(t,n)})),cr(t,e),t.style.display="none",this.$el.appendChild(t);var a=kr(t);return this.$el.removeChild(t),this._hasMove=a.hasTransform}}}};function ei(n,e){for(var t in e)n[t]=e[t];return n}Gt.config.mustUseProp=function(n,e,t){return"value"===t&&ea(n)&&"button"!==e||"selected"===t&&"option"===n||"checked"===t&&"input"===n||"muted"===t&&"video"===n},Gt.config.isReservedTag=ha,Gt.config.isReservedAttr=na,Gt.config.getTagNamespace=function(n){return ba(n)?"svg":"math"===n?"math":void 0},Gt.config.isUnknownElement=function(n){if(!W)return!0;if(ha(n))return!1;if(n=n.toLowerCase(),null!=va[n])return va[n];var e=document.createElement(n);return n.indexOf("-")>-1?va[n]=e.constructor===window.HTMLUnknownElement||e.constructor===window.HTMLElement:va[n]=/HTMLUnknownElement/.test(e.toString())},q(Gt.options.directives,Fr),q(Gt.options.components,ni),Gt.prototype.__patch__=W?Lr:M,Gt.prototype.$mount=function(n,e){return function(n,e,t){var a;n.$el=e,n.$options.render||(n.$options.render=gn),nt(n,"beforeMount"),a=function(){n._update(n._render(),t)},new He(n,a,M,{before:function(){n._isMounted&&!n._isDestroyed&&nt(n,"beforeUpdate")}},!0),t=!1;var r=n._preWatchers;if(r)for(var i=0;i<r.length;i++)r[i].run();return null==n.$vnode&&(n._isMounted=!0,nt(n,"mounted")),n}(this,n=n&&W?function(n){if("string"==typeof n){var e=document.querySelector(n);return e||document.createElement("div")}return n}(n):void 0,e)},W&&setTimeout((function(){F.devtools&&sn&&sn.emit("init",Gt)}),0);var ti=/[!'()*]/g,ai=function(n){return"%"+n.charCodeAt(0).toString(16)},ri=/%2C/g,ii=function(n){return encodeURIComponent(n).replace(ti,ai).replace(ri,",")};function oi(n){try{return decodeURIComponent(n)}catch(n){0}return n}var si=function(n){return null==n||"object"==typeof n?n:String(n)};function li(n){var e={};return(n=n.trim().replace(/^(\?|#|&)/,""))?(n.split("&").forEach((function(n){var t=n.replace(/\+/g," ").split("="),a=oi(t.shift()),r=t.length>0?oi(t.join("=")):null;void 0===e[a]?e[a]=r:Array.isArray(e[a])?e[a].push(r):e[a]=[e[a],r]})),e):e}function ci(n){var e=n?Object.keys(n).map((function(e){var t=n[e];if(void 0===t)return"";if(null===t)return ii(e);if(Array.isArray(t)){var a=[];return t.forEach((function(n){void 0!==n&&(null===n?a.push(ii(e)):a.push(ii(e)+"="+ii(n)))})),a.join("&")}return ii(e)+"="+ii(t)})).filter((function(n){return n.length>0})).join("&"):null;return e?"?"+e:""}var pi=/\/?$/;function di(n,e,t,a){var r=a&&a.options.stringifyQuery,i=e.query||{};try{i=ui(i)}catch(n){}var o={name:e.name||n&&n.name,meta:n&&n.meta||{},path:e.path||"/",hash:e.hash||"",query:i,params:e.params||{},fullPath:bi(e,r),matched:n?gi(n):[]};return t&&(o.redirectedFrom=bi(t,r)),Object.freeze(o)}function ui(n){if(Array.isArray(n))return n.map(ui);if(n&&"object"==typeof n){var e={};for(var t in n)e[t]=ui(n[t]);return e}return n}var mi=di(null,{path:"/"});function gi(n){for(var e=[];n;)e.unshift(n),n=n.parent;return e}function bi(n,e){var t=n.path,a=n.query;void 0===a&&(a={});var r=n.hash;return void 0===r&&(r=""),(t||"/")+(e||ci)(a)+r}function hi(n,e,t){return e===mi?n===e:!!e&&(n.path&&e.path?n.path.replace(pi,"")===e.path.replace(pi,"")&&(t||n.hash===e.hash&&vi(n.query,e.query)):!(!n.name||!e.name)&&(n.name===e.name&&(t||n.hash===e.hash&&vi(n.query,e.query)&&vi(n.params,e.params))))}function vi(n,e){if(void 0===n&&(n={}),void 0===e&&(e={}),!n||!e)return n===e;var t=Object.keys(n).sort(),a=Object.keys(e).sort();return t.length===a.length&&t.every((function(t,r){var i=n[t];if(a[r]!==t)return!1;var o=e[t];return null==i||null==o?i===o:"object"==typeof i&&"object"==typeof o?vi(i,o):String(i)===String(o)}))}function fi(n){for(var e=0;e<n.matched.length;e++){var t=n.matched[e];for(var a in t.instances){var r=t.instances[a],i=t.enteredCbs[a];if(r&&i){delete t.enteredCbs[a];for(var o=0;o<i.length;o++)r._isBeingDestroyed||i[o](r)}}}}var yi={name:"RouterView",functional:!0,props:{name:{type:String,default:"default"}},render:function(n,e){var t=e.props,a=e.children,r=e.parent,i=e.data;i.routerView=!0;for(var o=r.$createElement,s=t.name,l=r.$route,c=r._routerViewCache||(r._routerViewCache={}),p=0,d=!1;r&&r._routerRoot!==r;){var u=r.$vnode?r.$vnode.data:{};u.routerView&&p++,u.keepAlive&&r._directInactive&&r._inactive&&(d=!0),r=r.$parent}if(i.routerViewDepth=p,d){var m=c[s],g=m&&m.component;return g?(m.configProps&&xi(g,i,m.route,m.configProps),o(g,i,a)):o()}var b=l.matched[p],h=b&&b.components[s];if(!b||!h)return c[s]=null,o();c[s]={component:h},i.registerRouteInstance=function(n,e){var t=b.instances[s];(e&&t!==n||!e&&t===n)&&(b.instances[s]=e)},(i.hook||(i.hook={})).prepatch=function(n,e){b.instances[s]=e.componentInstance},i.hook.init=function(n){n.data.keepAlive&&n.componentInstance&&n.componentInstance!==b.instances[s]&&(b.instances[s]=n.componentInstance),fi(l)};var v=b.props&&b.props[s];return v&&(ei(c[s],{route:l,configProps:v}),xi(h,i,l,v)),o(h,i,a)}};function xi(n,e,t,a){var r=e.props=function(n,e){switch(typeof e){case"undefined":return;case"object":return e;case"function":return e(n);case"boolean":return e?n.params:void 0;default:0}}(t,a);if(r){r=e.props=ei({},r);var i=e.attrs=e.attrs||{};for(var o in r)n.props&&o in n.props||(i[o]=r[o],delete r[o])}}function wi(n,e,t){var a=n.charAt(0);if("/"===a)return n;if("?"===a||"#"===a)return e+n;var r=e.split("/");t&&r[r.length-1]||r.pop();for(var i=n.replace(/^\//,"").split("/"),o=0;o<i.length;o++){var s=i[o];".."===s?r.pop():"."!==s&&r.push(s)}return""!==r[0]&&r.unshift(""),r.join("/")}function Si(n){return n.replace(/\/(?:\s*\/)+/g,"/")}var ji=Array.isArray||function(n){return"[object Array]"==Object.prototype.toString.call(n)},ki=Bi,Ti=Ai,Ei=function(n,e){return Li(Ai(n,e),e)},Ii=Li,Ci=Pi,_i=new RegExp(["(\\\\.)","([\\/.])?(?:(?:\\:(\\w+)(?:\\(((?:\\\\.|[^\\\\()])+)\\))?|\\(((?:\\\\.|[^\\\\()])+)\\))([+*?])?|(\\*))"].join("|"),"g");function Ai(n,e){for(var t,a=[],r=0,i=0,o="",s=e&&e.delimiter||"/";null!=(t=_i.exec(n));){var l=t[0],c=t[1],p=t.index;if(o+=n.slice(i,p),i=p+l.length,c)o+=c[1];else{var d=n[i],u=t[2],m=t[3],g=t[4],b=t[5],h=t[6],v=t[7];o&&(a.push(o),o="");var f=null!=u&&null!=d&&d!==u,y="+"===h||"*"===h,x="?"===h||"*"===h,w=t[2]||s,S=g||b;a.push({name:m||r++,prefix:u||"",delimiter:w,optional:x,repeat:y,partial:f,asterisk:!!v,pattern:S?Di(S):v?".*":"[^"+Mi(w)+"]+?"})}}return i<n.length&&(o+=n.substr(i)),o&&a.push(o),a}function qi(n){return encodeURI(n).replace(/[\/?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()}))}function Li(n,e){for(var t=new Array(n.length),a=0;a<n.length;a++)"object"==typeof n[a]&&(t[a]=new RegExp("^(?:"+n[a].pattern+")$",Ri(e)));return function(e,a){for(var r="",i=e||{},o=(a||{}).pretty?qi:encodeURIComponent,s=0;s<n.length;s++){var l=n[s];if("string"!=typeof l){var c,p=i[l.name];if(null==p){if(l.optional){l.partial&&(r+=l.prefix);continue}throw new TypeError('Expected "'+l.name+'" to be defined')}if(ji(p)){if(!l.repeat)throw new TypeError('Expected "'+l.name+'" to not repeat, but received `'+JSON.stringify(p)+"`");if(0===p.length){if(l.optional)continue;throw new TypeError('Expected "'+l.name+'" to not be empty')}for(var d=0;d<p.length;d++){if(c=o(p[d]),!t[s].test(c))throw new TypeError('Expected all "'+l.name+'" to match "'+l.pattern+'", but received `'+JSON.stringify(c)+"`");r+=(0===d?l.prefix:l.delimiter)+c}}else{if(c=l.asterisk?encodeURI(p).replace(/[?#]/g,(function(n){return"%"+n.charCodeAt(0).toString(16).toUpperCase()})):o(p),!t[s].test(c))throw new TypeError('Expected "'+l.name+'" to match "'+l.pattern+'", but received "'+c+'"');r+=l.prefix+c}}else r+=l}return r}}function Mi(n){return n.replace(/([.+*?=^!:${}()[\]|\/\\])/g,"\\$1")}function Di(n){return n.replace(/([=!:$\/()])/g,"\\$1")}function Oi(n,e){return n.keys=e,n}function Ri(n){return n&&n.sensitive?"":"i"}function Pi(n,e,t){ji(e)||(t=e||t,e=[]);for(var a=(t=t||{}).strict,r=!1!==t.end,i="",o=0;o<n.length;o++){var s=n[o];if("string"==typeof s)i+=Mi(s);else{var l=Mi(s.prefix),c="(?:"+s.pattern+")";e.push(s),s.repeat&&(c+="(?:"+l+c+")*"),i+=c=s.optional?s.partial?l+"("+c+")?":"(?:"+l+"("+c+"))?":l+"("+c+")"}}var p=Mi(t.delimiter||"/"),d=i.slice(-p.length)===p;return a||(i=(d?i.slice(0,-p.length):i)+"(?:"+p+"(?=$))?"),i+=r?"$":a&&d?"":"(?="+p+"|$)",Oi(new RegExp("^"+i,Ri(t)),e)}function Bi(n,e,t){return ji(e)||(t=e||t,e=[]),t=t||{},n instanceof RegExp?function(n,e){var t=n.source.match(/\((?!\?)/g);if(t)for(var a=0;a<t.length;a++)e.push({name:a,prefix:null,delimiter:null,optional:!1,repeat:!1,partial:!1,asterisk:!1,pattern:null});return Oi(n,e)}(n,e):ji(n)?function(n,e,t){for(var a=[],r=0;r<n.length;r++)a.push(Bi(n[r],e,t).source);return Oi(new RegExp("(?:"+a.join("|")+")",Ri(t)),e)}(n,e,t):function(n,e,t){return Pi(Ai(n,t),e,t)}(n,e,t)}ki.parse=Ti,ki.compile=Ei,ki.tokensToFunction=Ii,ki.tokensToRegExp=Ci;var zi=Object.create(null);function Ni(n,e,t){e=e||{};try{var a=zi[n]||(zi[n]=ki.compile(n));return"string"==typeof e.pathMatch&&(e[0]=e.pathMatch),a(e,{pretty:!0})}catch(n){return""}finally{delete e[0]}}function Ui(n,e,t,a){var r="string"==typeof n?{path:n}:n;if(r._normalized)return r;if(r.name){var i=(r=ei({},n)).params;return i&&"object"==typeof i&&(r.params=ei({},i)),r}if(!r.path&&r.params&&e){(r=ei({},r))._normalized=!0;var o=ei(ei({},e.params),r.params);if(e.name)r.name=e.name,r.params=o;else if(e.matched.length){var s=e.matched[e.matched.length-1].path;r.path=Ni(s,o,e.path)}else 0;return r}var l=function(n){var e="",t="",a=n.indexOf("#");a>=0&&(e=n.slice(a),n=n.slice(0,a));var r=n.indexOf("?");return r>=0&&(t=n.slice(r+1),n=n.slice(0,r)),{path:n,query:t,hash:e}}(r.path||""),c=e&&e.path||"/",p=l.path?wi(l.path,c,t||r.append):c,d=function(n,e,t){void 0===e&&(e={});var a,r=t||li;try{a=r(n||"")}catch(n){a={}}for(var i in e){var o=e[i];a[i]=Array.isArray(o)?o.map(si):si(o)}return a}(l.query,r.query,a&&a.options.parseQuery),u=r.hash||l.hash;return u&&"#"!==u.charAt(0)&&(u="#"+u),{_normalized:!0,path:p,query:d,hash:u}}var Fi,Ji=function(){},$i={name:"RouterLink",props:{to:{type:[String,Object],required:!0},tag:{type:String,default:"a"},custom:Boolean,exact:Boolean,exactPath:Boolean,append:Boolean,replace:Boolean,activeClass:String,exactActiveClass:String,ariaCurrentValue:{type:String,default:"page"},event:{type:[String,Array],default:"click"}},render:function(n){var e=this,t=this.$router,a=this.$route,r=t.resolve(this.to,a,this.append),i=r.location,o=r.route,s=r.href,l={},c=t.options.linkActiveClass,p=t.options.linkExactActiveClass,d=null==c?"router-link-active":c,u=null==p?"router-link-exact-active":p,m=null==this.activeClass?d:this.activeClass,g=null==this.exactActiveClass?u:this.exactActiveClass,b=o.redirectedFrom?di(null,Ui(o.redirectedFrom),null,t):o;l[g]=hi(a,b,this.exactPath),l[m]=this.exact||this.exactPath?l[g]:function(n,e){return 0===n.path.replace(pi,"/").indexOf(e.path.replace(pi,"/"))&&(!e.hash||n.hash===e.hash)&&function(n,e){for(var t in e)if(!(t in n))return!1;return!0}(n.query,e.query)}(a,b);var h=l[g]?this.ariaCurrentValue:null,v=function(n){Hi(n)&&(e.replace?t.replace(i,Ji):t.push(i,Ji))},f={click:Hi};Array.isArray(this.event)?this.event.forEach((function(n){f[n]=v})):f[this.event]=v;var y={class:l},x=!this.$scopedSlots.$hasNormal&&this.$scopedSlots.default&&this.$scopedSlots.default({href:s,route:o,navigate:v,isActive:l[m],isExactActive:l[g]});if(x){if(1===x.length)return x[0];if(x.length>1||!x.length)return 0===x.length?n():n("span",{},x)}if("a"===this.tag)y.on=f,y.attrs={href:s,"aria-current":h};else{var w=function n(e){var t;if(e)for(var a=0;a<e.length;a++){if("a"===(t=e[a]).tag)return t;if(t.children&&(t=n(t.children)))return t}}(this.$slots.default);if(w){w.isStatic=!1;var S=w.data=ei({},w.data);for(var j in S.on=S.on||{},S.on){var k=S.on[j];j in f&&(S.on[j]=Array.isArray(k)?k:[k])}for(var T in f)T in S.on?S.on[T].push(f[T]):S.on[T]=v;var E=w.data.attrs=ei({},w.data.attrs);E.href=s,E["aria-current"]=h}else y.on=f}return n(this.tag,y,this.$slots.default)}};function Hi(n){if(!(n.metaKey||n.altKey||n.ctrlKey||n.shiftKey||n.defaultPrevented||void 0!==n.button&&0!==n.button)){if(n.currentTarget&&n.currentTarget.getAttribute){var e=n.currentTarget.getAttribute("target");if(/\b_blank\b/i.test(e))return}return n.preventDefault&&n.preventDefault(),!0}}var Gi="undefined"!=typeof window;function Vi(n,e,t,a,r){var i=e||[],o=t||Object.create(null),s=a||Object.create(null);n.forEach((function(n){!function n(e,t,a,r,i,o){var s=r.path,l=r.name;0;var c=r.pathToRegexpOptions||{},p=function(n,e,t){t||(n=n.replace(/\/$/,""));if("/"===n[0])return n;if(null==e)return n;return Si(e.path+"/"+n)}(s,i,c.strict);"boolean"==typeof r.caseSensitive&&(c.sensitive=r.caseSensitive);var d={path:p,regex:Wi(p,c),components:r.components||{default:r.component},alias:r.alias?"string"==typeof r.alias?[r.alias]:r.alias:[],instances:{},enteredCbs:{},name:l,parent:i,matchAs:o,redirect:r.redirect,beforeEnter:r.beforeEnter,meta:r.meta||{},props:null==r.props?{}:r.components?r.props:{default:r.props}};r.children&&r.children.forEach((function(r){var i=o?Si(o+"/"+r.path):void 0;n(e,t,a,r,d,i)}));t[d.path]||(e.push(d.path),t[d.path]=d);if(void 0!==r.alias)for(var u=Array.isArray(r.alias)?r.alias:[r.alias],m=0;m<u.length;++m){0;var g={path:u[m],children:r.children};n(e,t,a,g,i,d.path||"/")}l&&(a[l]||(a[l]=d))}(i,o,s,n,r)}));for(var l=0,c=i.length;l<c;l++)"*"===i[l]&&(i.push(i.splice(l,1)[0]),c--,l--);return{pathList:i,pathMap:o,nameMap:s}}function Wi(n,e){return ki(n,[],e)}function Qi(n,e){var t=Vi(n),a=t.pathList,r=t.pathMap,i=t.nameMap;function o(n,t,o){var s=Ui(n,t,!1,e),c=s.name;if(c){var p=i[c];if(!p)return l(null,s);var d=p.regex.keys.filter((function(n){return!n.optional})).map((function(n){return n.name}));if("object"!=typeof s.params&&(s.params={}),t&&"object"==typeof t.params)for(var u in t.params)!(u in s.params)&&d.indexOf(u)>-1&&(s.params[u]=t.params[u]);return s.path=Ni(p.path,s.params),l(p,s,o)}if(s.path){s.params={};for(var m=0;m<a.length;m++){var g=a[m],b=r[g];if(Xi(b.regex,s.path,s.params))return l(b,s,o)}}return l(null,s)}function s(n,t){var a=n.redirect,r="function"==typeof a?a(di(n,t,null,e)):a;if("string"==typeof r&&(r={path:r}),!r||"object"!=typeof r)return l(null,t);var s=r,c=s.name,p=s.path,d=t.query,u=t.hash,m=t.params;if(d=s.hasOwnProperty("query")?s.query:d,u=s.hasOwnProperty("hash")?s.hash:u,m=s.hasOwnProperty("params")?s.params:m,c){i[c];return o({_normalized:!0,name:c,query:d,hash:u,params:m},void 0,t)}if(p){var g=function(n,e){return wi(n,e.parent?e.parent.path:"/",!0)}(p,n);return o({_normalized:!0,path:Ni(g,m),query:d,hash:u},void 0,t)}return l(null,t)}function l(n,t,a){return n&&n.redirect?s(n,a||t):n&&n.matchAs?function(n,e,t){var a=o({_normalized:!0,path:Ni(t,e.params)});if(a){var r=a.matched,i=r[r.length-1];return e.params=a.params,l(i,e)}return l(null,e)}(0,t,n.matchAs):di(n,t,a,e)}return{match:o,addRoute:function(n,e){var t="object"!=typeof n?i[n]:void 0;Vi([e||n],a,r,i,t),t&&t.alias.length&&Vi(t.alias.map((function(n){return{path:n,children:[e]}})),a,r,i,t)},getRoutes:function(){return a.map((function(n){return r[n]}))},addRoutes:function(n){Vi(n,a,r,i)}}}function Xi(n,e,t){var a=e.match(n);if(!a)return!1;if(!t)return!0;for(var r=1,i=a.length;r<i;++r){var o=n.keys[r-1];o&&(t[o.name||"pathMatch"]="string"==typeof a[r]?oi(a[r]):a[r])}return!0}var Ki=Gi&&window.performance&&window.performance.now?window.performance:Date;function Yi(){return Ki.now().toFixed(3)}var Zi=Yi();function no(){return Zi}function eo(n){return Zi=n}var to=Object.create(null);function ao(){"scrollRestoration"in window.history&&(window.history.scrollRestoration="manual");var n=window.location.protocol+"//"+window.location.host,e=window.location.href.replace(n,""),t=ei({},window.history.state);return t.key=no(),window.history.replaceState(t,"",e),window.addEventListener("popstate",oo),function(){window.removeEventListener("popstate",oo)}}function ro(n,e,t,a){if(n.app){var r=n.options.scrollBehavior;r&&n.app.$nextTick((function(){var i=function(){var n=no();if(n)return to[n]}(),o=r.call(n,e,t,a?i:null);o&&("function"==typeof o.then?o.then((function(n){uo(n,i)})).catch((function(n){0})):uo(o,i))}))}}function io(){var n=no();n&&(to[n]={x:window.pageXOffset,y:window.pageYOffset})}function oo(n){io(),n.state&&n.state.key&&eo(n.state.key)}function so(n){return co(n.x)||co(n.y)}function lo(n){return{x:co(n.x)?n.x:window.pageXOffset,y:co(n.y)?n.y:window.pageYOffset}}function co(n){return"number"==typeof n}var po=/^#\d/;function uo(n,e){var t,a="object"==typeof n;if(a&&"string"==typeof n.selector){var r=po.test(n.selector)?document.getElementById(n.selector.slice(1)):document.querySelector(n.selector);if(r){var i=n.offset&&"object"==typeof n.offset?n.offset:{};e=function(n,e){var t=document.documentElement.getBoundingClientRect(),a=n.getBoundingClientRect();return{x:a.left-t.left-e.x,y:a.top-t.top-e.y}}(r,i={x:co((t=i).x)?t.x:0,y:co(t.y)?t.y:0})}else so(n)&&(e=lo(n))}else a&&so(n)&&(e=lo(n));e&&("scrollBehavior"in document.documentElement.style?window.scrollTo({left:e.x,top:e.y,behavior:n.behavior}):window.scrollTo(e.x,e.y))}var mo,go=Gi&&((-1===(mo=window.navigator.userAgent).indexOf("Android 2.")&&-1===mo.indexOf("Android 4.0")||-1===mo.indexOf("Mobile Safari")||-1!==mo.indexOf("Chrome")||-1!==mo.indexOf("Windows Phone"))&&window.history&&"function"==typeof window.history.pushState);function bo(n,e){io();var t=window.history;try{if(e){var a=ei({},t.state);a.key=no(),t.replaceState(a,"",n)}else t.pushState({key:eo(Yi())},"",n)}catch(t){window.location[e?"replace":"assign"](n)}}function ho(n){bo(n,!0)}var vo={redirected:2,aborted:4,cancelled:8,duplicated:16};function fo(n,e){return xo(n,e,vo.redirected,'Redirected when going from "'+n.fullPath+'" to "'+function(n){if("string"==typeof n)return n;if("path"in n)return n.path;var e={};return wo.forEach((function(t){t in n&&(e[t]=n[t])})),JSON.stringify(e,null,2)}(e)+'" via a navigation guard.')}function yo(n,e){return xo(n,e,vo.cancelled,'Navigation cancelled from "'+n.fullPath+'" to "'+e.fullPath+'" with a new navigation.')}function xo(n,e,t,a){var r=new Error(a);return r._isRouter=!0,r.from=n,r.to=e,r.type=t,r}var wo=["params","query","hash"];function So(n){return Object.prototype.toString.call(n).indexOf("Error")>-1}function jo(n,e){return So(n)&&n._isRouter&&(null==e||n.type===e)}function ko(n,e,t){var a=function(r){r>=n.length?t():n[r]?e(n[r],(function(){a(r+1)})):a(r+1)};a(0)}function To(n){return function(e,t,a){var r=!1,i=0,o=null;Eo(n,(function(n,e,t,s){if("function"==typeof n&&void 0===n.cid){r=!0,i++;var l,c=_o((function(e){var r;((r=e).__esModule||Co&&"Module"===r[Symbol.toStringTag])&&(e=e.default),n.resolved="function"==typeof e?e:Fi.extend(e),t.components[s]=e,--i<=0&&a()})),p=_o((function(n){var e="Failed to resolve async component "+s+": "+n;o||(o=So(n)?n:new Error(e),a(o))}));try{l=n(c,p)}catch(n){p(n)}if(l)if("function"==typeof l.then)l.then(c,p);else{var d=l.component;d&&"function"==typeof d.then&&d.then(c,p)}}})),r||a()}}function Eo(n,e){return Io(n.map((function(n){return Object.keys(n.components).map((function(t){return e(n.components[t],n.instances[t],n,t)}))})))}function Io(n){return Array.prototype.concat.apply([],n)}var Co="function"==typeof Symbol&&"symbol"==typeof Symbol.toStringTag;function _o(n){var e=!1;return function(){for(var t=[],a=arguments.length;a--;)t[a]=arguments[a];if(!e)return e=!0,n.apply(this,t)}}var Ao=function(n,e){this.router=n,this.base=function(n){if(!n)if(Gi){var e=document.querySelector("base");n=(n=e&&e.getAttribute("href")||"/").replace(/^https?:\/\/[^\/]+/,"")}else n="/";"/"!==n.charAt(0)&&(n="/"+n);return n.replace(/\/$/,"")}(e),this.current=mi,this.pending=null,this.ready=!1,this.readyCbs=[],this.readyErrorCbs=[],this.errorCbs=[],this.listeners=[]};function qo(n,e,t,a){var r=Eo(n,(function(n,a,r,i){var o=function(n,e){"function"!=typeof n&&(n=Fi.extend(n));return n.options[e]}(n,e);if(o)return Array.isArray(o)?o.map((function(n){return t(n,a,r,i)})):t(o,a,r,i)}));return Io(a?r.reverse():r)}function Lo(n,e){if(e)return function(){return n.apply(e,arguments)}}Ao.prototype.listen=function(n){this.cb=n},Ao.prototype.onReady=function(n,e){this.ready?n():(this.readyCbs.push(n),e&&this.readyErrorCbs.push(e))},Ao.prototype.onError=function(n){this.errorCbs.push(n)},Ao.prototype.transitionTo=function(n,e,t){var a,r=this;try{a=this.router.match(n,this.current)}catch(n){throw this.errorCbs.forEach((function(e){e(n)})),n}var i=this.current;this.confirmTransition(a,(function(){r.updateRoute(a),e&&e(a),r.ensureURL(),r.router.afterHooks.forEach((function(n){n&&n(a,i)})),r.ready||(r.ready=!0,r.readyCbs.forEach((function(n){n(a)})))}),(function(n){t&&t(n),n&&!r.ready&&(jo(n,vo.redirected)&&i===mi||(r.ready=!0,r.readyErrorCbs.forEach((function(e){e(n)}))))}))},Ao.prototype.confirmTransition=function(n,e,t){var a=this,r=this.current;this.pending=n;var i,o,s=function(n){!jo(n)&&So(n)&&(a.errorCbs.length?a.errorCbs.forEach((function(e){e(n)})):console.error(n)),t&&t(n)},l=n.matched.length-1,c=r.matched.length-1;if(hi(n,r)&&l===c&&n.matched[l]===r.matched[c])return this.ensureURL(),n.hash&&ro(this.router,r,n,!1),s(((o=xo(i=r,n,vo.duplicated,'Avoided redundant navigation to current location: "'+i.fullPath+'".')).name="NavigationDuplicated",o));var p=function(n,e){var t,a=Math.max(n.length,e.length);for(t=0;t<a&&n[t]===e[t];t++);return{updated:e.slice(0,t),activated:e.slice(t),deactivated:n.slice(t)}}(this.current.matched,n.matched),d=p.updated,u=p.deactivated,m=p.activated,g=[].concat(function(n){return qo(n,"beforeRouteLeave",Lo,!0)}(u),this.router.beforeHooks,function(n){return qo(n,"beforeRouteUpdate",Lo)}(d),m.map((function(n){return n.beforeEnter})),To(m)),b=function(e,t){if(a.pending!==n)return s(yo(r,n));try{e(n,r,(function(e){!1===e?(a.ensureURL(!0),s(function(n,e){return xo(n,e,vo.aborted,'Navigation aborted from "'+n.fullPath+'" to "'+e.fullPath+'" via a navigation guard.')}(r,n))):So(e)?(a.ensureURL(!0),s(e)):"string"==typeof e||"object"==typeof e&&("string"==typeof e.path||"string"==typeof e.name)?(s(fo(r,n)),"object"==typeof e&&e.replace?a.replace(e):a.push(e)):t(e)}))}catch(n){s(n)}};ko(g,b,(function(){ko(function(n){return qo(n,"beforeRouteEnter",(function(n,e,t,a){return function(n,e,t){return function(a,r,i){return n(a,r,(function(n){"function"==typeof n&&(e.enteredCbs[t]||(e.enteredCbs[t]=[]),e.enteredCbs[t].push(n)),i(n)}))}}(n,t,a)}))}(m).concat(a.router.resolveHooks),b,(function(){if(a.pending!==n)return s(yo(r,n));a.pending=null,e(n),a.router.app&&a.router.app.$nextTick((function(){fi(n)}))}))}))},Ao.prototype.updateRoute=function(n){this.current=n,this.cb&&this.cb(n)},Ao.prototype.setupListeners=function(){},Ao.prototype.teardown=function(){this.listeners.forEach((function(n){n()})),this.listeners=[],this.current=mi,this.pending=null};var Mo=function(n){function e(e,t){n.call(this,e,t),this._startLocation=Do(this.base)}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router,t=e.options.scrollBehavior,a=go&&t;a&&this.listeners.push(ao());var r=function(){var t=n.current,r=Do(n.base);n.current===mi&&r===n._startLocation||n.transitionTo(r,(function(n){a&&ro(e,n,t,!0)}))};window.addEventListener("popstate",r),this.listeners.push((function(){window.removeEventListener("popstate",r)}))}},e.prototype.go=function(n){window.history.go(n)},e.prototype.push=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){bo(Si(a.base+n.fullPath)),ro(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){ho(Si(a.base+n.fullPath)),ro(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.ensureURL=function(n){if(Do(this.base)!==this.current.fullPath){var e=Si(this.base+this.current.fullPath);n?bo(e):ho(e)}},e.prototype.getCurrentLocation=function(){return Do(this.base)},e}(Ao);function Do(n){var e=window.location.pathname,t=e.toLowerCase(),a=n.toLowerCase();return!n||t!==a&&0!==t.indexOf(Si(a+"/"))||(e=e.slice(n.length)),(e||"/")+window.location.search+window.location.hash}var Oo=function(n){function e(e,t,a){n.call(this,e,t),a&&function(n){var e=Do(n);if(!/^\/#/.test(e))return window.location.replace(Si(n+"/#"+e)),!0}(this.base)||Ro()}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.setupListeners=function(){var n=this;if(!(this.listeners.length>0)){var e=this.router.options.scrollBehavior,t=go&&e;t&&this.listeners.push(ao());var a=function(){var e=n.current;Ro()&&n.transitionTo(Po(),(function(a){t&&ro(n.router,a,e,!0),go||No(a.fullPath)}))},r=go?"popstate":"hashchange";window.addEventListener(r,a),this.listeners.push((function(){window.removeEventListener(r,a)}))}},e.prototype.push=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){zo(n.fullPath),ro(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this,r=this.current;this.transitionTo(n,(function(n){No(n.fullPath),ro(a.router,n,r,!1),e&&e(n)}),t)},e.prototype.go=function(n){window.history.go(n)},e.prototype.ensureURL=function(n){var e=this.current.fullPath;Po()!==e&&(n?zo(e):No(e))},e.prototype.getCurrentLocation=function(){return Po()},e}(Ao);function Ro(){var n=Po();return"/"===n.charAt(0)||(No("/"+n),!1)}function Po(){var n=window.location.href,e=n.indexOf("#");return e<0?"":n=n.slice(e+1)}function Bo(n){var e=window.location.href,t=e.indexOf("#");return(t>=0?e.slice(0,t):e)+"#"+n}function zo(n){go?bo(Bo(n)):window.location.hash=n}function No(n){go?ho(Bo(n)):window.location.replace(Bo(n))}var Uo=function(n){function e(e,t){n.call(this,e,t),this.stack=[],this.index=-1}return n&&(e.__proto__=n),e.prototype=Object.create(n&&n.prototype),e.prototype.constructor=e,e.prototype.push=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index+1).concat(n),a.index++,e&&e(n)}),t)},e.prototype.replace=function(n,e,t){var a=this;this.transitionTo(n,(function(n){a.stack=a.stack.slice(0,a.index).concat(n),e&&e(n)}),t)},e.prototype.go=function(n){var e=this,t=this.index+n;if(!(t<0||t>=this.stack.length)){var a=this.stack[t];this.confirmTransition(a,(function(){var n=e.current;e.index=t,e.updateRoute(a),e.router.afterHooks.forEach((function(e){e&&e(a,n)}))}),(function(n){jo(n,vo.duplicated)&&(e.index=t)}))}},e.prototype.getCurrentLocation=function(){var n=this.stack[this.stack.length-1];return n?n.fullPath:"/"},e.prototype.ensureURL=function(){},e}(Ao),Fo=function(n){void 0===n&&(n={}),this.app=null,this.apps=[],this.options=n,this.beforeHooks=[],this.resolveHooks=[],this.afterHooks=[],this.matcher=Qi(n.routes||[],this);var e=n.mode||"hash";switch(this.fallback="history"===e&&!go&&!1!==n.fallback,this.fallback&&(e="hash"),Gi||(e="abstract"),this.mode=e,e){case"history":this.history=new Mo(this,n.base);break;case"hash":this.history=new Oo(this,n.base,this.fallback);break;case"abstract":this.history=new Uo(this,n.base);break;default:0}},Jo={currentRoute:{configurable:!0}};Fo.prototype.match=function(n,e,t){return this.matcher.match(n,e,t)},Jo.currentRoute.get=function(){return this.history&&this.history.current},Fo.prototype.init=function(n){var e=this;if(this.apps.push(n),n.$once("hook:destroyed",(function(){var t=e.apps.indexOf(n);t>-1&&e.apps.splice(t,1),e.app===n&&(e.app=e.apps[0]||null),e.app||e.history.teardown()})),!this.app){this.app=n;var t=this.history;if(t instanceof Mo||t instanceof Oo){var a=function(n){t.setupListeners(),function(n){var a=t.current,r=e.options.scrollBehavior;go&&r&&"fullPath"in n&&ro(e,n,a,!1)}(n)};t.transitionTo(t.getCurrentLocation(),a,a)}t.listen((function(n){e.apps.forEach((function(e){e._route=n}))}))}},Fo.prototype.beforeEach=function(n){return Ho(this.beforeHooks,n)},Fo.prototype.beforeResolve=function(n){return Ho(this.resolveHooks,n)},Fo.prototype.afterEach=function(n){return Ho(this.afterHooks,n)},Fo.prototype.onReady=function(n,e){this.history.onReady(n,e)},Fo.prototype.onError=function(n){this.history.onError(n)},Fo.prototype.push=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.push(n,e,t)}));this.history.push(n,e,t)},Fo.prototype.replace=function(n,e,t){var a=this;if(!e&&!t&&"undefined"!=typeof Promise)return new Promise((function(e,t){a.history.replace(n,e,t)}));this.history.replace(n,e,t)},Fo.prototype.go=function(n){this.history.go(n)},Fo.prototype.back=function(){this.go(-1)},Fo.prototype.forward=function(){this.go(1)},Fo.prototype.getMatchedComponents=function(n){var e=n?n.matched?n:this.resolve(n).route:this.currentRoute;return e?[].concat.apply([],e.matched.map((function(n){return Object.keys(n.components).map((function(e){return n.components[e]}))}))):[]},Fo.prototype.resolve=function(n,e,t){var a=Ui(n,e=e||this.history.current,t,this),r=this.match(a,e),i=r.redirectedFrom||r.fullPath;return{location:a,route:r,href:function(n,e,t){var a="hash"===t?"#"+e:e;return n?Si(n+"/"+a):a}(this.history.base,i,this.mode),normalizedTo:a,resolved:r}},Fo.prototype.getRoutes=function(){return this.matcher.getRoutes()},Fo.prototype.addRoute=function(n,e){this.matcher.addRoute(n,e),this.history.current!==mi&&this.history.transitionTo(this.history.getCurrentLocation())},Fo.prototype.addRoutes=function(n){this.matcher.addRoutes(n),this.history.current!==mi&&this.history.transitionTo(this.history.getCurrentLocation())},Object.defineProperties(Fo.prototype,Jo);var $o=Fo;function Ho(n,e){return n.push(e),function(){var t=n.indexOf(e);t>-1&&n.splice(t,1)}}Fo.install=function n(e){if(!n.installed||Fi!==e){n.installed=!0,Fi=e;var t=function(n){return void 0!==n},a=function(n,e){var a=n.$options._parentVnode;t(a)&&t(a=a.data)&&t(a=a.registerRouteInstance)&&a(n,e)};e.mixin({beforeCreate:function(){t(this.$options.router)?(this._routerRoot=this,this._router=this.$options.router,this._router.init(this),e.util.defineReactive(this,"_route",this._router.history.current)):this._routerRoot=this.$parent&&this.$parent._routerRoot||this,a(this,this)},destroyed:function(){a(this)}}),Object.defineProperty(e.prototype,"$router",{get:function(){return this._routerRoot._router}}),Object.defineProperty(e.prototype,"$route",{get:function(){return this._routerRoot._route}}),e.component("RouterView",yi),e.component("RouterLink",$i);var r=e.config.optionMergeStrategies;r.beforeRouteEnter=r.beforeRouteLeave=r.beforeRouteUpdate=r.created}},Fo.version="3.6.5",Fo.isNavigationFailure=jo,Fo.NavigationFailureType=vo,Fo.START_LOCATION=mi,Gi&&window.Vue&&window.Vue.use(Fo);t(105);t(18),t(132);var Go={NotFound:()=>Promise.all([t.e(0),t.e(4)]).then(t.bind(null,342)),Layout:()=>Promise.all([t.e(0),t.e(2)]).then(t.bind(null,341))},Vo={"v-d4591194":()=>t.e(6).then(t.bind(null,344)),"v-0ab12568":()=>t.e(7).then(t.bind(null,345)),"v-397f32ac":()=>t.e(9).then(t.bind(null,346)),"v-c88be50c":()=>t.e(8).then(t.bind(null,347)),"v-b5521cb0":()=>t.e(10).then(t.bind(null,348)),"v-36016ffa":()=>t.e(11).then(t.bind(null,349)),"v-1232d768":()=>t.e(12).then(t.bind(null,350)),"v-f3615e36":()=>t.e(13).then(t.bind(null,351)),"v-48faa1d3":()=>t.e(16).then(t.bind(null,352)),"v-65c36e4f":()=>t.e(14).then(t.bind(null,353)),"v-004efb11":()=>t.e(17).then(t.bind(null,354)),"v-1fde75d5":()=>t.e(19).then(t.bind(null,355)),"v-22ffbd7d":()=>t.e(15).then(t.bind(null,356)),"v-e9056132":()=>t.e(18).then(t.bind(null,357)),"v-2adb23eb":()=>t.e(20).then(t.bind(null,358)),"v-8c5f91b2":()=>t.e(22).then(t.bind(null,359)),"v-031c20de":()=>t.e(21).then(t.bind(null,360)),"v-3ead9483":()=>t.e(23).then(t.bind(null,361)),"v-fb49d4e2":()=>t.e(24).then(t.bind(null,362)),"v-0e5d2811":()=>t.e(25).then(t.bind(null,363)),"v-10261aa3":()=>t.e(27).then(t.bind(null,364)),"v-6f9743c0":()=>t.e(26).then(t.bind(null,365)),"v-5169e0e4":()=>t.e(28).then(t.bind(null,366)),"v-cd1cf0e8":()=>t.e(30).then(t.bind(null,367)),"v-b93f4c84":()=>t.e(29).then(t.bind(null,368)),"v-e6903300":()=>t.e(31).then(t.bind(null,369)),"v-3fdb40e9":()=>t.e(32).then(t.bind(null,370)),"v-f872bd68":()=>t.e(33).then(t.bind(null,371)),"v-3f258632":()=>t.e(35).then(t.bind(null,372)),"v-302a0722":()=>t.e(34).then(t.bind(null,373)),"v-3f4e8dea":()=>t.e(36).then(t.bind(null,374)),"v-62776f4a":()=>t.e(39).then(t.bind(null,375)),"v-6e838041":()=>t.e(38).then(t.bind(null,376)),"v-4bc1b449":()=>t.e(41).then(t.bind(null,377)),"v-4de788f0":()=>t.e(40).then(t.bind(null,378)),"v-256a7c79":()=>t.e(42).then(t.bind(null,379)),"v-056e9e9e":()=>t.e(37).then(t.bind(null,380)),"v-21b1d4ee":()=>t.e(46).then(t.bind(null,381)),"v-b074d626":()=>t.e(43).then(t.bind(null,382)),"v-439f0503":()=>t.e(44).then(t.bind(null,383)),"v-1f123e21":()=>t.e(48).then(t.bind(null,384)),"v-27ebad24":()=>t.e(45).then(t.bind(null,385)),"v-266c61ea":()=>t.e(47).then(t.bind(null,386)),"v-5156a597":()=>t.e(49).then(t.bind(null,387)),"v-450e1b5c":()=>t.e(53).then(t.bind(null,388)),"v-59358ae3":()=>t.e(54).then(t.bind(null,389)),"v-69a39f61":()=>t.e(50).then(t.bind(null,390)),"v-5a6df113":()=>t.e(56).then(t.bind(null,391)),"v-8c5b9946":()=>t.e(55).then(t.bind(null,392)),"v-e9724afe":()=>t.e(52).then(t.bind(null,393)),"v-71eb58e1":()=>t.e(51).then(t.bind(null,394)),"v-2e058210":()=>t.e(58).then(t.bind(null,395)),"v-34330dd8":()=>t.e(60).then(t.bind(null,396)),"v-261bed0c":()=>t.e(62).then(t.bind(null,397)),"v-070e9099":()=>t.e(57).then(t.bind(null,398)),"v-790e32d0":()=>t.e(64).then(t.bind(null,399)),"v-c84beac8":()=>t.e(61).then(t.bind(null,400)),"v-613d8bec":()=>t.e(59).then(t.bind(null,401)),"v-e882b48e":()=>t.e(66).then(t.bind(null,402)),"v-2693326f":()=>t.e(63).then(t.bind(null,403)),"v-4f61d496":()=>t.e(65).then(t.bind(null,404)),"v-02f39703":()=>t.e(67).then(t.bind(null,405)),"v-5854de66":()=>t.e(68).then(t.bind(null,406)),"v-16d518b6":()=>t.e(71).then(t.bind(null,407)),"v-28e963c8":()=>t.e(69).then(t.bind(null,408)),"v-57f0b14b":()=>t.e(70).then(t.bind(null,409)),"v-1a1104fd":()=>t.e(72).then(t.bind(null,410)),"v-1b4d203a":()=>t.e(73).then(t.bind(null,411)),"v-020f8ced":()=>t.e(75).then(t.bind(null,412)),"v-75e3f174":()=>t.e(74).then(t.bind(null,413)),"v-123114c4":()=>t.e(77).then(t.bind(null,414)),"v-01efe0dc":()=>t.e(76).then(t.bind(null,415)),"v-986ca544":()=>t.e(78).then(t.bind(null,416)),"v-28c6e85e":()=>t.e(80).then(t.bind(null,417)),"v-9077d038":()=>t.e(79).then(t.bind(null,418)),"v-fa7faa54":()=>t.e(81).then(t.bind(null,419)),"v-6d0cc81e":()=>t.e(85).then(t.bind(null,420)),"v-7b6e642c":()=>t.e(82).then(t.bind(null,421)),"v-13f835b1":()=>t.e(84).then(t.bind(null,422)),"v-2a180b97":()=>t.e(86).then(t.bind(null,423)),"v-6af45ef5":()=>t.e(83).then(t.bind(null,424)),"v-a68a0746":()=>t.e(90).then(t.bind(null,425)),"v-d177183e":()=>t.e(88).then(t.bind(null,426)),"v-462a5c98":()=>t.e(89).then(t.bind(null,427)),"v-5b6cb686":()=>t.e(92).then(t.bind(null,428)),"v-0ecba8f6":()=>t.e(87).then(t.bind(null,429)),"v-4b0d10ec":()=>t.e(91).then(t.bind(null,430)),"v-7e82dfbf":()=>t.e(93).then(t.bind(null,431)),"v-9a683472":()=>t.e(94).then(t.bind(null,432)),"v-93907e36":()=>t.e(95).then(t.bind(null,433)),"v-e909945c":()=>t.e(96).then(t.bind(null,343)),"v-44ee75b0":()=>t.e(100).then(t.bind(null,434)),"v-12033e88":()=>t.e(99).then(t.bind(null,435)),"v-2c6a8ca8":()=>t.e(98).then(t.bind(null,436)),"v-41736a06":()=>t.e(97).then(t.bind(null,437)),"v-4768fc14":()=>t.e(101).then(t.bind(null,438))};function Wo(n){const e=Object.create(null);return function(t){return e[t]||(e[t]=n(t))}}const Qo=/-(\w)/g,Xo=Wo(n=>n.replace(Qo,(n,e)=>e?e.toUpperCase():"")),Ko=/\B([A-Z])/g,Yo=Wo(n=>n.replace(Ko,"-$1").toLowerCase()),Zo=Wo(n=>n.charAt(0).toUpperCase()+n.slice(1));function ns(n,e){if(!e)return;if(n(e))return n(e);return e.includes("-")?n(Zo(Xo(e))):n(Zo(e))||n(Yo(e))}const es=Object.assign({},Go,Vo),ts=n=>es[n],as=n=>Vo[n],rs=n=>Go[n],is=n=>Gt.component(n);function os(n){return ns(as,n)}function ss(n){return ns(rs,n)}function ls(n){return ns(ts,n)}function cs(n){return ns(is,n)}function ps(...n){return Promise.all(n.filter(n=>n).map(async n=>{if(!cs(n)&&ls(n)){const e=await ls(n)();Gt.component(n,e.default)}}))}function ds(n,e){"undefined"!=typeof window&&window.__VUEPRESS__&&(window.__VUEPRESS__[n]=e)}var us=t(93),ms=t.n(us),gs=t(94),bs=t.n(gs),hs={created(){if(this.siteMeta=this.$site.headTags.filter(([n])=>"meta"===n).map(([n,e])=>e),this.$ssrContext){const e=this.getMergedMetaTags();this.$ssrContext.title=this.$title,this.$ssrContext.lang=this.$lang,this.$ssrContext.pageMeta=(n=e)?n.map(n=>{let e="<meta";return Object.keys(n).forEach(t=>{e+=` ${t}="${bs()(n[t])}"`}),e+">"}).join("\n    "):"",this.$ssrContext.canonicalLink=fs(this.$canonicalUrl)}var n},mounted(){this.currentMetaTags=[...document.querySelectorAll("meta")],this.updateMeta(),this.updateCanonicalLink()},methods:{updateMeta(){document.title=this.$title,document.documentElement.lang=this.$lang;const n=this.getMergedMetaTags();this.currentMetaTags=ys(n,this.currentMetaTags)},getMergedMetaTags(){const n=this.$page.frontmatter.meta||[];return ms()([{name:"description",content:this.$description}],n,this.siteMeta,xs)},updateCanonicalLink(){vs(),this.$canonicalUrl&&document.head.insertAdjacentHTML("beforeend",fs(this.$canonicalUrl))}},watch:{$page(){this.updateMeta(),this.updateCanonicalLink()}},beforeDestroy(){ys(null,this.currentMetaTags),vs()}};function vs(){const n=document.querySelector("link[rel='canonical']");n&&n.remove()}function fs(n=""){return n?`<link href="${n}" rel="canonical" />`:""}function ys(n,e){if(e&&[...e].filter(n=>n.parentNode===document.head).forEach(n=>document.head.removeChild(n)),n)return n.map(n=>{const e=document.createElement("meta");return Object.keys(n).forEach(t=>{e.setAttribute(t,n[t])}),document.head.appendChild(e),e})}function xs(n){for(const e of["name","property","itemprop"])if(n.hasOwnProperty(e))return n[e]+e;return JSON.stringify(n)}var ws=t(51),Ss={mounted(){window.addEventListener("scroll",this.onScroll)},methods:{onScroll:t.n(ws)()((function(){this.setActiveHash()}),300),setActiveHash(){const n=[].slice.call(document.querySelectorAll(".sidebar-link")),e=[].slice.call(document.querySelectorAll(".header-anchor")).filter(e=>n.some(n=>n.hash===e.hash)),t=Math.max(window.pageYOffset,document.documentElement.scrollTop,document.body.scrollTop),a=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),r=window.innerHeight+t;for(let n=0;n<e.length;n++){const i=e[n],o=e[n+1],s=0===n&&0===t||t>=i.parentElement.offsetTop+10&&(!o||t<o.parentElement.offsetTop-10),l=decodeURIComponent(this.$route.hash);if(s&&l!==decodeURIComponent(i.hash)){const t=i;if(r===a)for(let t=n+1;t<e.length;t++)if(l===decodeURIComponent(e[t].hash))return;return this.$vuepress.$set("disableScrollBehavior",!0),void this.$router.replace(decodeURIComponent(t.hash),()=>{this.$nextTick(()=>{this.$vuepress.$set("disableScrollBehavior",!1)})})}}}},beforeDestroy(){window.removeEventListener("scroll",this.onScroll)}},js=t(27),ks=t.n(js),Ts={mounted(){ks.a.configure({showSpinner:!1}),this.$router.beforeEach((n,e,t)=>{n.path===e.path||Gt.component(n.name)||ks.a.start(),t()}),this.$router.afterEach(()=>{ks.a.done(),this.isSidebarOpen=!1})}};t(241),t(242);class Es{constructor(){this.containerEl=document.getElementById("message-container"),this.containerEl||(this.containerEl=document.createElement("div"),this.containerEl.id="message-container",document.body.appendChild(this.containerEl))}show({text:n="",duration:e=3e3}){let t=document.createElement("div");t.className="message move-in",t.innerHTML=`\n      <i style="fill: #06a35a;font-size: 14px;display:inline-flex;align-items: center;">\n        <svg style="fill: #06a35a;font-size: 14px;" t="1572421810237" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="2323" width="16" height="16"><path d="M822.811993 824.617989c-83.075838 81.99224-188.546032 124.613757-316.049383 127.86455-122.085362-3.250794-223.943563-45.87231-305.935802-127.86455s-124.613757-184.21164-127.86455-305.935802c3.250794-127.503351 45.87231-232.973545 127.86455-316.049383 81.99224-83.075838 184.21164-126.058554 305.935802-129.309347 127.503351 3.250794 232.973545 46.23351 316.049383 129.309347 83.075838 83.075838 126.058554 188.546032 129.309347 316.049383C949.231746 640.406349 905.887831 742.62575 822.811993 824.617989zM432.716755 684.111464c3.973192 3.973192 8.307584 5.779189 13.364374 6.140388 5.05679 0.361199 9.752381-1.444797 13.364374-5.417989l292.571429-287.514638c3.973192-3.973192 5.779189-8.307584 5.779189-13.364374 0-5.05679-1.805996-9.752381-5.779189-13.364374l1.805996 1.805996c-3.973192-3.973192-8.668783-5.779189-14.086772-6.140388-5.417989-0.361199-10.47478 1.444797-14.809171 5.417989l-264.397884 220.33157c-3.973192 3.250794-8.668783 4.695591-14.447972 4.695591-5.779189 0-10.835979-1.444797-15.53157-3.973192l-94.273016-72.962257c-4.334392-3.250794-9.391182-4.334392-14.447972-3.973192s-9.391182 3.250794-12.641975 7.585185l-2.889594 3.973192c-3.250794 4.334392-4.334392 9.391182-3.973192 14.809171 0.722399 5.417989 2.528395 10.11358 5.779189 14.086772L432.716755 684.111464z" p-id="2324"></path></svg>\n      </i>\n      <div class="text">${n}</div>\n    `,this.containerEl.appendChild(t),e>0&&setTimeout(()=>{this.close(t)},e)}close(n){n.className=n.className.replace("move-in",""),n.className+="move-out",n.addEventListener("animationend",()=>{n.remove()})}}var Is={mounted(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},updated(){!!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)||this.updateCopy()},methods:{updateCopy(){setTimeout(()=>{(['div[class*="language-"] pre','div[class*="aside-code"] aside']instanceof Array||Array.isArray(['div[class*="language-"] pre','div[class*="aside-code"] aside']))&&['div[class*="language-"] pre','div[class*="aside-code"] aside'].forEach(n=>{document.querySelectorAll(n).forEach(this.generateCopyButton)})},1e3)},generateCopyButton(n){if(n.classList.contains("codecopy-enabled"))return;const e=document.createElement("i");e.className="code-copy",e.innerHTML='<svg  style="color:#aaa;font-size:14px" t="1572422231464" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="3201" width="14" height="14"><path d="M866.461538 39.384615H354.461538c-43.323077 0-78.769231 35.446154-78.76923 78.769231v39.384616h472.615384c43.323077 0 78.769231 35.446154 78.769231 78.76923v551.384616h39.384615c43.323077 0 78.769231-35.446154 78.769231-78.769231V118.153846c0-43.323077-35.446154-78.769231-78.769231-78.769231z m-118.153846 275.692308c0-43.323077-35.446154-78.769231-78.76923-78.769231H157.538462c-43.323077 0-78.769231 35.446154-78.769231 78.769231v590.769231c0 43.323077 35.446154 78.769231 78.769231 78.769231h512c43.323077 0 78.769231-35.446154 78.76923-78.769231V315.076923z m-354.461538 137.846154c0 11.815385-7.876923 19.692308-19.692308 19.692308h-157.538461c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h157.538461c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z m157.538461 315.076923c0 11.815385-7.876923 19.692308-19.692307 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h315.076923c11.815385 0 19.692308 7.876923 19.692307 19.692308v39.384615z m78.769231-157.538462c0 11.815385-7.876923 19.692308-19.692308 19.692308H216.615385c-11.815385 0-19.692308-7.876923-19.692308-19.692308v-39.384615c0-11.815385 7.876923-19.692308 19.692308-19.692308h393.846153c11.815385 0 19.692308 7.876923 19.692308 19.692308v39.384615z" p-id="3202"></path></svg>',e.title="Copy to clipboard",e.addEventListener("click",()=>{this.copyToClipboard(n.innerText)}),n.appendChild(e),n.classList.add("codecopy-enabled")},copyToClipboard(n){const e=document.createElement("textarea");e.value=n,e.setAttribute("readonly",""),e.style.position="absolute",e.style.left="-9999px",document.body.appendChild(e);const t=document.getSelection().rangeCount>0&&document.getSelection().getRangeAt(0);e.select(),document.execCommand("copy");(new Es).show({text:"复制成功",duration:1e3}),document.body.removeChild(e),t&&(document.getSelection().removeAllRanges(),document.getSelection().addRange(t))}}};!function(n,e){void 0===e&&(e={});var t=e.insertAt;if(n&&"undefined"!=typeof document){var a=document.head||document.getElementsByTagName("head")[0],r=document.createElement("style");r.type="text/css","top"===t&&a.firstChild?a.insertBefore(r,a.firstChild):a.appendChild(r),r.styleSheet?r.styleSheet.cssText=n:r.appendChild(document.createTextNode(n))}}("@media (max-width: 1000px) {\n  .vuepress-plugin-demo-block__h_code {\n    display: none;\n  }\n  .vuepress-plugin-demo-block__app {\n    margin-left: auto !important;\n    margin-right: auto !important;\n  }\n}\n.vuepress-plugin-demo-block__wrapper {\n  margin-top: 10px;\n  border: 1px solid #ebebeb;\n  border-radius: 4px;\n  transition: all 0.2s;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display {\n  height: 400px;\n  display: flex;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__app {\n  width: 300px;\n  border: 1px solid #ebebeb;\n  box-shadow: 1px 1px 3px #ebebeb;\n  margin-right: 5px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code {\n  flex: 1;\n  overflow: auto;\n  height: 100%;\n}\n.vuepress-plugin-demo-block__wrapper.vuepress-plugin-demo-block__horizontal .vuepress-plugin-demo-block__display .vuepress-plugin-demo-block__h_code > pre {\n  overflow: visible;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  max-height: 400px;\n  overflow: auto;\n}\n.vuepress-plugin-demo-block__wrapper div {\n  box-sizing: border-box;\n}\n.vuepress-plugin-demo-block__wrapper:hover {\n  box-shadow: 0 0 11px rgba(33, 33, 33, 0.2);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code {\n  overflow: hidden;\n  height: 0;\n  padding: 0 !important;\n  background-color: #282c34;\n  border-radius: 0 !important;\n  transition: height 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__code pre {\n  margin: 0 !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__display {\n  padding: 20px;\n  border-bottom: 1px solid #ebebeb;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer {\n  position: relative;\n  text-align: center;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__codepen {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer.vuepress-plugin-demo-block__show-link .vuepress-plugin-demo-block__expand::before {\n  border-top: none;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid #ccc;\n  border-left: 6px solid transparent;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__codepen,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand span,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand {\n  opacity: 1;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover .vuepress-plugin-demo-block__expand::before {\n  border-top-color: #3eaf7c !important;\n  border-bottom-color: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer:hover svg {\n  fill: #3eaf7c !important;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand-text {\n  transition: all 0.5s;\n  opacity: 0;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:nth-last-child(2) {\n  right: 50px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer form:last-child {\n  right: 10px;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button {\n  border-color: transparent;\n  background-color: transparent;\n  font-size: 14px;\n  color: #3eaf7c;\n  cursor: pointer;\n  outline: none;\n  margin: 0;\n  width: 46px;\n  position: relative;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::before {\n  content: attr(data-tip);\n  white-space: nowrap;\n  position: absolute;\n  top: -30px;\n  left: 50%;\n  color: #eee;\n  line-height: 1;\n  z-index: 1000;\n  border-radius: 4px;\n  padding: 6px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  background-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button:hover::after {\n  content: '' !important;\n  display: block;\n  position: absolute;\n  left: 50%;\n  top: -5px;\n  -webkit-transform: translateX(-50%);\n          transform: translateX(-50%);\n  border: 5px solid transparent;\n  border-top-color: rgba(0, 0, 0, 0.8);\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__button svg {\n  width: 34px;\n  height: 20px;\n  fill: #ccc;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__jsfiddle,\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__codepen {\n  position: absolute;\n  top: 10px;\n  transition: all 0.5s;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand {\n  position: relative;\n  width: 100px;\n  height: 40px;\n  margin: 0;\n  color: #3eaf7c;\n  font-size: 14px;\n  background-color: transparent;\n  border-color: transparent;\n  outline: none;\n  transition: all 0.5s;\n  cursor: pointer;\n}\n.vuepress-plugin-demo-block__wrapper .vuepress-plugin-demo-block__footer .vuepress-plugin-demo-block__expand::before {\n  content: \"\";\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  width: 0;\n  height: 0;\n  border-top: 6px solid #ccc;\n  border-right: 6px solid transparent;\n  border-left: 6px solid transparent;\n  -webkit-transform: translate(-50%, -50%);\n          transform: translate(-50%, -50%);\n}\n");var Cs={jsLib:[],cssLib:[],jsfiddle:!0,codepen:!0,codepenLayout:"left",codepenJsProcessor:"babel",codepenEditors:"101",horizontal:!1,vue:"https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js",react:"https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js",reactDOM:"https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"},_s={},As=function(n){return'<div id="app">\n'.concat(n,"\n</div>")},qs=function(n){return window.$VUEPRESS_DEMO_BLOCK&&void 0!==window.$VUEPRESS_DEMO_BLOCK[n]?window.$VUEPRESS_DEMO_BLOCK[n]:Cs[n]},Ls=function n(e,t,a){var r=document.createElement(e);return t&&Object.keys(t).forEach((function(n){if(n.indexOf("data"))r[n]=t[n];else{var e=n.replace("data","");r.dataset[e]=t[n]}})),a&&a.forEach((function(e){var t=e.tag,a=e.attrs,i=e.children;r.appendChild(n(t,a,i))})),r},Ms=function(n,e,t){var a,r=(a=n.querySelectorAll(".".concat(e)),Array.prototype.slice.call(a));return 1!==r.length||t?r:r[0]},Ds=function(n,e){var t,a,r=n.match(/<style>([\s\S]+)<\/style>/),i=n.match(/<template>([\s\S]+)<\/template>/),o=n.match(/<script>([\s\S]+)<\/script>/),s={css:r&&r[1].replace(/^\n|\n$/g,""),html:i&&i[1].replace(/^\n|\n$/g,""),js:o&&o[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};s.htmlTpl=As(s.html),s.jsTpl=(t=s.js,a=t.replace(/export\s+default\s*?\{\n*/,"").replace(/\n*\}\s*$/,"").trim(),"new Vue({\n  el: '#app',\n  ".concat(a,"\n})")),s.script=function(n,e){var t=n.split(/export\s+default/),a="(function() {".concat(t[0]," ; return ").concat(t[1],"})()"),r=window.Babel?window.Babel.transform(a,{presets:["es2015"]}).code:a,i=[eval][0](r);return i.template=e,i}(s.js,s.html);var l=qs("vue");return s.jsLib.unshift(l),s},Os=function(n,e){var t,a=n.match(/<style>([\s\S]+)<\/style>/),r=n.match(/<html>([\s\S]+)<\/html>/),i=n.match(/<script>([\s\S]+)<\/script>/),o={css:a&&a[1].replace(/^\n|\n$/g,""),html:r&&r[1].replace(/^\n|\n$/g,""),js:i&&i[1].replace(/^\n|\n$/g,""),jsLib:e.jsLib||[],cssLib:e.cssLib||[]};return o.htmlTpl=o.html,o.jsTpl=o.js,o.script=(t=o.js,window.Babel?window.Babel.transform(t,{presets:["es2015"]}).code:t),o},Rs=function(n){return n=n.replace("export default ","").replace(/App\.__style__(\s*)=(\s*)`([\s\S]*)?`/,""),n+='ReactDOM.render(React.createElement(App), document.getElementById("app"))'};function Ps(){var n=Ms(document,"vuepress-plugin-demo-block__wrapper",!0);n.length?n.forEach((function(n){if("true"!==n.dataset.created){n.style.display="block";var e=Ms(n,"vuepress-plugin-demo-block__code"),t=Ms(n,"vuepress-plugin-demo-block__display"),a=Ms(n,"vuepress-plugin-demo-block__footer"),r=Ms(t,"vuepress-plugin-demo-block__app"),i=decodeURIComponent(n.dataset.code),o=decodeURIComponent(n.dataset.config),s=decodeURIComponent(n.dataset.type);o=o?JSON.parse(o):{};var l=e.querySelector("div").clientHeight,c="react"===s?function(n,e){var t=(0,window.Babel.transform)(n,{presets:["es2015","react"]}).code,a="(function(exports){var module={};module.exports=exports;".concat(t,";return module.exports.__esModule?module.exports.default:module.exports;})({})"),r=new Function("return ".concat(a))(),i={js:r,css:r.__style__||"",jsLib:e.jsLib||[],cssLib:e.cssLib||[],jsTpl:Rs(n),htmlTpl:As("")},o=qs("react"),s=qs("reactDOM");return i.jsLib.unshift(o,s),i}(i,o):"vanilla"===s?Os(i,o):Ds(i,o),p=Ls("button",{className:"".concat("vuepress-plugin-demo-block__expand")});if(a.appendChild(p),p.addEventListener("click",Bs.bind(null,p,l,e,a)),qs("jsfiddle")&&a.appendChild(function(n){var e=n.css,t=n.htmlTpl,a=n.jsTpl,r=n.jsLib,i=n.cssLib,o=r.concat(i).concat(qs("cssLib")).concat(qs("jsLib")).join(",");return Ls("form",{className:"vuepress-plugin-demo-block__jsfiddle",target:"_blank",action:"https://jsfiddle.net/api/post/library/pure/",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"css",value:e}},{tag:"input",attrs:{type:"hidden",name:"html",value:t}},{tag:"input",attrs:{type:"hidden",name:"js",value:a}},{tag:"input",attrs:{type:"hidden",name:"panel_js",value:3}},{tag:"input",attrs:{type:"hidden",name:"wrap",value:1}},{tag:"input",attrs:{type:"hidden",name:"resources",value:o}},{tag:"button",attrs:{type:"submit",className:"vuepress-plugin-demo-block__button",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088289967" class="icon" style="" viewBox="0 0 1170 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1952" xmlns:xlink="http://www.w3.org/1999/xlink" width="228.515625" height="200"><defs><style type="text/css"></style></defs><path d="M1028.571429 441.142857q63.428571 26.285714 102.571428 83.142857T1170.285714 650.857143q0 93.714286-67.428571 160.285714T940 877.714286q-2.285714 0-6.571429-0.285715t-6-0.285714H232q-97.142857-5.714286-164.571429-71.714286T0 645.142857q0-62.857143 31.428571-116t84-84q-6.857143-22.285714-6.857142-46.857143 0-65.714286 46.857142-112t113.714286-46.285714q54.285714 0 98.285714 33.142857 42.857143-88 127.142858-141.714286t186.571428-53.714285q94.857143 0 174.857143 46T982.571429 248.571429t46.571428 172q0 3.428571-0.285714 10.285714t-0.285714 10.285714zM267.428571 593.142857q0 69.714286 48 110.285714t118.857143 40.571429q78.285714 0 137.142857-56.571429-9.142857-11.428571-27.142857-32.285714T519.428571 626.285714q-38.285714 37.142857-82.285714 37.142857-31.428571 0-53.428571-19.142857T361.714286 594.285714q0-30.285714 22-49.714285t52.285714-19.428572q25.142857 0 48.285714 12t41.714286 31.428572 37.142857 42.857142 39.428572 46.857143 44 42.857143 55.428571 31.428572 69.428571 12q69.142857 0 116.857143-40.857143T936 594.857143q0-69.142857-48-109.714286t-118.285714-40.571428q-81.714286 0-137.714286 55.428571l53.142857 61.714286q37.714286-36.571429 81.142857-36.571429 29.714286 0 52.571429 18.857143t22.857143 48q0 32.571429-21.142857 52.285714t-53.714286 19.714286q-24.571429 0-47.142857-12t-41.142857-31.428571-37.428572-42.857143-39.714286-46.857143-44.285714-42.857143-55.142857-31.428571T434.285714 444.571429q-69.714286 0-118.285714 40.285714T267.428571 593.142857z" p-id="1953"></path></svg>',datatip:"JSFiddle"}}])}(c)),qs("codepen")&&a.appendChild(function(n){var e=n.css,t=n.htmlTpl,a=n.jsTpl,r=n.jsLib,i=n.cssLib,o=JSON.stringify({css:e,html:t,js:a,js_external:r.concat(qs("jsLib")).join(";"),css_external:i.concat(qs("cssLib")).join(";"),layout:qs("codepenLayout"),js_pre_processor:qs("codepenJsProcessor"),editors:qs("codepenEditors")});return Ls("form",{className:"vuepress-plugin-demo-block__codepen",target:"_blank",action:"https://codepen.io/pen/define",method:"post"},[{tag:"input",attrs:{type:"hidden",name:"data",value:o}},{tag:"button",attrs:{type:"submit",innerHTML:'<?xml version="1.0" standalone="no"?><!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd"><svg t="1547088271207" class="icon" style="" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1737" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><defs><style type="text/css"></style></defs><path d="M123.428571 668l344.571429 229.714286v-205.142857L277.142857 565.142857z m-35.428571-82.285714l110.285714-73.714286-110.285714-73.714286v147.428572z m468 312l344.571429-229.714286-153.714286-102.857143-190.857143 127.428572v205.142857z m-44-281.714286l155.428571-104-155.428571-104-155.428571 104zM277.142857 458.857143l190.857143-127.428572V126.285714L123.428571 356z m548.571429 53.142857l110.285714 73.714286V438.285714z m-78.857143-53.142857l153.714286-102.857143-344.571429-229.714286v205.142857z m277.142857-102.857143v312q0 23.428571-19.428571 36.571429l-468 312q-12 7.428571-24.571429 7.428571t-24.571429-7.428571L19.428571 704.571429q-19.428571-13.142857-19.428571-36.571429V356q0-23.428571 19.428571-36.571429L487.428571 7.428571q12-7.428571 24.571429-7.428571t24.571429 7.428571l468 312q19.428571 13.142857 19.428571 36.571429z" p-id="1738"></path></svg>',className:"vuepress-plugin-demo-block__button",datatip:"Codepen"}}])}(c)),void 0!==o.horizontal?o.horizontal:qs("horizontal")){n.classList.add("vuepress-plugin-demo-block__horizontal");var d=e.firstChild.cloneNode(!0);d.classList.add("vuepress-plugin-demo-block__h_code"),t.appendChild(d)}if(c.css&&function(n){if(!_s[n]){var e=Ls("style",{innerHTML:n});document.body.appendChild(e),_s[n]=!0}}(c.css),"react"===s)ReactDOM.render(React.createElement(c.js),r);else if("vue"===s){var u=(new(Vue.extend(c.script))).$mount();r.appendChild(u.$el)}else"vanilla"===s&&(r.innerHTML=c.html,new Function("return (function(){".concat(c.script,"})()"))());n.dataset.created="true"}})):setTimeout((function(n){Ps()}),300)}function Bs(n,e,t,a){var r="1"!==n.dataset.isExpand;t.style.height=r?"".concat(e,"px"):0,r?a.classList.add("vuepress-plugin-demo-block__show-link"):a.classList.remove("vuepress-plugin-demo-block__show-link"),n.dataset.isExpand=r?"1":"0"}var zs={mounted:function(){window.$VUEPRESS_DEMO_BLOCK={jsfiddle:!1,codepen:!0,horizontal:!1},Ps()},updated:function(){Ps()}},Ns="auto",Us="zoom-in",Fs="zoom-out",Js="grab",$s="move";function Hs(n,e,t){var a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r={passive:!1};a?n.addEventListener(e,t,r):n.removeEventListener(e,t,r)}function Gs(n,e){if(n){var t=new Image;t.onload=function(){e&&e(t)},t.src=n}}function Vs(n){return n.dataset.original?n.dataset.original:"A"===n.parentNode.tagName?n.parentNode.getAttribute("href"):null}function Ws(n,e,t){!function(n){var e=Qs,t=Xs;if(n.transition){var a=n.transition;delete n.transition,n[e]=a}if(n.transform){var r=n.transform;delete n.transform,n[t]=r}}(e);var a=n.style,r={};for(var i in e)t&&(r[i]=a[i]||""),a[i]=e[i];return r}var Qs="transition",Xs="transform",Ks="transform",Ys="transitionend";var Zs=function(){},nl={enableGrab:!0,preloadImage:!1,closeOnWindowResize:!0,transitionDuration:.4,transitionTimingFunction:"cubic-bezier(0.4, 0, 0, 1)",bgColor:"rgb(255, 255, 255)",bgOpacity:1,scaleBase:1,scaleExtra:.5,scrollThreshold:40,zIndex:998,customSize:null,onOpen:Zs,onClose:Zs,onGrab:Zs,onMove:Zs,onRelease:Zs,onBeforeOpen:Zs,onBeforeClose:Zs,onBeforeGrab:Zs,onBeforeRelease:Zs,onImageLoading:Zs,onImageLoaded:Zs},el={init:function(n){var e,t;e=this,t=n,Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach((function(n){e[n]=e[n].bind(t)}))},click:function(n){if(n.preventDefault(),al(n))return window.open(this.target.srcOriginal||n.currentTarget.src,"_blank");this.shown?this.released?this.close():this.release():this.open(n.currentTarget)},scroll:function(){var n=document.documentElement||document.body.parentNode||document.body,e=window.pageXOffset||n.scrollLeft,t=window.pageYOffset||n.scrollTop;null===this.lastScrollPosition&&(this.lastScrollPosition={x:e,y:t});var a=this.lastScrollPosition.x-e,r=this.lastScrollPosition.y-t,i=this.options.scrollThreshold;(Math.abs(r)>=i||Math.abs(a)>=i)&&(this.lastScrollPosition=null,this.close())},keydown:function(n){(function(n){return"Escape"===(n.key||n.code)||27===n.keyCode})(n)&&(this.released?this.close():this.release(this.close))},mousedown:function(n){if(tl(n)&&!al(n)){n.preventDefault();var e=n.clientX,t=n.clientY;this.pressTimer=setTimeout(function(){this.grab(e,t)}.bind(this),200)}},mousemove:function(n){this.released||this.move(n.clientX,n.clientY)},mouseup:function(n){tl(n)&&!al(n)&&(clearTimeout(this.pressTimer),this.released?this.close():this.release())},touchstart:function(n){n.preventDefault();var e=n.touches[0],t=e.clientX,a=e.clientY;this.pressTimer=setTimeout(function(){this.grab(t,a)}.bind(this),200)},touchmove:function(n){if(!this.released){var e=n.touches[0],t=e.clientX,a=e.clientY;this.move(t,a)}},touchend:function(n){(function(n){n.targetTouches.length})(n)||(clearTimeout(this.pressTimer),this.released?this.close():this.release())},clickOverlay:function(){this.close()},resizeWindow:function(){this.close()}};function tl(n){return 0===n.button}function al(n){return n.metaKey||n.ctrlKey}var rl={init:function(n){this.el=document.createElement("div"),this.instance=n,this.parent=document.body,Ws(this.el,{position:"fixed",top:0,left:0,right:0,bottom:0,opacity:0}),this.updateStyle(n.options),Hs(this.el,"click",n.handler.clickOverlay.bind(n))},updateStyle:function(n){Ws(this.el,{zIndex:n.zIndex,backgroundColor:n.bgColor,transition:"opacity\n        "+n.transitionDuration+"s\n        "+n.transitionTimingFunction})},insert:function(){this.parent.appendChild(this.el)},remove:function(){this.parent.removeChild(this.el)},fadeIn:function(){this.el.offsetWidth,this.el.style.opacity=this.instance.options.bgOpacity},fadeOut:function(){this.el.style.opacity=0}},il="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(n){return typeof n}:function(n){return n&&"function"==typeof Symbol&&n.constructor===Symbol&&n!==Symbol.prototype?"symbol":typeof n},ol=function(){function n(n,e){for(var t=0;t<e.length;t++){var a=e[t];a.enumerable=a.enumerable||!1,a.configurable=!0,"value"in a&&(a.writable=!0),Object.defineProperty(n,a.key,a)}}return function(e,t,a){return t&&n(e.prototype,t),a&&n(e,a),e}}(),sl=Object.assign||function(n){for(var e=1;e<arguments.length;e++){var t=arguments[e];for(var a in t)Object.prototype.hasOwnProperty.call(t,a)&&(n[a]=t[a])}return n},ll={init:function(n,e){this.el=n,this.instance=e,this.srcThumbnail=this.el.getAttribute("src"),this.srcset=this.el.getAttribute("srcset"),this.srcOriginal=Vs(this.el),this.rect=this.el.getBoundingClientRect(),this.translate=null,this.scale=null,this.styleOpen=null,this.styleClose=null},zoomIn:function(){var n=this.instance.options,e=n.zIndex,t=n.enableGrab,a=n.transitionDuration,r=n.transitionTimingFunction;this.translate=this.calculateTranslate(),this.scale=this.calculateScale(),this.styleOpen={position:"relative",zIndex:e+1,cursor:t?Js:Fs,transition:Ks+"\n        "+a+"s\n        "+r,transform:"translate3d("+this.translate.x+"px, "+this.translate.y+"px, 0px)\n        scale("+this.scale.x+","+this.scale.y+")",height:this.rect.height+"px",width:this.rect.width+"px"},this.el.offsetWidth,this.styleClose=Ws(this.el,this.styleOpen,!0)},zoomOut:function(){this.el.offsetWidth,Ws(this.el,{transform:"none"})},grab:function(n,e,t){var a=cl(),r=a.x-n,i=a.y-e;Ws(this.el,{cursor:$s,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},move:function(n,e,t){var a=cl(),r=a.x-n,i=a.y-e;Ws(this.el,{transition:Ks,transform:"translate3d(\n        "+(this.translate.x+r)+"px, "+(this.translate.y+i)+"px, 0px)\n        scale("+(this.scale.x+t)+","+(this.scale.y+t)+")"})},restoreCloseStyle:function(){Ws(this.el,this.styleClose)},restoreOpenStyle:function(){Ws(this.el,this.styleOpen)},upgradeSource:function(){if(this.srcOriginal){var n=this.el.parentNode;this.srcset&&this.el.removeAttribute("srcset");var e=this.el.cloneNode(!1);e.setAttribute("src",this.srcOriginal),e.style.position="fixed",e.style.visibility="hidden",n.appendChild(e),setTimeout(function(){this.el.setAttribute("src",this.srcOriginal),n.removeChild(e)}.bind(this),50)}},downgradeSource:function(){this.srcOriginal&&(this.srcset&&this.el.setAttribute("srcset",this.srcset),this.el.setAttribute("src",this.srcThumbnail))},calculateTranslate:function(){var n=cl(),e=this.rect.left+this.rect.width/2,t=this.rect.top+this.rect.height/2;return{x:n.x-e,y:n.y-t}},calculateScale:function(){var n=this.el.dataset,e=n.zoomingHeight,t=n.zoomingWidth,a=this.instance.options,r=a.customSize,i=a.scaleBase;if(!r&&e&&t)return{x:t/this.rect.width,y:e/this.rect.height};if(r&&"object"===(void 0===r?"undefined":il(r)))return{x:r.width/this.rect.width,y:r.height/this.rect.height};var o=this.rect.width/2,s=this.rect.height/2,l=cl(),c={x:l.x-o,y:l.y-s},p=c.x/o,d=c.y/s,u=i+Math.min(p,d);if(r&&"string"==typeof r){var m=t||this.el.naturalWidth,g=e||this.el.naturalHeight,b=parseFloat(r)*m/(100*this.rect.width),h=parseFloat(r)*g/(100*this.rect.height);if(u>b||u>h)return{x:b,y:h}}return{x:u,y:u}}};function cl(){var n=document.documentElement;return{x:Math.min(n.clientWidth,window.innerWidth)/2,y:Math.min(n.clientHeight,window.innerHeight)/2}}function pl(n,e,t){["mousedown","mousemove","mouseup","touchstart","touchmove","touchend"].forEach((function(a){Hs(n,a,e[a],t)}))}var dl=function(){function n(e){!function(n,e){if(!(n instanceof e))throw new TypeError("Cannot call a class as a function")}(this,n),this.target=Object.create(ll),this.overlay=Object.create(rl),this.handler=Object.create(el),this.body=document.body,this.shown=!1,this.lock=!1,this.released=!0,this.lastScrollPosition=null,this.pressTimer=null,this.options=sl({},nl,e),this.overlay.init(this),this.handler.init(this)}return ol(n,[{key:"listen",value:function(n){if("string"==typeof n)for(var e=document.querySelectorAll(n),t=e.length;t--;)this.listen(e[t]);else"IMG"===n.tagName&&(n.style.cursor=Us,Hs(n,"click",this.handler.click),this.options.preloadImage&&Gs(Vs(n)));return this}},{key:"config",value:function(n){return n?(sl(this.options,n),this.overlay.updateStyle(this.options),this):this.options}},{key:"open",value:function(n){var e=this,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.options.onOpen;if(!this.shown&&!this.lock){var a="string"==typeof n?document.querySelector(n):n;if("IMG"===a.tagName){if(this.options.onBeforeOpen(a),this.target.init(a,this),!this.options.preloadImage){var r=this.target.srcOriginal;null!=r&&(this.options.onImageLoading(a),Gs(r,this.options.onImageLoaded))}this.shown=!0,this.lock=!0,this.target.zoomIn(),this.overlay.insert(),this.overlay.fadeIn(),Hs(document,"scroll",this.handler.scroll),Hs(document,"keydown",this.handler.keydown),this.options.closeOnWindowResize&&Hs(window,"resize",this.handler.resizeWindow);var i=function n(){Hs(a,Ys,n,!1),e.lock=!1,e.target.upgradeSource(),e.options.enableGrab&&pl(document,e.handler,!0),t(a)};return Hs(a,Ys,i),this}}}},{key:"close",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onClose;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeClose(t),this.lock=!0,this.body.style.cursor=Ns,this.overlay.fadeOut(),this.target.zoomOut(),Hs(document,"scroll",this.handler.scroll,!1),Hs(document,"keydown",this.handler.keydown,!1),this.options.closeOnWindowResize&&Hs(window,"resize",this.handler.resizeWindow,!1);var a=function a(){Hs(t,Ys,a,!1),n.shown=!1,n.lock=!1,n.target.downgradeSource(),n.options.enableGrab&&pl(document,n.handler,!1),n.target.restoreCloseStyle(),n.overlay.remove(),e(t)};return Hs(t,Ys,a),this}}},{key:"grab",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onGrab;if(this.shown&&!this.lock){var r=this.target.el;this.options.onBeforeGrab(r),this.released=!1,this.target.grab(n,e,t);var i=function n(){Hs(r,Ys,n,!1),a(r)};return Hs(r,Ys,i),this}}},{key:"move",value:function(n,e){var t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:this.options.scaleExtra,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:this.options.onMove;if(this.shown&&!this.lock){this.released=!1,this.body.style.cursor=$s,this.target.move(n,e,t);var r=this.target.el,i=function n(){Hs(r,Ys,n,!1),a(r)};return Hs(r,Ys,i),this}}},{key:"release",value:function(){var n=this,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.options.onRelease;if(this.shown&&!this.lock){var t=this.target.el;this.options.onBeforeRelease(t),this.lock=!0,this.body.style.cursor=Ns,this.target.restoreOpenStyle();var a=function a(){Hs(t,Ys,a,!1),n.lock=!1,n.released=!0,e(t)};return Hs(t,Ys,a),this}}}]),n}();const ul=JSON.parse('{"bgColor":"rgba(0,0,0,0.6)"}'),ml=Number("500");class gl{constructor(){this.instance=new dl(ul)}update(n=".theme-vdoing-content img:not(.no-zoom)"){"undefined"!=typeof window&&this.instance.listen(n)}updateDelay(n=".theme-vdoing-content img:not(.no-zoom)",e=ml){setTimeout(()=>this.update(n),e)}}var bl=[hs,Ss,Ts,Is,zs,{watch:{"$page.path"(){void 0!==this.$vuepress.zooming&&this.$vuepress.zooming.updateDelay()}},mounted(){this.$vuepress.zooming=new gl,this.$vuepress.zooming.updateDelay()}}],hl={name:"GlobalLayout",computed:{layout(){const n=this.getLayout();return ds("layout",n),Gt.component(n)}},methods:{getLayout(){if(this.$page.path){const n=this.$page.frontmatter.layout;return n&&(this.$vuepress.getLayoutAsyncComponent(n)||this.$vuepress.getVueComponent(n))?n:"Layout"}return"NotFound"}}},vl=t(4),fl=Object(vl.a)(hl,(function(){return(0,this._self._c)(this.layout,{tag:"component"})}),[],!1,null,null,null).exports;!function(n,e,t){switch(e){case"components":n[e]||(n[e]={}),Object.assign(n[e],t);break;case"mixins":n[e]||(n[e]=[]),n[e].push(...t);break;default:throw new Error("Unknown option name.")}}(fl,"mixins",bl);const yl=[{name:"v-d4591194",path:"/backend/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-d4591194").then(t)}},{path:"/backend/index.html",redirect:"/backend/"},{path:"/00.目录页/01.后端.html",redirect:"/backend/"},{name:"v-0ab12568",path:"/web/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-0ab12568").then(t)}},{path:"/web/index.html",redirect:"/web/"},{path:"/00.目录页/02.前端.html",redirect:"/web/"},{name:"v-397f32ac",path:"/backend/ac1298/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-397f32ac").then(t)}},{path:"/backend/ac1298/index.html",redirect:"/backend/ac1298/"},{path:"/01.后端/01.Java基础/01.认知.html",redirect:"/backend/ac1298/"},{name:"v-c88be50c",path:"/other/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-c88be50c").then(t)}},{path:"/other/index.html",redirect:"/other/"},{path:"/00.目录页/03.更多.html",redirect:"/other/"},{name:"v-b5521cb0",path:"/backend/pe1123/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-b5521cb0").then(t)}},{path:"/backend/pe1123/index.html",redirect:"/backend/pe1123/"},{path:"/01.后端/01.Java基础/02.类和对象.html",redirect:"/backend/pe1123/"},{name:"v-36016ffa",path:"/backend/m0die6/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-36016ffa").then(t)}},{path:"/backend/m0die6/index.html",redirect:"/backend/m0die6/"},{path:"/01.后端/01.Java基础/03.API.html",redirect:"/backend/m0die6/"},{name:"v-1232d768",path:"/backend/39ibdm/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-1232d768").then(t)}},{path:"/backend/39ibdm/index.html",redirect:"/backend/39ibdm/"},{path:"/01.后端/01.Java基础/04.三大特性.html",redirect:"/backend/39ibdm/"},{name:"v-f3615e36",path:"/backend/9sun1b/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-f3615e36").then(t)}},{path:"/backend/9sun1b/index.html",redirect:"/backend/9sun1b/"},{path:"/01.后端/01.Java基础/05.类的高级特性.html",redirect:"/backend/9sun1b/"},{name:"v-48faa1d3",path:"/backend/x25lyh/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-48faa1d3").then(t)}},{path:"/backend/x25lyh/index.html",redirect:"/backend/x25lyh/"},{path:"/01.后端/01.Java基础/08.集合类.html",redirect:"/backend/x25lyh/"},{name:"v-65c36e4f",path:"/backend/b5ikzm/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-65c36e4f").then(t)}},{path:"/backend/b5ikzm/index.html",redirect:"/backend/b5ikzm/"},{path:"/01.后端/01.Java基础/06.异常.html",redirect:"/backend/b5ikzm/"},{name:"v-004efb11",path:"/backend/dampib/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-004efb11").then(t)}},{path:"/backend/dampib/index.html",redirect:"/backend/dampib/"},{path:"/01.后端/01.Java基础/09.IO流.html",redirect:"/backend/dampib/"},{name:"v-1fde75d5",path:"/backend/r3608t/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-1fde75d5").then(t)}},{path:"/backend/r3608t/index.html",redirect:"/backend/r3608t/"},{path:"/01.后端/01.Java基础/11.枚举.html",redirect:"/backend/r3608t/"},{name:"v-22ffbd7d",path:"/backend/g25p48/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-22ffbd7d").then(t)}},{path:"/backend/g25p48/index.html",redirect:"/backend/g25p48/"},{path:"/01.后端/01.Java基础/07.Swing 程序设计.html",redirect:"/backend/g25p48/"},{name:"v-e9056132",path:"/backend/y0rkxc/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-e9056132").then(t)}},{path:"/backend/y0rkxc/index.html",redirect:"/backend/y0rkxc/"},{path:"/01.后端/01.Java基础/10.反射.html",redirect:"/backend/y0rkxc/"},{name:"v-2adb23eb",path:"/backend/v3dlns/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-2adb23eb").then(t)}},{path:"/backend/v3dlns/index.html",redirect:"/backend/v3dlns/"},{path:"/01.后端/01.Java基础/12.泛型.html",redirect:"/backend/v3dlns/"},{name:"v-8c5f91b2",path:"/backend/pwb68r/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-8c5f91b2").then(t)}},{path:"/backend/pwb68r/index.html",redirect:"/backend/pwb68r/"},{path:"/01.后端/01.Java基础/14.网络通信.html",redirect:"/backend/pwb68r/"},{name:"v-031c20de",path:"/backend/zvajuy/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-031c20de").then(t)}},{path:"/backend/zvajuy/index.html",redirect:"/backend/zvajuy/"},{path:"/01.后端/01.Java基础/13.线程.html",redirect:"/backend/zvajuy/"},{name:"v-3ead9483",path:"/backend/tfnnik/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-3ead9483").then(t)}},{path:"/backend/tfnnik/index.html",redirect:"/backend/tfnnik/"},{path:"/01.后端/01.Java基础/15.监听事件.html",redirect:"/backend/tfnnik/"},{name:"v-fb49d4e2",path:"/backend/34q8xb/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-fb49d4e2").then(t)}},{path:"/backend/34q8xb/index.html",redirect:"/backend/34q8xb/"},{path:"/01.后端/01.Java基础/16.AWT绘图.html",redirect:"/backend/34q8xb/"},{name:"v-0e5d2811",path:"/backend/1s9khm/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-0e5d2811").then(t)}},{path:"/backend/1s9khm/index.html",redirect:"/backend/1s9khm/"},{path:"/01.后端/01.Java基础/17.URL说明.html",redirect:"/backend/1s9khm/"},{name:"v-10261aa3",path:"/backend/zyaf2n/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-10261aa3").then(t)}},{path:"/backend/zyaf2n/index.html",redirect:"/backend/zyaf2n/"},{path:"/01.后端/01.Java基础/20.注解.html",redirect:"/backend/zyaf2n/"},{name:"v-6f9743c0",path:"/backend/lipl8p/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-6f9743c0").then(t)}},{path:"/backend/lipl8p/index.html",redirect:"/backend/lipl8p/"},{path:"/01.后端/01.Java基础/19.MXL&JSON.html",redirect:"/backend/lipl8p/"},{name:"v-5169e0e4",path:"/backend/0y9sdx/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-5169e0e4").then(t)}},{path:"/backend/0y9sdx/index.html",redirect:"/backend/0y9sdx/"},{path:"/01.后端/02.JavaWeb/01.Tomcat应用.html",redirect:"/backend/0y9sdx/"},{name:"v-cd1cf0e8",path:"/backend/nkcjdp/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-cd1cf0e8").then(t)}},{path:"/backend/nkcjdp/index.html",redirect:"/backend/nkcjdp/"},{path:"/01.后端/02.JavaWeb/03.JSP.html",redirect:"/backend/nkcjdp/"},{name:"v-b93f4c84",path:"/backend/qls54u/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-b93f4c84").then(t)}},{path:"/backend/qls54u/index.html",redirect:"/backend/qls54u/"},{path:"/01.后端/02.JavaWeb/02.servlet应用.html",redirect:"/backend/qls54u/"},{name:"v-e6903300",path:"/backend/0nybdh/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-e6903300").then(t)}},{path:"/backend/0nybdh/index.html",redirect:"/backend/0nybdh/"},{path:"/01.后端/02.JavaWeb/04.Filter过滤监听器.html",redirect:"/backend/0nybdh/"},{name:"v-3fdb40e9",path:"/backend/tlfhkk/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-3fdb40e9").then(t)}},{path:"/backend/tlfhkk/index.html",redirect:"/backend/tlfhkk/"},{path:"/01.后端/02.JavaWeb/05.Session&Cookie会话跟踪.html",redirect:"/backend/tlfhkk/"},{name:"v-f872bd68",path:"/backend/aud35w/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-f872bd68").then(t)}},{path:"/backend/aud35w/index.html",redirect:"/backend/aud35w/"},{path:"/01.后端/02.JavaWeb/06.MVC.html",redirect:"/backend/aud35w/"},{name:"v-3f258632",path:"/backend/d4tcq2/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-3f258632").then(t)}},{path:"/backend/d4tcq2/index.html",redirect:"/backend/d4tcq2/"},{path:"/01.后端/02.JavaWeb/08.JSON操作.html",redirect:"/backend/d4tcq2/"},{name:"v-302a0722",path:"/backend/s9wrzy/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-302a0722").then(t)}},{path:"/backend/s9wrzy/index.html",redirect:"/backend/s9wrzy/"},{path:"/01.后端/02.JavaWeb/07.AJAX应用.html",redirect:"/backend/s9wrzy/"},{name:"v-3f4e8dea",path:"/backend/r5xd4s/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-3f4e8dea").then(t)}},{path:"/backend/r5xd4s/index.html",redirect:"/backend/r5xd4s/"},{path:"/01.后端/02.JavaWeb/09.文件上传下载.html",redirect:"/backend/r5xd4s/"},{name:"v-62776f4a",path:"/backend/c69655/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-62776f4a").then(t)}},{path:"/backend/c69655/index.html",redirect:"/backend/c69655/"},{path:"/01.后端/03.Java拓展/03.Stream流操作.html",redirect:"/backend/c69655/"},{name:"v-6e838041",path:"/backend/d69655/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-6e838041").then(t)}},{path:"/backend/d69655/index.html",redirect:"/backend/d69655/"},{path:"/01.后端/03.Java拓展/02. Properties 序列化与反序列化.html",redirect:"/backend/d69655/"},{name:"v-4bc1b449",path:"/backend/a69655/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-4bc1b449").then(t)}},{path:"/backend/a69655/index.html",redirect:"/backend/a69655/"},{path:"/01.后端/03.Java拓展/05.zip解压缩.html",redirect:"/backend/a69655/"},{name:"v-4de788f0",path:"/backend/b69655/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-4de788f0").then(t)}},{path:"/backend/b69655/index.html",redirect:"/backend/b69655/"},{path:"/01.后端/03.Java拓展/04.Lombok简化开发.html",redirect:"/backend/b69655/"},{name:"v-256a7c79",path:"/backend/60chrc/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-256a7c79").then(t)}},{path:"/backend/60chrc/index.html",redirect:"/backend/60chrc/"},{path:"/01.后端/04.框架技术/01.Maven.html",redirect:"/backend/60chrc/"},{name:"v-056e9e9e",path:"/backend/ea9655/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-056e9e9e").then(t)}},{path:"/backend/ea9655/index.html",redirect:"/backend/ea9655/"},{path:"/01.后端/03.Java拓展/01.Java 设计模式.html",redirect:"/backend/ea9655/"},{name:"v-21b1d4ee",path:"/backend/afbo81/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-21b1d4ee").then(t)}},{path:"/backend/afbo81/index.html",redirect:"/backend/afbo81/"},{path:"/01.后端/04.框架技术/05.Apache Dubbo.html",redirect:"/backend/afbo81/"},{name:"v-b074d626",path:"/backend/60chrp/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-b074d626").then(t)}},{path:"/backend/60chrp/index.html",redirect:"/backend/60chrp/"},{path:"/01.后端/04.框架技术/02.Activiti工作流.html",redirect:"/backend/60chrp/"},{name:"v-439f0503",path:"/backend/40kn38/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-439f0503").then(t)}},{path:"/backend/40kn38/index.html",redirect:"/backend/40kn38/"},{path:"/01.后端/04.框架技术/03.Shiro安全框架.html",redirect:"/backend/40kn38/"},{name:"v-1f123e21",path:"/backend/621sa1/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-1f123e21").then(t)}},{path:"/backend/621sa1/index.html",redirect:"/backend/621sa1/"},{path:"/01.后端/05.数据库/01.MySQL.html",redirect:"/backend/621sa1/"},{name:"v-27ebad24",path:"/backend/40kn39/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-27ebad24").then(t)}},{path:"/backend/40kn39/index.html",redirect:"/backend/40kn39/"},{path:"/01.后端/04.框架技术/04.SpringBoot .html",redirect:"/backend/40kn39/"},{name:"v-266c61ea",path:"/backend/afbo8k/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-266c61ea").then(t)}},{path:"/backend/afbo8k/index.html",redirect:"/backend/afbo8k/"},{path:"/01.后端/04.框架技术/06.RabbitMQ.html",redirect:"/backend/afbo8k/"},{name:"v-5156a597",path:"/backend/0ygxqu/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-5156a597").then(t)}},{path:"/backend/0ygxqu/index.html",redirect:"/backend/0ygxqu/"},{path:"/01.后端/05.数据库/02.JDBC.html",redirect:"/backend/0ygxqu/"},{name:"v-450e1b5c",path:"/backend/iis6im/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-450e1b5c").then(t)}},{path:"/backend/iis6im/index.html",redirect:"/backend/iis6im/"},{path:"/01.后端/06.数据结构/01.队列.html",redirect:"/backend/iis6im/"},{name:"v-59358ae3",path:"/backend/7g3bqt/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-59358ae3").then(t)}},{path:"/backend/7g3bqt/index.html",redirect:"/backend/7g3bqt/"},{path:"/01.后端/06.数据结构/02.二叉树.html",redirect:"/backend/7g3bqt/"},{name:"v-69a39f61",path:"/backend/k5hxej/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-69a39f61").then(t)}},{path:"/backend/k5hxej/index.html",redirect:"/backend/k5hxej/"},{path:"/01.后端/05.数据库/03.Hibernate.html",redirect:"/backend/k5hxej/"},{name:"v-5a6df113",path:"/backend/k43waq/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-5a6df113").then(t)}},{path:"/backend/k43waq/index.html",redirect:"/backend/k43waq/"},{path:"/01.后端/06.数据结构/04.链表.html",redirect:"/backend/k43waq/"},{name:"v-8c5b9946",path:"/backend/2zy34y/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-8c5b9946").then(t)}},{path:"/backend/2zy34y/index.html",redirect:"/backend/2zy34y/"},{path:"/01.后端/06.数据结构/03.栈.html",redirect:"/backend/2zy34y/"},{name:"v-e9724afe",path:"/backend/ldn760/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-e9724afe").then(t)}},{path:"/backend/ldn760/index.html",redirect:"/backend/ldn760/"},{path:"/01.后端/05.数据库/05.Redis.html",redirect:"/backend/ldn760/"},{name:"v-71eb58e1",path:"/backend/zi2hq0/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-71eb58e1").then(t)}},{path:"/backend/zi2hq0/index.html",redirect:"/backend/zi2hq0/"},{path:"/01.后端/05.数据库/04.MyBatis.html",redirect:"/backend/zi2hq0/"},{name:"v-2e058210",path:"/backend/x1cutb/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-2e058210").then(t)}},{path:"/backend/x1cutb/index.html",redirect:"/backend/x1cutb/"},{path:"/01.后端/07.Spring/02.Spring核心Loc.html",redirect:"/backend/x1cutb/"},{name:"v-34330dd8",path:"/backend/x1cutd/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-34330dd8").then(t)}},{path:"/backend/x1cutd/index.html",redirect:"/backend/x1cutd/"},{path:"/01.后端/07.Spring/04.Spring拓展.html",redirect:"/backend/x1cutd/"},{name:"v-261bed0c",path:"/backend/6nom7s/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-261bed0c").then(t)}},{path:"/backend/6nom7s/index.html",redirect:"/backend/6nom7s/"},{path:"/01.后端/08.SpringMVC/02.访问静态资源.html",redirect:"/backend/6nom7s/"},{name:"v-070e9099",path:"/backend/x1cuta/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-070e9099").then(t)}},{path:"/backend/x1cuta/index.html",redirect:"/backend/x1cuta/"},{path:"/01.后端/07.Spring/01.Spring概述.html",redirect:"/backend/x1cuta/"},{name:"v-790e32d0",path:"/backend/8pqmjz/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-790e32d0").then(t)}},{path:"/backend/8pqmjz/index.html",redirect:"/backend/8pqmjz/"},{path:"/01.后端/08.SpringMVC/04.重定向和转发.html",redirect:"/backend/8pqmjz/"},{name:"v-c84beac8",path:"/backend/t373xy/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-c84beac8").then(t)}},{path:"/backend/t373xy/index.html",redirect:"/backend/t373xy/"},{path:"/01.后端/08.SpringMVC/01.认知应用.html",redirect:"/backend/t373xy/"},{name:"v-613d8bec",path:"/backend/x1cutc/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-613d8bec").then(t)}},{path:"/backend/x1cutc/index.html",redirect:"/backend/x1cutc/"},{path:"/01.后端/07.Spring/03.Spring核心AOP.html",redirect:"/backend/x1cutc/"},{name:"v-e882b48e",path:"/backend/k8ocwe/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-e882b48e").then(t)}},{path:"/backend/k8ocwe/index.html",redirect:"/backend/k8ocwe/"},{path:"/01.后端/08.SpringMVC/06.拦截器.html",redirect:"/backend/k8ocwe/"},{name:"v-2693326f",path:"/backend/pahdv0/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-2693326f").then(t)}},{path:"/backend/pahdv0/index.html",redirect:"/backend/pahdv0/"},{path:"/01.后端/08.SpringMVC/03.传递参数.html",redirect:"/backend/pahdv0/"},{name:"v-4f61d496",path:"/backend/2sohbn/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-4f61d496").then(t)}},{path:"/backend/2sohbn/index.html",redirect:"/backend/2sohbn/"},{path:"/01.后端/08.SpringMVC/05.异常.html",redirect:"/backend/2sohbn/"},{name:"v-02f39703",path:"/backend/i3cqqj/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-02f39703").then(t)}},{path:"/backend/i3cqqj/index.html",redirect:"/backend/i3cqqj/"},{path:"/01.后端/08.SpringMVC/07.上传下载.html",redirect:"/backend/i3cqqj/"},{name:"v-5854de66",path:"/backend/ggmgk1/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-5854de66").then(t)}},{path:"/backend/ggmgk1/index.html",redirect:"/backend/ggmgk1/"},{path:"/01.后端/08.SpringMVC/08.RESTful风格.html",redirect:"/backend/ggmgk1/"},{name:"v-16d518b6",path:"/backend/s4wg1j/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-16d518b6").then(t)}},{path:"/backend/s4wg1j/index.html",redirect:"/backend/s4wg1j/"},{path:"/01.后端/09.SpringClound/03.Ribbon负载均衡.html",redirect:"/backend/s4wg1j/"},{name:"v-28e963c8",path:"/backend/ibtuuq/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-28e963c8").then(t)}},{path:"/backend/ibtuuq/index.html",redirect:"/backend/ibtuuq/"},{path:"/01.后端/09.SpringClound/01.概念.html",redirect:"/backend/ibtuuq/"},{name:"v-57f0b14b",path:"/backend/wx8zdz/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-57f0b14b").then(t)}},{path:"/backend/wx8zdz/index.html",redirect:"/backend/wx8zdz/"},{path:"/01.后端/09.SpringClound/02.Eureka服务注册中心.html",redirect:"/backend/wx8zdz/"},{name:"v-1a1104fd",path:"/backend/ask5pn/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-1a1104fd").then(t)}},{path:"/backend/ask5pn/index.html",redirect:"/backend/ask5pn/"},{path:"/01.后端/09.SpringClound/04.Hystrix熔断器.html",redirect:"/backend/ask5pn/"},{name:"v-1b4d203a",path:"/backend/kej3du/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-1b4d203a").then(t)}},{path:"/backend/kej3du/index.html",redirect:"/backend/kej3du/"},{path:"/01.后端/09.SpringClound/05.Feign.html",redirect:"/backend/kej3du/"},{name:"v-020f8ced",path:"/backend/4iocm4/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-020f8ced").then(t)}},{path:"/backend/4iocm4/index.html",redirect:"/backend/4iocm4/"},{path:"/01.后端/09.SpringClound/07.Config配置中心.html",redirect:"/backend/4iocm4/"},{name:"v-75e3f174",path:"/backend/y2b432/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-75e3f174").then(t)}},{path:"/backend/y2b432/index.html",redirect:"/backend/y2b432/"},{path:"/01.后端/09.SpringClound/06.Gateway网关.html",redirect:"/backend/y2b432/"},{name:"v-123114c4",path:"/backend/6nss7s/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-123114c4").then(t)}},{path:"/backend/6nss7s/index.html",redirect:"/backend/6nss7s/"},{path:"/01.后端/10.Netty网络编程/01概述.html",redirect:"/backend/6nss7s/"},{name:"v-01efe0dc",path:"/backend/0qlndf/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-01efe0dc").then(t)}},{path:"/backend/0qlndf/index.html",redirect:"/backend/0qlndf/"},{path:"/01.后端/09.SpringClound/08.Bus服务总线.html",redirect:"/backend/0qlndf/"},{name:"v-986ca544",path:"/web/1hg7aa/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-986ca544").then(t)}},{path:"/web/1hg7aa/index.html",redirect:"/web/1hg7aa/"},{path:"/02.前端/01.前端必备/01.HTML.html",redirect:"/web/1hg7aa/"},{name:"v-28c6e85e",path:"/web/1hg7aw/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-28c6e85e").then(t)}},{path:"/web/1hg7aw/index.html",redirect:"/web/1hg7aw/"},{path:"/02.前端/01.前端必备/03.JavaScript.html",redirect:"/web/1hg7aw/"},{name:"v-9077d038",path:"/web/1hg7cw/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-9077d038").then(t)}},{path:"/web/1hg7cw/index.html",redirect:"/web/1hg7cw/"},{path:"/02.前端/01.前端必备/02.CSS.html",redirect:"/web/1hg7cw/"},{name:"v-fa7faa54",path:"/web/1hg7cd/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-fa7faa54").then(t)}},{path:"/web/1hg7cd/index.html",redirect:"/web/1hg7cd/"},{path:"/02.前端/01.前端必备/04.ES6.html",redirect:"/web/1hg7cd/"},{name:"v-6d0cc81e",path:"/web/1hg7wc/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-6d0cc81e").then(t)}},{path:"/web/1hg7wc/index.html",redirect:"/web/1hg7wc/"},{path:"/02.前端/02.技术拓展/03.TypeScript.html",redirect:"/web/1hg7wc/"},{name:"v-7b6e642c",path:"/web/1hg7sg/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-7b6e642c").then(t)}},{path:"/web/1hg7sg/index.html",redirect:"/web/1hg7sg/"},{path:"/02.前端/01.前端必备/05.Git应用.html",redirect:"/web/1hg7sg/"},{name:"v-13f835b1",path:"/web/1hg7wv/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-13f835b1").then(t)}},{path:"/web/1hg7wv/index.html",redirect:"/web/1hg7wv/"},{path:"/02.前端/02.技术拓展/02.JQuery.html",redirect:"/web/1hg7wv/"},{name:"v-2a180b97",path:"/web/1hg7wd/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-2a180b97").then(t)}},{path:"/web/1hg7wd/index.html",redirect:"/web/1hg7wd/"},{path:"/02.前端/02.技术拓展/04.Nginx.html",redirect:"/web/1hg7wd/"},{name:"v-6af45ef5",path:"/web/1hg7wa/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-6af45ef5").then(t)}},{path:"/web/1hg7wa/index.html",redirect:"/web/1hg7wa/"},{path:"/02.前端/02.技术拓展/01.Bootstrap.html",redirect:"/web/1hg7wa/"},{name:"v-a68a0746",path:"/blog/2scac/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-a68a0746").then(t)}},{path:"/blog/2scac/index.html",redirect:"/blog/2scac/"},{path:"/03.更多/01.博客相关/02.Vdoing主题.html",redirect:"/blog/2scac/"},{name:"v-d177183e",path:"/web/1hg7wq/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-d177183e").then(t)}},{path:"/web/1hg7wq/index.html",redirect:"/web/1hg7wq/"},{path:"/02.前端/03.前端技巧/02.vue技巧功能.html",redirect:"/web/1hg7wq/"},{name:"v-462a5c98",path:"/blog/1hg722/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-462a5c98").then(t)}},{path:"/blog/1hg722/index.html",redirect:"/blog/1hg722/"},{path:"/03.更多/01.博客相关/01.Vdoing主题搭建.html",redirect:"/blog/1hg722/"},{name:"v-5b6cb686",path:"/other/183ssax/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-5b6cb686").then(t)}},{path:"/other/183ssax/index.html",redirect:"/other/183ssax/"},{path:"/03.更多/02.Linux/01.Linux常用手册.html",redirect:"/other/183ssax/"},{name:"v-0ecba8f6",path:"/web/1hg7ww/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-0ecba8f6").then(t)}},{path:"/web/1hg7ww/index.html",redirect:"/web/1hg7ww/"},{path:"/02.前端/03.前端技巧/01.JavaScript进阶技巧.html",redirect:"/web/1hg7ww/"},{name:"v-4b0d10ec",path:"/blog/2ccess/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-4b0d10ec").then(t)}},{path:"/blog/2ccess/index.html",redirect:"/blog/2ccess/"},{path:"/03.更多/01.博客相关/03.Markdown语法拓展.html",redirect:"/blog/2ccess/"},{name:"v-7e82dfbf",path:"/other/122ssa/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-7e82dfbf").then(t)}},{path:"/other/122ssa/index.html",redirect:"/other/122ssa/"},{path:"/03.更多/02.Linux/02.Linux文件管理.html",redirect:"/other/122ssa/"},{name:"v-9a683472",path:"/other/cbba2/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-9a683472").then(t)}},{path:"/other/cbba2/index.html",redirect:"/other/cbba2/"},{path:"/03.更多/02.Linux/03.Linux框架搭建.html",redirect:"/other/cbba2/"},{name:"v-93907e36",path:"/backend/1hg7cc/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-93907e36").then(t)}},{path:"/backend/1hg7cc/index.html",redirect:"/backend/1hg7cc/"},{path:"/03.更多/99.零碎/01.Docker.html",redirect:"/backend/1hg7cc/"},{name:"v-e909945c",path:"/about/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-e909945c").then(t)}},{path:"/about/index.html",redirect:"/about/"},{path:"/04.关于/01.关于.html",redirect:"/about/"},{name:"v-44ee75b0",path:"/tags/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-44ee75b0").then(t)}},{path:"/tags/index.html",redirect:"/tags/"},{path:"/@pages/tagsPage.html",redirect:"/tags/"},{name:"v-12033e88",path:"/categories/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-12033e88").then(t)}},{path:"/categories/index.html",redirect:"/categories/"},{path:"/@pages/categoriesPage.html",redirect:"/categories/"},{name:"v-2c6a8ca8",path:"/archives/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-2c6a8ca8").then(t)}},{path:"/archives/index.html",redirect:"/archives/"},{path:"/@pages/archivesPage.html",redirect:"/archives/"},{name:"v-41736a06",path:"/friendLink/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-41736a06").then(t)}},{path:"/friendLink/index.html",redirect:"/friendLink/"},{path:"/99.友链.html",redirect:"/friendLink/"},{name:"v-4768fc14",path:"/",component:fl,beforeEnter:(n,e,t)=>{ps("Layout","v-4768fc14").then(t)}},{path:"/index.html",redirect:"/"},{path:"*",component:fl}],xl={title:"",description:"",base:"/",headTags:[["link",{rel:"icon",href:"https://image.bozhu12.cc/myblog/Essay/favicon.ico"}],["meta",{name:"Sasncan12",content:"柏竹博客, 个人技术博客, 前后端端 , 技术文档"}],["meta",{name:"baidu-site-verification",content:"7F55weZDDc"}],["meta",{name:"theme-color",content:"#bd93f9"}],["script",{language:"javascript",type:"text/javascript",src:"/js/pgmanor-self.js"}]],pages:[{title:"后端",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"01.后端",imgUrl:"https://image.bozhu12.cc/myblog/Essay/backend.png",description:"后端笔记记录"}},title:"后端",date:"2022-03-11T00:00:00.000Z",permalink:"/backend/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"Sanscan12",link:"https://github.com/Sanscan12"}},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/01.%E5%90%8E%E7%AB%AF.html",relativePath:"00.目录页/01.后端.md",key:"v-d4591194",path:"/backend/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"前端",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"02.前端",imgUrl:"https://image.bozhu12.cc/myblog/Essay/web.png",description:"前端笔记记录"}},title:"前端",date:"2022-03-11T00:00:00.000Z",permalink:"/web/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"Sanscan12",link:"https://github.com/Sanscan12"}},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/02.%E5%89%8D%E7%AB%AF.html",relativePath:"00.目录页/02.前端.md",key:"v-0ab12568",path:"/web/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Java认识",frontmatter:{title:"Java认识",date:"2020-02-18T00:00:00.000Z",permalink:"/backend/ac1298",categories:["后端","Java基础"],tags:["Java"],author:"柏竹"},regularPath:"/01.%E5%90%8E%E7%AB%AF/01.Java%E5%9F%BA%E7%A1%80/01.%E8%AE%A4%E7%9F%A5.html",relativePath:"01.后端/01.Java基础/01.认知.md",key:"v-397f32ac",path:"/backend/ac1298/",headers:[{level:2,title:"Java 发展史",slug:"java-发展史",normalizedTitle:"java 发展史",charIndex:13},{level:2,title:"Java 体系",slug:"java-体系",normalizedTitle:"java 体系",charIndex:1446},{level:2,title:"Java 特性",slug:"java-特性",normalizedTitle:"java 特性",charIndex:1659},{level:2,title:"Java跨平台原理",slug:"java跨平台原理",normalizedTitle:"java跨平台原理",charIndex:1779},{level:2,title:"JVM 与 GC",slug:"jvm-与-gc",normalizedTitle:"jvm 与 gc",charIndex:1793},{level:3,title:"JVM Java虚拟机",slug:"jvm-java虚拟机",normalizedTitle:"jvm java虚拟机",charIndex:1806},{level:3,title:"GC 垃圾回收器",slug:"gc-垃圾回收器",normalizedTitle:"gc 垃圾回收器",charIndex:1942},{level:2,title:"JDK 与 JRE",slug:"jdk-与-jre",normalizedTitle:"jdk 与 jre",charIndex:2167},{level:2,title:"环境变量",slug:"环境变量",normalizedTitle:"环境变量",charIndex:2689}],headersStr:"Java 发展史 Java 体系 Java 特性 Java跨平台原理 JVM 与 GC JVM Java虚拟机 GC 垃圾回收器 JDK 与 JRE 环境变量",content:"# Java认识\n\n\n# Java 发展史\n\n * 1991年 诞生了Java前世语言 “OaK”\n * 1995年 由Oak语言 更至为 “Java”\n * 1996.1 SUN公司推出 JDK1.0 开发工具&运行环境（标志成为独立开发工具）\n   * JDK1.0：核心API、集成API、用户界面API、发布技术、Java虚拟机(JVM)、Applet、AWT\n * 1997.2 SUN公司紧接推出 JDK1.1\n   * JDBC、JavaBeans、RMI、JAR文件格式、Java内部类&反射\n * 1998.12 推出JDK1.2-企业版J2EE发布\n   * JDK1.2：Swing、Java IDL、EJB、Java Plug-in 等，添加了 strictfp 关键字和 Collections 集合类\n * 1999.4 SUN公司 收购 HotSpot公司发布的虚拟机\n * 1999.6 SUN公司把Java体系划分方向&不同的供应商API接口（最主要的里程碑）\n   * J2ME（微型版），应用于移动、无线及有限资源的环境\n   * J2SE（标准版），应用于桌面环境\n   * J2EE（企业版），应用于基于 Java 的应用服务器\n   * Java Core API：Java 核心类库\n   * Java Optional API：对之前 API 的扩充\n   * 特殊 API：由特殊厂商或组织提供的 API\n * 2000.5 JDK1.3、JDK1.4、J2SE1.3 发布\n   * JavaSE1.3：数据库、WEB、网络、图形、多媒体、电话、影像等信息技术领域\n * 2002.2 J2SE1.4发布，接口和类多了60%+\n   * J2SE1.4：XML支持、安全套接字（Socket）支持（通过 SSL 与 TLS 协议）、全新的 I/OAPI、 正则表达式、日志与断言\n * 2004.9 J2SE1.5发布，J2SE1.5 更名至 Java SE5.0（内部版本1.5.0）\n   * Java SE 5.0(J2SE1.5)：泛型支持、基本类型的自动装箱、改进的循环、枚举类型、格式化 I/O 及可变参数\n * 2005.6 Java SE6 发布，集体更名\n   * J2EE 更名为 JavaEE\n   * J2SE 更名为 JavaSE\n   * J2ME 更名为 JavaME\n * 2011.7 Java SE7 发布，SUN公司 收购 Oracle\n   * Java SE7：二进制整数、支持字符串的 switch 语句、棱形语法、多异常捕抓、自动关闭资源的 try 语言等新特性\n * 2014.3 Oracle公司 发布 Java SE8\n   * Java SE8：Lambda 表达 式、流式编程等大量新特性\n * 2017.9 Oracle公司 发布 Java SE9 ，强化Java模块化系统\n   * Java SE9：语言更轻量化，更高效、 GI 垃圾回收器\n * 2018.3 Java SE10 发布。包垃圾收集器改善、GC 改进、性能提升、线程管控\n * 2018.9 Java SE11 发布。ZGC、Http Client 等重要特性，一共包含 17 个 JEP\n * 2019.3 Java SE12 发布\n * 2019.9 Java SE13 发布。添加了“文本块”功能\n\n\n# Java 体系\n\nJava SE：Java Platform，Standard Edition 标准版：各应用平台的基础，桌面开发和低端商务应用的解决方案。\n\nJava EE：Java Platform，Enterprise Edition 企业版：以企业为环境而开发应用程序的解决方案\n\nJava ME ：Java Platform, Micro Edition 微型版：致力于消费产品 和嵌入式设备的最佳解决方案\n\n\n# Java 特性\n\n * 面向对象\n * 平台无关性。与平台无关（跨平台）的语言。(它提供了在不同平台下运行的解释环境)\n * 简单性。健壮的语言，吸收了 C/C++语言的优点\n * 安全性。(自动回收垃圾，强制类型检查，取消指针)\n\n\n# Java跨平台原理\n\n\n# JVM 与 GC\n\n\n# JVM Java虚拟机\n\n虚拟机(Java Virtual Machine) JVM\n\nJVM 可以理解成一个可运行 Java 字节码的虚拟计算机\n\n * 解释器组件，可以实现 Java 字节码和计算机操作系统之间的通信\n * 对于不同的运行平台，有不同的JVM\n\n\n# GC 垃圾回收器\n\n垃圾回收器(Garbage Collection) GC\n\n * 不再使用的内存空间应当进行回收-垃圾回收\n * 在 C/C++等语言中，由程序员负责回收无用内存\n * Java 语言消除了程序员回收无用内存空间的责任\n * JVM 提供了一种系统线程跟踪存储空间的分配情况\n * 并在 JVM 的空闲时，检查并释放那些可以被释放的存储空间\n * 垃圾回收器在 Java 程序运行过程中自动启用，程序员无法精确控制和干预\n\n\n# JDK 与 JRE\n\nJava SE 组成概念图\n\n * JDK(Java Development Kits) Java 开发工具集\n   \n   用来开发Java程序的，针对java开发者（JDK是整个JAVA的核心）\n\n * JRE(Java Runtime Environment)Java 运行时环境 JVM需要调用解释所需要的类库lib。JRE里面有两个文件夹bin和lib，这里可以认为bin就是JVM，lib就是JVM所需要的类库，而JVM和lib合起来就称为JRE（JRE包含JVM）\n\nJRE主要功能：\n\n * 加载代码：由类 加载器(class loader)完成\n * 校验代码：由 字节码校验器(byte code verifier)完成\n * 执行代码：由 运行时解释器(runtime interpreter)完成\n\nJDK根路径文件明细：\n\n * bin： 存放JDK各种工具命令（如：javac、java命令等\n * db： 安装 Java DB 的路径\n * include： 部分平台特定的头文件\n * jre： 运行 Java程序的必要环境\n * lib： 该路径下的JDK工具命令的实习执行程序\n\n\n# 环境变量\n\n环境变量相当于 人们生活所需要依赖的东西，比如 鱼的生存离不开水\n\n输入命令 时需要配好环境的路径的前提 才可以使用执行（外部命令） 或者 该路径是已经进入环境 也可以执行（内部命令）\n\n外部命令 需要在系统变量“Path”追加路径 才进行执行（追加后加分号';'）",normalizedContent:"# java认识\n\n\n# java 发展史\n\n * 1991年 诞生了java前世语言 “oak”\n * 1995年 由oak语言 更至为 “java”\n * 1996.1 sun公司推出 jdk1.0 开发工具&运行环境（标志成为独立开发工具）\n   * jdk1.0：核心api、集成api、用户界面api、发布技术、java虚拟机(jvm)、applet、awt\n * 1997.2 sun公司紧接推出 jdk1.1\n   * jdbc、javabeans、rmi、jar文件格式、java内部类&反射\n * 1998.12 推出jdk1.2-企业版j2ee发布\n   * jdk1.2：swing、java idl、ejb、java plug-in 等，添加了 strictfp 关键字和 collections 集合类\n * 1999.4 sun公司 收购 hotspot公司发布的虚拟机\n * 1999.6 sun公司把java体系划分方向&不同的供应商api接口（最主要的里程碑）\n   * j2me（微型版），应用于移动、无线及有限资源的环境\n   * j2se（标准版），应用于桌面环境\n   * j2ee（企业版），应用于基于 java 的应用服务器\n   * java core api：java 核心类库\n   * java optional api：对之前 api 的扩充\n   * 特殊 api：由特殊厂商或组织提供的 api\n * 2000.5 jdk1.3、jdk1.4、j2se1.3 发布\n   * javase1.3：数据库、web、网络、图形、多媒体、电话、影像等信息技术领域\n * 2002.2 j2se1.4发布，接口和类多了60%+\n   * j2se1.4：xml支持、安全套接字（socket）支持（通过 ssl 与 tls 协议）、全新的 i/oapi、 正则表达式、日志与断言\n * 2004.9 j2se1.5发布，j2se1.5 更名至 java se5.0（内部版本1.5.0）\n   * java se 5.0(j2se1.5)：泛型支持、基本类型的自动装箱、改进的循环、枚举类型、格式化 i/o 及可变参数\n * 2005.6 java se6 发布，集体更名\n   * j2ee 更名为 javaee\n   * j2se 更名为 javase\n   * j2me 更名为 javame\n * 2011.7 java se7 发布，sun公司 收购 oracle\n   * java se7：二进制整数、支持字符串的 switch 语句、棱形语法、多异常捕抓、自动关闭资源的 try 语言等新特性\n * 2014.3 oracle公司 发布 java se8\n   * java se8：lambda 表达 式、流式编程等大量新特性\n * 2017.9 oracle公司 发布 java se9 ，强化java模块化系统\n   * java se9：语言更轻量化，更高效、 gi 垃圾回收器\n * 2018.3 java se10 发布。包垃圾收集器改善、gc 改进、性能提升、线程管控\n * 2018.9 java se11 发布。zgc、http client 等重要特性，一共包含 17 个 jep\n * 2019.3 java se12 发布\n * 2019.9 java se13 发布。添加了“文本块”功能\n\n\n# java 体系\n\njava se：java platform，standard edition 标准版：各应用平台的基础，桌面开发和低端商务应用的解决方案。\n\njava ee：java platform，enterprise edition 企业版：以企业为环境而开发应用程序的解决方案\n\njava me ：java platform, micro edition 微型版：致力于消费产品 和嵌入式设备的最佳解决方案\n\n\n# java 特性\n\n * 面向对象\n * 平台无关性。与平台无关（跨平台）的语言。(它提供了在不同平台下运行的解释环境)\n * 简单性。健壮的语言，吸收了 c/c++语言的优点\n * 安全性。(自动回收垃圾，强制类型检查，取消指针)\n\n\n# java跨平台原理\n\n\n# jvm 与 gc\n\n\n# jvm java虚拟机\n\n虚拟机(java virtual machine) jvm\n\njvm 可以理解成一个可运行 java 字节码的虚拟计算机\n\n * 解释器组件，可以实现 java 字节码和计算机操作系统之间的通信\n * 对于不同的运行平台，有不同的jvm\n\n\n# gc 垃圾回收器\n\n垃圾回收器(garbage collection) gc\n\n * 不再使用的内存空间应当进行回收-垃圾回收\n * 在 c/c++等语言中，由程序员负责回收无用内存\n * java 语言消除了程序员回收无用内存空间的责任\n * jvm 提供了一种系统线程跟踪存储空间的分配情况\n * 并在 jvm 的空闲时，检查并释放那些可以被释放的存储空间\n * 垃圾回收器在 java 程序运行过程中自动启用，程序员无法精确控制和干预\n\n\n# jdk 与 jre\n\njava se 组成概念图\n\n * jdk(java development kits) java 开发工具集\n   \n   用来开发java程序的，针对java开发者（jdk是整个java的核心）\n\n * jre(java runtime environment)java 运行时环境 jvm需要调用解释所需要的类库lib。jre里面有两个文件夹bin和lib，这里可以认为bin就是jvm，lib就是jvm所需要的类库，而jvm和lib合起来就称为jre（jre包含jvm）\n\njre主要功能：\n\n * 加载代码：由类 加载器(class loader)完成\n * 校验代码：由 字节码校验器(byte code verifier)完成\n * 执行代码：由 运行时解释器(runtime interpreter)完成\n\njdk根路径文件明细：\n\n * bin： 存放jdk各种工具命令（如：javac、java命令等\n * db： 安装 java db 的路径\n * include： 部分平台特定的头文件\n * jre： 运行 java程序的必要环境\n * lib： 该路径下的jdk工具命令的实习执行程序\n\n\n# 环境变量\n\n环境变量相当于 人们生活所需要依赖的东西，比如 鱼的生存离不开水\n\n输入命令 时需要配好环境的路径的前提 才可以使用执行（外部命令） 或者 该路径是已经进入环境 也可以执行（内部命令）\n\n外部命令 需要在系统变量“path”追加路径 才进行执行（追加后加分号';'）",charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"拓展",frontmatter:{pageComponent:{name:"Catalogue",data:{path:"03.更多",imgUrl:"https://image.bozhu12.cc/myblog/Essay/other.png",description:"技术文档、教程、技巧等文章"}},title:"拓展",date:"2022-03-11T00:00:00.000Z",permalink:"/other/",sidebar:!1,article:!1,comment:!1,editLink:!1,author:{name:"Sanscan12",link:"https://github.com/Sanscan12"}},regularPath:"/00.%E7%9B%AE%E5%BD%95%E9%A1%B5/03.%E6%9B%B4%E5%A4%9A.html",relativePath:"00.目录页/03.更多.md",key:"v-c88be50c",path:"/other/",headersStr:null,content:"",normalizedContent:"",charsets:{}},{title:"面向对象概述",frontmatter:{title:"面向对象概述",date:"2020-02-18T00:00:00.000Z",permalink:"/backend/pe1123",categories:["后端","Java基础"],tags:["Java"],author:"柏竹"},regularPath:"/01.%E5%90%8E%E7%AB%AF/01.Java%E5%9F%BA%E7%A1%80/02.%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1.html",relativePath:"01.后端/01.Java基础/02.类和对象.md",key:"v-b5521cb0",path:"/backend/pe1123/",headers:[{level:2,title:"对象",slug:"对象",normalizedTitle:"对象",charIndex:4},{level:3,title:"构造器",slug:"构造器",normalizedTitle:"构造器",charIndex:272},{level:2,title:"类",slug:"类",normalizedTitle:"类",charIndex:28},{level:2,title:"封装",slug:"封装",normalizedTitle:"封装",charIndex:56},{level:2,title:"继承",slug:"继承",normalizedTitle:"继承",charIndex:657},{level:2,title:"多态",slug:"多态",normalizedTitle:"多态",charIndex:706},{level:2,title:"对象属性与行为",slug:"对象属性与行为",normalizedTitle:"对象属性与行为",charIndex:802},{level:2,title:"对象引用",slug:"对象引用",normalizedTitle:"对象引用",charIndex:1655}],headersStr:"对象 构造器 类 封装 继承 多态 对象属性与行为 对象引用",content:'# 面向对象概述\n\n\n# 对象\n\n对象 就是通过java类所产生的实体\n\n> 动物百科的记载中有兔子类（java封装的类），根据百科中所呈现出来且真实存在的 实体 被为对象，相当于得到了兔子的 对象\n> \n> 指定 某个事物、某个计划、汽车、动物（指定广泛且不具体的）\n\n每个对象都在堆中有他们自己的内存地址\n\n对象创建\n\nText text = new Text();\nText text = new Text("a");\n\n\n> Text：类名 text：创建Text类引用对象 new：创建对象操作符 “ a ”：构造方法的参数\n\n\n# 构造器\n\n构造器是类的特殊方法，专门用于在类被实例时，定义初始化类的成员属性所使用(无需再次set方法)\n\n构造器特点：\n\n * 方法名与类名相同\n * 没有返回值\n * 系统默认生成无参的构造器\n * 可重载构造器\n\n重载构造器参数应用\n\n * 参数顺序\n * 参数类型\n\n\n# 类\n\n类 是封装 对象的行为 和 属性 的载体。反过来，具有 相同属性 和 行为 的一类实体被称为类\n\n> 兔子类（所有物种的兔子）封装有兔子的 共同 属性(有体毛、长耳朵、...) 和 行为（跳着走、喜欢吃萝卜、...）\n\n\n# 封装\n\n封装是将类的某些信息隐藏在类的内部，不许外部直接访问 通过类提供的方法实现隐藏细节，对外提供访问，便于使用者调用\n\n封装关键字： private 类私有\n\n> 外部不能通过 ==类.成员== 进行调用。如果应用需要通过 方法返回 进行使用\n\n\n# 继承\n\n继承 是类与类之间同样具有关系，则为两类的关联 如：学生类 与 教师类 关联关系\n\n\n# 多态\n\n多态 是同一操作作用于不同的对象，可以有不同的解释，产生不同 的执行结果。父类对象应用于子类的特征\n\n如：类继承 或 接口实现、子类要重写父类的方法、父类的引用指向子类的对象\n\n\n# 对象属性与行为\n\n使用new操作符创建对象后，可以使用 对象.类成员 获取对象的 属性 或 行为\n\npublic class no1 {\n    int i = 50;\n    public void max(int a,int b){\n        System.out.println("调用no1类的max方法(no1.max)");\n        if(a > b){\n            System.out.println("max = a"+a);\n        }else{\n            System.out.println("max = b"+b);\n        }\n    }\n    \n    public static void main(String[] args) {\n        //对象的创建\n        no1 t1 = new no1();\n        no1 t2 = new no1();\n        \n        //获取对象的属性（变量）\n        t2.i = 60;\n        System.out.println("t2对象i："+t2.i);\n        System.out.println("t1对象i："+t1.i);\n        System.out.println("t1对象i："+t1.i++);\n    \n        System.out.println();\n        //调用t1对象max方法\n        t1.max(12,23);\n        //调用t2对象max方法\n        t2.max(22,33);\n    }\n}\n\n\n运行结果\n\nt2对象i：60\nt1对象i：50\nt1对象i：50\n\n调用no1类的max方法(no1.max)\nmax = b23\n调用no1类的max方法(no1.max)\nmax = b33\n\n\n\n# 对象引用\n\nText t = new Text();\n\n\n> Text：类 t：引用 new Book（）：对象',normalizedContent:'# 面向对象概述\n\n\n# 对象\n\n对象 就是通过java类所产生的实体\n\n> 动物百科的记载中有兔子类（java封装的类），根据百科中所呈现出来且真实存在的 实体 被为对象，相当于得到了兔子的 对象\n> \n> 指定 某个事物、某个计划、汽车、动物（指定广泛且不具体的）\n\n每个对象都在堆中有他们自己的内存地址\n\n对象创建\n\ntext text = new text();\ntext text = new text("a");\n\n\n> text：类名 text：创建text类引用对象 new：创建对象操作符 “ a ”：构造方法的参数\n\n\n# 构造器\n\n构造器是类的特殊方法，专门用于在类被实例时，定义初始化类的成员属性所使用(无需再次set方法)\n\n构造器特点：\n\n * 方法名与类名相同\n * 没有返回值\n * 系统默认生成无参的构造器\n * 可重载构造器\n\n重载构造器参数应用\n\n * 参数顺序\n * 参数类型\n\n\n# 类\n\n类 是封装 对象的行为 和 属性 的载体。反过来，具有 相同属性 和 行为 的一类实体被称为类\n\n> 兔子类（所有物种的兔子）封装有兔子的 共同 属性(有体毛、长耳朵、...) 和 行为（跳着走、喜欢吃萝卜、...）\n\n\n# 封装\n\n封装是将类的某些信息隐藏在类的内部，不许外部直接访问 通过类提供的方法实现隐藏细节，对外提供访问，便于使用者调用\n\n封装关键字： private 类私有\n\n> 外部不能通过 ==类.成员== 进行调用。如果应用需要通过 方法返回 进行使用\n\n\n# 继承\n\n继承 是类与类之间同样具有关系，则为两类的关联 如：学生类 与 教师类 关联关系\n\n\n# 多态\n\n多态 是同一操作作用于不同的对象，可以有不同的解释，产生不同 的执行结果。父类对象应用于子类的特征\n\n如：类继承 或 接口实现、子类要重写父类的方法、父类的引用指向子类的对象\n\n\n# 对象属性与行为\n\n使用new操作符创建对象后，可以使用 对象.类成员 获取对象的 属性 或 行为\n\npublic class no1 {\n    int i = 50;\n    public void max(int a,int b){\n        system.out.println("调用no1类的max方法(no1.max)");\n        if(a > b){\n            system.out.println("max = a"+a);\n        }else{\n            system.out.println("max = b"+b);\n        }\n    }\n    \n    public static void main(string[] args) {\n        //对象的创建\n        no1 t1 = new no1();\n        no1 t2 = new no1();\n        \n        //获取对象的属性（变量）\n        t2.i = 60;\n        system.out.println("t2对象i："+t2.i);\n        system.out.println("t1对象i："+t1.i);\n        system.out.println("t1对象i："+t1.i++);\n    \n        system.out.println();\n        //调用t1对象max方法\n        t1.max(12,23);\n        //调用t2对象max方法\n        t2.max(22,33);\n    }\n}\n\n\n运行结果\n\nt2对象i：60\nt1对象i：50\nt1对象i：50\n\n调用no1类的max方法(no1.max)\nmax = b23\n调用no1类的max方法(no1.max)\nmax = b33\n\n\n\n# 对象引用\n\ntext t = new text();\n\n\n> text：类 t：引用 new book（）：对象',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Java API",frontmatter:{title:"Java API",date:"2020-02-18T00:00:00.000Z",permalink:"/backend/m0die6",categories:["后端","Java基础"],tags:["Java"],author:"柏竹"},regularPath:"/01.%E5%90%8E%E7%AB%AF/01.Java%E5%9F%BA%E7%A1%80/03.API.html",relativePath:"01.后端/01.Java基础/03.API.md",key:"v-36016ffa",path:"/backend/m0die6/",headers:[{level:2,title:"装箱和拆箱操作",slug:"装箱和拆箱操作",normalizedTitle:"装箱和拆箱操作",charIndex:496},{level:2,title:"Object",slug:"object",normalizedTitle:"object",charIndex:751},{level:2,title:"Integer",slug:"integer",normalizedTitle:"integer",charIndex:60},{level:2,title:"Boolean",slug:"boolean",normalizedTitle:"boolean",charIndex:244},{level:2,title:"Byte",slug:"byte",normalizedTitle:"byte",charIndex:290},{level:2,title:"Character",slug:"character",normalizedTitle:"character",charIndex:106},{level:2,title:"Float",slug:"float",normalizedTitle:"float",charIndex:152},{level:2,title:"Double",slug:"double",normalizedTitle:"double",charIndex:198},{level:2,title:"Number",slug:"number",normalizedTitle:"number",charIndex:429},{level:2,title:"System",slug:"system",normalizedTitle:"system",charIndex:1291},{level:2,title:"String",slug:"string",normalizedTitle:"string",charIndex:931},{level:2,title:"Array",slug:"array",normalizedTitle:"array",charIndex:19997},{level:2,title:"Math",slug:"math",normalizedTitle:"math",charIndex:21144},{level:3,title:"随机数",slug:"随机数",normalizedTitle:"随机数",charIndex:21249},{level:2,title:"Random",slug:"random",normalizedTitle:"random",charIndex:21406},{level:2,title:"BigInteger",slug:"biginteger",normalizedTitle:"biginteger",charIndex:21598},{level:2,title:"BigDecimal",slug:"bigdecimal",normalizedTitle:"bigdecimal",charIndex:22107},{level:2,title:"Date",slug:"date",normalizedTitle:"date",charIndex:22587},{level:3,title:"Calendar",slug:"calendar",normalizedTitle:"calendar",charIndex:22987},{level:2,title:"Format",slug:"format",normalizedTitle:"format",charIndex:25031},{level:3,title:"DecimalFormat",slug:"decimalformat",normalizedTitle:"decimalformat",charIndex:25060},{level:3,title:"DateFormat",slug:"dateformat",normalizedTitle:"dateformat",charIndex:25758},{level:3,title:"SimpleDateFormat",slug:"simpledateformat",normalizedTitle:"simpledateformat",charIndex:26571}],headersStr:"装箱和拆箱操作 Object Integer Boolean Byte Character Float Double Number System String Array Math 随机数 Random BigInteger BigDecimal Date Calendar Format DecimalFormat DateFormat SimpleDateFormat",content:'# Java API\n\n包装类         最小值             最大值             字节数\nInteger     -2^31           2^31 -1         4\nCharacter   0               65536           2\nFloat       -               -               4\nDouble      -               -               8\nBoolean     -               -               1\nByte        -128(-2^7)      127 (2^7-1)     1\nShort       -32768(-2^15)   32767(2^15-1)   2\nLong        -2^63           2^63-1          8\n\nNumber： Integer、Short、Long、Double、Float、Byte都是Number的子类表示是一个数字\n\n\n# 装箱和拆箱操作\n\n将一个基本数据类型变为包装类，那么这样的操作称为 装箱操作 将一个包装类变为一个基本数据类型，这样的操作称为 拆箱操作\n\n/*过时的*/\nint temp = 10 ; // 基本数据类型\nInteger x = new Integer(temp) ; // 将基本数据类型变为包装类\n/*JDK1.5 后 ，新版自动拆装箱*/\n// 自动装箱\nFloat f = 10.3f ;\nInteger i = 200;\n// 自动拆箱\nfloat x = f ;\nint j = i;\n\n\n\n# Object\n\nObject是所有类的父类\n\n如果一个类没有继承有其他类，则默认继承Object类\n\n常用方法\n\n返回        方法                   说明\n类<?>      getClass()           获取 此运行时的Object类\nint       hashCode()           获取 对象的哈希码值\nString    toString()           返回 对象的字符串形式 (一般是 属性/地址)\nboolean   equals(Object obj)   比较 参数对象是否与此对象相同\n\n\n# Integer\n\nInteger构造方法\n\nInteger(int number)\n\nInteger(String str)\n\n以上有两种方式获取 Integer对象\n\nInteger常量\n\nInteger.MAX_VALUE 返回int型的最大值\n\nInteger.MIN_VALUE 返回int型的最小值\n\nInteger.SIZE 用二进制补码形式表示 int位数\n\nInteger.TYPE 基本类型int\n\npublic static void main(String[] args) {\n    System.out.println("int最大值(max)："+Integer.MAX_VALUE);\n    System.out.println("int最小值(min)："+Integer.MIN_VALUE);\n    System.out.println("max："+Integer.SIZE);\n    System.out.println("max："+Integer.TYPE);\n}\n\n/*\n\nint最大值(max)：2147483647\nint最小值(min)：-2147483648\nmax：32\nmax：int\n\n*/\n\n\n\nInteger方法\n\nInteger.byteValue() 以 byte类型 返回\n\nInteger.compareTo(Integer i) 比较是否相同，两值相同则返回 0，对象小于 参数i 返回负值，否则为正值\n\nInteger.intValue() 以 int类型 返回\n\nInteger.shortValue() 以 short类型 返回\n\nInteger.toString() 返回 Integer值 的 String对象，返回String\n\nInteger.valueOf(String str) 返回保存参数的 Integer对象\n\nInteger.parseInt(String str) 返回参数中的数值\n\npublic class no1 {\n    public static void main(String[] args) {\n        Integer n = new Integer(12);\n        \n        System.out.println("byteValue() 以 byte类型 返回(12)："+n.byteValue());\n        \n        System.out.println("compareTo(Integer i)比较是否相同(12 v 10)："+n.compareTo(10));\n    \n        System.out.println("intValue()以 int类型 返回："+n.intValue());\n    \n        System.out.println("shortValue()以 short类型 返回："+n.shortValue());\n    \n        String str = new String("123");\n        System.out.println("toString()返回 Integer值 的 String对象："+str.toString());\n    \n        System.out.println("valueOf(String str) 返回保存参数的 Integer对象((String)123) : "+n.valueOf("123"));\n    \n        System.out.println("parseInt(String str) 返回参数中的数值((String)123)："+n.parseInt("123"));\n    }\n}\n\n/*\n\nbyteValue() 以 byte类型 返回(12)：12\ncompareTo(Integer i)比较是否相同(12 v 10)：1\nintValue()以 int类型 返回：12\nshortValue()以 short类型 返回：12\ntoString()返回 Integer值 的 String对象：123\nvalueOf(String str) 返回保存参数的 Integer对象((String)123) : 123\nparseInt(String str) 返回参数中的数值((String)123)：123\n\n*/\n\n\n\n# Boolean\n\nBoolean构造方法\n\nBoolean(boolean value)\n\nBoolean(String str)\n\n以上有两种方式获取 Boolean对象\n\nBoolean常量\n\nBoolean.TRUE 对应基于true的 Boolean对象\n\nBoolean.FALSE 对应基于false的 Boolean对象\n\nBoolean.TYPE 基本类型Boolean\n\npublic static void main(String[] args) {\n    System.out.println("Boolean.TRUE："+Boolean.TRUE);\n    System.out.println("Boolean.FALSE："+Boolean.FALSE);\n    System.out.println("Boolean.TYPE："+Boolean.TYPE);\n}\n\n/*\n\nBoolean.TRUE：true\nBoolean.FALSE：false\nBoolean.TYPE：boolean\n\n*/\n\n\nBoolean方法\n\nBoolean.BooleanValue() 将Boolean对象的值对应返回 Boolean值\n\nBoolean.equsla(Object obj) 对象相同返回true，否则false\n\nBoolean.parseBoolean(String s) 参数字符串解析为 Boolean值\n\nBoolean.toString() 返回boolean值的String对象，返回String\n\nBoolean.valueOf(String s) 返回参数Boolean值\n\npublic static void main(String[] args) {\n    Boolean b1 = new Boolean(true);\n    //默认false\n    Boolean b2 = new Boolean("yes");\n    System.out.println("BooleanValue(b1) : "+b1.booleanValue());\n    System.out.println("BooleanValue(b2) : "+b2.booleanValue());\n\n    System.out.println("b1.equsla(b2)："+b1.equals(b2));\n\n    System.out.println("valueOf(b1)："+Boolean.valueOf(b1));\n    System.out.println("valueOf(b2)："+Boolean.valueOf(b2));\n    \n    //String.valueOf(b1)：把b1引用的对象字符串化\n    System.out.println("parseBoolean(b1)："+Boolean.parseBoolean(String.valueOf(b1)));\n    //String.valueOf(b1)：把b2引用的对象字符串化\n    System.out.println("parseBoolean(b2)："+Boolean.parseBoolean(String.valueOf(b2)));\n}\n\n/*\n\nBooleanValue(b1) : true\nBooleanValue(b2) : false\nb1.equsla(b2)：false\nvalueOf(String s)：true\nvalueOf(String s)：false\nparseBoolean(String s)：true\nparseBoolean(String s)：false\n\n*/\n\n\n\n# Byte\n\nByte构造方法\n\nByte(byte value)\n\nByte(String str)\n\n以上有两种方式获取 Byte对象\n\nByte常量\n\nByte.MAX_VALUE 返回byte型的最大值\n\nByte.MIN_VALUE 返回byte型的最小值\n\nByte.SIZE 用二进制补码形式表示 byte位数\n\nByte.TYPE 基本类型byte\n\npublic static void main(String[] args) {\n    System.out.println("Byte.MAX："+Byte.MAX_VALUE);\n    System.out.println("Byte.MIN："+Byte.MIN_VALUE);\n    System.out.println("Byte.SIZE："+Byte.SIZE);\n    System.out.println("Byte.TYPE："+Byte.TYPE);\n}\n\n/*\n\nByte.MAX：127\nByte.MIN：-128\nByte.SIZE：8\nByte.TYPE：byte\n\n*/\n\n\nByte方法\n\nByte.parseByte(String str) 参数String以byte值返回\n\nByte.valueOf(String str) 参数String以byte对象返回\n\nByte.equals(Object obj) 两个Byte对象判断是否相同\n\nByte.byteValue() 返回此对象的byte值\n\nByte.intValue() 返回此对象的int值\n\nByte.doubleValue() 返回此对象的double值\n\npublic static void main(String[] args) {\n//        Byte be = new Byte(12);  过时了\n//        实例化对象的例子需要调用valueOf方法\n        Byte b = Byte.valueOf((byte) 12);\n//        或者\n        Byte b2 = (byte)12;\n    \n        System.out.println("parseByte(String str)参数String以byte值返回："+b.parseByte("23"));\n    \n        System.out.println("valueOf(String str)参数String以byte对象返回："+b.valueOf("22"));\n    \n        System.out.println("equals(Object obj)两个Byte对象判断是否相同："+b.equals(b2));\n    \n        System.out.println("byteValue() 返回此对象的byte值："+b.byteValue());\n    \n        System.out.println("intValue()返回此对象的int值："+b.intValue());\n    \n        System.out.println("doubleValue() 返回此对象的double值："+b.doubleValue());\n    }\n}\n\n/*\n\nparseByte(String str)参数String以byte值返回：23\nvalueOf(String str)参数String以byte对象返回：22\nequals(Object obj)两个Byte对象判断是否相同：true\nbyteValue() 返回此对象的byte值：12\nintValue()返回此对象的int值：12\ndoubleValue() 返回此对象的double值：12.0\n\n*/\n\n\n\n# Character\n\nCharacter构造方法\n\nCharacter(char value)\n\nCharacter常量\n\nCharacter.CONNECTOR_PUNCTUATION 返回byte型值，表示Unicode的常规类别 Pc\n\nCharacter.UNASSIGNED 返回byte型值，表示Unicode的常规类别 Cn\n\nCharacter.TITLECASE_LETTER 返回byte型值，表示Unicode的常规类别 Lt\n\nCharacter方法\n\nCharacter.compareTo(Charcter char) 比较两个对象是否相同，相同则0\n\nCharacter.equals(Object obj) 比较两对象的值，返回boolean值\n\nCharacter.toUpperCase(char ch) 参数字母转化为大写doubleValue()\n\nCharacter.toLowerCase(char ch) 参数字母转化为小写\n\nCharacter.toString() 返回指定的char值的String对象\n\nCharacter.charValue() 返回Character对象的值\n\nCharacter.isUpperCase(char ch) 判断参数字符是否是大写\n\nCharacter.isLowerCase(char ch) 判断参数字符是否是小写\n\npublic static void main(String[] args) {\n        Character ch = new Character(\'S\');\n        Character ch2 = new Character(\'s\');\n    \n        System.out.println("compareTo(Charcter char)比较两个对象是否相同，相同则0："+ch.compareTo(ch2));\n        \n        System.out.println("equals(Object obj)比较两对象的值，返回boolean值："+ch.equals(ch2));\n    \n        System.out.println("toUpperCase(char ch)参数字母转化为大写："+Character.toUpperCase(ch));\n    \n        System.out.println("toLowerCase(char ch)参数字母转化为小写："+Character.toLowerCase(ch));\n        \n        System.out.println("toString()返回指定的char值的String对象："+ch.toString());\n    \n        System.out.println("charValue() 返回Character对象的值："+ch.charValue());\n        \n        System.out.println("isUpperCase(char ch) 判断参数字符是否是大写(S)："+Character.isUpperCase(ch));\n        System.out.println("isUpperCase(char ch) 判断参数字符是否是大写(s)："+Character.isUpperCase(ch2));\n        \n        System.out.println("isLowerCase(char ch) 判断参数字符是否是小写(S)："+Character.isLowerCase(ch));\n        System.out.println("isLowerCase(char ch) 判断参数字符是否是小写(s)："+Character.isLowerCase(ch2));\n        \n}\n\n/*\n\ncompareTo(Charcter char)比较两个对象是否相同，相同则0：-32\nequals(Object obj)比较两对象的值，返回boolean值：false\ntoUpperCase(char ch)参数字母转化为大写：S\ntoLowerCase(char ch)参数字母转化为小写：s\ntoString()返回指定的char值的String对象：S\ncharValue() 返回Character对象的值：S\nisUpperCase(char ch) 判断参数字符是否是大写(S)：true\nisUpperCase(char ch) 判断参数字符是否是大写(s)：false\nisLowerCase(char ch) 判断参数字符是否是小写(S)：false\nisLowerCase(char ch) 判断参数字符是否是小写(s)：true\n\n*/\n\n\n\n# Float\n\nFloat 类在对象中包装了一个基本类型 float 的值\n\nFloat构造方法\n\n构造方法                  说明\nFloat(double value)   double 转换为 Float\nFloat(float value)    分配新对象\nFloat(String s)       String 转换为 Float\n\nFloat常量\n\nMAX_VALUE：float 类型的最大值 (1.4E38)\n\nMIN_VALUE：float 类型的最小值 (3.4E-45)\n\nMAX_EXPONENT: float 变量可能具有的最大指数\n\nMIN_EXPONENT：标准化 float 变量可能具有的最小指数\n\nMIN_NORMAL：保存 float 类型数值的最小标准值的常量，即 2-126\n\nNaN：保存 float 类型的非数字值的常量\n\nSIZE：用来以二进制补码形式表示 float 值的比特位数\n\nTYPE：表示基本类型 float 的 Class 实例\n\nFloat方法\n\n返回        方法                     说明\nint       intValue()             强制转换为 int 类型\nlong      longValue()            强制转换为 long 类型\n··        ··(其他类型用法如此)           ··\nboolean   isNaN()                是否为非数字值 NaN\nboolean   isNaN(float v)         参数是否为非数字值 NaN\nFloat     valueOf(String s)      String 强转为 Float对象\nfloat     parseFloat(String s)   String 强转为 float\n\n\n# Double\n\nDouble 类在对象中包装了一个基本类型 double 的值\n\nDouble构造方法\n\n构造方法                   说明\nDouble(double value)   分配新对象\nDouble(String str)     String 转换为 Double\n\nDouble常量\n\nMAX_EXPONENT 返回int值，double最大指数\n\nMIN_EXPONENT 返回int值，double最小指数\n\nTYPE 基本类型double\n\nSIZE 用二进制补码形式表示 double位数\n\nNEGATIVE_INFINITY 返回double值，保存double类型的负穷大值\n\nPOSITIVE_INFINITY 返回double值，返回double类型的正无穷大值\n\npublic static void main(String[] args) {\n     System.out.println("Double.MAX："+Double.MAX_EXPONENT);\n     System.out.println("Double.NIN："+Double.MIN_EXPONENT);\n     System.out.println("Double.SIZE："+Double.SIZE);\n     System.out.println("Double.TYPE："+Double.TYPE);\n}\n\n/*\n\nDouble.MAX：1023\nDouble.NIN：-1022\nDouble.SIZE：64\nDouble.TYPE：double\n\n*/\n\n\nDouble方法\n\nDouble.byteValue() 以byte形式返回Double对象值\n\nDouble.compareTo(Double d) 两Double对象进行数值比较，相同则0\n\nDouble.equals(Object obj) 比较两对象是否相同，返回boolean\n\nDouble.intValue() 以int形式返回double值\n\nDouble.isNaN() 非数字值，则返回true，否则false\n\nString.toString() 返回Double对象的字符串形式\n\nDouble.valueOf(String str) 返回保存参数的double值的对象\n\nDouble.doubleValue() 以double形式返回Double对象\n\nDouble.longValue() 以long形式返回double值\n\nDouble.parseDouble(String str)返回参数中的数值\n\npublic static void main(String[] args) {\n        Double d = new Double(11.22);\n        Double d2 = new Double(22);\n        Double d3 = new Double(11.22);\n        \n        System.out.println("byteValue() 以byte形式返回Double对象值："+d.byteValue());\n        \n        System.out.println("compareTo(Double d) 两Double对象进行数值比较，相同则0(d2)："+d.compareTo(d2));\n        System.out.println("compareTo(Double d) 两Double对象进行数值比较，相同则0(d3)："+d.compareTo(d3));\n        \n        System.out.println("equals(Object obj)比较两对象是否相同，返回boolean(d2)："+d.equals(d2));\n        System.out.println("equals(Object obj)比较两对象是否相同，返回boolean(d3)："+d.equals(d3));\n        \n        System.out.println("intValue()以int形式返回double值："+d.intValue());\n        \n        System.out.println("isNaN()非数字值，则返回true，否则false(d2)："+d2.isNaN());\n        \n        System.out.println("toString()返回Double对象的字符串形式："+d.toString());\n    \n        System.out.println("valueOf(String str)返回保存参数的double值的对象："+d.valueOf("22.33"));\n        \n        System.out.println("doubleValue()以double形式返回Double对象："+d.doubleValue());\n        \n        System.out.println("longValue() 以long形式返回double值："+d.longValue());\n    \n    \tSystem.out.println("parseDouble(String str)返回参数中的数值："+d.parseDouble("33.2"));\n}\n\n/*\n\nbyteValue() 以byte形式返回Double对象值：11\ncompareTo(Double d) 两Double对象进行数值比较，相同则0(d2)：-1\ncompareTo(Double d) 两Double对象进行数值比较，相同则0(d3)：0\nequals(Object obj)比较两对象是否相同，返回boolean(d2)：false\nequals(Object obj)比较两对象是否相同，返回boolean(d3)：true\nintValue()以int形式返回double值：11\nisNaN()非数字值，则返回true，否则false(d2)：false\ntoString()返回Double对象的字符串形式：11.22\nvalueOf(String str)返回保存参数的double值的对象：22.33\ndoubleValue()以double形式返回Double对象：11.22\nlongValue() 以long形式返回double值：11\nparseDouble(String str)返回参数中的数值：33.2\n\n*/\n\n\n\n# Number\n\nNumber数值类是byte、Integer、long、float、Double、··· 的父类，Number的方法子类都可以用！！\n\nNumber方法\n\n方法              返回值      说明\nbyteValue()     byte     以byte形式返回数值\nintValue()      int      以int形式返回数值\nfloatValue()    float    以float形式返回数值\nshortValue()    short    以short形式返回数值\nlongValue()     long     以long形式返回数值\ndoubleValue()   double   以double形式返回数值\n\npublic static void main(String[] args) {\n     Number num = new Double(23000.23);\n \n     System.out.println("以byte形式返回数值："+num.byteValue());\n  \n     System.out.println("以int形式返回数值："+num.intValue());\n     \n     System.out.println("以float形式返回数值："+num.floatValue());\n     \n     System.out.println("以short形式返回数值："+num.shortValue());\n     \n     System.out.println("以long形式返回数值："+num.longValue());\n     \n     System.out.println("以double形式返回数值："+num.doubleValue());\n }\n\n/*\n\n以byte形式返回数值：-40\n以int形式返回数值：23000\n以float形式返回数值：23000.23\n以short形式返回数值：23000\n以long形式返回数值：23000\n以double形式返回数值：23000.23\n\n*/\n\n\n\n# System\n\nSystem类 代表Java运行的平台，系统级的很多属性和控制方法都放置在该类的内部\n\n静态变量\n\n * PrintStream out ：标准输出流 (用于输出打印\n * InputStream in ：标准输入流 (用于用户输入\n * PrintStream err ：错误输出流 (用于错误打印\n\n方法\n\n返回                  方法                                                            参数               说明\nstatic void         arraycopy(Object src,int srcPos,Object dest,int destPos,int   1. 源数组           数组复制，指定源数组中复制一个数组\n                    length)                                                       2. 源数组中的起始位置\n                                                                                  3. 目标数组\n                                                                                  4. 目标数据中的起始位置\n                                                                                  5. 要复制的数组元素的数量\nstatic long         currentTimeMillis()                                           -                返回当前时间戳\nstatic void         exit(int status)                                              static - 退出状态    终止JVM\nstatic void         gc()                                                          -                请求垃圾回收\nstatic Properties   getProperties()                                               -                获取 当前系统所有数据\nstatic String       getProperty(String key)                                       key - 系统属性       获取 指定的值\n\n系统常见属性\n\n属性名            说明\njava.version   Java 运行时环境版本\njava.home      Java 安装目录\nos.name        操作系统的名称\nos.version     操作系统的版本\nuser.name      用户的账户名称\nuser.home      用户的主目录\nuser.dir       用户的当前工作目录\n\n\n# String\n\n字符串方法\n\n修饰           方法                              说明\nint          length()                        测长度 ，返回字符串长度\nint          indxOf(String s)                找参数的位置，返回参数字符串在字符串首个字符索引位置\nint          lastIndexOf(String s)           找参数最后出现的位置，返回指定参数的字符串最后一个出现的索引位置\nchar         charAt(int i)                   查找索引下标，返回指定索引处的字符\nString       substring(int i)                查找索引下标开始到结尾，返回指定位置开始到结尾的字符串\nString       substring(int i , int j)        获取指定范围字符串，返回指定位置范围的字符串\nString       trim()                          去除多余空格，返回字符串副本，消除多余空格的\nString       replace(char str1,char str2)    字符串/字符替换，返回字符串副本，指定 字符 / 字符串 替换新的 字符 / 字符串\nboolean      startsWith(String p)            匹配前缀字符串，判定字符串前缀是否匹配参数字符串\nboolean      endsWith(String p)              匹配后缀字符串，判断字符串后缀是否匹配参数字符串\nboolean      equals(String str2)             判断是否相同，判断字符串与参数字符串的字符和长度是否相同\nboolean      equalsIgnoreCase(String str2)   判断是否相同，比较两个字符串的对象\nint          compareTo(String o)             比较顺序，按字典顺序比较两个字符串，参数位置前正，后负，等于0\nString       toLowerCase()                   转换小写，字符串全部转换为小写\nString       toUpperCase()                   转换大写，字符串全部转换为大写\nString[]     split(String sign)              分割字符串，指定分割符对字符串进行拆分\n                                             sign为分割的字符串，也可以是正则表达式\nString[]     split(String sign , int i)      分割字符串指定数量，指定分割符对字符串进行拆分，并限制拆分数\nAppendable   append(content)                 添加数据，字符串后面追加内容，频繁操作时引用，限于StringBuilder对象的使用(16字节)\n                                             content可以是任何数据类型或其他对象\n             insert(int i , String str2)     插入数据，参数索引的后一位插入字符串数据\n             delete(int i , int j)           删除字符串\n\npublic static void main(String[] args) {\n        String str = new String("I love Java  20.06.05   !!! , or not love Java");\n        System.out.println("str："+str);\n        String str2 = "Sanscan";\n        System.out.println("str2："+str2+"\\n");\n        String str3 = "192.168.0.1";\n        StringBuilder str4 = new StringBuilder("Sanscan");\n    \n        long no1 = System.currentTimeMillis();\n        //length() 测长度\n        System.out.println("str.length() 测长度："+str.length());\n        //inexOf(String s)找字符串位置\n        System.out.println("str.inexOf(String s)找Java字符串位置："+str.indexOf("Java"));\n        //lastIndexOf(String s)找参数最后出现的位置\n        System.out.println("str.lastIndexOf(String s)找参数最后出现的位置："+str.lastIndexOf("Java"));\n        //charAt(int i)查找索引下标\n        System.out.println("str.charAt(int i)查找索引下标："+str.charAt(7));\n        //substring(int i) 查找索引下标开始到结尾\n        System.out.println("str.ubstring(int i) 查找索引下标开始到结尾："+str.substring(5));\n        //substring(int i , int j) 获取指定范围字符串\n        System.out.println("str.substring(int i , int j)获取指定范围字符串: "+str.substring(3,6));\n        //trim() 去除多余空格\n        System.out.println("str.trim() 去除多余空格："+str.trim());\n        //replace(char str1,char str2) 字符串/字符替换\n        System.out.println("str.replace(char str1,char str2) 字符串/字符替换(javas)："+str.replace("Java","javas"));\n        //startsWith(String p) 匹配字符\n        System.out.println("str.startsWith(String p) 匹配字符(java)："+str.startsWith("java"));\n        //endsWith(String p) 匹配后缀字符串\n        System.out.println("str.endsWith(String p) 匹配后缀字符串(java): "+str.endsWith("java"));\n        //equals(String str2) 判断是否相同\n        System.out.println("str2.equals(String str2) 判断是否相同(Sanscan) :"+str2.equals("Sanscan"));\n        //equalsIgnoreCase(String str2) 判断是否相同\n        System.out.println("str2.equalsIgnoreCase(String str2)判断是否相同(Sanscan)："+str2.equalsIgnoreCase("Sanscan"));\n        //compareTo(String o) 比较顺序\n        System.out.println("str2.compareTo(String o)  比较顺序(sans)："+str2.compareTo("sans"));\n        //toLowerCase() 转换小写\n        System.out.println("str.toLowerCase() 转换小写："+str.toLowerCase());\n        //toUpperCase() 转换大写\n        System.out.println("str.toUpperCase() 转换大写： "+str.toUpperCase());\n        //split(String sign) 分割字符串\n        System.out.println("str.split(String sign) 分割字符串192.168.0.1："+ str3.split("\\\\."));\n        //split(String sign ,int i) 分割字符串指定数量\n        System.out.println("str.split(String sign) 分割字符串192.168.0.1："+ str3.split("\\\\.", 2));\n        //append(content)添加数据\n        System.out.println("str4.append(content)添加数据(Java)："+str4.append("Java"));\n        //insert(int i , String str2) 插入数据\n        System.out.println("str4.insert(int i , String str2) 插入数据(Java)："+str4.insert(2,"Java"));\n        //delete(int i , int j) 删除字符串\n        System.out.println("str4.delete(int i , int j) 删除字符串："+str4.delete(1,5));\n        long no2 = System.currentTimeMillis();\n        System.out.println("代码运行了："+(no2-no1));\n}\n\n/* 运行结果\n\nstr：I love Java  20.06.05   !!! , or not love Java\nstr2：Sanscan\n\nstr.length() 测长度：46\nstr.inexOf(String s)找Java字符串位置：7\nstr.lastIndexOf(String s)找参数最后出现的位置：42\nstr.charAt(int i)查找索引下标：J\nstr.ubstring(int i) 查找索引下标开始到结尾：e Java  20.06.05   !!! , or not love Java\nstr.substring(int i , int j)获取指定范围字符串: ove\nstr.trim() 去除多余空格：I love Java  20.06.05   !!! , or not love Java\nstr.replace(char str1,char str2) 字符串/字符替换(javas)：I love javas  20.06.05   !!! , or not love javas\nstr.startsWith(String p) 匹配字符(java)：false\nstr.endsWith(String p) 匹配后缀字符串(java): false\nstr2.equals(String str2) 判断是否相同(Sanscan) :true\nstr2.equalsIgnoreCase(String str2)判断是否相同(Sanscan)：true\nstr2.compareTo(String o)  比较顺序(sans)：-32\nstr.toLowerCase() 转换小写：i love java  20.06.05   !!! , or not love java\nstr.toUpperCase() 转换大写： I LOVE JAVA  20.06.05   !!! , OR NOT LOVE JAVA\nstr.split(String sign) 分割字符串192.168.0.1：[Ljava.lang.String;@cc34f4d\nstr.split(String sign) 分割字符串192.168.0.1：[Ljava.lang.String;@17a7cec2\nstr4.append(content)添加数据(Java)：SanscanJava\nstr4.insert(int i , String str2) 插入数据(Java)：SaJavanscanJava\nstr4.delete(int i , int j) 删除字符串：SanscanJava\n代码运行了：5\n\n*/\n\n\n\n# Array\n\n修饰                  方法                                                      参数        说明\nstatic void         sort(Object[] a)                                        1. 数组     升序排列数组\nstatic Object[]     copyOf(Object[] o , int count)                          1. 数组     复制数组\n                                                                            2. 长度\nstatic Object[]     copyOfRange(Object [] o , int head , int tail)          1. 数组     范围复制数组\n                                                                            2. 开始范围\n                                                                            3. 截止范围\nstatic int (下标索引)   binarySearch(Object[] o , Object key)                   1. 数组     数组查询\n                                                                            2. 查找的值\nstatic int (下标索引)   binarySearch(Object[] o , int i , int j , Object key)   1. 数组     数组范围查询\n                                                                            2. 开始范围\n                                                                            3. 截止范围\n                                                                            4. 查找的值\n\n\n# Math\n\nMath类提供了数学函数方法。不用实例调用，静态应用即可\n\nMath 包含有\n\n * 三角函数方法\n * 指数函数方法\n * 取整函数方法\n * 最大、最小、绝对值函数方法\n * ....\n\n\n# 随机数\n\nMath类中的 random() 方法，用于产生随机数字，生成 [0,1) 之间的 double随机数\n\n控制Math类生成随机数范围的方法\n\n 1. ==Math.random()*m==\n 2. ==0*m <= 随机值 * m < 1 * m==\n 3. ==0 <= 随机值 < m==\n\n\n# Random\n\nRandom类，Random对象创建随机数生成器\n\n常用生成对随机数的方法\n\n修饰符   方法                 说明\nint   nextInt()          生成随机 整型\nint   nextInt(int n)     生成随机 整型 范围 [0,n)\nE     ==next<类型名称>()==   根据类型名称进行随机生成\n\n\n# BigInteger\n\nBigInteger类 可以准确地表示任何大小的整型而不会丢失数据\n\n构造方法\n\n构造方法                     说明\nBigInteger(String val)   十进制字符串实例\n····                     \n\n常用方法\n\n返回           方法                          说明\nBigInteger   abs()                       获取 绝对值\nBigInteger   add(BigInteger val)         加法\nBigInteger   subtract(BigInteger val)    减法\nBigInteger   mulitply(BigInteger val)    乘法\nBigInteger   divide(BigInteger val)      除法\nBigInteger   remainder(BigInteger val)   取余\n···          ···                         ···\n\n\n# BigDecimal\n\nBigDecimal类 可以高精度浮动运算，支持任何精度的定点数\n\n构造方法\n\n构造方法                     说明\nBigDecimal(String val)   根据 String 进行转化 BigDecimal\nBigDecima(double val)    根据 double 进行转化 BigDecimal\n\n常用方法\n\n返回                 方法                     说明\nstatic BigDecima   valueOf(double val)    获取 BigDecima对象，指定浮点\nBigDecimal         add(double val)        加法\nBigDecimal         subtract(double val)   减法\nBigDecimal         multiply(double val)   乘法\nBigDecimal         divide(double val)     除法\n\n\n# Date\n\nDate 类主要封装了系统的日期和时间的信息\n\n构造方法\n\n构造方法              说明\nDate()            分配 Date对象\nDate(long date)   根据时间戳 分配Date对象\n\n方法\n\n返回        方法                            说明\nboolean   after(Date when)              判断此日期是否在 指定日期 之后\nboolean   before(Date when)             判断此日期是否在 指定日期 之前\nint       compareTo(Date anotherDate)   比较两个日期的顺序（原理类似相减时间戳进行判断顺序\nlong      getTime()                     获取 对象的时间戳\n\n\n# Calendar\n\nCalendar 类是一个抽象类，该类 会根据系统的日历来解释 Date 对象。\n\n该类不能被new实例应用，需要 ==Calendar.getInstance()== 静态方法进行获取对象\n\n应用大致：\n\n 1. 获取 Calendar 对象 (通过该类的静态方法进行获取)\n 2. 设置 指定时间 （如set指定新时间等\n 3. 改变时间的方法 set()/add()/roll() PS：注意参数通常是 常量 和 指定变化的数值\n 4. 通过 getTime() 返回Date对象\n\n常用常量\n\n常量             说明\nYEAR           年份\nMONTH          月份\nDATE           日期\nDAY_OF_MONTH   日期\nHOUR           12小时制\nHOUR_OF_DAY    24小时制\nMINUTE         分钟\nSECOND         秒\nDAY_OF_WEEK    星期几\n\n方法\n\n返回                方法                                                      描述\nvoid              add(int field, int amount)                              更变 日历字段 field 添加/减去 指定的时间量\nboolean           after(Object when)                                      判断 Calendar 是否为 when 之后的时间\nboolean           before(Object when)                                     判断 Calendar 是否为 when 之前的时间\nvoid              clear()                                                 清空 Calendar 中的日期时间值\nint               compareTo(Calendar anotherCalendar)                     比较 两个 Calendar对象表示的时间值，大则返回 1，小则返回 -1，相等返回 0\nint               get(int field)                                          获取 指定日历字段 field 的值\nint               getActualMaximum(int field)                             获取 指定日历字段 field 的最大值\nint               getActualMinimum(int field)                             获取 指定日历字段 field 的最大值\nstatic Calendar   getInstance()                                           使用默认时区和语言坏境获得一个日历\nDate              getTime()                                               获取 Calendar 时间值的 Date 对象\nlong              getTimeInMillis()                                       获取 Calendar 时间值的 时间戳\nvoid              set(int field, int value)                               为指定的日历字段设置给定值\nvoid              set(int year, int month, int date)                      设置 Calendar 时间值，以参数的 年月日\nvoid              set(int year, int month, int date, int hourOfDay, int   设置 Calendar 时间值，以参数的 年月日时分秒\n                  minute, int second)\nvoid              setTimeInMillis(long millis)                            设置 Calendar 时间值，根据参数的时间戳\n\n\n# Format\n\nFormat 是格式化模板的父类\n\n\n# DecimalFormat\n\nDecimalFormat 用于格式化十进制数字，该类有特殊字符 构成的格式化模板，是数字会按照特殊字符规则进行匹配\n\n应用大致：\n\n 1. 获取对象\n 2. 指定 需要格式化的模板 （设置模板 new参数/applyPattern()方法\n 3. 获取格式化后的字符串，通过 format() 指定格式化对象\n\n特殊字符\n\n字符       说明\n0        一个数字，不存在则显示0\n#        一个数字，存在则显示，否则不显示\n.        小数分隔符或货币小数分隔符\n-        符号\n,        分组分隔符\nE        分隔科学计数法中的尾数和指数\n%        存在数字的前缀或后缀，乘100显示百分数\n\\u2030   存在数字的前缀或后缀，乘1000显示千分数\n\\u00A4   存在数字的前缀或后缀，显示货币记号\n‘        视为普通单引号处理\n\n构造方法\n\n构造方法                            说明\nDecimalFormat()                 -\nDecimalFormat(String pattern)   指定 pattern模板 实例\n\n常用方法\n\n返回     方法                             说明\nvoid   applyPattern(String pattern)   指定 pattern 为模板\n字符串    format()                       格式化对象以字符串生成\n\n\n# DateFormat\n\nDateFormat 是 日期/时间 格式化子类的抽象类，以与语言无关的方式格式化并解析 日期/时间\n\n该类不能被new实例应用，需要 ==DateFormat.getDateInstance()== 静态方法进行获取对象\n\n返回                  方法                      描述\nstatic DateFormat   getDateInstance()       获取 DateFormat 对象\n                                            格式：yyyy-MM-dd\nstatic DateFormat   getTimeInstance()       获取 DateFormat 对象\n                                            格式：HH:mm:ss\nstatic DateFormat   getDateTimeInstance()   获取 DateFormat 对象\n                                            格式：yyyy-MM-dd HH:mm:ss\nString              format(Date date)       获取 指定 Date 格式化日期字符串\nCalendar            getCalendar()           获取 此日期/时间格式相关联的日历\nDate                parse(String source)    获取 指定 String 字符串解析成 日期/时间\n                                            格式：yyyy-MM-dd HH:mm:ss (前提要对应模板)\n\n\n# SimpleDateFormat\n\nSimpleDateFormat 以与语言环境有关的方式来格式化和解析日期的具体类，格式/解析 均可操作\n\n常量\n\n字母   含义       示例\ny    年份       yy 表示的年扮，如 11； 使用 yyyy 表示的年份，如 2011\nM    月份       MM 表示的月份，如 05\nd    天数       dd 表示的天数，如 10\nD    年份中的天数   D 表示的年份中的天数，如 295\nE    星期几      E 表示星期几\nH    小时数24制   HH 表示的小时数，如 18\nh    小时数12制   hh 表示的小时数，如 10 (无上下午区分)\nm    分钟数      mm 表示的分钟数，如 29\ns    秒数       ss 表示的秒数，如 38\nS    毫秒数      SSS 表示的毫秒数，如 156\n\n构造方法\n\n构造方法                               说明\nSimpleDateFormat()                 -\nSimpleDateFormat(String pattern)   指定 pattern模板 实例\n\n方法\n\n返回       方法                             说明\nvoid     applyPattern(String pattern)   指定 pattern 为模板\n字符串      format()                       格式化对象以字符串生成\nString   toPattern()                    获取 pattern模板\nDate     parse()                        获取 指定模板 解析成 Date',normalizedContent:'# java api\n\n包装类         最小值             最大值             字节数\ninteger     -2^31           2^31 -1         4\ncharacter   0               65536           2\nfloat       -               -               4\ndouble      -               -               8\nboolean     -               -               1\nbyte        -128(-2^7)      127 (2^7-1)     1\nshort       -32768(-2^15)   32767(2^15-1)   2\nlong        -2^63           2^63-1          8\n\nnumber： integer、short、long、double、float、byte都是number的子类表示是一个数字\n\n\n# 装箱和拆箱操作\n\n将一个基本数据类型变为包装类，那么这样的操作称为 装箱操作 将一个包装类变为一个基本数据类型，这样的操作称为 拆箱操作\n\n/*过时的*/\nint temp = 10 ; // 基本数据类型\ninteger x = new integer(temp) ; // 将基本数据类型变为包装类\n/*jdk1.5 后 ，新版自动拆装箱*/\n// 自动装箱\nfloat f = 10.3f ;\ninteger i = 200;\n// 自动拆箱\nfloat x = f ;\nint j = i;\n\n\n\n# object\n\nobject是所有类的父类\n\n如果一个类没有继承有其他类，则默认继承object类\n\n常用方法\n\n返回        方法                   说明\n类<?>      getclass()           获取 此运行时的object类\nint       hashcode()           获取 对象的哈希码值\nstring    tostring()           返回 对象的字符串形式 (一般是 属性/地址)\nboolean   equals(object obj)   比较 参数对象是否与此对象相同\n\n\n# integer\n\ninteger构造方法\n\ninteger(int number)\n\ninteger(string str)\n\n以上有两种方式获取 integer对象\n\ninteger常量\n\ninteger.max_value 返回int型的最大值\n\ninteger.min_value 返回int型的最小值\n\ninteger.size 用二进制补码形式表示 int位数\n\ninteger.type 基本类型int\n\npublic static void main(string[] args) {\n    system.out.println("int最大值(max)："+integer.max_value);\n    system.out.println("int最小值(min)："+integer.min_value);\n    system.out.println("max："+integer.size);\n    system.out.println("max："+integer.type);\n}\n\n/*\n\nint最大值(max)：2147483647\nint最小值(min)：-2147483648\nmax：32\nmax：int\n\n*/\n\n\n\ninteger方法\n\ninteger.bytevalue() 以 byte类型 返回\n\ninteger.compareto(integer i) 比较是否相同，两值相同则返回 0，对象小于 参数i 返回负值，否则为正值\n\ninteger.intvalue() 以 int类型 返回\n\ninteger.shortvalue() 以 short类型 返回\n\ninteger.tostring() 返回 integer值 的 string对象，返回string\n\ninteger.valueof(string str) 返回保存参数的 integer对象\n\ninteger.parseint(string str) 返回参数中的数值\n\npublic class no1 {\n    public static void main(string[] args) {\n        integer n = new integer(12);\n        \n        system.out.println("bytevalue() 以 byte类型 返回(12)："+n.bytevalue());\n        \n        system.out.println("compareto(integer i)比较是否相同(12 v 10)："+n.compareto(10));\n    \n        system.out.println("intvalue()以 int类型 返回："+n.intvalue());\n    \n        system.out.println("shortvalue()以 short类型 返回："+n.shortvalue());\n    \n        string str = new string("123");\n        system.out.println("tostring()返回 integer值 的 string对象："+str.tostring());\n    \n        system.out.println("valueof(string str) 返回保存参数的 integer对象((string)123) : "+n.valueof("123"));\n    \n        system.out.println("parseint(string str) 返回参数中的数值((string)123)："+n.parseint("123"));\n    }\n}\n\n/*\n\nbytevalue() 以 byte类型 返回(12)：12\ncompareto(integer i)比较是否相同(12 v 10)：1\nintvalue()以 int类型 返回：12\nshortvalue()以 short类型 返回：12\ntostring()返回 integer值 的 string对象：123\nvalueof(string str) 返回保存参数的 integer对象((string)123) : 123\nparseint(string str) 返回参数中的数值((string)123)：123\n\n*/\n\n\n\n# boolean\n\nboolean构造方法\n\nboolean(boolean value)\n\nboolean(string str)\n\n以上有两种方式获取 boolean对象\n\nboolean常量\n\nboolean.true 对应基于true的 boolean对象\n\nboolean.false 对应基于false的 boolean对象\n\nboolean.type 基本类型boolean\n\npublic static void main(string[] args) {\n    system.out.println("boolean.true："+boolean.true);\n    system.out.println("boolean.false："+boolean.false);\n    system.out.println("boolean.type："+boolean.type);\n}\n\n/*\n\nboolean.true：true\nboolean.false：false\nboolean.type：boolean\n\n*/\n\n\nboolean方法\n\nboolean.booleanvalue() 将boolean对象的值对应返回 boolean值\n\nboolean.equsla(object obj) 对象相同返回true，否则false\n\nboolean.parseboolean(string s) 参数字符串解析为 boolean值\n\nboolean.tostring() 返回boolean值的string对象，返回string\n\nboolean.valueof(string s) 返回参数boolean值\n\npublic static void main(string[] args) {\n    boolean b1 = new boolean(true);\n    //默认false\n    boolean b2 = new boolean("yes");\n    system.out.println("booleanvalue(b1) : "+b1.booleanvalue());\n    system.out.println("booleanvalue(b2) : "+b2.booleanvalue());\n\n    system.out.println("b1.equsla(b2)："+b1.equals(b2));\n\n    system.out.println("valueof(b1)："+boolean.valueof(b1));\n    system.out.println("valueof(b2)："+boolean.valueof(b2));\n    \n    //string.valueof(b1)：把b1引用的对象字符串化\n    system.out.println("parseboolean(b1)："+boolean.parseboolean(string.valueof(b1)));\n    //string.valueof(b1)：把b2引用的对象字符串化\n    system.out.println("parseboolean(b2)："+boolean.parseboolean(string.valueof(b2)));\n}\n\n/*\n\nbooleanvalue(b1) : true\nbooleanvalue(b2) : false\nb1.equsla(b2)：false\nvalueof(string s)：true\nvalueof(string s)：false\nparseboolean(string s)：true\nparseboolean(string s)：false\n\n*/\n\n\n\n# byte\n\nbyte构造方法\n\nbyte(byte value)\n\nbyte(string str)\n\n以上有两种方式获取 byte对象\n\nbyte常量\n\nbyte.max_value 返回byte型的最大值\n\nbyte.min_value 返回byte型的最小值\n\nbyte.size 用二进制补码形式表示 byte位数\n\nbyte.type 基本类型byte\n\npublic static void main(string[] args) {\n    system.out.println("byte.max："+byte.max_value);\n    system.out.println("byte.min："+byte.min_value);\n    system.out.println("byte.size："+byte.size);\n    system.out.println("byte.type："+byte.type);\n}\n\n/*\n\nbyte.max：127\nbyte.min：-128\nbyte.size：8\nbyte.type：byte\n\n*/\n\n\nbyte方法\n\nbyte.parsebyte(string str) 参数string以byte值返回\n\nbyte.valueof(string str) 参数string以byte对象返回\n\nbyte.equals(object obj) 两个byte对象判断是否相同\n\nbyte.bytevalue() 返回此对象的byte值\n\nbyte.intvalue() 返回此对象的int值\n\nbyte.doublevalue() 返回此对象的double值\n\npublic static void main(string[] args) {\n//        byte be = new byte(12);  过时了\n//        实例化对象的例子需要调用valueof方法\n        byte b = byte.valueof((byte) 12);\n//        或者\n        byte b2 = (byte)12;\n    \n        system.out.println("parsebyte(string str)参数string以byte值返回："+b.parsebyte("23"));\n    \n        system.out.println("valueof(string str)参数string以byte对象返回："+b.valueof("22"));\n    \n        system.out.println("equals(object obj)两个byte对象判断是否相同："+b.equals(b2));\n    \n        system.out.println("bytevalue() 返回此对象的byte值："+b.bytevalue());\n    \n        system.out.println("intvalue()返回此对象的int值："+b.intvalue());\n    \n        system.out.println("doublevalue() 返回此对象的double值："+b.doublevalue());\n    }\n}\n\n/*\n\nparsebyte(string str)参数string以byte值返回：23\nvalueof(string str)参数string以byte对象返回：22\nequals(object obj)两个byte对象判断是否相同：true\nbytevalue() 返回此对象的byte值：12\nintvalue()返回此对象的int值：12\ndoublevalue() 返回此对象的double值：12.0\n\n*/\n\n\n\n# character\n\ncharacter构造方法\n\ncharacter(char value)\n\ncharacter常量\n\ncharacter.connector_punctuation 返回byte型值，表示unicode的常规类别 pc\n\ncharacter.unassigned 返回byte型值，表示unicode的常规类别 cn\n\ncharacter.titlecase_letter 返回byte型值，表示unicode的常规类别 lt\n\ncharacter方法\n\ncharacter.compareto(charcter char) 比较两个对象是否相同，相同则0\n\ncharacter.equals(object obj) 比较两对象的值，返回boolean值\n\ncharacter.touppercase(char ch) 参数字母转化为大写doublevalue()\n\ncharacter.tolowercase(char ch) 参数字母转化为小写\n\ncharacter.tostring() 返回指定的char值的string对象\n\ncharacter.charvalue() 返回character对象的值\n\ncharacter.isuppercase(char ch) 判断参数字符是否是大写\n\ncharacter.islowercase(char ch) 判断参数字符是否是小写\n\npublic static void main(string[] args) {\n        character ch = new character(\'s\');\n        character ch2 = new character(\'s\');\n    \n        system.out.println("compareto(charcter char)比较两个对象是否相同，相同则0："+ch.compareto(ch2));\n        \n        system.out.println("equals(object obj)比较两对象的值，返回boolean值："+ch.equals(ch2));\n    \n        system.out.println("touppercase(char ch)参数字母转化为大写："+character.touppercase(ch));\n    \n        system.out.println("tolowercase(char ch)参数字母转化为小写："+character.tolowercase(ch));\n        \n        system.out.println("tostring()返回指定的char值的string对象："+ch.tostring());\n    \n        system.out.println("charvalue() 返回character对象的值："+ch.charvalue());\n        \n        system.out.println("isuppercase(char ch) 判断参数字符是否是大写(s)："+character.isuppercase(ch));\n        system.out.println("isuppercase(char ch) 判断参数字符是否是大写(s)："+character.isuppercase(ch2));\n        \n        system.out.println("islowercase(char ch) 判断参数字符是否是小写(s)："+character.islowercase(ch));\n        system.out.println("islowercase(char ch) 判断参数字符是否是小写(s)："+character.islowercase(ch2));\n        \n}\n\n/*\n\ncompareto(charcter char)比较两个对象是否相同，相同则0：-32\nequals(object obj)比较两对象的值，返回boolean值：false\ntouppercase(char ch)参数字母转化为大写：s\ntolowercase(char ch)参数字母转化为小写：s\ntostring()返回指定的char值的string对象：s\ncharvalue() 返回character对象的值：s\nisuppercase(char ch) 判断参数字符是否是大写(s)：true\nisuppercase(char ch) 判断参数字符是否是大写(s)：false\nislowercase(char ch) 判断参数字符是否是小写(s)：false\nislowercase(char ch) 判断参数字符是否是小写(s)：true\n\n*/\n\n\n\n# float\n\nfloat 类在对象中包装了一个基本类型 float 的值\n\nfloat构造方法\n\n构造方法                  说明\nfloat(double value)   double 转换为 float\nfloat(float value)    分配新对象\nfloat(string s)       string 转换为 float\n\nfloat常量\n\nmax_value：float 类型的最大值 (1.4e38)\n\nmin_value：float 类型的最小值 (3.4e-45)\n\nmax_exponent: float 变量可能具有的最大指数\n\nmin_exponent：标准化 float 变量可能具有的最小指数\n\nmin_normal：保存 float 类型数值的最小标准值的常量，即 2-126\n\nnan：保存 float 类型的非数字值的常量\n\nsize：用来以二进制补码形式表示 float 值的比特位数\n\ntype：表示基本类型 float 的 class 实例\n\nfloat方法\n\n返回        方法                     说明\nint       intvalue()             强制转换为 int 类型\nlong      longvalue()            强制转换为 long 类型\n··        ··(其他类型用法如此)           ··\nboolean   isnan()                是否为非数字值 nan\nboolean   isnan(float v)         参数是否为非数字值 nan\nfloat     valueof(string s)      string 强转为 float对象\nfloat     parsefloat(string s)   string 强转为 float\n\n\n# double\n\ndouble 类在对象中包装了一个基本类型 double 的值\n\ndouble构造方法\n\n构造方法                   说明\ndouble(double value)   分配新对象\ndouble(string str)     string 转换为 double\n\ndouble常量\n\nmax_exponent 返回int值，double最大指数\n\nmin_exponent 返回int值，double最小指数\n\ntype 基本类型double\n\nsize 用二进制补码形式表示 double位数\n\nnegative_infinity 返回double值，保存double类型的负穷大值\n\npositive_infinity 返回double值，返回double类型的正无穷大值\n\npublic static void main(string[] args) {\n     system.out.println("double.max："+double.max_exponent);\n     system.out.println("double.nin："+double.min_exponent);\n     system.out.println("double.size："+double.size);\n     system.out.println("double.type："+double.type);\n}\n\n/*\n\ndouble.max：1023\ndouble.nin：-1022\ndouble.size：64\ndouble.type：double\n\n*/\n\n\ndouble方法\n\ndouble.bytevalue() 以byte形式返回double对象值\n\ndouble.compareto(double d) 两double对象进行数值比较，相同则0\n\ndouble.equals(object obj) 比较两对象是否相同，返回boolean\n\ndouble.intvalue() 以int形式返回double值\n\ndouble.isnan() 非数字值，则返回true，否则false\n\nstring.tostring() 返回double对象的字符串形式\n\ndouble.valueof(string str) 返回保存参数的double值的对象\n\ndouble.doublevalue() 以double形式返回double对象\n\ndouble.longvalue() 以long形式返回double值\n\ndouble.parsedouble(string str)返回参数中的数值\n\npublic static void main(string[] args) {\n        double d = new double(11.22);\n        double d2 = new double(22);\n        double d3 = new double(11.22);\n        \n        system.out.println("bytevalue() 以byte形式返回double对象值："+d.bytevalue());\n        \n        system.out.println("compareto(double d) 两double对象进行数值比较，相同则0(d2)："+d.compareto(d2));\n        system.out.println("compareto(double d) 两double对象进行数值比较，相同则0(d3)："+d.compareto(d3));\n        \n        system.out.println("equals(object obj)比较两对象是否相同，返回boolean(d2)："+d.equals(d2));\n        system.out.println("equals(object obj)比较两对象是否相同，返回boolean(d3)："+d.equals(d3));\n        \n        system.out.println("intvalue()以int形式返回double值："+d.intvalue());\n        \n        system.out.println("isnan()非数字值，则返回true，否则false(d2)："+d2.isnan());\n        \n        system.out.println("tostring()返回double对象的字符串形式："+d.tostring());\n    \n        system.out.println("valueof(string str)返回保存参数的double值的对象："+d.valueof("22.33"));\n        \n        system.out.println("doublevalue()以double形式返回double对象："+d.doublevalue());\n        \n        system.out.println("longvalue() 以long形式返回double值："+d.longvalue());\n    \n    \tsystem.out.println("parsedouble(string str)返回参数中的数值："+d.parsedouble("33.2"));\n}\n\n/*\n\nbytevalue() 以byte形式返回double对象值：11\ncompareto(double d) 两double对象进行数值比较，相同则0(d2)：-1\ncompareto(double d) 两double对象进行数值比较，相同则0(d3)：0\nequals(object obj)比较两对象是否相同，返回boolean(d2)：false\nequals(object obj)比较两对象是否相同，返回boolean(d3)：true\nintvalue()以int形式返回double值：11\nisnan()非数字值，则返回true，否则false(d2)：false\ntostring()返回double对象的字符串形式：11.22\nvalueof(string str)返回保存参数的double值的对象：22.33\ndoublevalue()以double形式返回double对象：11.22\nlongvalue() 以long形式返回double值：11\nparsedouble(string str)返回参数中的数值：33.2\n\n*/\n\n\n\n# number\n\nnumber数值类是byte、integer、long、float、double、··· 的父类，number的方法子类都可以用！！\n\nnumber方法\n\n方法              返回值      说明\nbytevalue()     byte     以byte形式返回数值\nintvalue()      int      以int形式返回数值\nfloatvalue()    float    以float形式返回数值\nshortvalue()    short    以short形式返回数值\nlongvalue()     long     以long形式返回数值\ndoublevalue()   double   以double形式返回数值\n\npublic static void main(string[] args) {\n     number num = new double(23000.23);\n \n     system.out.println("以byte形式返回数值："+num.bytevalue());\n  \n     system.out.println("以int形式返回数值："+num.intvalue());\n     \n     system.out.println("以float形式返回数值："+num.floatvalue());\n     \n     system.out.println("以short形式返回数值："+num.shortvalue());\n     \n     system.out.println("以long形式返回数值："+num.longvalue());\n     \n     system.out.println("以double形式返回数值："+num.doublevalue());\n }\n\n/*\n\n以byte形式返回数值：-40\n以int形式返回数值：23000\n以float形式返回数值：23000.23\n以short形式返回数值：23000\n以long形式返回数值：23000\n以double形式返回数值：23000.23\n\n*/\n\n\n\n# system\n\nsystem类 代表java运行的平台，系统级的很多属性和控制方法都放置在该类的内部\n\n静态变量\n\n * printstream out ：标准输出流 (用于输出打印\n * inputstream in ：标准输入流 (用于用户输入\n * printstream err ：错误输出流 (用于错误打印\n\n方法\n\n返回                  方法                                                            参数               说明\nstatic void         arraycopy(object src,int srcpos,object dest,int destpos,int   1. 源数组           数组复制，指定源数组中复制一个数组\n                    length)                                                       2. 源数组中的起始位置\n                                                                                  3. 目标数组\n                                                                                  4. 目标数据中的起始位置\n                                                                                  5. 要复制的数组元素的数量\nstatic long         currenttimemillis()                                           -                返回当前时间戳\nstatic void         exit(int status)                                              static - 退出状态    终止jvm\nstatic void         gc()                                                          -                请求垃圾回收\nstatic properties   getproperties()                                               -                获取 当前系统所有数据\nstatic string       getproperty(string key)                                       key - 系统属性       获取 指定的值\n\n系统常见属性\n\n属性名            说明\njava.version   java 运行时环境版本\njava.home      java 安装目录\nos.name        操作系统的名称\nos.version     操作系统的版本\nuser.name      用户的账户名称\nuser.home      用户的主目录\nuser.dir       用户的当前工作目录\n\n\n# string\n\n字符串方法\n\n修饰           方法                              说明\nint          length()                        测长度 ，返回字符串长度\nint          indxof(string s)                找参数的位置，返回参数字符串在字符串首个字符索引位置\nint          lastindexof(string s)           找参数最后出现的位置，返回指定参数的字符串最后一个出现的索引位置\nchar         charat(int i)                   查找索引下标，返回指定索引处的字符\nstring       substring(int i)                查找索引下标开始到结尾，返回指定位置开始到结尾的字符串\nstring       substring(int i , int j)        获取指定范围字符串，返回指定位置范围的字符串\nstring       trim()                          去除多余空格，返回字符串副本，消除多余空格的\nstring       replace(char str1,char str2)    字符串/字符替换，返回字符串副本，指定 字符 / 字符串 替换新的 字符 / 字符串\nboolean      startswith(string p)            匹配前缀字符串，判定字符串前缀是否匹配参数字符串\nboolean      endswith(string p)              匹配后缀字符串，判断字符串后缀是否匹配参数字符串\nboolean      equals(string str2)             判断是否相同，判断字符串与参数字符串的字符和长度是否相同\nboolean      equalsignorecase(string str2)   判断是否相同，比较两个字符串的对象\nint          compareto(string o)             比较顺序，按字典顺序比较两个字符串，参数位置前正，后负，等于0\nstring       tolowercase()                   转换小写，字符串全部转换为小写\nstring       touppercase()                   转换大写，字符串全部转换为大写\nstring[]     split(string sign)              分割字符串，指定分割符对字符串进行拆分\n                                             sign为分割的字符串，也可以是正则表达式\nstring[]     split(string sign , int i)      分割字符串指定数量，指定分割符对字符串进行拆分，并限制拆分数\nappendable   append(content)                 添加数据，字符串后面追加内容，频繁操作时引用，限于stringbuilder对象的使用(16字节)\n                                             content可以是任何数据类型或其他对象\n             insert(int i , string str2)     插入数据，参数索引的后一位插入字符串数据\n             delete(int i , int j)           删除字符串\n\npublic static void main(string[] args) {\n        string str = new string("i love java  20.06.05   !!! , or not love java");\n        system.out.println("str："+str);\n        string str2 = "sanscan";\n        system.out.println("str2："+str2+"\\n");\n        string str3 = "192.168.0.1";\n        stringbuilder str4 = new stringbuilder("sanscan");\n    \n        long no1 = system.currenttimemillis();\n        //length() 测长度\n        system.out.println("str.length() 测长度："+str.length());\n        //inexof(string s)找字符串位置\n        system.out.println("str.inexof(string s)找java字符串位置："+str.indexof("java"));\n        //lastindexof(string s)找参数最后出现的位置\n        system.out.println("str.lastindexof(string s)找参数最后出现的位置："+str.lastindexof("java"));\n        //charat(int i)查找索引下标\n        system.out.println("str.charat(int i)查找索引下标："+str.charat(7));\n        //substring(int i) 查找索引下标开始到结尾\n        system.out.println("str.ubstring(int i) 查找索引下标开始到结尾："+str.substring(5));\n        //substring(int i , int j) 获取指定范围字符串\n        system.out.println("str.substring(int i , int j)获取指定范围字符串: "+str.substring(3,6));\n        //trim() 去除多余空格\n        system.out.println("str.trim() 去除多余空格："+str.trim());\n        //replace(char str1,char str2) 字符串/字符替换\n        system.out.println("str.replace(char str1,char str2) 字符串/字符替换(javas)："+str.replace("java","javas"));\n        //startswith(string p) 匹配字符\n        system.out.println("str.startswith(string p) 匹配字符(java)："+str.startswith("java"));\n        //endswith(string p) 匹配后缀字符串\n        system.out.println("str.endswith(string p) 匹配后缀字符串(java): "+str.endswith("java"));\n        //equals(string str2) 判断是否相同\n        system.out.println("str2.equals(string str2) 判断是否相同(sanscan) :"+str2.equals("sanscan"));\n        //equalsignorecase(string str2) 判断是否相同\n        system.out.println("str2.equalsignorecase(string str2)判断是否相同(sanscan)："+str2.equalsignorecase("sanscan"));\n        //compareto(string o) 比较顺序\n        system.out.println("str2.compareto(string o)  比较顺序(sans)："+str2.compareto("sans"));\n        //tolowercase() 转换小写\n        system.out.println("str.tolowercase() 转换小写："+str.tolowercase());\n        //touppercase() 转换大写\n        system.out.println("str.touppercase() 转换大写： "+str.touppercase());\n        //split(string sign) 分割字符串\n        system.out.println("str.split(string sign) 分割字符串192.168.0.1："+ str3.split("\\\\."));\n        //split(string sign ,int i) 分割字符串指定数量\n        system.out.println("str.split(string sign) 分割字符串192.168.0.1："+ str3.split("\\\\.", 2));\n        //append(content)添加数据\n        system.out.println("str4.append(content)添加数据(java)："+str4.append("java"));\n        //insert(int i , string str2) 插入数据\n        system.out.println("str4.insert(int i , string str2) 插入数据(java)："+str4.insert(2,"java"));\n        //delete(int i , int j) 删除字符串\n        system.out.println("str4.delete(int i , int j) 删除字符串："+str4.delete(1,5));\n        long no2 = system.currenttimemillis();\n        system.out.println("代码运行了："+(no2-no1));\n}\n\n/* 运行结果\n\nstr：i love java  20.06.05   !!! , or not love java\nstr2：sanscan\n\nstr.length() 测长度：46\nstr.inexof(string s)找java字符串位置：7\nstr.lastindexof(string s)找参数最后出现的位置：42\nstr.charat(int i)查找索引下标：j\nstr.ubstring(int i) 查找索引下标开始到结尾：e java  20.06.05   !!! , or not love java\nstr.substring(int i , int j)获取指定范围字符串: ove\nstr.trim() 去除多余空格：i love java  20.06.05   !!! , or not love java\nstr.replace(char str1,char str2) 字符串/字符替换(javas)：i love javas  20.06.05   !!! , or not love javas\nstr.startswith(string p) 匹配字符(java)：false\nstr.endswith(string p) 匹配后缀字符串(java): false\nstr2.equals(string str2) 判断是否相同(sanscan) :true\nstr2.equalsignorecase(string str2)判断是否相同(sanscan)：true\nstr2.compareto(string o)  比较顺序(sans)：-32\nstr.tolowercase() 转换小写：i love java  20.06.05   !!! , or not love java\nstr.touppercase() 转换大写： i love java  20.06.05   !!! , or not love java\nstr.split(string sign) 分割字符串192.168.0.1：[ljava.lang.string;@cc34f4d\nstr.split(string sign) 分割字符串192.168.0.1：[ljava.lang.string;@17a7cec2\nstr4.append(content)添加数据(java)：sanscanjava\nstr4.insert(int i , string str2) 插入数据(java)：sajavanscanjava\nstr4.delete(int i , int j) 删除字符串：sanscanjava\n代码运行了：5\n\n*/\n\n\n\n# array\n\n修饰                  方法                                                      参数        说明\nstatic void         sort(object[] a)                                        1. 数组     升序排列数组\nstatic object[]     copyof(object[] o , int count)                          1. 数组     复制数组\n                                                                            2. 长度\nstatic object[]     copyofrange(object [] o , int head , int tail)          1. 数组     范围复制数组\n                                                                            2. 开始范围\n                                                                            3. 截止范围\nstatic int (下标索引)   binarysearch(object[] o , object key)                   1. 数组     数组查询\n                                                                            2. 查找的值\nstatic int (下标索引)   binarysearch(object[] o , int i , int j , object key)   1. 数组     数组范围查询\n                                                                            2. 开始范围\n                                                                            3. 截止范围\n                                                                            4. 查找的值\n\n\n# math\n\nmath类提供了数学函数方法。不用实例调用，静态应用即可\n\nmath 包含有\n\n * 三角函数方法\n * 指数函数方法\n * 取整函数方法\n * 最大、最小、绝对值函数方法\n * ....\n\n\n# 随机数\n\nmath类中的 random() 方法，用于产生随机数字，生成 [0,1) 之间的 double随机数\n\n控制math类生成随机数范围的方法\n\n 1. ==math.random()*m==\n 2. ==0*m <= 随机值 * m < 1 * m==\n 3. ==0 <= 随机值 < m==\n\n\n# random\n\nrandom类，random对象创建随机数生成器\n\n常用生成对随机数的方法\n\n修饰符   方法                 说明\nint   nextint()          生成随机 整型\nint   nextint(int n)     生成随机 整型 范围 [0,n)\ne     ==next<类型名称>()==   根据类型名称进行随机生成\n\n\n# biginteger\n\nbiginteger类 可以准确地表示任何大小的整型而不会丢失数据\n\n构造方法\n\n构造方法                     说明\nbiginteger(string val)   十进制字符串实例\n····                     \n\n常用方法\n\n返回           方法                          说明\nbiginteger   abs()                       获取 绝对值\nbiginteger   add(biginteger val)         加法\nbiginteger   subtract(biginteger val)    减法\nbiginteger   mulitply(biginteger val)    乘法\nbiginteger   divide(biginteger val)      除法\nbiginteger   remainder(biginteger val)   取余\n···          ···                         ···\n\n\n# bigdecimal\n\nbigdecimal类 可以高精度浮动运算，支持任何精度的定点数\n\n构造方法\n\n构造方法                     说明\nbigdecimal(string val)   根据 string 进行转化 bigdecimal\nbigdecima(double val)    根据 double 进行转化 bigdecimal\n\n常用方法\n\n返回                 方法                     说明\nstatic bigdecima   valueof(double val)    获取 bigdecima对象，指定浮点\nbigdecimal         add(double val)        加法\nbigdecimal         subtract(double val)   减法\nbigdecimal         multiply(double val)   乘法\nbigdecimal         divide(double val)     除法\n\n\n# date\n\ndate 类主要封装了系统的日期和时间的信息\n\n构造方法\n\n构造方法              说明\ndate()            分配 date对象\ndate(long date)   根据时间戳 分配date对象\n\n方法\n\n返回        方法                            说明\nboolean   after(date when)              判断此日期是否在 指定日期 之后\nboolean   before(date when)             判断此日期是否在 指定日期 之前\nint       compareto(date anotherdate)   比较两个日期的顺序（原理类似相减时间戳进行判断顺序\nlong      gettime()                     获取 对象的时间戳\n\n\n# calendar\n\ncalendar 类是一个抽象类，该类 会根据系统的日历来解释 date 对象。\n\n该类不能被new实例应用，需要 ==calendar.getinstance()== 静态方法进行获取对象\n\n应用大致：\n\n 1. 获取 calendar 对象 (通过该类的静态方法进行获取)\n 2. 设置 指定时间 （如set指定新时间等\n 3. 改变时间的方法 set()/add()/roll() ps：注意参数通常是 常量 和 指定变化的数值\n 4. 通过 gettime() 返回date对象\n\n常用常量\n\n常量             说明\nyear           年份\nmonth          月份\ndate           日期\nday_of_month   日期\nhour           12小时制\nhour_of_day    24小时制\nminute         分钟\nsecond         秒\nday_of_week    星期几\n\n方法\n\n返回                方法                                                      描述\nvoid              add(int field, int amount)                              更变 日历字段 field 添加/减去 指定的时间量\nboolean           after(object when)                                      判断 calendar 是否为 when 之后的时间\nboolean           before(object when)                                     判断 calendar 是否为 when 之前的时间\nvoid              clear()                                                 清空 calendar 中的日期时间值\nint               compareto(calendar anothercalendar)                     比较 两个 calendar对象表示的时间值，大则返回 1，小则返回 -1，相等返回 0\nint               get(int field)                                          获取 指定日历字段 field 的值\nint               getactualmaximum(int field)                             获取 指定日历字段 field 的最大值\nint               getactualminimum(int field)                             获取 指定日历字段 field 的最大值\nstatic calendar   getinstance()                                           使用默认时区和语言坏境获得一个日历\ndate              gettime()                                               获取 calendar 时间值的 date 对象\nlong              gettimeinmillis()                                       获取 calendar 时间值的 时间戳\nvoid              set(int field, int value)                               为指定的日历字段设置给定值\nvoid              set(int year, int month, int date)                      设置 calendar 时间值，以参数的 年月日\nvoid              set(int year, int month, int date, int hourofday, int   设置 calendar 时间值，以参数的 年月日时分秒\n                  minute, int second)\nvoid              settimeinmillis(long millis)                            设置 calendar 时间值，根据参数的时间戳\n\n\n# format\n\nformat 是格式化模板的父类\n\n\n# decimalformat\n\ndecimalformat 用于格式化十进制数字，该类有特殊字符 构成的格式化模板，是数字会按照特殊字符规则进行匹配\n\n应用大致：\n\n 1. 获取对象\n 2. 指定 需要格式化的模板 （设置模板 new参数/applypattern()方法\n 3. 获取格式化后的字符串，通过 format() 指定格式化对象\n\n特殊字符\n\n字符       说明\n0        一个数字，不存在则显示0\n#        一个数字，存在则显示，否则不显示\n.        小数分隔符或货币小数分隔符\n-        符号\n,        分组分隔符\ne        分隔科学计数法中的尾数和指数\n%        存在数字的前缀或后缀，乘100显示百分数\n\\u2030   存在数字的前缀或后缀，乘1000显示千分数\n\\u00a4   存在数字的前缀或后缀，显示货币记号\n‘        视为普通单引号处理\n\n构造方法\n\n构造方法                            说明\ndecimalformat()                 -\ndecimalformat(string pattern)   指定 pattern模板 实例\n\n常用方法\n\n返回     方法                             说明\nvoid   applypattern(string pattern)   指定 pattern 为模板\n字符串    format()                       格式化对象以字符串生成\n\n\n# dateformat\n\ndateformat 是 日期/时间 格式化子类的抽象类，以与语言无关的方式格式化并解析 日期/时间\n\n该类不能被new实例应用，需要 ==dateformat.getdateinstance()== 静态方法进行获取对象\n\n返回                  方法                      描述\nstatic dateformat   getdateinstance()       获取 dateformat 对象\n                                            格式：yyyy-mm-dd\nstatic dateformat   gettimeinstance()       获取 dateformat 对象\n                                            格式：hh:mm:ss\nstatic dateformat   getdatetimeinstance()   获取 dateformat 对象\n                                            格式：yyyy-mm-dd hh:mm:ss\nstring              format(date date)       获取 指定 date 格式化日期字符串\ncalendar            getcalendar()           获取 此日期/时间格式相关联的日历\ndate                parse(string source)    获取 指定 string 字符串解析成 日期/时间\n                                            格式：yyyy-mm-dd hh:mm:ss (前提要对应模板)\n\n\n# simpledateformat\n\nsimpledateformat 以与语言环境有关的方式来格式化和解析日期的具体类，格式/解析 均可操作\n\n常量\n\n字母   含义       示例\ny    年份       yy 表示的年扮，如 11； 使用 yyyy 表示的年份，如 2011\nm    月份       mm 表示的月份，如 05\nd    天数       dd 表示的天数，如 10\nd    年份中的天数   d 表示的年份中的天数，如 295\ne    星期几      e 表示星期几\nh    小时数24制   hh 表示的小时数，如 18\nh    小时数12制   hh 表示的小时数，如 10 (无上下午区分)\nm    分钟数      mm 表示的分钟数，如 29\ns    秒数       ss 表示的秒数，如 38\ns    毫秒数      sss 表示的毫秒数，如 156\n\n构造方法\n\n构造方法                               说明\nsimpledateformat()                 -\nsimpledateformat(string pattern)   指定 pattern模板 实例\n\n方法\n\n返回       方法                             说明\nvoid     applypattern(string pattern)   指定 pattern 为模板\n字符串      format()                       格式化对象以字符串生成\nstring   topattern()                    获取 pattern模板\ndate     parse()                        获取 指定模板 解析成 date',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Java三大特性",frontmatter:{title:"Java三大特性",date:"2020-02-18T00:00:00.000Z",permalink:"/backend/39ibdm",categories:["后端","Java基础"],tags:["Java"],author:"柏竹"},regularPath:"/01.%E5%90%8E%E7%AB%AF/01.Java%E5%9F%BA%E7%A1%80/04.%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7.html",relativePath:"01.后端/01.Java基础/04.三大特性.md",key:"v-1232d768",path:"/backend/39ibdm/",headers:[{level:2,title:"继承",slug:"继承",normalizedTitle:"继承",charIndex:15},{level:3,title:"方法重写Oveeride",slug:"方法重写oveeride",normalizedTitle:"方法重写oveeride",charIndex:211},{level:3,title:"Object类",slug:"object类",normalizedTitle:"object类",charIndex:1541},{level:3,title:"instanceof关键字",slug:"instanceof关键字",normalizedTitle:"instanceof关键字",charIndex:3251},{level:2,title:"多态",slug:"多态",normalizedTitle:"多态",charIndex:4007},{level:3,title:"对象类型的转换",slug:"对象类型的转换",normalizedTitle:"对象类型的转换",charIndex:4045},{level:4,title:"向上转型",slug:"向上转型",normalizedTitle:"向上转型",charIndex:4056},{level:4,title:"向下转型",slug:"向下转型",normalizedTitle:"向下转型",charIndex:4165},{level:3,title:"方法重载Overload",slug:"方法重载overload",normalizedTitle:"方法重载overload",charIndex:5230},{level:2,title:"封装",slug:"封装",normalizedTitle:"封装",charIndex:6682},{level:2,title:"抽象类",slug:"抽象类",normalizedTitle:"抽象类",charIndex:6910},{level:3,title:"抽象方法",slug:"抽象方法",normalizedTitle:"抽象方法",charIndex:6974},{level:2,title:"接口",slug:"接口",normalizedTitle:"接口",charIndex:3725},{level:3,title:"接口和抽象类的区别",slug:"接口和抽象类的区别",normalizedTitle:"接口和抽象类的区别",charIndex:9786},{level:2,title:"三大特性的总结",slug:"三大特性的总结",normalizedTitle:"三大特性的总结",charIndex:10056}],headersStr:"继承 方法重写Oveeride Object类 instanceof关键字 多态 对象类型的转换 向上转型 向下转型 方法重载Overload 封装 抽象类 抽象方法 接口 接口和抽象类的区别 三大特性的总结",content:'# Java三大特性\n\n\n# 继承\n\n子类可以继承父类原有的 属性 和 方法，也可以增加父类没有的属性和方法，还可以重写父类中的某些方法，继承应用的关键字：extends\n\n继承特性说明：\n\n * 继承关系信息的传递\n * 降低功能和属性复用\n * 父类方法重写以及修饰权限的访问\n * 多父类的继承\n * 继承关系中 子类只能继承一个父类，不能继承多个父类\n * 子类可以覆盖父类方法，而且还可以覆盖父类的属性\n\n\n# 方法重写Oveeride\n\n方法重写在子父类中发生的，子类修改父类方法，名字必须相同返回类型也必须一致\n\n注意：\n\n * 父类用 final/static 关键字声明的方法不能被子类进行重写\n * 构造方法不能被重写\n\n示例：\n\npublic class Demo {\n    public static void main(String[] args) {\n        \n        Animals ton = new Dog("Dog(狗)");\n        System.out.println(ton.move());\n        \n        Animals Jak = new Rabbit("Rabbit(兔子)");\n        System.out.println(Jak.move());\n    \n        Animals Yin = new Eagle("Eagle(鹰)");\n        System.out.println(Yin.move());\n        \n    }\n}\n\n//动物类\nclass Animals {\n    String type;\n    public Animals(String type){\n        this.type = type;\n    }\n    //移动的方法\n    public String move(){\n        return(type+"的移动方式：");\n    }\n}\n\n//狗类 继承 动物类\nclass Dog extends Animals{\n    public Dog(String type) {\n        super(type);\n    }\n    \n    @Override\n    //重写移动方法\n    public String move(){\n        return (super.move()+"跑");\n    }\n}\n\n//兔子类 继承 动物类\nclass Rabbit extends Animals{\n    public Rabbit(String type) {\n        super(type);\n    }\n    \n    @Override\n    //重写移动方法\n    public String move(){\n        return (super.move()+"跳");\n    }\n}\n\n//鹰类 继承 动物类\nclass Eagle extends Animals{\n    public Eagle(String type) {\n        super(type);\n    }\n    \n    @Override\n    //重写移动方法\n    public String move(){\n        return (super.move()+"飞翔");\n    }\n}\n\n/* 运行结果\n\nDog(狗)的移动方式：跑\nRabbit(兔子)的移动方式：跳\nEagle(鹰)的移动方式：飞翔\n\n*/\n\n\n\n# Object类\n\nObject类是所有类的父类，是最顶层的类，定义类时可省略 extends Object 关键字 ，任何类都可以重写Object类中的方法\n\nObject方法\n\nObject.getClass()  返回对象执行时的Class实例\n\nObject.toString()  以字符串形式返回对象\n\nObject.equals(Object val)  比较两对象的引用是否相等（内容）\n\n> equals（）方法比较内容，== 比较对象引用的地址\n\n以下代码 Object方法测试\n\npublic class Demo{\n    public static void main(String[] args) {\n        Object[] arr = new Object[4];\n        arr[0] = new Object();\n        arr[1] = new String("字符串");\n        arr[2] = new Demo();\n        arr[3] = new Integer(12);\n        \n        //getClass()方法\n        System.out.println("---------getClass()方法--------");\n        for(Object tmp : arr){\n            System.out.println(tmp.getClass()); }\n        System.out.println();\n    \n        //toString()方法\n        System.out.println("---------toString()方法--------");\n        for(Object tmp : arr){\n            System.out.println(tmp.toString()); }\n        System.out.println("-----------------");\n        for(Object tmp : arr){\n            System.out.println(tmp); }\n        System.out.println();\n    \n        //equals()方法\n        Object no1 = new Integer(12);\n        Object no2 = new String("12");\n        Object no3 = new Integer(12);\n        System.out.println("---------equals()方法--------");\n        System.out.println(no1.equals(12));\n        System.out.println(no1.equals(no3));\n        System.out.println(no1.equals(arr[3]));\n        System.out.println(no1.equals(no2));\n    }\n}\n\n\n运行结果\n\n---------getClass()方法--------\nclass java.lang.Object\nclass java.lang.String\nclass Demo\nclass java.lang.Integer\n\n---------toString()方法--------\njava.lang.Object@10f87f48\n字符串\nDemo@b4c966a\n12\n-----------------\njava.lang.Object@10f87f48\n字符串\nDemo@b4c966a\n12\n\n---------equals()方法--------\ntrue\ntrue\ntrue\nfalse\n\n\n\n# instanceof关键字\n\ninstanceof关键字 是判断 指定子类是否继承该父类\n\nBoolean bool = A instanceof B\n// A 继承 B =》bool = true \n// A 不继承 B =》bool = false\n\n\n示例：\n\nclass A{ }\n\nclass B extends A{ }\n\nclass C extends B implements E{ }\n\ninterface E{ }\n\npublic class Demo {\n    public static void main(String[] ars) {\n        C c = new C();\n        System.out.println("c是否继承A父类?"+(c instanceof A));\n        \n        System.out.println("c是否继承B父类?"+(c instanceof B));\n        \n        System.out.println("c是否调用E接口?"+(c instanceof E));\n        \n        B b = new B();\n        System.out.println("\\nb是否继承C父类?"+(b instanceof C));\n        \n        System.out.println("b是否继承A父类?"+(b instanceof A));\n    }\n}\n\n/* 运行结果\n\nc是否继承A父类?true\nc是否继承B父类?true\nc是否调用E接口?true\n\nb是否继承C父类?false\nb是否继承A父类?true\n\n*/\n\n\n\n# 多态\n\n多态可以根据不同类在同一变量，同一方法，执行结果不同的作用\n\n\n# 对象类型的转换\n\n# 向上转型\n\n向上转型是子类对象赋值给父类类型的变量 （子类 → 父类）\n\nclass A {}\nclass B extends A{}\n// 测试主方法\nmain(){\n   A b = new B();\n}\n\n\n# 向下转型\n\n向下转型是将比较抽象的类转换为较具体的类（父类 → 子类）\n\n> 转换的前提继承父类的子类必须是它本身\n\nclass A {}\nclass B extends A{}\n// 测试主方法\nmain(){\n   A b = new B();\n    //向下转型\n   B b = (B) b;\n}\n\n\n注意：\n\n> 编译 参考父类是否存在指定成员 成员方法：\n> \n>  * 编译时，参考父类是否存在该方法，有则成功，没有则失败\n>  * 运行时，参考子类重写的方法\n> \n> 成员变量：\n> \n>  * 编译时，参考父类是否有该变量，有则成功，没有则失败\n>  * 运行时，运行出的结果是父类的成员变量\n\n实例：\n\npublic class Demo {\n    public static void main(String[] args) {\n        \n        A a  = new A();\n        System.out.println(a.a); //4\n        System.out.println(a.test());  //BB\n    \n        System.out.println();\n        \n        // 向上转型输出情况\n        A b = new B();\n        System.out.println(b.a); //4\n        System.out.println(b.test());  //BB\n    \n        System.out.println();\n        \n        // 向下转型输出情况\n        B b1 = (B)b;\n        System.out.println(b1.a); //5\n        System.out.println(b1.test()); //BB\n        \n    }\n}\n\nclass A{\n    int a = 4;\n    public String test(){\n        return "AA";\n    }\n}\nclass B extends A{\n    int a = 5;\n    @Override\n    public String test() {\n        return "BB";\n    }\n}\n\n/* 运行结果\n\n4\nAA\n\n4\nBB\n\n5\nBB\n\n*/\n\n\n\n# 方法重载Overload\n\n方法重载是在同一个类中允许多个同名方法，只要方法参数的形参不同即可！\n\n满足不同的条件：\n\n * 参数个数的不同\n * 参数顺序的不同\n * 参数类型的不同\n * ...定义不定长的参数个数\n\n示例：\n\npublic class Demo {\n    public static void main(String[] args) {\n        Demo d = new Demo();\n        long a =1;\n        \n        d.method(1);\n        d.method(1,2);\n        d.method(1,a);\n        d.method(a,1);\n        d.method(1,2,3,4,5,6,7,8);\n        d.method(a,2,3,4,5,6,7,8);\n    }\n    \n    public void method(int a){\n        System.out.println("调用了method( int )的方法");\n    }\n    \n    //参数个数的不同\n    public void method(int a,int b){\n        System.out.println("调用了method( int , int )的方法");\n    }\n    \n    //参数类型的不同\n    public void method(int a,long b){\n        System.out.println("调用了method( int , long )的方法");\n    }\n    \n    //参数顺序的不同\n    public void method(long a,int b){\n        System.out.println("调用了method( long , int )的方法");\n    }\n    \n    //不定长度参数方法\n    public void method(int... a){\n        System.out.println("调用了method(int...)的方法");\n        for (int tmp : a){\n            System.out.print(tmp+"\\t"); }\n        System.out.println();\n    }\n    \n    public void method(long b, int... a){\n        System.out.println("调用了method(long,int...)的方法");\n        for (int tmp : a){\n            System.out.print(tmp+"\\t"); }\n    }\n   \n}\n\n/* 运行结果\n\n调用了method( int )的方法\n调用了method( int , int )的方法\n调用了method( int , long )的方法\n调用了method( long , int )的方法\n调用了method(int...)的方法\n1\t2\t3\t4\t5\t6\t7\t8\t\n调用了method(long,int...)的方法\n2\t3\t4\t5\t6\t7\t8\t\n\n*/\n\n\n\n# 封装\n\n封装是将类的某些信息隐藏在类的内部，不许外部直接访问，只能通过类提供的方法实现隐藏细节，对外提供访问，便于使用者调用\n\n特点：\n\n * 避免外部类直接访问\n * 隐藏实现细节\n * 提供接口外部访问\n * 提高代码的复用率\n * 封装的属性私有\n * private 修饰的类属性，访问需要通过封装的方法进行访问类的属性\n\n> 外部不能通过 ==类.成员属性== 进行访问 private 修饰的属性。如果应用需要通过 方法返回 进行使用\n\n\n# 抽象类\n\n抽象类 一般定义在父类，用来进行 继承和多态 的处理，该抽象类不能被 new实例化，需要子类具体化\n\n特点：\n\n * 抽象方法和抽象类 都是需要 abstract 修饰的\n * 抽象类不能被 new实例化\n * 只有被子类继承才有存在的意义\n\n定义抽象类 的关键字 abstract\n\npublic abstract class Text {\t}\n\n\n\n# 抽象方法\n\n抽象方法没有方法体，本身是没有意义，需要被继承，子类必须重写且具体化重写的方法\n\n特点：\n\n * 抽象方法只能存在于该类是抽象类的情况\n * 抽象方法存在的意义是被 子类重写\n\npublic abstract class Text {\n\tabstract void textAbstract();\n}\n\n\n以下代码 抽象类和方法的使用\n\npublic class Demo {\n    public static void main(String[] args) {\n        Teachers Tom = new Englishteachers();\n        Teachers Jak = new Mathteachers();\n//        Teachers Tea = new Teachers();\n        \n        Tom.teaching();\n        Jak.teaching();\n    }\n}\n\n//教师抽象类\nabstract class Teachers {\n    //讲课抽象方法\n    public abstract void teaching();\n}\n\n//英语老师 继承 教师抽象类\nclass Englishteachers extends Teachers {\n    @Override\n    //重写讲课方法\n    public void teaching(){\n        System.out.println("英语老师，讲课");\n    }\n}\n\n//数学老师 继承 教师抽象类\nclass Mathteachers extends Teachers {\n    @Override\n    //重写讲课方法\n    public void teaching(){\n        System.out.println("数学老师，讲课");\n    }\n}\n\n/* 运行结果\n\n英语老师，讲课\n数学老师，讲课\n\n*/\n\n\n\n# 接口\n\n接口是抽象类的延伸，能批量设置部分子类独有方法\n\n特点：\n\n * 修饰符默认为 public\n * 定义的变量 只能是 常量\n * 可以继承多个父接口，但类不能 (接口继承使用extends 关键字)\n * 接口没有构造方法\n * 子接口可以重写父接口的 常量和方法\n\n定义接口 的关键字 interface\n\npublic interface Test {\n    void run(); \n}\n\n\n接口 继承与多继承\n\n子接口被调用时，该子接口的父接口全部方法都要继承，都要调用\n\n一个类可以实现多个继承接口，在interface关键字后面逗号分隔即可\n\n示例：\n\ninterface DrawInterface {// 绘制接口\n    public void draw();\n}\n\ninterface Ddc extends DrawInterface{\n    public void cs();\n}\n\ninterface Ddcb {\n    public void csb();\n}\n\npublic class Demo {\n    public static void main(String[] args) {\n        DrawInterface d = new Qua();\n        //调用重写接口方法\n        d.draw();\n    \n        System.out.println("\\n重新测试：");\n        //实例化类本身\n        Qua q = new Qua();\n        //调用类本身的方法\n        q.benshen();\n        //调用重写接口方法\n        q.draw();\n        System.out.println();\n        \n        DrawInterface d2 = new Square();\n        d2.draw();\n        System.out.println();\n        \n        \n        Ddc d3 = new Triangle();\n        d3.draw();\n        d3.cs();\n        \n        //实例对象本身调用接口方法\n        Triangle t = new Triangle();\n        t.csb();\n    }\n}\n\n//三角形类\nclass Triangle implements Ddc ,Ddcb{    //实现多接口继承\n    \n    @Override\n    public void draw() {\n        System.out.println("绘制三角形");\n    }\n    \n    @Override\n    public void cs() {\n        System.out.println("测试继承");\n    }\n    \n    @Override\n    public void csb() {\n        System.out.println("测试继承2");\n    }\n}\n\n//四边形类\nclass Qua implements DrawInterface {\n    @Override\n    public void draw(){\n        System.out.println("绘制四边形");\n    }\n    \n    public void benshen(){\n        System.out.println("我是四边形");\n    }\n}\n\n//正方形类 继承 四边形\nclass Square extends Qua implements DrawInterface {\n    \n    @Override\n    public void draw() {\n        System.out.println("绘制正方形");\n    }\n    \n}\n\n/* 运行结果\n\n绘制四边形\n\n重新测试：\n我是四边形\n绘制四边形\n\n绘制正方形\n\n绘制三角形\n测试继承\n测试继承2\n\n*/\n\n\n\n# 接口和抽象类的区别\n\n 1. 实现方式 抽象类：被子类继承 接口：被类实现\n\n 2. 方法形式 抽象类：可声明 抽象/非抽象 方法 接口：只能声明抽象方法\n\n 3. 声明变量 抽象类：成员变量 接口：只能是公共的静态常量\n\n 4. 类继承&实现形式 抽象类： 一个类只能继承一个父类 接口：一个类可实现多个接口\n\n 5. 静态方法 抽象类： 允许出现静态方法 接口：不允许存在静态方法\n    \n    > PS：静态方法不能被子类重写，因此接口中不能声明静态方法\n\n 6. 构造方法 抽象类： 可以有构造方法 接口：没有构造方法\n\n\n# 三大特性的总结\n\n封装：把对象的属性与方法的实现细节隐藏，仅对外提供一些公共的访问方式\n\n继承：子类会自动拥有父类所有可继承的属性和方法\n\n多态：配合继承与方法重写提高了代码的复用性与扩展性；如果没有方法重写，则多态同样没有意义',normalizedContent:'# java三大特性\n\n\n# 继承\n\n子类可以继承父类原有的 属性 和 方法，也可以增加父类没有的属性和方法，还可以重写父类中的某些方法，继承应用的关键字：extends\n\n继承特性说明：\n\n * 继承关系信息的传递\n * 降低功能和属性复用\n * 父类方法重写以及修饰权限的访问\n * 多父类的继承\n * 继承关系中 子类只能继承一个父类，不能继承多个父类\n * 子类可以覆盖父类方法，而且还可以覆盖父类的属性\n\n\n# 方法重写oveeride\n\n方法重写在子父类中发生的，子类修改父类方法，名字必须相同返回类型也必须一致\n\n注意：\n\n * 父类用 final/static 关键字声明的方法不能被子类进行重写\n * 构造方法不能被重写\n\n示例：\n\npublic class demo {\n    public static void main(string[] args) {\n        \n        animals ton = new dog("dog(狗)");\n        system.out.println(ton.move());\n        \n        animals jak = new rabbit("rabbit(兔子)");\n        system.out.println(jak.move());\n    \n        animals yin = new eagle("eagle(鹰)");\n        system.out.println(yin.move());\n        \n    }\n}\n\n//动物类\nclass animals {\n    string type;\n    public animals(string type){\n        this.type = type;\n    }\n    //移动的方法\n    public string move(){\n        return(type+"的移动方式：");\n    }\n}\n\n//狗类 继承 动物类\nclass dog extends animals{\n    public dog(string type) {\n        super(type);\n    }\n    \n    @override\n    //重写移动方法\n    public string move(){\n        return (super.move()+"跑");\n    }\n}\n\n//兔子类 继承 动物类\nclass rabbit extends animals{\n    public rabbit(string type) {\n        super(type);\n    }\n    \n    @override\n    //重写移动方法\n    public string move(){\n        return (super.move()+"跳");\n    }\n}\n\n//鹰类 继承 动物类\nclass eagle extends animals{\n    public eagle(string type) {\n        super(type);\n    }\n    \n    @override\n    //重写移动方法\n    public string move(){\n        return (super.move()+"飞翔");\n    }\n}\n\n/* 运行结果\n\ndog(狗)的移动方式：跑\nrabbit(兔子)的移动方式：跳\neagle(鹰)的移动方式：飞翔\n\n*/\n\n\n\n# object类\n\nobject类是所有类的父类，是最顶层的类，定义类时可省略 extends object 关键字 ，任何类都可以重写object类中的方法\n\nobject方法\n\nobject.getclass()  返回对象执行时的class实例\n\nobject.tostring()  以字符串形式返回对象\n\nobject.equals(object val)  比较两对象的引用是否相等（内容）\n\n> equals（）方法比较内容，== 比较对象引用的地址\n\n以下代码 object方法测试\n\npublic class demo{\n    public static void main(string[] args) {\n        object[] arr = new object[4];\n        arr[0] = new object();\n        arr[1] = new string("字符串");\n        arr[2] = new demo();\n        arr[3] = new integer(12);\n        \n        //getclass()方法\n        system.out.println("---------getclass()方法--------");\n        for(object tmp : arr){\n            system.out.println(tmp.getclass()); }\n        system.out.println();\n    \n        //tostring()方法\n        system.out.println("---------tostring()方法--------");\n        for(object tmp : arr){\n            system.out.println(tmp.tostring()); }\n        system.out.println("-----------------");\n        for(object tmp : arr){\n            system.out.println(tmp); }\n        system.out.println();\n    \n        //equals()方法\n        object no1 = new integer(12);\n        object no2 = new string("12");\n        object no3 = new integer(12);\n        system.out.println("---------equals()方法--------");\n        system.out.println(no1.equals(12));\n        system.out.println(no1.equals(no3));\n        system.out.println(no1.equals(arr[3]));\n        system.out.println(no1.equals(no2));\n    }\n}\n\n\n运行结果\n\n---------getclass()方法--------\nclass java.lang.object\nclass java.lang.string\nclass demo\nclass java.lang.integer\n\n---------tostring()方法--------\njava.lang.object@10f87f48\n字符串\ndemo@b4c966a\n12\n-----------------\njava.lang.object@10f87f48\n字符串\ndemo@b4c966a\n12\n\n---------equals()方法--------\ntrue\ntrue\ntrue\nfalse\n\n\n\n# instanceof关键字\n\ninstanceof关键字 是判断 指定子类是否继承该父类\n\nboolean bool = a instanceof b\n// a 继承 b =》bool = true \n// a 不继承 b =》bool = false\n\n\n示例：\n\nclass a{ }\n\nclass b extends a{ }\n\nclass c extends b implements e{ }\n\ninterface e{ }\n\npublic class demo {\n    public static void main(string[] ars) {\n        c c = new c();\n        system.out.println("c是否继承a父类?"+(c instanceof a));\n        \n        system.out.println("c是否继承b父类?"+(c instanceof b));\n        \n        system.out.println("c是否调用e接口?"+(c instanceof e));\n        \n        b b = new b();\n        system.out.println("\\nb是否继承c父类?"+(b instanceof c));\n        \n        system.out.println("b是否继承a父类?"+(b instanceof a));\n    }\n}\n\n/* 运行结果\n\nc是否继承a父类?true\nc是否继承b父类?true\nc是否调用e接口?true\n\nb是否继承c父类?false\nb是否继承a父类?true\n\n*/\n\n\n\n# 多态\n\n多态可以根据不同类在同一变量，同一方法，执行结果不同的作用\n\n\n# 对象类型的转换\n\n# 向上转型\n\n向上转型是子类对象赋值给父类类型的变量 （子类 → 父类）\n\nclass a {}\nclass b extends a{}\n// 测试主方法\nmain(){\n   a b = new b();\n}\n\n\n# 向下转型\n\n向下转型是将比较抽象的类转换为较具体的类（父类 → 子类）\n\n> 转换的前提继承父类的子类必须是它本身\n\nclass a {}\nclass b extends a{}\n// 测试主方法\nmain(){\n   a b = new b();\n    //向下转型\n   b b = (b) b;\n}\n\n\n注意：\n\n> 编译 参考父类是否存在指定成员 成员方法：\n> \n>  * 编译时，参考父类是否存在该方法，有则成功，没有则失败\n>  * 运行时，参考子类重写的方法\n> \n> 成员变量：\n> \n>  * 编译时，参考父类是否有该变量，有则成功，没有则失败\n>  * 运行时，运行出的结果是父类的成员变量\n\n实例：\n\npublic class demo {\n    public static void main(string[] args) {\n        \n        a a  = new a();\n        system.out.println(a.a); //4\n        system.out.println(a.test());  //bb\n    \n        system.out.println();\n        \n        // 向上转型输出情况\n        a b = new b();\n        system.out.println(b.a); //4\n        system.out.println(b.test());  //bb\n    \n        system.out.println();\n        \n        // 向下转型输出情况\n        b b1 = (b)b;\n        system.out.println(b1.a); //5\n        system.out.println(b1.test()); //bb\n        \n    }\n}\n\nclass a{\n    int a = 4;\n    public string test(){\n        return "aa";\n    }\n}\nclass b extends a{\n    int a = 5;\n    @override\n    public string test() {\n        return "bb";\n    }\n}\n\n/* 运行结果\n\n4\naa\n\n4\nbb\n\n5\nbb\n\n*/\n\n\n\n# 方法重载overload\n\n方法重载是在同一个类中允许多个同名方法，只要方法参数的形参不同即可！\n\n满足不同的条件：\n\n * 参数个数的不同\n * 参数顺序的不同\n * 参数类型的不同\n * ...定义不定长的参数个数\n\n示例：\n\npublic class demo {\n    public static void main(string[] args) {\n        demo d = new demo();\n        long a =1;\n        \n        d.method(1);\n        d.method(1,2);\n        d.method(1,a);\n        d.method(a,1);\n        d.method(1,2,3,4,5,6,7,8);\n        d.method(a,2,3,4,5,6,7,8);\n    }\n    \n    public void method(int a){\n        system.out.println("调用了method( int )的方法");\n    }\n    \n    //参数个数的不同\n    public void method(int a,int b){\n        system.out.println("调用了method( int , int )的方法");\n    }\n    \n    //参数类型的不同\n    public void method(int a,long b){\n        system.out.println("调用了method( int , long )的方法");\n    }\n    \n    //参数顺序的不同\n    public void method(long a,int b){\n        system.out.println("调用了method( long , int )的方法");\n    }\n    \n    //不定长度参数方法\n    public void method(int... a){\n        system.out.println("调用了method(int...)的方法");\n        for (int tmp : a){\n            system.out.print(tmp+"\\t"); }\n        system.out.println();\n    }\n    \n    public void method(long b, int... a){\n        system.out.println("调用了method(long,int...)的方法");\n        for (int tmp : a){\n            system.out.print(tmp+"\\t"); }\n    }\n   \n}\n\n/* 运行结果\n\n调用了method( int )的方法\n调用了method( int , int )的方法\n调用了method( int , long )的方法\n调用了method( long , int )的方法\n调用了method(int...)的方法\n1\t2\t3\t4\t5\t6\t7\t8\t\n调用了method(long,int...)的方法\n2\t3\t4\t5\t6\t7\t8\t\n\n*/\n\n\n\n# 封装\n\n封装是将类的某些信息隐藏在类的内部，不许外部直接访问，只能通过类提供的方法实现隐藏细节，对外提供访问，便于使用者调用\n\n特点：\n\n * 避免外部类直接访问\n * 隐藏实现细节\n * 提供接口外部访问\n * 提高代码的复用率\n * 封装的属性私有\n * private 修饰的类属性，访问需要通过封装的方法进行访问类的属性\n\n> 外部不能通过 ==类.成员属性== 进行访问 private 修饰的属性。如果应用需要通过 方法返回 进行使用\n\n\n# 抽象类\n\n抽象类 一般定义在父类，用来进行 继承和多态 的处理，该抽象类不能被 new实例化，需要子类具体化\n\n特点：\n\n * 抽象方法和抽象类 都是需要 abstract 修饰的\n * 抽象类不能被 new实例化\n * 只有被子类继承才有存在的意义\n\n定义抽象类 的关键字 abstract\n\npublic abstract class text {\t}\n\n\n\n# 抽象方法\n\n抽象方法没有方法体，本身是没有意义，需要被继承，子类必须重写且具体化重写的方法\n\n特点：\n\n * 抽象方法只能存在于该类是抽象类的情况\n * 抽象方法存在的意义是被 子类重写\n\npublic abstract class text {\n\tabstract void textabstract();\n}\n\n\n以下代码 抽象类和方法的使用\n\npublic class demo {\n    public static void main(string[] args) {\n        teachers tom = new englishteachers();\n        teachers jak = new mathteachers();\n//        teachers tea = new teachers();\n        \n        tom.teaching();\n        jak.teaching();\n    }\n}\n\n//教师抽象类\nabstract class teachers {\n    //讲课抽象方法\n    public abstract void teaching();\n}\n\n//英语老师 继承 教师抽象类\nclass englishteachers extends teachers {\n    @override\n    //重写讲课方法\n    public void teaching(){\n        system.out.println("英语老师，讲课");\n    }\n}\n\n//数学老师 继承 教师抽象类\nclass mathteachers extends teachers {\n    @override\n    //重写讲课方法\n    public void teaching(){\n        system.out.println("数学老师，讲课");\n    }\n}\n\n/* 运行结果\n\n英语老师，讲课\n数学老师，讲课\n\n*/\n\n\n\n# 接口\n\n接口是抽象类的延伸，能批量设置部分子类独有方法\n\n特点：\n\n * 修饰符默认为 public\n * 定义的变量 只能是 常量\n * 可以继承多个父接口，但类不能 (接口继承使用extends 关键字)\n * 接口没有构造方法\n * 子接口可以重写父接口的 常量和方法\n\n定义接口 的关键字 interface\n\npublic interface test {\n    void run(); \n}\n\n\n接口 继承与多继承\n\n子接口被调用时，该子接口的父接口全部方法都要继承，都要调用\n\n一个类可以实现多个继承接口，在interface关键字后面逗号分隔即可\n\n示例：\n\ninterface drawinterface {// 绘制接口\n    public void draw();\n}\n\ninterface ddc extends drawinterface{\n    public void cs();\n}\n\ninterface ddcb {\n    public void csb();\n}\n\npublic class demo {\n    public static void main(string[] args) {\n        drawinterface d = new qua();\n        //调用重写接口方法\n        d.draw();\n    \n        system.out.println("\\n重新测试：");\n        //实例化类本身\n        qua q = new qua();\n        //调用类本身的方法\n        q.benshen();\n        //调用重写接口方法\n        q.draw();\n        system.out.println();\n        \n        drawinterface d2 = new square();\n        d2.draw();\n        system.out.println();\n        \n        \n        ddc d3 = new triangle();\n        d3.draw();\n        d3.cs();\n        \n        //实例对象本身调用接口方法\n        triangle t = new triangle();\n        t.csb();\n    }\n}\n\n//三角形类\nclass triangle implements ddc ,ddcb{    //实现多接口继承\n    \n    @override\n    public void draw() {\n        system.out.println("绘制三角形");\n    }\n    \n    @override\n    public void cs() {\n        system.out.println("测试继承");\n    }\n    \n    @override\n    public void csb() {\n        system.out.println("测试继承2");\n    }\n}\n\n//四边形类\nclass qua implements drawinterface {\n    @override\n    public void draw(){\n        system.out.println("绘制四边形");\n    }\n    \n    public void benshen(){\n        system.out.println("我是四边形");\n    }\n}\n\n//正方形类 继承 四边形\nclass square extends qua implements drawinterface {\n    \n    @override\n    public void draw() {\n        system.out.println("绘制正方形");\n    }\n    \n}\n\n/* 运行结果\n\n绘制四边形\n\n重新测试：\n我是四边形\n绘制四边形\n\n绘制正方形\n\n绘制三角形\n测试继承\n测试继承2\n\n*/\n\n\n\n# 接口和抽象类的区别\n\n 1. 实现方式 抽象类：被子类继承 接口：被类实现\n\n 2. 方法形式 抽象类：可声明 抽象/非抽象 方法 接口：只能声明抽象方法\n\n 3. 声明变量 抽象类：成员变量 接口：只能是公共的静态常量\n\n 4. 类继承&实现形式 抽象类： 一个类只能继承一个父类 接口：一个类可实现多个接口\n\n 5. 静态方法 抽象类： 允许出现静态方法 接口：不允许存在静态方法\n    \n    > ps：静态方法不能被子类重写，因此接口中不能声明静态方法\n\n 6. 构造方法 抽象类： 可以有构造方法 接口：没有构造方法\n\n\n# 三大特性的总结\n\n封装：把对象的属性与方法的实现细节隐藏，仅对外提供一些公共的访问方式\n\n继承：子类会自动拥有父类所有可继承的属性和方法\n\n多态：配合继承与方法重写提高了代码的复用性与扩展性；如果没有方法重写，则多态同样没有意义',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Java类的高级特性",frontmatter:{title:"Java类的高级特性",date:"2020-02-18T00:00:00.000Z",permalink:"/backend/9sun1b",categories:["后端","Java基础"],tags:["Java"],author:"柏竹"},regularPath:"/01.%E5%90%8E%E7%AB%AF/01.Java%E5%9F%BA%E7%A1%80/05.%E7%B1%BB%E7%9A%84%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7.html",relativePath:"01.后端/01.Java基础/05.类的高级特性.md",key:"v-f3615e36",path:"/backend/9sun1b/",headers:[{level:2,title:"类",slug:"类",normalizedTitle:"类",charIndex:6},{level:3,title:"成员变量",slug:"成员变量",normalizedTitle:"成员变量",charIndex:23},{level:3,title:"局部变量",slug:"局部变量",normalizedTitle:"局部变量",charIndex:140},{level:3,title:"成员方法",slug:"成员方法",normalizedTitle:"成员方法",charIndex:300},{level:3,title:"this关键子",slug:"this关键子",normalizedTitle:"this关键子",charIndex:695},{level:3,title:"super关键字",slug:"super关键字",normalizedTitle:"super关键字",charIndex:1093},{level:3,title:"this和super区别",slug:"this和super区别",normalizedTitle:"this和super区别",charIndex:1779},{level:3,title:"构造方法",slug:"构造方法",normalizedTitle:"构造方法",charIndex:1193},{level:2,title:"包",slug:"包",normalizedTitle:"包",charIndex:2041},{level:3,title:"类名冲突",slug:"类名冲突",normalizedTitle:"类名冲突",charIndex:2076},{level:3,title:"完整的类路径",slug:"完整的类路径",normalizedTitle:"完整的类路径",charIndex:2134},{level:3,title:"包的特性",slug:"包的特性",normalizedTitle:"包的特性",charIndex:2321},{level:3,title:"import 导入包",slug:"import-导入包",normalizedTitle:"import 导入包",charIndex:2645},{level:3,title:"import 导入静态成员",slug:"import-导入静态成员",normalizedTitle:"import 导入静态成员",charIndex:2707},{level:2,title:"权限修饰符",slug:"权限修饰符",normalizedTitle:"权限修饰符",charIndex:494},{level:2,title:"final 常量",slug:"final-常量",normalizedTitle:"final 常量",charIndex:3722},{level:3,title:"final变量",slug:"final变量",normalizedTitle:"final变量",charIndex:3806},{level:3,title:"final方法",slug:"final方法",normalizedTitle:"final方法",charIndex:3871},{level:3,title:"final类",slug:"final类",normalizedTitle:"final类",charIndex:3975},{level:3,title:"final 总结",slug:"final-总结",normalizedTitle:"final 总结",charIndex:4353},{level:2,title:"static 静态",slug:"static-静态",normalizedTitle:"static 静态",charIndex:2735},{level:3,title:"静态变量",slug:"静态变量",normalizedTitle:"静态变量",charIndex:4568},{level:4,title:"静态变量与实例变量的区别",slug:"静态变量与实例变量的区别",normalizedTitle:"静态变量与实例变量的区别",charIndex:5311},{level:3,title:"静态方法",slug:"静态方法",normalizedTitle:"静态方法",charIndex:3096},{level:4,title:"静态方法与实例方法的区别",slug:"静态方法与实例方法的区别",normalizedTitle:"静态方法与实例方法的区别",charIndex:6255},{level:2,title:"内部类",slug:"内部类",normalizedTitle:"内部类",charIndex:6387},{level:3,title:"成员内部类",slug:"成员内部类",normalizedTitle:"成员内部类",charIndex:6653},{level:3,title:"局部内部类",slug:"局部内部类",normalizedTitle:"局部内部类",charIndex:8625},{level:3,title:"匿名内部类",slug:"匿名内部类",normalizedTitle:"匿名内部类",charIndex:9590},{level:4,title:"lambda表达式",slug:"lambda表达式",normalizedTitle:"lambda表达式",charIndex:10242},{level:3,title:"静态内部类",slug:"静态内部类",normalizedTitle:"静态内部类",charIndex:10805},{level:3,title:"内部类继承",slug:"内部类继承",normalizedTitle:"内部类继承",charIndex:11638},{level:2,title:"代码块",slug:"代码块",normalizedTitle:"代码块",charIndex:9725},{level:3,title:"局部代码块",slug:"局部代码块",normalizedTitle:"局部代码块",charIndex:12327},{level:3,title:"成员代码块",slug:"成员代码块",normalizedTitle:"成员代码块",charIndex:12381},{level:3,title:"静态代码块",slug:"静态代码块",normalizedTitle:"静态代码块",charIndex:9723},{level:3,title:"代码块的加载顺序",slug:"代码块的加载顺序",normalizedTitle:"代码块的加载顺序",charIndex:12635}],headersStr:"类 成员变量 局部变量 成员方法 this关键子 super关键字 this和super区别 构造方法 包 类名冲突 完整的类路径 包的特性 import 导入包 import 导入静态成员 权限修饰符 final 常量 final变量 final方法 final类 final 总结 static 静态 静态变量 静态变量与实例变量的区别 静态方法 静态方法与实例方法的区别 内部类 成员内部类 局部内部类 匿名内部类 lambda表达式 静态内部类 内部类继承 代码块 局部代码块 成员代码块 静态代码块 代码块的加载顺序",content:'# Java类的高级特性\n\n\n# 类\n\n\n# 成员变量\n\n成员变量是 类中的属性\n\npublic class tuzi {\n    String eat;     //吃\n    String hair;    //毛\n    String jump;  \t//跳\n}\n\n\n\n# 局部变量\n\n局部变量是 方法或{}括号 内定义的变量\n\npublic class jububianliang {\n\tpublic static void main(String[] args) {\n\t\tint i = 2,j = 4;\n\t\tSystem.out.private(max(i,j));\t\n\t}\n    //成员方法\n\tpublic int max(int a , int b ){\n        //局部变量max。max变量限于该方法的范围\n\t\tint max = 0;\n\t\tif(a > b){\n\t\t\tmax = a;\n\t\t\treturn max;\n\t\t}else{\n\t\t\tmax = b;\n\t\t\treturn max;}\n\t}\n}\n\n\n\n# 成员方法\n\n成员方法是 类的功能(行为)\n\n权限修饰符 返回值类型 方法名(参数类型 参数名[,···){\n    ····\t\t//方法体\n    return 返回的值;\n}\n//例子\npublic int max(int a , int b){\n    if(a > b){\n        return a;\n    }else{\n        return b;\n    }\n}\n\n\n> 如果方法返回类型为void，则无返回空\n\n\n# this关键子\n\nthis关键字用于引用对象的成员变量和方法 ，将方法的参数值赋予类本身的成员变量\n\npublic class thsiches {\n    String  str = "abc";\n    public void no1(String str) {\n        //打印 str形参\n        System.out.println("no1："+str);\n        //打印 thsiches类 中的str成员变量\n        System.out.println("no2："+this.str);\n    }\n    public static void main(String[] args) {\n        String str2 = "123";\n        new thsiches().no1(str2);\n    }\n}\n\n\n\n# super关键字\n\nsuper关键字可以调用父类的 属性 和 方法\n\n应方式                       父类成员 属性&方法\nsuper()                   父类构造方法\nsuper.name (name成员变量)     父类的属性（成员变量）\nsuper.run() (run()成员方法)   父类的方法\n\n**注意 : **\n\n * 只要是构造方法都会默认 第一行 为 super(); (不管是什么类，都是Object的父类)\n * 父类有参构造方法需要 super 调用父类构造方法\n * 用 private 修饰的成员，其他类无法 调用和重写\n\nsuper实例：\n\npublic class Demo {\n    public static void main(String[] args) {\n        new B("");\n    }\n}\n\nclass A{\n    String a;\n    // 构造方法\n    public A(String a) {\n        System.out.println("A有参构造方法");\n        this.a = a;\n    }\n}\nclass B extends A{\n    // B构造方法\n    public B(String a) {\n        super(a);\n        System.out.println("B有参构造方法");\n    }\n}\n\n/* 执行结果\n\nA有参构造方法\nB有参构造方法\n\n*/\n\n\n\n# this和super区别\n\nthis : 当前对象的引用 super : 当前对象的父对象的引用\n\n\n# 构造方法\n\n构造器是类的特殊方法，专门用于在类被实例时，定义初始化类的成员属性所使用(无需再次set方法)\n\n构造方法特点\n\n * 没有返回值\n * 方法名与类名相同\n * 没有定义构造方法，会自动生成无参数构造方法\n * 实例化对象，类都会自动调用 构造方法\n * 在无参构造方法 this 调用有参构造方法，则该语句必须为第一个\n * 可重载构造器\n\n重载构造器参数应用\n\n * 参数顺序\n * 参数类型\n\n\n# 包\n\nJava JDK API中提供了类功能，它们封装为类包\n\n\n# 类名冲突\n\nJDK API 中提供的类，在同一类包 同类名 会导致编译器无法执行 ，要把类包分开或更改类名\n\n\n# 完整的类路径\n\n完整的类名需要包名与类名的组合\n\njava.包名.类名\n//例子\njava.lang.String\n\n\n> 如果指定路径不确定可能会翻车，像以下是需要完整路径 ==java.util.Date date = new java.util.Date();== ==java.sql.Date date2 = new java.sql.Date();==\n\n\n# 包的特性\n\n * 把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用\n\n * 包如同文件夹一样，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名 加以区别。因此，包可以避免名字冲突\n\n * 包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类\n\nJava包是为了防止命名冲突，访问控制，提供搜索和定位类、接口、枚举和注释等\n\n没有定义包会自动归纳在预设包（默认包）中，最好为所有类设置包名（良好习惯）\n\npackage 包名.包名...;\n\n\n注意：\n\n * 在类中指定包名时，需要将 package表达式 放在程序的第一行 （非注释\n\n * Java包的命名规则是全部使用小写字母的\n\n\n# import 导入包\n\n引入包可以调用包中的方法，不能调用两包中的同类名，指定包后面有 * ，指定包路径中的所有类\n\n\n# import 导入静态成员\n\n调用指定\n\nimport static 静态成员\n\n\n> 例子：\n> \n> ==java.lang.System== 类中的 out成员变量 ==java.lang.Math== 类中的 max成员方法\n> \n> 它们都是静态成员，这是前提！！！\n\nimport static java.lang.System.*; //导入静态成员方法\nimport static java.lang.Math.*;   //导入静态成员变量\n\npublic class Demo2 {\n    public static void main(String[] args) {\n        //静态成员简写调用\n        out.println("123");\n        System.out.println("123");\n        //静态方法简写调用\n        out.println("max(3,4)?"+max(3,4));\n        out.println("max(3,4)?"+Math.max(3,4));\n    }\n}\n\n/* 运行结果\n\n123\n123\nmax(3,4)?4\nmax(3,4)?4\n\n*/\n\n\n包的使用规则\n\n * 包中Java文件的定义： 在.java文件的首部， 必须编写类所属哪个包\n * 包的定义： 所有包的名称都由小写字母， 单词与单词之间使用 . 隔开 ，一般命名为==com.公司名.项目 名.模块名....==\n * 规范由来： 由于Java面向对象的特性，每名Java开发人员都可以编写属于自己的Java包，为了保障每个Java Package命名的唯一性。由于 互联网上 的域名称是不会重复的，因此很多开发者都会采用自己公司的名称作为前缀。例如： ==com.java.xxx==\n\n\n# 权限修饰符\n\n权限修饰符控制 类/成员变量/成员方法 的访问，不同的权限指定的不同范围\n\n修饰符         类   包   子类   其他包\npublic      √   √   √    √\nprotected   √   √   √    ×\ndefault     √   √   ×    ×\nprivate     √   ×   ×    ×\n\n> 注意： 类不使用修饰符时，则该类预设为包存取范围\n\n\n# final 常量\n\n被final修饰，表明改对象是专一的（不能有第三方）\n\n特点：\n\n * 变量 不能被更改\n\n * 方法 不能被重写\n\n * 类 不能被继承\n\n\n# final变量\n\nfinal 修饰后, 不能更改该变量的值，该变量称为常量！\n\nfinal 数据类型 变量名 = 值;\n\n\n\n# final方法\n\nfinal 修饰的方法 不能 重写\n\nprivate修饰的方法隐式被指定为 final ，可无需添加 final\n\n[修饰符] final 数据类型 方法名([参数]){···}\n\n\n\n# final类\n\n被final修饰的方法类，不能被继承 （跟部分API类类似）\n\nfinal class 类名{···}\n\n\n示例：\n\npublic class Demo {\n    // final修饰变量 测试\n    final int a = 1;\n    // a 变量不能被修改（报红）\n    // a = 2;\n}\n\n// final修饰方法 测试\nclass A{\n    public final void test(){}\n}\nclass B extends A{\n    // A中的test方法 不能继承（报红）\n    // public void test(){}\n}\n\n// final修饰类 测试\nfinal class AA{ }\n// AA 不能被继承（报红）\n// class B extends AA{}\n\n\n\n# final 总结\n\n修饰对象   说明\n变量     变量只能初始化赋值\n方法     方法不能被重写\n类      类不能被继承\n\n\n# static 静态\n\n静态修饰的代码，整个程序运行结束之后才会释放\n\n静态特点：\n\n * 静态的数据都是共享的，其他类调用不需实例化进行应用\n * 静态在内存中永远只有一份，无论有多个对象\n * 静态不能访问非静态，而非静态可访问静态（静态方法）\n * 加载时静态总会优先于非静态\n\n\n# 静态变量\n\n静态变量的共享，在不同类对同一变量可以进行操作\n\npublic class Demo {\n    private static String stu1 = "hello";\n    \n    public static void main(String[] args) {\n        String stu2 = "world";\n        \n        // 直接访问变量\n        System.out.println("直接访问："+stu1+stu2);\n        // 类访问变量\n        System.out.println("通过类访问："+Demo.stu1+stu2);\n        // 通过对象访问变量 (静态被赋值)\n        Demo demo = new Demo();\n        demo.stu1 += stu2;\n        System.out.println("通过对象访问："+demo.stu1);\n        // 通过对象访问变量2 通过相同变量进行测试\n        Demo demo1 = new Demo();\n        System.out.println("通过对象访问："+demo1.stu1+stu2);\n    \n        System.out.println("\\n 静态值为："+stu1);\n    }\n} \n\n/* 运行结果\n\n直接访问：helloworld\n通过类访问：helloworld\n通过对象访问：helloworld\n通过对象访问：helloworldworld\n\n 静态值为：helloworld\n\n*/\n\n\n# 静态变量与实例变量的区别\n\n          静态变量                    实例变量\n内存开辟时期    类加载时                    对象实例时\n内存分配区域    方法独有静态区                 实例对象堆中\n类内部访问变量   类内的任何方法可直接访问            只能访问非静态方法\n类外部访问变量   通过类名进行访问 ==类型.静态变量名==   通过类的实例对象进行访问\n\n\n# 静态方法\n\n静态方法无需创建类的对象\n\npublic class Method {\n    \n    // 静态方法\n    public static void test1() {\n        System.out.println("静态方法");\n    }\n    \n    // 实例方法\n    public void test2() {\n        System.out.println("实例方法");\n    }\n    \n    public static void main(String[] args) {\n        // 静态直接调用\n        System.out.println("静态直接调用！");\n        test1();\n        // test2(); (报红)\n        \n        // 实例对象调用\n        System.out.println("\\n实例对象调用！");\n        Method method = new Method();\n        method.test1();\n        method.test2();\n        \n        // 通过类名调用\n        System.out.println("\\n通过类名调用！");\n        Method.test1();\n        // Method.test2();\n    }\n}\n\n/* 运行结果\n\n静态直接调用！\n静态方法\n\n实例对象调用！\n静态方法\n实例方法\n\n通过类名调用！\n静态方法\n\n* */\n\n\n# 静态方法与实例方法的区别\n\n静态方法：\n\n * 不能访问类中的非静态成员(方法，变量)\n * this 不能访问非静态成员\n * super 不能访问构造器\n\n实例方法：\n\n * 在内部可直接访问\n * 在类外部需实例访问\n * 在静态方法内需要实例访问\n\n\n# 内部类\n\n一个类中再定义一个类，在类中再定义的类 称为内部类\n\n特点：\n\n * 内部类仍是个独立的类，在编译之后内部类会被编译成独立的.class文件\n * 外部类以外需要实例内部类需要外部类指定内部类进行实例 ==外部类名.内部类==\n * 内部类是外部类的成员，内部类可外部类的成员，哪怕是 private 也可访问\n * 内部类声明成静态，就不能访问外部类的成员，只能访问外部类的静态成员\n * 内部类不能与外部类重名\n * 内部类访问与外部类 同名的变量时，则需要 ==外部类名.this.变量名== 进行访问成员\n\n\n# 成员内部类\n\n可直接使用所在的类中的 成员方法/成员变量\n\n注意：\n\n * 在外部类外和非静态方法外实例内部类对象，需要外部类指定该对象才能应用内部类\n * 访问被 private修饰的内部类方法，需要接口重写调用\n * this 调用本类的成员变量，外部类需要类名作为前缀（需要完整类路径）\n\npublic class Outer {\n    // 实例内部类\n    class Inner { }\n}\n\n\n示例：\n\n// 外部类\npublic class OuterVariable {\n    \n    // 外部类 成员变量\n    public int i = 111;\n    private int j = 222;\n    \n    // 内部类\n    class Inner {\n        // 内部类 成员变量\n        private int i = 333;\n        private int j = 444;\n        \n        // 直接访问\n        public void goInVariable(int i , int j){\n            //共用外类的变量\n            System.out.println("内部类 直接变量：");\n            System.out.println("i : " + i);\n            System.out.println("j : " + j);\n            System.out.println("内部类 访问内部类成员变量");\n            System.out.println("this.i : " + this.i);\n            System.out.println("this.j : " + this.j);\n            System.out.println("内部类 类指定访问外部类成员变量：");\n            System.out.println("OuterVariable.this.i : " + OuterVariable.this.i);\n            System.out.println("OuterVariable.this.j : " + OuterVariable.this.j);\n        }\n        \n        // 直接访问 外部类方法\n        private void privateTest1(){\n            //父类.本身.方法();\n            privateTest();\n        }\n        // 指定类访问 外部类方法\n        private void privateTest2(){\n            //父类.本身.方法();\n            OuterVariable.this.privateTest();\n        }\n    }\n    \n    private void privateTest(){\n        System.out.println("外部类 privateTest()方法！");\n    }\n    \n    public static void main(String[] args) {\n        // 实例 外部类&内部类\n        OuterVariable outerVariable = new OuterVariable();\n        Inner inner = outerVariable.new Inner();\n        \n        // 内部类 访问 外部变量\n        inner.goInVariable(555,666);\n    \n        // 内部类 访问 外部方法\n        inner.privateTest1();\n        inner.privateTest2();\n        \n    }\n}\n\n/*  运行结果\n\n内部类 直接变量：\ni : 555\nj : 666\n内部类 访问内部类成员变量\nthis.i : 333\nthis.j : 444\n内部类访问 类指定访问外部类成员变量：\nOuterVariable.this.i : 111\nOuterVariable.this.j : 222\n外部类 privateTest()方法！\n外部类 privateTest()方法！\n\n*/\n\n\n\n# 局部内部类\n\n局部内部类是指 类定义在 方法/任意作用域 中的类\n\n特点：\n\n * 局部内部类与局部变量一样，不能使用以上修饰 public/private/protected/static\n * 局部内部类只在当前方法中有效\n * 局部内部类中不能定义 static\n * 局部内部类中可访问外部类的所有成员\n * 局部内部类中只可访问当前方法中 final 变量\n\npublic class Test {\n    public void method() {\n        // 局部内部类\n        class Inner { }\n    }\n}\n\n\n示例：\n\npublic class OuterPart {\n    int a = 10;\n    public void method(){\n        \n        // 局部内部类\n        class Inner{\n            int a = 20;\n            public void print(int a){\n                System.out.println("a : " + a);\n                System.out.println("this.a : " + this.a);\n                System.out.println("OuterPart.this.a : " + OuterPart.this.a);\n            }\n        }\n    \n        Inner inner = new Inner();\n        inner.print(30);\n    }\n    \n    public static void main(String[] args) {\n        // OuterPart.Inner inner = new OuterPart().new Inner(); (报红)\n        new OuterPart().method();\n    }\n}\n\n/*  运行结果\n\na : 30\nthis.a : 20\nOuterPart.this.a : 10\n\n*/\n\n\n\n# 匿名内部类\n\n匿名内部类没有类名，必须在创建时使用 new 来声明类\n\n特点：\n\n * 匿名内部类只能够调用一次\n * 匿名对象只在堆内存中开辟空间\n * 每次创建匿名对象都是不同对象\n * 匿名类和局部内部类一样，可以访问外部类的所有成员\n * 匿名类中允许使用非静态代码块进行成员初始化操作\n * 匿名类的非静态代码块会在父类的构造方法之后被执行\n * 使用匿名内部类时，必须是 继承类/实现接口\n * 匿名内部类 不能定义构造函数\n * 匿名内部类 不能存在静态成员\n\nnew <类/接口>() {\n    // 实现区\n};\n\n\n示例：\n\ninterface Port {\n    void show();\n}\n\npublic class OuterAnonymous {\n    \n    public static void main(String[] args) {\n        // 匿名内部类\n        \n        // 写法1\n        Port app = new Port() {\n            @Override\n            public void show() {\n                System.out.println("测试1 匿名内部类！！");\n            }\n        };\n        app.show();\n        \n        /** 写法2\n         *  lambda表达式 1.8新特性\n         *  (该用法限于实现一个方法的情况使用)\n         */\n        Port app2 = () -> System.out.println("测试2 匿名内部类！！");\n        app2.show();\n       \n    }\n}\n\n/* 运行结果：\n\n测试1 匿名内部类！！\n测试2 匿名内部类！！\n\n*/\n\n\n# lambda表达式\n\nlambda表达式 也是一个匿名函数\n\n特点：\n\n * 只能应用于 接口 的实现\n * 只能应用于 实现一个抽象方法\n\n// 前提需要有 抽象方法 \nnew 接口名([参数]) -> {\n    // 实现区\n};\n\n\nlambda其他应用说明：\n\n * 参数无需指定数据类型，因抽象方法已经指定参数的数据类型以及个数\n * lambda表达式 只能应用于实现一个抽象方法，多个方法则不能应用\n\n应用实例：\n\n * 一个参数 （变量随意，一个参数无需添加括号）\n\nPort app = a ->{ //实现区 };\n\n\n * 两个参数 （两个变量需要括号括起来）\n\nPort app = (a,b) ->{ //实现区 };\n\n\n示例以上代码已经有了；不同参数可在以上代码的基础上自行更变应用\n\n\n# 静态内部类\n\n静态内部类在前面加 static 即可，静态内部类只能调用静态的成员，用于调试\n\n特点：\n\n * 创建静态内部类实例无需创建外部类实例\n * 静态内部类可定义 静态成员/实例成员\n * 静态内部类可直接访问外部类静态成员，访问外部类成员则需外部类实例去访问\n\npublic class Outer {\n    static class Inner {\n        // 静态内部类\n    }\n}\n\n\n示例：\n\npublic class OuterStatic {\n    \n    int a = 10;\n    static int b = 10;\n    \n    static class Inner{\n        int c = 20;\n        static int d = 20 ;\n        \n        // 访问外部\n        public void print() {\n            System.out.println("new OuterStatic().a : " + new OuterStatic().a);\n            // System.out.println(OuterStatic.this.a); (报红)\n            // System.out.println(a); (报红)\n            System.out.println("b : " + b);\n            System.out.println("OuterStatic.b : " + OuterStatic.b);\n        }\n    }\n     \n}\n\n/* 运行结果\n\ninner.a : 20\ninner.b : 20\nnew OuterStatic().a : 10\nb : 10\nOuterStatic.b : 10\n\n*/\n\n\n\n# 内部类继承\n\n内部类继承相对较复杂，需要设置专门的语法完成\n\n继承内部类时，必须有构造方法带参数的，参数是内部类的外部类对象，同时构造方法里要借助外部对象进行实例内部类 ==外部类.super()==\n\npublic class OuterExtends {\n    \n    class Inner {\n        private String name;\n        public Inner(String name) {\n            this.name = name;\n        }\n        public String info(){\n            return name;\n        }\n    }\n}\n\nclass Demo extends OuterExtends.Inner {\n    \n    public Demo(OuterExtends out,String name) {\n        out.super(name);\n    }\n    \n    public static void main(String[] args) {\n        // 继承内部类进行调用\n        Demo demo = new Demo(new OuterExtends() , "柏竹");\n        System.out.println("输出内部类成员："+demo.info());\n    }\n    \n}\n\n/*  运行结果\n\n输出内部类成员：柏竹\n \n*/\n\n\n\n# 代码块\n\n\n# 局部代码块\n\n局部代码块 是定义在指定的方法或作用域中\n\n * {} 范围的作用域，只需关注作用域\n\n\n# 成员代码块\n\n成员代码块 定义在 类中的 成员位置\n\n * 优先执行与 构造方法，一般用于对 成员进行初始化的操作\n * 每次实例对象都会执行一次\n\n\n# 静态代码块\n\n静态代码块 定义在 类中的 ==static{ }==\n\n * 优先于 主方法的执行、构造方法的执行\n * 只会执行一次，无论实例对象多次(一般用于初始化静态成员)\n * 静态代码块类似于一个方法，但不可以存在于任何方法中\n * 静态代码块可以置于类中的任何地方，类中可以有多个静态初始化块（存在多个静态也会依按顺序执行代码块）\n\n\n# 代码块的加载顺序\n\n类的加载顺序\n\n 1. 父类 静态对象和静态代码块\n 2. 子类 静态对象和静态代码块\n 3. 父类 非静态对象和非静态代码块\n 4. 父类 构造函数\n 5. 子类 非静态对象和非静态代码块\n 6. 子类 构造函数\n\npublic class Demo {\n    public static void main(String[] args) {\n        new B();\n    }\n}\n\nclass A{\n    public A() {\n        System.out.println("A 父类 无参构造方法");\n    }\n    {\n        System.out.println("A 父类 不同初始化块");\n    }\n    static{\n        System.out.println("A 父类 静态初始化块");\n    }\n    \n}\nclass B extends A{\n    public B() {\n        System.out.println("B 子类 无参构造方法");\n    }\n    {\n        System.out.println("B 子类 不同初始化块");\n    }\n    static{\n        System.out.println("B 子类 静态初始化块");\n    }\n}\n\n/* 运行结果\n\nA 父类 静态初始化块\nB 子类 静态初始化块\nA 父类 不同初始化块\nA 父类 无参构造方法\nB 子类 不同初始化块\nB 子类 无参构造方法\n\n*/\n',normalizedContent:'# java类的高级特性\n\n\n# 类\n\n\n# 成员变量\n\n成员变量是 类中的属性\n\npublic class tuzi {\n    string eat;     //吃\n    string hair;    //毛\n    string jump;  \t//跳\n}\n\n\n\n# 局部变量\n\n局部变量是 方法或{}括号 内定义的变量\n\npublic class jububianliang {\n\tpublic static void main(string[] args) {\n\t\tint i = 2,j = 4;\n\t\tsystem.out.private(max(i,j));\t\n\t}\n    //成员方法\n\tpublic int max(int a , int b ){\n        //局部变量max。max变量限于该方法的范围\n\t\tint max = 0;\n\t\tif(a > b){\n\t\t\tmax = a;\n\t\t\treturn max;\n\t\t}else{\n\t\t\tmax = b;\n\t\t\treturn max;}\n\t}\n}\n\n\n\n# 成员方法\n\n成员方法是 类的功能(行为)\n\n权限修饰符 返回值类型 方法名(参数类型 参数名[,···){\n    ····\t\t//方法体\n    return 返回的值;\n}\n//例子\npublic int max(int a , int b){\n    if(a > b){\n        return a;\n    }else{\n        return b;\n    }\n}\n\n\n> 如果方法返回类型为void，则无返回空\n\n\n# this关键子\n\nthis关键字用于引用对象的成员变量和方法 ，将方法的参数值赋予类本身的成员变量\n\npublic class thsiches {\n    string  str = "abc";\n    public void no1(string str) {\n        //打印 str形参\n        system.out.println("no1："+str);\n        //打印 thsiches类 中的str成员变量\n        system.out.println("no2："+this.str);\n    }\n    public static void main(string[] args) {\n        string str2 = "123";\n        new thsiches().no1(str2);\n    }\n}\n\n\n\n# super关键字\n\nsuper关键字可以调用父类的 属性 和 方法\n\n应方式                       父类成员 属性&方法\nsuper()                   父类构造方法\nsuper.name (name成员变量)     父类的属性（成员变量）\nsuper.run() (run()成员方法)   父类的方法\n\n**注意 : **\n\n * 只要是构造方法都会默认 第一行 为 super(); (不管是什么类，都是object的父类)\n * 父类有参构造方法需要 super 调用父类构造方法\n * 用 private 修饰的成员，其他类无法 调用和重写\n\nsuper实例：\n\npublic class demo {\n    public static void main(string[] args) {\n        new b("");\n    }\n}\n\nclass a{\n    string a;\n    // 构造方法\n    public a(string a) {\n        system.out.println("a有参构造方法");\n        this.a = a;\n    }\n}\nclass b extends a{\n    // b构造方法\n    public b(string a) {\n        super(a);\n        system.out.println("b有参构造方法");\n    }\n}\n\n/* 执行结果\n\na有参构造方法\nb有参构造方法\n\n*/\n\n\n\n# this和super区别\n\nthis : 当前对象的引用 super : 当前对象的父对象的引用\n\n\n# 构造方法\n\n构造器是类的特殊方法，专门用于在类被实例时，定义初始化类的成员属性所使用(无需再次set方法)\n\n构造方法特点\n\n * 没有返回值\n * 方法名与类名相同\n * 没有定义构造方法，会自动生成无参数构造方法\n * 实例化对象，类都会自动调用 构造方法\n * 在无参构造方法 this 调用有参构造方法，则该语句必须为第一个\n * 可重载构造器\n\n重载构造器参数应用\n\n * 参数顺序\n * 参数类型\n\n\n# 包\n\njava jdk api中提供了类功能，它们封装为类包\n\n\n# 类名冲突\n\njdk api 中提供的类，在同一类包 同类名 会导致编译器无法执行 ，要把类包分开或更改类名\n\n\n# 完整的类路径\n\n完整的类名需要包名与类名的组合\n\njava.包名.类名\n//例子\njava.lang.string\n\n\n> 如果指定路径不确定可能会翻车，像以下是需要完整路径 ==java.util.date date = new java.util.date();== ==java.sql.date date2 = new java.sql.date();==\n\n\n# 包的特性\n\n * 把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用\n\n * 包如同文件夹一样，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名 加以区别。因此，包可以避免名字冲突\n\n * 包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类\n\njava包是为了防止命名冲突，访问控制，提供搜索和定位类、接口、枚举和注释等\n\n没有定义包会自动归纳在预设包（默认包）中，最好为所有类设置包名（良好习惯）\n\npackage 包名.包名...;\n\n\n注意：\n\n * 在类中指定包名时，需要将 package表达式 放在程序的第一行 （非注释\n\n * java包的命名规则是全部使用小写字母的\n\n\n# import 导入包\n\n引入包可以调用包中的方法，不能调用两包中的同类名，指定包后面有 * ，指定包路径中的所有类\n\n\n# import 导入静态成员\n\n调用指定\n\nimport static 静态成员\n\n\n> 例子：\n> \n> ==java.lang.system== 类中的 out成员变量 ==java.lang.math== 类中的 max成员方法\n> \n> 它们都是静态成员，这是前提！！！\n\nimport static java.lang.system.*; //导入静态成员方法\nimport static java.lang.math.*;   //导入静态成员变量\n\npublic class demo2 {\n    public static void main(string[] args) {\n        //静态成员简写调用\n        out.println("123");\n        system.out.println("123");\n        //静态方法简写调用\n        out.println("max(3,4)?"+max(3,4));\n        out.println("max(3,4)?"+math.max(3,4));\n    }\n}\n\n/* 运行结果\n\n123\n123\nmax(3,4)?4\nmax(3,4)?4\n\n*/\n\n\n包的使用规则\n\n * 包中java文件的定义： 在.java文件的首部， 必须编写类所属哪个包\n * 包的定义： 所有包的名称都由小写字母， 单词与单词之间使用 . 隔开 ，一般命名为==com.公司名.项目 名.模块名....==\n * 规范由来： 由于java面向对象的特性，每名java开发人员都可以编写属于自己的java包，为了保障每个java package命名的唯一性。由于 互联网上 的域名称是不会重复的，因此很多开发者都会采用自己公司的名称作为前缀。例如： ==com.java.xxx==\n\n\n# 权限修饰符\n\n权限修饰符控制 类/成员变量/成员方法 的访问，不同的权限指定的不同范围\n\n修饰符         类   包   子类   其他包\npublic      √   √   √    √\nprotected   √   √   √    ×\ndefault     √   √   ×    ×\nprivate     √   ×   ×    ×\n\n> 注意： 类不使用修饰符时，则该类预设为包存取范围\n\n\n# final 常量\n\n被final修饰，表明改对象是专一的（不能有第三方）\n\n特点：\n\n * 变量 不能被更改\n\n * 方法 不能被重写\n\n * 类 不能被继承\n\n\n# final变量\n\nfinal 修饰后, 不能更改该变量的值，该变量称为常量！\n\nfinal 数据类型 变量名 = 值;\n\n\n\n# final方法\n\nfinal 修饰的方法 不能 重写\n\nprivate修饰的方法隐式被指定为 final ，可无需添加 final\n\n[修饰符] final 数据类型 方法名([参数]){···}\n\n\n\n# final类\n\n被final修饰的方法类，不能被继承 （跟部分api类类似）\n\nfinal class 类名{···}\n\n\n示例：\n\npublic class demo {\n    // final修饰变量 测试\n    final int a = 1;\n    // a 变量不能被修改（报红）\n    // a = 2;\n}\n\n// final修饰方法 测试\nclass a{\n    public final void test(){}\n}\nclass b extends a{\n    // a中的test方法 不能继承（报红）\n    // public void test(){}\n}\n\n// final修饰类 测试\nfinal class aa{ }\n// aa 不能被继承（报红）\n// class b extends aa{}\n\n\n\n# final 总结\n\n修饰对象   说明\n变量     变量只能初始化赋值\n方法     方法不能被重写\n类      类不能被继承\n\n\n# static 静态\n\n静态修饰的代码，整个程序运行结束之后才会释放\n\n静态特点：\n\n * 静态的数据都是共享的，其他类调用不需实例化进行应用\n * 静态在内存中永远只有一份，无论有多个对象\n * 静态不能访问非静态，而非静态可访问静态（静态方法）\n * 加载时静态总会优先于非静态\n\n\n# 静态变量\n\n静态变量的共享，在不同类对同一变量可以进行操作\n\npublic class demo {\n    private static string stu1 = "hello";\n    \n    public static void main(string[] args) {\n        string stu2 = "world";\n        \n        // 直接访问变量\n        system.out.println("直接访问："+stu1+stu2);\n        // 类访问变量\n        system.out.println("通过类访问："+demo.stu1+stu2);\n        // 通过对象访问变量 (静态被赋值)\n        demo demo = new demo();\n        demo.stu1 += stu2;\n        system.out.println("通过对象访问："+demo.stu1);\n        // 通过对象访问变量2 通过相同变量进行测试\n        demo demo1 = new demo();\n        system.out.println("通过对象访问："+demo1.stu1+stu2);\n    \n        system.out.println("\\n 静态值为："+stu1);\n    }\n} \n\n/* 运行结果\n\n直接访问：helloworld\n通过类访问：helloworld\n通过对象访问：helloworld\n通过对象访问：helloworldworld\n\n 静态值为：helloworld\n\n*/\n\n\n# 静态变量与实例变量的区别\n\n          静态变量                    实例变量\n内存开辟时期    类加载时                    对象实例时\n内存分配区域    方法独有静态区                 实例对象堆中\n类内部访问变量   类内的任何方法可直接访问            只能访问非静态方法\n类外部访问变量   通过类名进行访问 ==类型.静态变量名==   通过类的实例对象进行访问\n\n\n# 静态方法\n\n静态方法无需创建类的对象\n\npublic class method {\n    \n    // 静态方法\n    public static void test1() {\n        system.out.println("静态方法");\n    }\n    \n    // 实例方法\n    public void test2() {\n        system.out.println("实例方法");\n    }\n    \n    public static void main(string[] args) {\n        // 静态直接调用\n        system.out.println("静态直接调用！");\n        test1();\n        // test2(); (报红)\n        \n        // 实例对象调用\n        system.out.println("\\n实例对象调用！");\n        method method = new method();\n        method.test1();\n        method.test2();\n        \n        // 通过类名调用\n        system.out.println("\\n通过类名调用！");\n        method.test1();\n        // method.test2();\n    }\n}\n\n/* 运行结果\n\n静态直接调用！\n静态方法\n\n实例对象调用！\n静态方法\n实例方法\n\n通过类名调用！\n静态方法\n\n* */\n\n\n# 静态方法与实例方法的区别\n\n静态方法：\n\n * 不能访问类中的非静态成员(方法，变量)\n * this 不能访问非静态成员\n * super 不能访问构造器\n\n实例方法：\n\n * 在内部可直接访问\n * 在类外部需实例访问\n * 在静态方法内需要实例访问\n\n\n# 内部类\n\n一个类中再定义一个类，在类中再定义的类 称为内部类\n\n特点：\n\n * 内部类仍是个独立的类，在编译之后内部类会被编译成独立的.class文件\n * 外部类以外需要实例内部类需要外部类指定内部类进行实例 ==外部类名.内部类==\n * 内部类是外部类的成员，内部类可外部类的成员，哪怕是 private 也可访问\n * 内部类声明成静态，就不能访问外部类的成员，只能访问外部类的静态成员\n * 内部类不能与外部类重名\n * 内部类访问与外部类 同名的变量时，则需要 ==外部类名.this.变量名== 进行访问成员\n\n\n# 成员内部类\n\n可直接使用所在的类中的 成员方法/成员变量\n\n注意：\n\n * 在外部类外和非静态方法外实例内部类对象，需要外部类指定该对象才能应用内部类\n * 访问被 private修饰的内部类方法，需要接口重写调用\n * this 调用本类的成员变量，外部类需要类名作为前缀（需要完整类路径）\n\npublic class outer {\n    // 实例内部类\n    class inner { }\n}\n\n\n示例：\n\n// 外部类\npublic class outervariable {\n    \n    // 外部类 成员变量\n    public int i = 111;\n    private int j = 222;\n    \n    // 内部类\n    class inner {\n        // 内部类 成员变量\n        private int i = 333;\n        private int j = 444;\n        \n        // 直接访问\n        public void goinvariable(int i , int j){\n            //共用外类的变量\n            system.out.println("内部类 直接变量：");\n            system.out.println("i : " + i);\n            system.out.println("j : " + j);\n            system.out.println("内部类 访问内部类成员变量");\n            system.out.println("this.i : " + this.i);\n            system.out.println("this.j : " + this.j);\n            system.out.println("内部类 类指定访问外部类成员变量：");\n            system.out.println("outervariable.this.i : " + outervariable.this.i);\n            system.out.println("outervariable.this.j : " + outervariable.this.j);\n        }\n        \n        // 直接访问 外部类方法\n        private void privatetest1(){\n            //父类.本身.方法();\n            privatetest();\n        }\n        // 指定类访问 外部类方法\n        private void privatetest2(){\n            //父类.本身.方法();\n            outervariable.this.privatetest();\n        }\n    }\n    \n    private void privatetest(){\n        system.out.println("外部类 privatetest()方法！");\n    }\n    \n    public static void main(string[] args) {\n        // 实例 外部类&内部类\n        outervariable outervariable = new outervariable();\n        inner inner = outervariable.new inner();\n        \n        // 内部类 访问 外部变量\n        inner.goinvariable(555,666);\n    \n        // 内部类 访问 外部方法\n        inner.privatetest1();\n        inner.privatetest2();\n        \n    }\n}\n\n/*  运行结果\n\n内部类 直接变量：\ni : 555\nj : 666\n内部类 访问内部类成员变量\nthis.i : 333\nthis.j : 444\n内部类访问 类指定访问外部类成员变量：\noutervariable.this.i : 111\noutervariable.this.j : 222\n外部类 privatetest()方法！\n外部类 privatetest()方法！\n\n*/\n\n\n\n# 局部内部类\n\n局部内部类是指 类定义在 方法/任意作用域 中的类\n\n特点：\n\n * 局部内部类与局部变量一样，不能使用以上修饰 public/private/protected/static\n * 局部内部类只在当前方法中有效\n * 局部内部类中不能定义 static\n * 局部内部类中可访问外部类的所有成员\n * 局部内部类中只可访问当前方法中 final 变量\n\npublic class test {\n    public void method() {\n        // 局部内部类\n        class inner { }\n    }\n}\n\n\n示例：\n\npublic class outerpart {\n    int a = 10;\n    public void method(){\n        \n        // 局部内部类\n        class inner{\n            int a = 20;\n            public void print(int a){\n                system.out.println("a : " + a);\n                system.out.println("this.a : " + this.a);\n                system.out.println("outerpart.this.a : " + outerpart.this.a);\n            }\n        }\n    \n        inner inner = new inner();\n        inner.print(30);\n    }\n    \n    public static void main(string[] args) {\n        // outerpart.inner inner = new outerpart().new inner(); (报红)\n        new outerpart().method();\n    }\n}\n\n/*  运行结果\n\na : 30\nthis.a : 20\nouterpart.this.a : 10\n\n*/\n\n\n\n# 匿名内部类\n\n匿名内部类没有类名，必须在创建时使用 new 来声明类\n\n特点：\n\n * 匿名内部类只能够调用一次\n * 匿名对象只在堆内存中开辟空间\n * 每次创建匿名对象都是不同对象\n * 匿名类和局部内部类一样，可以访问外部类的所有成员\n * 匿名类中允许使用非静态代码块进行成员初始化操作\n * 匿名类的非静态代码块会在父类的构造方法之后被执行\n * 使用匿名内部类时，必须是 继承类/实现接口\n * 匿名内部类 不能定义构造函数\n * 匿名内部类 不能存在静态成员\n\nnew <类/接口>() {\n    // 实现区\n};\n\n\n示例：\n\ninterface port {\n    void show();\n}\n\npublic class outeranonymous {\n    \n    public static void main(string[] args) {\n        // 匿名内部类\n        \n        // 写法1\n        port app = new port() {\n            @override\n            public void show() {\n                system.out.println("测试1 匿名内部类！！");\n            }\n        };\n        app.show();\n        \n        /** 写法2\n         *  lambda表达式 1.8新特性\n         *  (该用法限于实现一个方法的情况使用)\n         */\n        port app2 = () -> system.out.println("测试2 匿名内部类！！");\n        app2.show();\n       \n    }\n}\n\n/* 运行结果：\n\n测试1 匿名内部类！！\n测试2 匿名内部类！！\n\n*/\n\n\n# lambda表达式\n\nlambda表达式 也是一个匿名函数\n\n特点：\n\n * 只能应用于 接口 的实现\n * 只能应用于 实现一个抽象方法\n\n// 前提需要有 抽象方法 \nnew 接口名([参数]) -> {\n    // 实现区\n};\n\n\nlambda其他应用说明：\n\n * 参数无需指定数据类型，因抽象方法已经指定参数的数据类型以及个数\n * lambda表达式 只能应用于实现一个抽象方法，多个方法则不能应用\n\n应用实例：\n\n * 一个参数 （变量随意，一个参数无需添加括号）\n\nport app = a ->{ //实现区 };\n\n\n * 两个参数 （两个变量需要括号括起来）\n\nport app = (a,b) ->{ //实现区 };\n\n\n示例以上代码已经有了；不同参数可在以上代码的基础上自行更变应用\n\n\n# 静态内部类\n\n静态内部类在前面加 static 即可，静态内部类只能调用静态的成员，用于调试\n\n特点：\n\n * 创建静态内部类实例无需创建外部类实例\n * 静态内部类可定义 静态成员/实例成员\n * 静态内部类可直接访问外部类静态成员，访问外部类成员则需外部类实例去访问\n\npublic class outer {\n    static class inner {\n        // 静态内部类\n    }\n}\n\n\n示例：\n\npublic class outerstatic {\n    \n    int a = 10;\n    static int b = 10;\n    \n    static class inner{\n        int c = 20;\n        static int d = 20 ;\n        \n        // 访问外部\n        public void print() {\n            system.out.println("new outerstatic().a : " + new outerstatic().a);\n            // system.out.println(outerstatic.this.a); (报红)\n            // system.out.println(a); (报红)\n            system.out.println("b : " + b);\n            system.out.println("outerstatic.b : " + outerstatic.b);\n        }\n    }\n     \n}\n\n/* 运行结果\n\ninner.a : 20\ninner.b : 20\nnew outerstatic().a : 10\nb : 10\nouterstatic.b : 10\n\n*/\n\n\n\n# 内部类继承\n\n内部类继承相对较复杂，需要设置专门的语法完成\n\n继承内部类时，必须有构造方法带参数的，参数是内部类的外部类对象，同时构造方法里要借助外部对象进行实例内部类 ==外部类.super()==\n\npublic class outerextends {\n    \n    class inner {\n        private string name;\n        public inner(string name) {\n            this.name = name;\n        }\n        public string info(){\n            return name;\n        }\n    }\n}\n\nclass demo extends outerextends.inner {\n    \n    public demo(outerextends out,string name) {\n        out.super(name);\n    }\n    \n    public static void main(string[] args) {\n        // 继承内部类进行调用\n        demo demo = new demo(new outerextends() , "柏竹");\n        system.out.println("输出内部类成员："+demo.info());\n    }\n    \n}\n\n/*  运行结果\n\n输出内部类成员：柏竹\n \n*/\n\n\n\n# 代码块\n\n\n# 局部代码块\n\n局部代码块 是定义在指定的方法或作用域中\n\n * {} 范围的作用域，只需关注作用域\n\n\n# 成员代码块\n\n成员代码块 定义在 类中的 成员位置\n\n * 优先执行与 构造方法，一般用于对 成员进行初始化的操作\n * 每次实例对象都会执行一次\n\n\n# 静态代码块\n\n静态代码块 定义在 类中的 ==static{ }==\n\n * 优先于 主方法的执行、构造方法的执行\n * 只会执行一次，无论实例对象多次(一般用于初始化静态成员)\n * 静态代码块类似于一个方法，但不可以存在于任何方法中\n * 静态代码块可以置于类中的任何地方，类中可以有多个静态初始化块（存在多个静态也会依按顺序执行代码块）\n\n\n# 代码块的加载顺序\n\n类的加载顺序\n\n 1. 父类 静态对象和静态代码块\n 2. 子类 静态对象和静态代码块\n 3. 父类 非静态对象和非静态代码块\n 4. 父类 构造函数\n 5. 子类 非静态对象和非静态代码块\n 6. 子类 构造函数\n\npublic class demo {\n    public static void main(string[] args) {\n        new b();\n    }\n}\n\nclass a{\n    public a() {\n        system.out.println("a 父类 无参构造方法");\n    }\n    {\n        system.out.println("a 父类 不同初始化块");\n    }\n    static{\n        system.out.println("a 父类 静态初始化块");\n    }\n    \n}\nclass b extends a{\n    public b() {\n        system.out.println("b 子类 无参构造方法");\n    }\n    {\n        system.out.println("b 子类 不同初始化块");\n    }\n    static{\n        system.out.println("b 子类 静态初始化块");\n    }\n}\n\n/* 运行结果\n\na 父类 静态初始化块\nb 子类 静态初始化块\na 父类 不同初始化块\na 父类 无参构造方法\nb 子类 不同初始化块\nb 子类 无参构造方法\n\n*/\n',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Java集合类",frontmatter:{title:"Java集合类",date:"2020-02-18T00:00:00.000Z",permalink:"/backend/x25lyh",categories:["后端","Java基础"],tags:["Java"],author:"柏竹"},regularPath:"/01.%E5%90%8E%E7%AB%AF/01.Java%E5%9F%BA%E7%A1%80/08.%E9%9B%86%E5%90%88%E7%B1%BB.html",relativePath:"01.后端/01.Java基础/08.集合类.md",key:"v-48faa1d3",path:"/backend/x25lyh/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:14},{level:2,title:"Collection接口",slug:"collection接口",normalizedTitle:"collection接口",charIndex:72},{level:3,title:"List集合",slug:"list集合",normalizedTitle:"list集合",charIndex:885},{level:4,title:"ArrayList 类",slug:"arraylist-类",normalizedTitle:"arraylist 类",charIndex:1866},{level:4,title:"LinkedList 类",slug:"linkedlist-类",normalizedTitle:"linkedlist 类",charIndex:1796},{level:4,title:"ArrayList与LinkedList的区别",slug:"arraylist与linkedlist的区别",normalizedTitle:"arraylist与linkedlist的区别",charIndex:3247},{level:3,title:"Set集合",slug:"set集合",normalizedTitle:"set集合",charIndex:4231},{level:4,title:"TreeSet类",slug:"treeset类",normalizedTitle:"treeset类",charIndex:4364},{level:4,title:"HashSet类",slug:"hashset类",normalizedTitle:"hashset类",charIndex:9201},{level:2,title:"Map集合",slug:"map集合",normalizedTitle:"map集合",charIndex:11559},{level:3,title:"HashMap类",slug:"hashmap类",normalizedTitle:"hashmap类",charIndex:12564},{level:3,title:"LinkedHashMap类",slug:"linkedhashmap类",normalizedTitle:"linkedhashmap类",charIndex:12819},{level:3,title:"TreeMap类",slug:"treemap类",normalizedTitle:"treemap类",charIndex:13033},{level:3,title:"Hashtable类",slug:"hashtable类",normalizedTitle:"hashtable类",charIndex:13204},{level:3,title:"ConcurrentHashMap类",slug:"concurrenthashmap类",normalizedTitle:"concurrenthashmap类",charIndex:13378},{level:3,title:"实现类的区别",slug:"实现类的区别",normalizedTitle:"实现类的区别",charIndex:13605},{level:2,title:"集合总结",slug:"集合总结",normalizedTitle:"集合总结",charIndex:15507},{level:2,title:"迭代器",slug:"迭代器",normalizedTitle:"迭代器",charIndex:861},{level:3,title:"Iterator接口",slug:"iterator接口",normalizedTitle:"iterator接口",charIndex:16139},{level:3,title:"ListIterator接口",slug:"listiterator接口",normalizedTitle:"listiterator接口",charIndex:16346}],headersStr:"概述 Collection接口 List集合 ArrayList 类 LinkedList 类 ArrayList与LinkedList的区别 Set集合 TreeSet类 HashSet类 Map集合 HashMap类 LinkedHashMap类 TreeMap类 Hashtable类 ConcurrentHashMap类 实现类的区别 集合总结 迭代器 Iterator接口 ListIterator接口",content:'# Java集合类\n\n\n# 概述\n\njava.util提供的，集合类可称为容器，集合的长度是可变的(动态长度)，集合存放的是对象的引用\n\n\n# Collection接口\n\nCollection接口不能直接使用，它提供了 添加、删除、管理 元素等操作 给 List 和 Set 子接口进行操作\n\n常用方法\n\n修饰符           方法                          参数      说明\nvoid          add(Object o)               1.对象    添加指定 对象\nvoid          addAll(Collection c)        1. 集合   添加指定集合对象\nvoid          clear()                     -       清空集合中的元素\nboolean       contains(Object o)          1. 对象   查找一个元素是否存在\nboolean       containsAll(Collection c)   1.对象    查找一个集合相同元素是否存在\nboolean       retainAll(Collection c)     1.对象    保存指定集合中的元素\nvoid          remove(Object o)            1. 对象   指定对象在集合中移除\nboolean       isEmpty()                   -       判断集合是否为空\nint           size()                      -       获取集合中的个数\nObject[]      toArray()                   -       将集合以数组形式输出\nIterator<E>   iterator()                  -       集合迭代器(Iterator 接口实例化)\n\n\n# List集合\n\nList集合像列表清单，它允许元素重复，但各个元素的顺序就是对象插入的顺序\n\nList接口及实现类\n\nList接口 继承了 Collection接口，因此也有父接口的方法\n\n方法\n\n返回类型              方法                                     说明\nboolean           add(Object obj)                        插入数据\nboolean           add(int index  , Object obj)           指定位置插入数据\nE                 get(int index)                         获取指定索引的元素\nint               indexOf(Object o)                      根据对象查找指定的位置，不存在则-1\nint               lastIndexOf(Object o)                  从后面向前查找位置，不存在则-1\nListIterator<E>   listIterator(int index)                返回从指定位置的 ListIterator 接口的实例\nE                 remove(int index)                      删除指定位置的内容\nE                 set(int index , Object obj)            将集合中指定索引位置的对象修改为指定的对象\nList<E>           subList(int fromIndex , int toIndex)   返回子集合\nListIterator<E>   listIterator()                         返回特殊的迭代器(含插入更改功能)\n\n实现类\n\nList接口常用的类有 ArrayList 、Vector 和 LinkedList 类\n\nVector 与 ArrayList 操作是相同的 ，Vector类 过时了 建议使用ArrayList\n\n# ArrayList 类\n\n> Class ArrayList<E>\n> \n> java.lang.Object java.util.AbstractCollection<E> java.util.AbstractList<E> java.util.ArrayList<E>\n\nArrayList类 以数组的形式存储 ，该类提供了数组操作的方法！\n\n/*ArrayList类 的定义*/\npublic class ArrayList<E> extends AbstractList<E> implements List<E>, RandomAccess,Cloneable, Serializable\n\n\nArrayList类 动态数组\n\nList<E> array = new ArrayList<E>();\nList<E> array = new ArrayList<E>(int max); //设置空间大小\n\n\n----------------------------------------\n\n# LinkedList 类\n\n> Class LinkedList<E>\n> \n> java.lang.Object java.util.AbstractCollection<E> java.util.AbstractList<E> java.util.AbstractSequentialList<E> java.util.LinkedList<E>\n\nLinkedList类 以双向链表的形式存储数据 ，也一样继承 List类 中的方法！\n\n/*LinkedList的定义*/\npublic class LinkedList<E> extends AbstractSequentialList<E> implements List<E>, Deque<E>, Cloneable, Serializable\n\n\nLinkedList类 链表结构保存对象\n\nList list = new LinkedList();\n\n\nDeque接口 拓展 Queue 接口 ，Queue接口实现的方法：\n\n返回类型      方法              说明\nboolean   add(E e)        添加元素\nboolean   offer(E e)      添加元素\nE         element()       获取头元素\nE         peek()          获取头元素\nE         poll()          获取并删除头元素\nE         remove()        获取并删除头元素\nE         removeLast()    获取并删除最后一个\nE         removeFirst()   获取并删除第一个\n\n方法区别\n\n> add 与 offer 区别\n> \n> offer 在队列有限制的的情况下优势更大！\n> \n> element 与 peek 区别\n> \n> element 队列为空，则抛出异常 peek 队列为空，则返回 null\n> \n> poll 与 remove 区别\n> \n> poll 队列为空，则返回 null remove 队列为空，则抛出异常\n\n# ArrayList与LinkedList的区别\n\nArrayList查找较快，但插入、删除对象的速度较慢\n\nLinkedList查找较慢，但插入、删除对象的速度较快\n\n代码示例：\n\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Demo {\n    public static void main(String[] args) {\n        //另个用法一样\n//        List  list = new ArrayList();\n        List list = new LinkedList();\n        \n        list.add("a");\n        list.add("b");\n        list.add("c");\n        list.add("d");\n        list.add("e");\n        \n        //集合长度\n        System.out.println("长度为："+list.size());\n        //集合获取索引值(2)\n        System.out.println("get(2)："+list.get(2));\n        //更该索引值(2)\n        list.set(2,"cc");\n        //删除索引值4\n        list.remove(4);\n        //中间插入\n        list.add(1,"bb");\n        list.add(null);\n        \n        //输出内容\n        System.out.println("遍历集合：");\n        for (int i = 0; i < list.size(); i++) {\n            System.out.println(list.get(i));\n        }\n        \n    }\n}\n\n/*\n\n长度为：5\nget(2)：c\n遍历集合：\na\nbb\nb\ncc\nd\nnull\n\n*/\n\n\n\n# Set集合\n\nSet集合中的对象不按特定的方式排序，只是单纯的把对象添加到集合中，但不能有重复对象，Set接口 继承了 Collection接口，因此也有父接口的方法。想要获取 Set集合中的元素，需要获取整个集合与元素遍历，不能更改集合元素值！！\n\n实现类\n\n# TreeSet类\n\n> Class TreeSet<E> java.lang.Object java.util.AbstractCollection<E> java.util.AbstractSet<E> java.util.TreeSet<E>\n\nTreeSet类 实现了Set集合在遍历集合时按照自然顺序递增排序\n\n存储的类型如果是 对象，那么该对象就必须实现 Comparable接口 ，Comparable接口中有compareTo抽象方法 可以对集合处理排列方式 ，compareTo抽象方法 返回整型进行控制排列(0(相等) 、 正数 (小于)、 负数(大于))\n\nTreeSet<E> set = new TreeSet<E>();\n\n\nTreeSet类 提供方法\n\n返回类型           方法                                   说明\n<E>            first()                              返回集合中当前的第一个(最低)元素\n<E>            last()                               返回集合中当前的最后(最高)元素\n<E>            comparator()                         用于对集合元素进行排序的比较器，以比较返回 null\nSortedSet<E>   headSet(E toElement)                 返回新的Set集合，新集合 toElement(不包含)之前所有对象\nSortedSet<E>   subSet(E fromElement, E toElement)   返回新的Set集合，其元素的范围从 fromElement (含)到 toElement\nSortedSet<E>   tailSet(E fromElement)               返回新的Set集合，新集合 7fromElement(包含)之后所有对象\n\n代码示例：\n\nimport java.util.Iterator;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.TreeSet;\n\npublic class Demo {\n    public static void main(String[] args) {\n        TreeSet<Student> set = new TreeSet();\n        \n        Student s = new Student(1 , 20 , "小明");\n        Student s2 = new Student(2 , 22 , "小红");\n        Student s3 = new Student(3 , 22 , "小军");\n        Student s4 = new Student(4 , 24 , "小张");\n        Student s5 = new Student(6 , 21 , "张三");\n        Student s6 = new Student(9 , 23 , "李四");\n        \n        set.add(s);\n        set.add(s2);\n        set.add(s3);\n        set.add(s4);\n        set.add(s5);\n        set.add(s6);\n        set.add(s6);//重复，则无效\n//        set.add(null); 异常\n    \n        System.out.println("集合总数为："+set.size());\n    \n        System.out.println("返回集合第一个元素："+set.first());\n        \n        System.out.println("返回集合最后一个元素："+set.last());\n    \n        System.out.println("排序比较结果为："+set.comparator());\n        \n        System.out.println("\\n输出集合：");\n        Iterator it = set.iterator();\n        //如果迭代有更多的元素，则true\n        while(it.hasNext()){\n            //next() 会自动调用对象的 toString()方法\n            System.out.println(it.next());\n        }\n        \n        //测试headSet()方法\n        System.out.println("\\n测试方法2");\n        //截止至s4对象位置\n        it = set.headSet(s4).iterator();\n        while(it.hasNext()){\n            //next() 会自动调用对象的 toString()方法\n            System.out.println(it.next());\n        }\n    \n        //测试subSet()方法\n        System.out.println("\\n测试方法3");\n        //指定对象范围s ，s3\n        it = set.subSet(s , s3).iterator();\n        while(it.hasNext()){\n            //next() 会自动调用对象的 toString()方法\n            System.out.println(it.next());\n        }\n    \n        //测试stailSet()方法\n        System.out.println("\\n测试方法4");\n        //从s4对象位置开始排序\n        it = set.tailSet(s4).iterator();\n        while(it.hasNext()){\n            //next() 会自动调用对象的 toString()方法\n            System.out.println(it.next());\n        }\n        \n    }\n}\n\n\nclass Student implements Comparable<Student>{\n    int id;\n    int age;\n    String name;\n    \n    public Student(){}\n    //实例对象时获取的参数(信息)\n    public Student(int id , int age , String name){\n        super();\n        this.id = id;\n        this.age = age;\n        this.name = name;\n    }\n    \n    //迭代输出的信息\n    @Override\n    public String toString() {\n        return "Student{" +\n                "id=" + id +\n                ", age=" + age +\n                ", name=\'" + name + \'\\\'\' +\n                \'}\';\n    }\n    \n    //迭代排序用到的方法\n    @Override\n    public int compareTo(Student stt) {\n        /*\n        * 排序的值尽可能保持 唯一\n        * 如唯一的id\n        * */\n        \n        //按照age排序的顺序(重复会被覆盖掉)\n//        int tmp = this.age - stt.age;\n        \n        //按照id排序的顺序\n        int tmp = this.id - stt.id;\n        if(tmp != 0){\n            //Math.abs() 绝对值\n            //差值 除以本身 绝对值，结果只有 1 或 -1值\n            tmp = tmp / Math.abs(tmp);\n        }\n        /*\n        * 判断结果只有 0 、 1 、 -1(相等 ； 小于 ； 大于)\n        *   根据三值来进行排序\n        * */\n        return tmp;\n    }\n    \n    \n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        Student student = (Student) o;\n        return id == student.id;\n    }\n    \n    @Override\n    public int hashCode() {\n        return Objects.hash(id);\n    }\n}\n\n/*\n\n集合总数为：5\n返回集合第一个元素：Student{id=1, age=20, name=\'小明\'}\n返回集合最后一个元素：Student{id=9, age=23, name=\'李四\'}\n排序比较结果为：null\n\n输出集合：\nStudent{id=1, age=20, name=\'小明\'}\nStudent{id=2, age=22, name=\'小红\'}\nStudent{id=3, age=22, name=\'小军\'}\nStudent{id=4, age=24, name=\'小张\'}\nStudent{id=9, age=23, name=\'李四\'}\n\n测试方法2\nStudent{id=1, age=20, name=\'小明\'}\nStudent{id=2, age=22, name=\'小红\'}\nStudent{id=3, age=22, name=\'小军\'}\n\n测试方法3\nStudent{id=1, age=20, name=\'小明\'}\nStudent{id=2, age=22, name=\'小红\'}\n\n测试方法4\nStudent{id=4, age=24, name=\'小张\'}\nStudent{id=9, age=23, name=\'李四\'}\n\n*/\n\n\n# HashSet类\n\n> Class HashSet<E> java.lang.Object java.util.AbstractCollection<E> java.util.AbstractSet<E> Classs HashSet<E> java.lang.Object java.util.AbstractCollection<E> java.util.AbstractSet<E>\n\nHashSet类 在Set集合中的散列形式存储数据的！\n\n不能更改唯一值否则哈希表的唯一地址会错误，也能被删除！ 用HashSet存储的对象，应该重写以下两方法 hashCode()存哈希、equals()方法 哈希地址判断(以上两个方法会影响HashSet唯一性的存储状况)\n\n> HashSet集合 可能情况： 集合中不会保存相同的对象 同一个哈希地址可以存放多个不同对象\n\n代码示例：\n\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Objects;\n\npublic class Demo2 {\n    public static void main(String[] args) {\n        HashSet<Person> set = new HashSet<>();\n        \n        Person p1 = new Person(1,"小明");\n        Person p2 = new Person(2,"小红");\n        Person p3 = new Person(3,"小军");\n        Person p4 = new Person(4,"小张");\n        Person p5 = new Person(5,"小海");\n        Person p6 = new Person(6,"小明");\n    \n        //首位位置里的id：9\n        set.add(p1);\n    \n        /*p1添加错误是因为该集合唯一性是根据 属性id 进行判断唯一的*/\n        //最后位置里的id：9\n        p1.id = 9;\n        System.out.println("更改p1的id改至9添加是否成功？"+set.add(p1));\n    \n        /*添加无效*/\n        set.add(p1);\n        \n        set.add(p2);\n        set.add(p3);\n        set.add(p4);\n        set.add(p5);\n        set.add(p6);\n        \n        System.out.println("遍历数组：");\n        Iterator<Person> in = set.iterator();\n        while (in.hasNext()){\n            System.out.println(in.next());\n        }\n    }\n}\n\nclass Person{\n    int id ;\n    String name;\n    \n    public Person(int id , String name){\n        super();\n        this.id = id ;\n        this.name = name;\n    }\n    \n    //以下两个方法会影响 Set集合 的存储情况\n    \n    //输出对象的值\n    @Override\n    public String toString() {\n        return "Person{" +\n                "id=" + id +\n                ", name=\'" + name + \'\\\'\' +\n                \'}\';\n    }\n    \n    //比较哈希值的地址\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof Person)) {\n            return false;\n        }\n        Person person = (Person) o;\n        return id == person.id;\n    }\n    \n    //根据hash返回哈希值\n    @Override\n    public int hashCode() {\n        return Objects.hash(id);\n    }\n}\n\n/*\t运行结果\n\n更改p1的id改至9添加是否成功？true\n遍历数组：\nPerson{id=9, name=\'小明\'}\nPerson{id=2, name=\'小红\'}\nPerson{id=3, name=\'小军\'}\nPerson{id=4, name=\'小张\'}\nPerson{id=5, name=\'小海\'}\nPerson{id=6, name=\'小明\'}\nPerson{id=9, name=\'小明\'}\n\n*/\n\n\n\n# Map集合\n\nMap集合没有 Collection接口 ，但提供了 key (键)和 value(值)的映射， key (键)和 value(值)都是将其变为了 Map.Entry 并且将 Map.Entry 保存在了 Map 集合之中。Map中不能有相同的 key (键)，每个key (键)只能映射一个value(值)，key (键)决定了存储对象在映射中的存储位置\n\n哈希存储原理\n\n注意：\n\n> 当对象被存进 HashSet 集合后，就不能修改该对象中的那些参与计算的哈希值的属性了，否则，哈希值不对应找不到，在这种情况下，即使在 contains()方法检索对象，也是返回 null 空的结果，这也导致无法从 HashSet 集合中删除当前对象，从而造成内存泄露\n\nMap接口提供的方法\n\n修饰符             方法                            说明\nV               put(K key , V value)          添加一对 K,V ，覆盖原有的V，则返回旧V值 ，否则为null\nvoid            clear()                       清空所有 K , V\nboolean         containsKey(Object key)       查找指定 K值\nboolean         containsValue(Object value)   查找指定 V值\nV               get(Object key)               通过 K 找 V值\nSet<K>          keySet()                      获取 K值 集合\nCollection<V>   values()                      获取 V值 集合\nV               remove(Object key)            删除指定 K 删除，返回 V值 ，没有则null\ndefault V       replace(K key , V value)      Key映射的值，替换指定键条目\nint             size()                        获取 元素总数\n\n实现类\n\n\n# HashMap类\n\n> Class HashMap<K,V>\n> \n> java.lang.Object java.util.AbstractMap<K,V> java.util.HashMap<K,V>\n\nHashMap类 散列存储 键值对速度更快，允许null对象，无序存储，但添加、删除快\n\nHashMap<K , V> m = new HashMap<K , V>();\n/*构造一个空的 HashMap ，默认初始容量(16)和默认负载因子(0.75)(容量和负载因子是影响效率的因素*/\n\n\n\n# LinkedHashMap类\n\n> Class LinkedHashMap<K,V>\n> \n> java.lang.Object java.util.AbstractMap<K,V> java.util.HashMap<K,V> java.util.LinkedHashMap<K,V>\n\nLinkedHashMap类 有序存储 存储在 哈希表 和 双向链表 中，两个存储结合使得有序，实现快速查找，高性能，但消耗空间\n\n\n# TreeMap类\n\n> Class TreeMap<K,V>\n> \n> java.lang.Object java.util.AbstractMap<K,V> java.util.TreeMap<K,V>\n\nTreeMap类 树状 键值对存放有序，不允许null对象，映射关系有一定的顺序，Key(键)不支持对象，数值，null！！\n\n\n# Hashtable类\n\n> Class Hashtable<K,V>\n> \n> java.lang.Object java.util.Dictionary<K,V> java.util.Hashtable<K,V>\n\nHashtable类 安全线程(又称旧版哈希存储) 组中每个哈希桶的对象是以排队形式执行，得以保证 安全线程 ，但效率低\n\n\n# ConcurrentHashMap类\n\n> Class ConcurrentHashMap<K,V>\n> \n> java.lang.Object java.util.AbstractMap<K,V> java.util.concurrent.ConcurrentHashMap<K,V>\n\nConcurrentHashMap类 安全高效 每个哈希桶同时执行，但哈希桶中的链表是排队形式的(又称 分段锁机制)，得以保证 安全线程 和 高效率的情况\n\n\n# 实现类的区别\n\n安全方面 多线程 建议使用 Hashtable 、ConcurrentHashMap 有排序要求的 建议使用 LinkedHashMap 、TreeMap 使用操作方面基本一样，少部分用于特殊方面可自行api了解\n\n代码示例：\n\nimport java.util.*;\n\npublic class Demo {\n    public static void main(String[] args) {\n        HashMap<Object,Object> map = new HashMap<>();\n        \n        //添加数据\n        map.put("no1" , "no1字符串");\n        map.put(12 , "12数值");\n        map.put(12.3, "12.3单精度");\n        map.put(null , null);\n        map.put(new Object() , "obj对象");\n    \n        System.out.println("Map集合总数为："+ map.size());\n    \n        System.out.println("在Map集合中 查找12的键 是否存在？"+map.containsKey(12));\n    \n        System.out.println("在Map集合中 查找 obj的值 是否存在？"+map.containsValue("obj"));\n    \n        //遍历方式 1\n        System.out.println("\\n遍历Map集合：");\n        System.out.println("遍历key ：");\n        //以Set集合的形式获取所有对象Key对象\n        Set<Object> set = map.keySet();\n        for (Object key : set) {\n            //通过 键 获取值 并输出\n            System.out.println("key ：" + key + "\\t\\t\\tV ：" + map.get(key));\n        }\n       \n        System.out.println("\\n Collection 遍历value ：");\n        //以Collection形式获取对象值\n        Collection<Object> con = map.values();\n        for (Object o : con) {\n            System.out.println(o);\n        }\n        \n        //遍历方式 2\n        //也可以这样获取set\n        //Map存储的就是Map.Entry , Map.Entry存储了 Key键 和 Value值 \n        /*\n        \n        Set<Map.Entry<Object, Object>> set = map.entrySet();\n        Iterator<Map.Entry<Object, Object>> iter = set.iterator();\n        while(iter.hasNext()){\n        \tMap.Entry<Object,Object> me = iter.next();\n        \tSystem.out.println(me.getKey()+" --\x3e "+me.getValue());\n        }\n        */\n    }\n}\n\n/*\n\nMap集合总数为：5\n在Map集合中 查找12的键 是否存在？true\n在Map集合中 查找 obj的值 是否存在？false\n\n遍历Map集合：\n遍历key ：\nkey ：null\t\t\tV ：null\nkey ：java.lang.Object@10f87f48\t\t\tV ：obj对象\nkey ：no1\t\t\tV ：no1字符串\nkey ：12.3\t\t\tV ：12.3单精度\nkey ：12\t\t\tV ：12数值\n\n遍历value ：\nnull\nobj对象\nno1字符串\n12.3单精度\n12数值\n\n*/\n\n\n\n# 集合总结\n\n 1. 类集合是一个动态的对象数组，可以向集合中加入任意多的内容\n 2. List 接口中是允许有重复元素的，Set 接口中是不允许有重复元素\n 3. 所有的重复元素依靠 hashCode()和 equals 进行区分\n 4. List 接口的常用子类：ArrayList、Vector\n 5. Set 接口的常用子类：HashSet、TreeSet\n 6. TreeSet 是可以排序，一个类的对象依靠 Comparable 接口排序\n 7. Map 接口中允许存放一对内容，key(键)、value(值)\n 8. Map 接口的子类：HashMap、Hashtable、TreeMap\n 9. Map 使用 Iterator 输出的详细步骤\n\nMap集合区别\n\n集合类                 KEY   VLAUE   SUPER         说明\nHashtable           N     N       Dictionary    安全线程\nConcurrentHashMap   N     N       AbstractMap   锁分段技术\nTreeMap             N     Y       AbstractMap   不安全线程\nHashMap             Y     Y       AbstractMap   不安全线程\n\n\n# 迭代器\n\n迭代器用来遍历集合中的元素\n\n\n# Iterator接口\n\nIterator接口 是 Collection接口 的子接口 用来遍历删除数据用的\n\n方法\n\n返回类型      方法          说明\nboolean   hasNext()   迭代方向存在元素，则 true\nE         next()      返回当前指向元素，并前进一位\nvoid      remove()    从底层集合中删除此迭代器返回的最后一个元素\n\n\n# ListIterator接口\n\nListIterator接口 是 List接口 的子接口 用来 遍历 删除 添加使用\n\n方法\n\n返回类型      方法                说明\nvoid      add(E e)          将元素插入列表\nboolean   hasNext()         迭代正方向有元素\nE         next()            返回列表下一位元素的值\nint       nextIndex()       返回随后调用 next()元素 的索引\nE         previous()        返回列表上一位元素的值\nint       previousInext()   返回随后调用 previous()元素 的索引\nvoid      remove()          删除由 next() 或 previous() 返回的元素\nvoid      set(E e)          替换 由next() 或 previous() 返回的元素\n\n迭代器异常说明：\n\n> 快速失败： 迭代器创建后对集合进行批量更改或删除会导致迭代器出现不确定行为，迭代器会抛出ConcurrentModificationException 异常\n> \n> 安全失败： 迭代器在创建时候会备份一份集合，批量修改会导致数据的不确定，没能即使同步导致的异常，迭代器会抛出 ConcurrentModificationException 异常\n\n代码示例： (更多方法可执行测试)\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.ListIterator;\n\npublic class Demo {\n    public static void main(String[] args) {\n    \n        List<Integer> list = new ArrayList<>();\n        \n        list.add(1);\n        list.add(2);\n        list.add(3);\n        list.add(4);\n        list.add(5);\n        list.add(6);\n    \n        System.out.println("size : " +list.size());\n    \n    //   迭代器\n        \n        Iterator<Integer> ito = list.listIterator();\n        while (ito.hasNext()){\n            int n = ito.next();\n            if (n == 4){\n                ito.remove();\n                continue;\n            }\n            System.out.print(n+"  ");\n        }\n        System.out.println("\\n======");\n        System.out.println(list);\n        System.out.println("====================");\n    \n        System.out.println( );\n        System.out.println( );\n        \n        //此时 list内容 == [1, 2, 3, 5, 6]\n        \n        ListIterator<Integer> listIto = list.listIterator();\n        //向前两位\n        listIto.next();\n        listIto.next();\n        listIto.previous();\n        listIto.next();\n        listIto.previous();\n        System.out.println("迭代器前索引 ： "+ listIto.nextIndex());\n        \n        \n        System.out.println("\\n======");\n        System.out.println(list);\n        System.out.println("======");\n        \n    }\n}\n\n\n/*\n\nsize : 6\n1  2  3  5  6  \n======\n[1, 2, 3, 5, 6]\n====================\n\n\n迭代器前索引 ： 1\n\n======\n[1, 2, 3, 5, 6]\n======\n\n\n*/\n',normalizedContent:'# java集合类\n\n\n# 概述\n\njava.util提供的，集合类可称为容器，集合的长度是可变的(动态长度)，集合存放的是对象的引用\n\n\n# collection接口\n\ncollection接口不能直接使用，它提供了 添加、删除、管理 元素等操作 给 list 和 set 子接口进行操作\n\n常用方法\n\n修饰符           方法                          参数      说明\nvoid          add(object o)               1.对象    添加指定 对象\nvoid          addall(collection c)        1. 集合   添加指定集合对象\nvoid          clear()                     -       清空集合中的元素\nboolean       contains(object o)          1. 对象   查找一个元素是否存在\nboolean       containsall(collection c)   1.对象    查找一个集合相同元素是否存在\nboolean       retainall(collection c)     1.对象    保存指定集合中的元素\nvoid          remove(object o)            1. 对象   指定对象在集合中移除\nboolean       isempty()                   -       判断集合是否为空\nint           size()                      -       获取集合中的个数\nobject[]      toarray()                   -       将集合以数组形式输出\niterator<e>   iterator()                  -       集合迭代器(iterator 接口实例化)\n\n\n# list集合\n\nlist集合像列表清单，它允许元素重复，但各个元素的顺序就是对象插入的顺序\n\nlist接口及实现类\n\nlist接口 继承了 collection接口，因此也有父接口的方法\n\n方法\n\n返回类型              方法                                     说明\nboolean           add(object obj)                        插入数据\nboolean           add(int index  , object obj)           指定位置插入数据\ne                 get(int index)                         获取指定索引的元素\nint               indexof(object o)                      根据对象查找指定的位置，不存在则-1\nint               lastindexof(object o)                  从后面向前查找位置，不存在则-1\nlistiterator<e>   listiterator(int index)                返回从指定位置的 listiterator 接口的实例\ne                 remove(int index)                      删除指定位置的内容\ne                 set(int index , object obj)            将集合中指定索引位置的对象修改为指定的对象\nlist<e>           sublist(int fromindex , int toindex)   返回子集合\nlistiterator<e>   listiterator()                         返回特殊的迭代器(含插入更改功能)\n\n实现类\n\nlist接口常用的类有 arraylist 、vector 和 linkedlist 类\n\nvector 与 arraylist 操作是相同的 ，vector类 过时了 建议使用arraylist\n\n# arraylist 类\n\n> class arraylist<e>\n> \n> java.lang.object java.util.abstractcollection<e> java.util.abstractlist<e> java.util.arraylist<e>\n\narraylist类 以数组的形式存储 ，该类提供了数组操作的方法！\n\n/*arraylist类 的定义*/\npublic class arraylist<e> extends abstractlist<e> implements list<e>, randomaccess,cloneable, serializable\n\n\narraylist类 动态数组\n\nlist<e> array = new arraylist<e>();\nlist<e> array = new arraylist<e>(int max); //设置空间大小\n\n\n----------------------------------------\n\n# linkedlist 类\n\n> class linkedlist<e>\n> \n> java.lang.object java.util.abstractcollection<e> java.util.abstractlist<e> java.util.abstractsequentiallist<e> java.util.linkedlist<e>\n\nlinkedlist类 以双向链表的形式存储数据 ，也一样继承 list类 中的方法！\n\n/*linkedlist的定义*/\npublic class linkedlist<e> extends abstractsequentiallist<e> implements list<e>, deque<e>, cloneable, serializable\n\n\nlinkedlist类 链表结构保存对象\n\nlist list = new linkedlist();\n\n\ndeque接口 拓展 queue 接口 ，queue接口实现的方法：\n\n返回类型      方法              说明\nboolean   add(e e)        添加元素\nboolean   offer(e e)      添加元素\ne         element()       获取头元素\ne         peek()          获取头元素\ne         poll()          获取并删除头元素\ne         remove()        获取并删除头元素\ne         removelast()    获取并删除最后一个\ne         removefirst()   获取并删除第一个\n\n方法区别\n\n> add 与 offer 区别\n> \n> offer 在队列有限制的的情况下优势更大！\n> \n> element 与 peek 区别\n> \n> element 队列为空，则抛出异常 peek 队列为空，则返回 null\n> \n> poll 与 remove 区别\n> \n> poll 队列为空，则返回 null remove 队列为空，则抛出异常\n\n# arraylist与linkedlist的区别\n\narraylist查找较快，但插入、删除对象的速度较慢\n\nlinkedlist查找较慢，但插入、删除对象的速度较快\n\n代码示例：\n\nimport java.util.arraylist;\nimport java.util.linkedlist;\nimport java.util.list;\n\npublic class demo {\n    public static void main(string[] args) {\n        //另个用法一样\n//        list  list = new arraylist();\n        list list = new linkedlist();\n        \n        list.add("a");\n        list.add("b");\n        list.add("c");\n        list.add("d");\n        list.add("e");\n        \n        //集合长度\n        system.out.println("长度为："+list.size());\n        //集合获取索引值(2)\n        system.out.println("get(2)："+list.get(2));\n        //更该索引值(2)\n        list.set(2,"cc");\n        //删除索引值4\n        list.remove(4);\n        //中间插入\n        list.add(1,"bb");\n        list.add(null);\n        \n        //输出内容\n        system.out.println("遍历集合：");\n        for (int i = 0; i < list.size(); i++) {\n            system.out.println(list.get(i));\n        }\n        \n    }\n}\n\n/*\n\n长度为：5\nget(2)：c\n遍历集合：\na\nbb\nb\ncc\nd\nnull\n\n*/\n\n\n\n# set集合\n\nset集合中的对象不按特定的方式排序，只是单纯的把对象添加到集合中，但不能有重复对象，set接口 继承了 collection接口，因此也有父接口的方法。想要获取 set集合中的元素，需要获取整个集合与元素遍历，不能更改集合元素值！！\n\n实现类\n\n# treeset类\n\n> class treeset<e> java.lang.object java.util.abstractcollection<e> java.util.abstractset<e> java.util.treeset<e>\n\ntreeset类 实现了set集合在遍历集合时按照自然顺序递增排序\n\n存储的类型如果是 对象，那么该对象就必须实现 comparable接口 ，comparable接口中有compareto抽象方法 可以对集合处理排列方式 ，compareto抽象方法 返回整型进行控制排列(0(相等) 、 正数 (小于)、 负数(大于))\n\ntreeset<e> set = new treeset<e>();\n\n\ntreeset类 提供方法\n\n返回类型           方法                                   说明\n<e>            first()                              返回集合中当前的第一个(最低)元素\n<e>            last()                               返回集合中当前的最后(最高)元素\n<e>            comparator()                         用于对集合元素进行排序的比较器，以比较返回 null\nsortedset<e>   headset(e toelement)                 返回新的set集合，新集合 toelement(不包含)之前所有对象\nsortedset<e>   subset(e fromelement, e toelement)   返回新的set集合，其元素的范围从 fromelement (含)到 toelement\nsortedset<e>   tailset(e fromelement)               返回新的set集合，新集合 7fromelement(包含)之后所有对象\n\n代码示例：\n\nimport java.util.iterator;\nimport java.util.objects;\nimport java.util.set;\nimport java.util.treeset;\n\npublic class demo {\n    public static void main(string[] args) {\n        treeset<student> set = new treeset();\n        \n        student s = new student(1 , 20 , "小明");\n        student s2 = new student(2 , 22 , "小红");\n        student s3 = new student(3 , 22 , "小军");\n        student s4 = new student(4 , 24 , "小张");\n        student s5 = new student(6 , 21 , "张三");\n        student s6 = new student(9 , 23 , "李四");\n        \n        set.add(s);\n        set.add(s2);\n        set.add(s3);\n        set.add(s4);\n        set.add(s5);\n        set.add(s6);\n        set.add(s6);//重复，则无效\n//        set.add(null); 异常\n    \n        system.out.println("集合总数为："+set.size());\n    \n        system.out.println("返回集合第一个元素："+set.first());\n        \n        system.out.println("返回集合最后一个元素："+set.last());\n    \n        system.out.println("排序比较结果为："+set.comparator());\n        \n        system.out.println("\\n输出集合：");\n        iterator it = set.iterator();\n        //如果迭代有更多的元素，则true\n        while(it.hasnext()){\n            //next() 会自动调用对象的 tostring()方法\n            system.out.println(it.next());\n        }\n        \n        //测试headset()方法\n        system.out.println("\\n测试方法2");\n        //截止至s4对象位置\n        it = set.headset(s4).iterator();\n        while(it.hasnext()){\n            //next() 会自动调用对象的 tostring()方法\n            system.out.println(it.next());\n        }\n    \n        //测试subset()方法\n        system.out.println("\\n测试方法3");\n        //指定对象范围s ，s3\n        it = set.subset(s , s3).iterator();\n        while(it.hasnext()){\n            //next() 会自动调用对象的 tostring()方法\n            system.out.println(it.next());\n        }\n    \n        //测试stailset()方法\n        system.out.println("\\n测试方法4");\n        //从s4对象位置开始排序\n        it = set.tailset(s4).iterator();\n        while(it.hasnext()){\n            //next() 会自动调用对象的 tostring()方法\n            system.out.println(it.next());\n        }\n        \n    }\n}\n\n\nclass student implements comparable<student>{\n    int id;\n    int age;\n    string name;\n    \n    public student(){}\n    //实例对象时获取的参数(信息)\n    public student(int id , int age , string name){\n        super();\n        this.id = id;\n        this.age = age;\n        this.name = name;\n    }\n    \n    //迭代输出的信息\n    @override\n    public string tostring() {\n        return "student{" +\n                "id=" + id +\n                ", age=" + age +\n                ", name=\'" + name + \'\\\'\' +\n                \'}\';\n    }\n    \n    //迭代排序用到的方法\n    @override\n    public int compareto(student stt) {\n        /*\n        * 排序的值尽可能保持 唯一\n        * 如唯一的id\n        * */\n        \n        //按照age排序的顺序(重复会被覆盖掉)\n//        int tmp = this.age - stt.age;\n        \n        //按照id排序的顺序\n        int tmp = this.id - stt.id;\n        if(tmp != 0){\n            //math.abs() 绝对值\n            //差值 除以本身 绝对值，结果只有 1 或 -1值\n            tmp = tmp / math.abs(tmp);\n        }\n        /*\n        * 判断结果只有 0 、 1 、 -1(相等 ； 小于 ； 大于)\n        *   根据三值来进行排序\n        * */\n        return tmp;\n    }\n    \n    \n    @override\n    public boolean equals(object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getclass() != o.getclass()) {\n            return false;\n        }\n        student student = (student) o;\n        return id == student.id;\n    }\n    \n    @override\n    public int hashcode() {\n        return objects.hash(id);\n    }\n}\n\n/*\n\n集合总数为：5\n返回集合第一个元素：student{id=1, age=20, name=\'小明\'}\n返回集合最后一个元素：student{id=9, age=23, name=\'李四\'}\n排序比较结果为：null\n\n输出集合：\nstudent{id=1, age=20, name=\'小明\'}\nstudent{id=2, age=22, name=\'小红\'}\nstudent{id=3, age=22, name=\'小军\'}\nstudent{id=4, age=24, name=\'小张\'}\nstudent{id=9, age=23, name=\'李四\'}\n\n测试方法2\nstudent{id=1, age=20, name=\'小明\'}\nstudent{id=2, age=22, name=\'小红\'}\nstudent{id=3, age=22, name=\'小军\'}\n\n测试方法3\nstudent{id=1, age=20, name=\'小明\'}\nstudent{id=2, age=22, name=\'小红\'}\n\n测试方法4\nstudent{id=4, age=24, name=\'小张\'}\nstudent{id=9, age=23, name=\'李四\'}\n\n*/\n\n\n# hashset类\n\n> class hashset<e> java.lang.object java.util.abstractcollection<e> java.util.abstractset<e> classs hashset<e> java.lang.object java.util.abstractcollection<e> java.util.abstractset<e>\n\nhashset类 在set集合中的散列形式存储数据的！\n\n不能更改唯一值否则哈希表的唯一地址会错误，也能被删除！ 用hashset存储的对象，应该重写以下两方法 hashcode()存哈希、equals()方法 哈希地址判断(以上两个方法会影响hashset唯一性的存储状况)\n\n> hashset集合 可能情况： 集合中不会保存相同的对象 同一个哈希地址可以存放多个不同对象\n\n代码示例：\n\nimport java.util.hashset;\nimport java.util.iterator;\nimport java.util.objects;\n\npublic class demo2 {\n    public static void main(string[] args) {\n        hashset<person> set = new hashset<>();\n        \n        person p1 = new person(1,"小明");\n        person p2 = new person(2,"小红");\n        person p3 = new person(3,"小军");\n        person p4 = new person(4,"小张");\n        person p5 = new person(5,"小海");\n        person p6 = new person(6,"小明");\n    \n        //首位位置里的id：9\n        set.add(p1);\n    \n        /*p1添加错误是因为该集合唯一性是根据 属性id 进行判断唯一的*/\n        //最后位置里的id：9\n        p1.id = 9;\n        system.out.println("更改p1的id改至9添加是否成功？"+set.add(p1));\n    \n        /*添加无效*/\n        set.add(p1);\n        \n        set.add(p2);\n        set.add(p3);\n        set.add(p4);\n        set.add(p5);\n        set.add(p6);\n        \n        system.out.println("遍历数组：");\n        iterator<person> in = set.iterator();\n        while (in.hasnext()){\n            system.out.println(in.next());\n        }\n    }\n}\n\nclass person{\n    int id ;\n    string name;\n    \n    public person(int id , string name){\n        super();\n        this.id = id ;\n        this.name = name;\n    }\n    \n    //以下两个方法会影响 set集合 的存储情况\n    \n    //输出对象的值\n    @override\n    public string tostring() {\n        return "person{" +\n                "id=" + id +\n                ", name=\'" + name + \'\\\'\' +\n                \'}\';\n    }\n    \n    //比较哈希值的地址\n    @override\n    public boolean equals(object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof person)) {\n            return false;\n        }\n        person person = (person) o;\n        return id == person.id;\n    }\n    \n    //根据hash返回哈希值\n    @override\n    public int hashcode() {\n        return objects.hash(id);\n    }\n}\n\n/*\t运行结果\n\n更改p1的id改至9添加是否成功？true\n遍历数组：\nperson{id=9, name=\'小明\'}\nperson{id=2, name=\'小红\'}\nperson{id=3, name=\'小军\'}\nperson{id=4, name=\'小张\'}\nperson{id=5, name=\'小海\'}\nperson{id=6, name=\'小明\'}\nperson{id=9, name=\'小明\'}\n\n*/\n\n\n\n# map集合\n\nmap集合没有 collection接口 ，但提供了 key (键)和 value(值)的映射， key (键)和 value(值)都是将其变为了 map.entry 并且将 map.entry 保存在了 map 集合之中。map中不能有相同的 key (键)，每个key (键)只能映射一个value(值)，key (键)决定了存储对象在映射中的存储位置\n\n哈希存储原理\n\n注意：\n\n> 当对象被存进 hashset 集合后，就不能修改该对象中的那些参与计算的哈希值的属性了，否则，哈希值不对应找不到，在这种情况下，即使在 contains()方法检索对象，也是返回 null 空的结果，这也导致无法从 hashset 集合中删除当前对象，从而造成内存泄露\n\nmap接口提供的方法\n\n修饰符             方法                            说明\nv               put(k key , v value)          添加一对 k,v ，覆盖原有的v，则返回旧v值 ，否则为null\nvoid            clear()                       清空所有 k , v\nboolean         containskey(object key)       查找指定 k值\nboolean         containsvalue(object value)   查找指定 v值\nv               get(object key)               通过 k 找 v值\nset<k>          keyset()                      获取 k值 集合\ncollection<v>   values()                      获取 v值 集合\nv               remove(object key)            删除指定 k 删除，返回 v值 ，没有则null\ndefault v       replace(k key , v value)      key映射的值，替换指定键条目\nint             size()                        获取 元素总数\n\n实现类\n\n\n# hashmap类\n\n> class hashmap<k,v>\n> \n> java.lang.object java.util.abstractmap<k,v> java.util.hashmap<k,v>\n\nhashmap类 散列存储 键值对速度更快，允许null对象，无序存储，但添加、删除快\n\nhashmap<k , v> m = new hashmap<k , v>();\n/*构造一个空的 hashmap ，默认初始容量(16)和默认负载因子(0.75)(容量和负载因子是影响效率的因素*/\n\n\n\n# linkedhashmap类\n\n> class linkedhashmap<k,v>\n> \n> java.lang.object java.util.abstractmap<k,v> java.util.hashmap<k,v> java.util.linkedhashmap<k,v>\n\nlinkedhashmap类 有序存储 存储在 哈希表 和 双向链表 中，两个存储结合使得有序，实现快速查找，高性能，但消耗空间\n\n\n# treemap类\n\n> class treemap<k,v>\n> \n> java.lang.object java.util.abstractmap<k,v> java.util.treemap<k,v>\n\ntreemap类 树状 键值对存放有序，不允许null对象，映射关系有一定的顺序，key(键)不支持对象，数值，null！！\n\n\n# hashtable类\n\n> class hashtable<k,v>\n> \n> java.lang.object java.util.dictionary<k,v> java.util.hashtable<k,v>\n\nhashtable类 安全线程(又称旧版哈希存储) 组中每个哈希桶的对象是以排队形式执行，得以保证 安全线程 ，但效率低\n\n\n# concurrenthashmap类\n\n> class concurrenthashmap<k,v>\n> \n> java.lang.object java.util.abstractmap<k,v> java.util.concurrent.concurrenthashmap<k,v>\n\nconcurrenthashmap类 安全高效 每个哈希桶同时执行，但哈希桶中的链表是排队形式的(又称 分段锁机制)，得以保证 安全线程 和 高效率的情况\n\n\n# 实现类的区别\n\n安全方面 多线程 建议使用 hashtable 、concurrenthashmap 有排序要求的 建议使用 linkedhashmap 、treemap 使用操作方面基本一样，少部分用于特殊方面可自行api了解\n\n代码示例：\n\nimport java.util.*;\n\npublic class demo {\n    public static void main(string[] args) {\n        hashmap<object,object> map = new hashmap<>();\n        \n        //添加数据\n        map.put("no1" , "no1字符串");\n        map.put(12 , "12数值");\n        map.put(12.3, "12.3单精度");\n        map.put(null , null);\n        map.put(new object() , "obj对象");\n    \n        system.out.println("map集合总数为："+ map.size());\n    \n        system.out.println("在map集合中 查找12的键 是否存在？"+map.containskey(12));\n    \n        system.out.println("在map集合中 查找 obj的值 是否存在？"+map.containsvalue("obj"));\n    \n        //遍历方式 1\n        system.out.println("\\n遍历map集合：");\n        system.out.println("遍历key ：");\n        //以set集合的形式获取所有对象key对象\n        set<object> set = map.keyset();\n        for (object key : set) {\n            //通过 键 获取值 并输出\n            system.out.println("key ：" + key + "\\t\\t\\tv ：" + map.get(key));\n        }\n       \n        system.out.println("\\n collection 遍历value ：");\n        //以collection形式获取对象值\n        collection<object> con = map.values();\n        for (object o : con) {\n            system.out.println(o);\n        }\n        \n        //遍历方式 2\n        //也可以这样获取set\n        //map存储的就是map.entry , map.entry存储了 key键 和 value值 \n        /*\n        \n        set<map.entry<object, object>> set = map.entryset();\n        iterator<map.entry<object, object>> iter = set.iterator();\n        while(iter.hasnext()){\n        \tmap.entry<object,object> me = iter.next();\n        \tsystem.out.println(me.getkey()+" --\x3e "+me.getvalue());\n        }\n        */\n    }\n}\n\n/*\n\nmap集合总数为：5\n在map集合中 查找12的键 是否存在？true\n在map集合中 查找 obj的值 是否存在？false\n\n遍历map集合：\n遍历key ：\nkey ：null\t\t\tv ：null\nkey ：java.lang.object@10f87f48\t\t\tv ：obj对象\nkey ：no1\t\t\tv ：no1字符串\nkey ：12.3\t\t\tv ：12.3单精度\nkey ：12\t\t\tv ：12数值\n\n遍历value ：\nnull\nobj对象\nno1字符串\n12.3单精度\n12数值\n\n*/\n\n\n\n# 集合总结\n\n 1. 类集合是一个动态的对象数组，可以向集合中加入任意多的内容\n 2. list 接口中是允许有重复元素的，set 接口中是不允许有重复元素\n 3. 所有的重复元素依靠 hashcode()和 equals 进行区分\n 4. list 接口的常用子类：arraylist、vector\n 5. set 接口的常用子类：hashset、treeset\n 6. treeset 是可以排序，一个类的对象依靠 comparable 接口排序\n 7. map 接口中允许存放一对内容，key(键)、value(值)\n 8. map 接口的子类：hashmap、hashtable、treemap\n 9. map 使用 iterator 输出的详细步骤\n\nmap集合区别\n\n集合类                 key   vlaue   super         说明\nhashtable           n     n       dictionary    安全线程\nconcurrenthashmap   n     n       abstractmap   锁分段技术\ntreemap             n     y       abstractmap   不安全线程\nhashmap             y     y       abstractmap   不安全线程\n\n\n# 迭代器\n\n迭代器用来遍历集合中的元素\n\n\n# iterator接口\n\niterator接口 是 collection接口 的子接口 用来遍历删除数据用的\n\n方法\n\n返回类型      方法          说明\nboolean   hasnext()   迭代方向存在元素，则 true\ne         next()      返回当前指向元素，并前进一位\nvoid      remove()    从底层集合中删除此迭代器返回的最后一个元素\n\n\n# listiterator接口\n\nlistiterator接口 是 list接口 的子接口 用来 遍历 删除 添加使用\n\n方法\n\n返回类型      方法                说明\nvoid      add(e e)          将元素插入列表\nboolean   hasnext()         迭代正方向有元素\ne         next()            返回列表下一位元素的值\nint       nextindex()       返回随后调用 next()元素 的索引\ne         previous()        返回列表上一位元素的值\nint       previousinext()   返回随后调用 previous()元素 的索引\nvoid      remove()          删除由 next() 或 previous() 返回的元素\nvoid      set(e e)          替换 由next() 或 previous() 返回的元素\n\n迭代器异常说明：\n\n> 快速失败： 迭代器创建后对集合进行批量更改或删除会导致迭代器出现不确定行为，迭代器会抛出concurrentmodificationexception 异常\n> \n> 安全失败： 迭代器在创建时候会备份一份集合，批量修改会导致数据的不确定，没能即使同步导致的异常，迭代器会抛出 concurrentmodificationexception 异常\n\n代码示例： (更多方法可执行测试)\n\nimport java.util.arraylist;\nimport java.util.iterator;\nimport java.util.list;\nimport java.util.listiterator;\n\npublic class demo {\n    public static void main(string[] args) {\n    \n        list<integer> list = new arraylist<>();\n        \n        list.add(1);\n        list.add(2);\n        list.add(3);\n        list.add(4);\n        list.add(5);\n        list.add(6);\n    \n        system.out.println("size : " +list.size());\n    \n    //   迭代器\n        \n        iterator<integer> ito = list.listiterator();\n        while (ito.hasnext()){\n            int n = ito.next();\n            if (n == 4){\n                ito.remove();\n                continue;\n            }\n            system.out.print(n+"  ");\n        }\n        system.out.println("\\n======");\n        system.out.println(list);\n        system.out.println("====================");\n    \n        system.out.println( );\n        system.out.println( );\n        \n        //此时 list内容 == [1, 2, 3, 5, 6]\n        \n        listiterator<integer> listito = list.listiterator();\n        //向前两位\n        listito.next();\n        listito.next();\n        listito.previous();\n        listito.next();\n        listito.previous();\n        system.out.println("迭代器前索引 ： "+ listito.nextindex());\n        \n        \n        system.out.println("\\n======");\n        system.out.println(list);\n        system.out.println("======");\n        \n    }\n}\n\n\n/*\n\nsize : 6\n1  2  3  5  6  \n======\n[1, 2, 3, 5, 6]\n====================\n\n\n迭代器前索引 ： 1\n\n======\n[1, 2, 3, 5, 6]\n======\n\n\n*/\n',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Java异常",frontmatter:{title:"Java异常",date:"2020-02-18T00:00:00.000Z",permalink:"/backend/b5ikzm",categories:["后端","Java基础"],tags:["Java"],author:"柏竹"},regularPath:"/01.%E5%90%8E%E7%AB%AF/01.Java%E5%9F%BA%E7%A1%80/06.%E5%BC%82%E5%B8%B8.html",relativePath:"01.后端/01.Java基础/06.异常.md",key:"v-65c36e4f",path:"/backend/b5ikzm/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:13},{level:2,title:"Throwable异常",slug:"throwable异常",normalizedTitle:"throwable异常",charIndex:226},{level:2,title:"常见异常",slug:"常见异常",normalizedTitle:"常见异常",charIndex:1587},{level:2,title:"捕捉异常",slug:"捕捉异常",normalizedTitle:"捕捉异常",charIndex:2434},{level:3,title:"try-catch 异常",slug:"try-catch-异常",normalizedTitle:"try-catch 异常",charIndex:2443},{level:3,title:"try-with-resources异常",slug:"try-with-resources异常",normalizedTitle:"try-with-resources异常",charIndex:2782},{level:2,title:"自定义异常",slug:"自定义异常",normalizedTitle:"自定义异常",charIndex:3028},{level:2,title:"抛出异常",slug:"抛出异常",normalizedTitle:"抛出异常",charIndex:3105},{level:3,title:"throws 抛出异常",slug:"throws-抛出异常",normalizedTitle:"throws 抛出异常",charIndex:3337},{level:3,title:"throw 抛出异常",slug:"throw-抛出异常",normalizedTitle:"throw 抛出异常",charIndex:3577},{level:2,title:"异常的使用原则",slug:"异常的使用原则",normalizedTitle:"异常的使用原则",charIndex:3668},{level:2,title:"代码索引",slug:"代码索引",normalizedTitle:"代码索引",charIndex:3831},{level:3,title:"Throwable异常",slug:"throwable异常-2",normalizedTitle:"throwable异常",charIndex:226},{level:4,title:"Deme类",slug:"deme类",normalizedTitle:"deme类",charIndex:3862},{level:4,title:"MyTest类",slug:"mytest类",normalizedTitle:"mytest类",charIndex:4736},{level:3,title:"try-catch 异常捕捉",slug:"try-catch-异常捕捉",normalizedTitle:"try-catch 异常捕捉",charIndex:2762},{level:3,title:"try-with-resources 异常",slug:"try-with-resources-异常",normalizedTitle:"try-with-resources 异常",charIndex:3001},{level:4,title:"Deme类",slug:"deme类-2",normalizedTitle:"deme类",charIndex:3862},{level:4,title:"MyTestA类",slug:"mytesta类",normalizedTitle:"mytesta类",charIndex:7842},{level:4,title:"MyTestB类",slug:"mytestb类",normalizedTitle:"mytestb类",charIndex:8348},{level:3,title:"自定义异常",slug:"自定义异常-2",normalizedTitle:"自定义异常",charIndex:3028},{level:3,title:"throws 抛出异常",slug:"throws-抛出异常-2",normalizedTitle:"throws 抛出异常",charIndex:3337},{level:3,title:"throw 抛出异常",slug:"throw-抛出异常-2",normalizedTitle:"throw 抛出异常",charIndex:3577}],headersStr:"概述 Throwable异常 常见异常 捕捉异常 try-catch 异常 try-with-resources异常 自定义异常 抛出异常 throws 抛出异常 throw 抛出异常 异常的使用原则 代码索引 Throwable异常 Deme类 MyTest类 try-catch 异常捕捉 try-with-resources 异常 Deme类 MyTestA类 MyTestB类 自定义异常 throws 抛出异常 throw 抛出异常",content:'# Java异常\n\n\n# 概述\n\n异常机制提供了程序退出的安全通道。当出现错误后，程序执行的流程发生改变，程序的控制权转移到异常处理器\n\nJava类库的每个包中都定义有异常类，所有的异常类都是 Throwable类 的子类，有两个子类分别是 Error类、Exception类\n\nError类 是描述java运行系统中的内部错误以及资源耗尽的错误，属于较为致命的错误\n\nException类 是可以通过捕捉处理使程序继续运行，属于非致命的错误\n\n\n# Throwable异常\n\nThrowable类 是所有错误和异常\n\n构造方法\n\nThrowable() Throwable(String message) Throwable(String message , Throwable cause) Throwable(Throwable cause)\n\n> message： 详细信息（getMessage() 提供） cause： 原因（getCause() 提供）\n\n方法\n\n返回                    方法                                              说明\nvoid                  addSuppressed(Throwable exception)              追加指定异常(有抑制的异常的作用)\nThrowable             fillInStackTrace()                              执行堆栈跟踪\nThrowable             getCause()                                      获取原因，未知 null\nString                getLocalizedMessage()                           创建此可抛出的本地化描述\nString                getMessage()                                    获取 异常详细，未知 null\nStackTraceElement[]   getStackTrace()                                 获取堆栈跟踪信息的数组\nThrowable[]           getSuppressed()                                 获取所有被抑制的异常的数组\nThrowable             initCause(Throwable cause)                      更改原因\nvoid                  printStackTrace()                               异常打印至错误流\nvoid                  printStackTrace(PrintStream s)                  异常打印至字节流\nvoid                  printStackTrace(PrintWriter s)                  异常打印至字符流\nvoid                  setStackTrace(StackTraceElement[] stackTrace)   设置堆栈元素\nString                toString()                                      简短描述错误\n\n点击代码示例*（Throwable操作）\n\n\n# 常见异常\n\n异常类                               说明\nClassCastException                类型转换异常类\nClassNotFoundException            没找到相应类异常\nArithmeticException               算术条件异常\nArrayIndexOutOfBoundsException    数组索引越界异常\nArrayStoreException               数组中包含不兼容的值抛出的异常\nSQLException                      操作数据库异常类\nNullPointerException              空指针异常\nNoSuchFieldException              字段未找到异常\nNoSuchMethodException             方法未找到抛出的异常\nNumberFormatException             字符串转换为数字抛出的异常\nNegativeArraySizeException        数组长度为负异常\nStringIndexOutOfBoundsException   字符串索引超出范围抛出的异常\nIOException                       操作输入流和输出流时异常\nIllegalAccessException            不允许访问某类异常\nInstantiationException            当应用程序试图使用Class类中的newInstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常\nEOFException                      文件已结束异常\nFileNotFoundException             文件未找到异常\n\n\n# 捕捉异常\n\n\n# try-catch 异常\n\ntry{\n   被捕获代码的区块\n}catch(异常类型 e){\n   对异常处理的区块\n}catch(异常类型 e){\n   对异常处理的区块\n}catch(异常类型 e){\n   对异常处理的区块\n}finally{\n    最后运行的区块\n}\n\n\n> try： 语句用来存放可能发生异常的语句 catch： 激发被捕获的异常类型 finally： 异常处理的最后运行的区域\n\nfinally语句不会执行情况：\n\n * 在finally语句块中发生了异常\n * 在前面的代码中使用了 System.exit()（退出程序）\n * 程序所在的线程死亡（运行时终止程序）\n * 关闭CPU\n\n点击代码示例* （try-catch 异常捕捉）\n\n\n# try-with-resources异常\n\ntry-with-resources异常是JDK9的新功能，\n\n * try 块没有发生异常，自动调用 close 方法\n * try 块 发生异常，然后自动调用 close()方法，如果 close 也发生异常，close() 方法的异常会在catch 中被压制，但是你可以在catch块中，用 Throwable.getSuppressed 方法来获取到压制异常的数组\n\n点击代码示例* （try-with-resources 异常）\n\n\n# 自定义异常\n\n创建API中没有的异常，自定条件的异常\n\n> 使用步骤：\n> \n>  1. 创建自定义异常类\n>  2. 在方法中通过 throw 关键字 抛出异常对象\n>  3. 如果在当前抛出异常的方法中处理异常，可以使用 try-catch语句块捕获并处理，否则在方法的声明处通过 throws关键字 指明要抛出给方法调用者的异常\n>  4. 在出现异常方法的调用者中捕获并处理异常\n\nclass 自定义异常类 extends 已有的异常类{···}\n\n\n点击代码示例* （自定义异常）\n\n\n# 抛出异常\n\n方法出现异常，又不想在当前方法处理，则可以用 throws、throw 关键字 在方法中抛出异常\n\n\n# throws 抛出异常\n\nthrows将代码中可能产生的异常交给上一级处理，直到处理异常 try-catch 语句调用 ，否则调用的那个方法也要加抛出的关键字已经方法类（一般使用于方法传参异常）\n\npublic void 方法名() throws 异常类型1,...,异常类型n{  }\n\n\n被调用时：\n\ntry{\n    方法名();\n}catch(异常类型 e){\n    e.printStackTrace();\n}\n\n\n点击代码示例* （throws 抛出异常）\n\n\n# throw 抛出异常\n\n手动制造异常。程序运行到throw语句时立即终止程序，不会执行后面的语句\n\n使用throw抛出异常的前提\n\n点击代码示例* （throw 抛出异常）\n\n\n# 异常的使用原则\n\n提高程序的安全性，控制流程状况以及异常修复！\n\n * 不要怱略捕捉到的异常\n * 不要过度使用异常\n * 不要使用过于庞大的 try-catch语句\n * 子类抛出的异常不能比父类高级（RuntimeException不受此约束）\n * 一个方法被覆盖时，覆盖它的方法必须抛出相同的异常或异常的子类\n\n\n# 代码索引\n\n\n# Throwable异常\n\n点击返回*\n\n# Deme类\n\npublic class Demo {\n    public static void main(String[] args){\n        MyTest myTest = new MyTest();\n        try {\n            myTest.arithmeticException();\n        } catch (Exception e) {\n            Throwable throwable = new Throwable(e);\n            //追加异常\n            e.addSuppressed(new NullPointerException());\n    \n            System.out.println("e.getMessage() => "+throwable.getMessage());\n    \n            System.out.println("e.getCause() => "+throwable.getCause());\n    \n            System.out.println("e.toString() => "+ throwable.toString());\n            \n            StackTraceElement[] ste = throwable.getStackTrace();\n    \n            System.out.println("所有堆栈跟踪：");\n            for(StackTraceElement tmp : ste){\n                System.out.println(tmp);\n            }\n            //打印 e 所有异常的错误流\n            e.printStackTrace();\n        }\n    }\n}\n\n\n# MyTest类\n\npublic class MyTest{\n    //异常测试\n    \n    //算术异常\n    public void arithmeticException() throws ArithmeticException{\n        System.out.println("MyTest : 调用 arithmeticException()");\n        throw new ArithmeticException("arithmeticException() : ArithmeticException!!!");\n        \n    }\n    \n    //类型转换异常类\n    public void classCastException() throws ClassCastException{\n        System.out.println("MyTest : 调用 classCastException()");\n        throw new ClassCastException("classCastException() : ClassCastException!!!");\n    }\n    \n    //字段未找到异常\n    public void noSuchFieldException() throws NoSuchFieldException{\n        System.out.println("MyTest : 调用 noSuchFieldException()");\n        throw new NoSuchFieldException("noSuchFieldException() : NoSuchFieldException!!!");\n    }\n    \n    //空指针异常\n    public void nullPointerException() throws NullPointerException{\n        System.out.println("MyTest : 调用 nullPointerException()");\n        throw new NullPointerException("nullPointerException() : NullPointerException!!!");\n    }\n    \n    //异常\n    public void exception()throws Exception{\n        System.out.println("MyTest : 调用 exception()");\n        throw new Exception("exception() ： Exception！！！");\n    }\n    \n}\n\n\n\n# try-catch 异常捕捉\n\n点击返回*\n\npublic class Demo {\n    public static void main(String[] args) {\n        \n        try{\n            int i = 1/0;\n        }catch (Exception e){\n    \n            //输出异常错误性质\n            System.out.println(e.getMessage());\n            System.out.println("--");\n    \n            //输出异常类型和性质\n            System.out.println(e.toString());\n            System.out.println("--");\n            \n            //输出异常类型、性质、栈层（出现位置不定）\n            e.printStackTrace();\n            System.out.println("--");\n            \n        }finally{\n            System.out.println("END.....");\n        }\n        \n    }\n}\n\n/*\n\n/ by zero\n--\njava.lang.ArithmeticException: / by zero\n--\n--\nEND.....\njava.lang.ArithmeticException: / by zero\n\tat Demo.main(Demo.java:5)\n\n*/\n\n\n\n# try-with-resources 异常\n\n点击返回*\n\n# Deme类\n\npublic class Demo {\n    public static void startTest(){\n        MyTestB myTestB = new MyTestB();\n        try(MyTestA myTestA = new MyTestA() ; myTestB){\n            myTestA.test();\n            //myTestA 中的 test 制造异常\n            myTestB.test();\n        }catch (Exception e){\n            System.out.println("Main : Exception!!!");\n            System.out.println("try异常  ： ");\n            //获取try异常 ： getMessage()\n            System.out.println(e.getMessage());\n            //获取抛出异常 ： getSuppressed()\n            //Throwable异常的超父类\n            Throwable[] suppressed = e.getSuppressed();\n    \n            System.out.println("抛出异常 ：");\n            for(Throwable tmp : suppressed){\n                System.out.println(tmp.getMessage());\n            }\n            \n        }\n    }\n    public static void main(String[] args) throws Exception{\n        startTest();\n    }\n}\n\n/*\n\nMyTextA : 调用 test() \nMytestB: 关闭 close()\nMyTextA: 关闭 close()\nMain : Exception!!!\ntry异常  ： \nMyTextA : test() !!!\n抛出异常 ：\nMytestB: close() ClassNotFoundException!!!\nMyTextA: close() ClassNotFoundException!!!\n\n*/\n\n\n# MyTestA类\n\nimport java.io.IOException;\n\npublic class MyTestA implements AutoCloseable {\n    \n    public void test()throws IOException{\n        System.out.println("MyTextA : 调用 test() ");\n        //制造异常\n        throw new IOException("MyTextA : test() !!!");\n    }\n    \n    @Override\n    public void close() throws Exception {\n        //提示关闭流\n        System.out.println("MyTextA: 关闭 close()");\n        //制造异常\n        throw new ClassNotFoundException("MyTextA: close() ClassNotFoundException!!!");\n    }\n}\n\n\n# MyTestB类\n\nimport java.io.IOException;\n\npublic class MyTestB implements AutoCloseable {\n    \n    public void test()throws IOException{\n        System.out.println("MytestB : 调用 test() ");\n        //制造异常\n        throw new IOException("MytestB : test() !!!");\n    }\n    \n    @Override\n    public void close() throws Exception {\n        //提示关闭流\n        System.out.println("MytestB: 关闭 close()");\n        //制造异常\n        throw new ClassNotFoundException("MytestB: close() ClassNotFoundException!!!");\n    }\n}\n\n\n\n# 自定义异常\n\n点击返回*\n\npublic class Demo {\n    public static void main(String[] args) {\n        \n        orangutan xingxing = new orangutan();\n        bird niao = new bird();\n        key yaoshi = new key();\n        \n        //No.1\n        try {\n            if (!(xingxing instanceof Animals)){\n                throw new CustomException("非动物"+xingxing);\n            }\n            System.out.println("开始1");\n        } catch (CustomException e) {\n            e.printStackTrace();\n        }\n        \n        //No.2\n        try {\n            if (!(niao instanceof Animals)){\n                throw new CustomException("非动物"+niao);\n            }\n            System.out.println("开始2");\n        } catch (CustomException e) {\n            e.printStackTrace();\n        }\n    \n        //No.3 类型错误\n        try {\n            throw new CustomException("非动物："+yaoshi);\n        } catch (CustomException e) {\n            e.printStackTrace();\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n        \n    }\n}\n\n//动物类\nclass Animals{ }\n\n//猩猩\nclass orangutan extends Animals{ }\n\n//鸟\nclass bird extends Animals { }\n\n//物品类\nclass Items{ }\n\n//钥匙\nclass key extends Items{ }\n\n//自定义异常类 继承异常类\nclass CustomException extends Exception{\n    \n    public CustomException(String message){\n        super(message);\n    }\n    \n}\n\n/*\n\n开始1\n开始2\nCustomException: 非动物：key@133314b\n\tat Demo.main(Demo.java:30)\n\n*/\n\n\n\n# throws 抛出异常\n\n点击返回*\n\npublic class Demo {\n    //抛出中断异常\t\tthrows 抛出\n    public static void show() throws InterruptedException ,ArithmeticException{\n        \n        for (int i = 0; i <= 10 ; i++) {\n           System.out.println(i);\n            \n           Thread.sleep(1000);\n           \n           if (i == 5){\n               i-=5;\n               int s = 1/i;\n           }\n           \n        }\n    }\n    \n    public static void (String[] args) {\n        \n        //获取方法中的异常\n        try {\n            show();\n            //终止异常\n        } catch (InterruptedException e) {\n            System.out.println("show()方法抛出终止异常");\n            //算术异常\n        }catch (ArithmeticException e) {\n            System.out.println("show()方法抛出算术异常");\n            //异常\n        }catch (Exception e) {\n            System.out.println("show()方法抛出异常");\n        }\n        \n    }\n}\n\n/*\n\n0\n1\n2\n3\n4\n5\nshow()方法抛出算术异常\n\n*/\n\n\n\n# throw 抛出异常\n\n点击返回*\n\npublic class Demo2 {\n    public static void main(String[] args) 想·{\n        int a = 1 , b = 0 ;\n            if (b == 0){\n                //强制中断\n                throw new NullPointerException("b 为 0");\n            }\n            int s = a / b ;\n    \n    }\n}\n\n/*\n\njava.lang.NullPointerException: b 为 0\n\tat Demo2.main(Demo2.java:7)\n\n*/\n',normalizedContent:'# java异常\n\n\n# 概述\n\n异常机制提供了程序退出的安全通道。当出现错误后，程序执行的流程发生改变，程序的控制权转移到异常处理器\n\njava类库的每个包中都定义有异常类，所有的异常类都是 throwable类 的子类，有两个子类分别是 error类、exception类\n\nerror类 是描述java运行系统中的内部错误以及资源耗尽的错误，属于较为致命的错误\n\nexception类 是可以通过捕捉处理使程序继续运行，属于非致命的错误\n\n\n# throwable异常\n\nthrowable类 是所有错误和异常\n\n构造方法\n\nthrowable() throwable(string message) throwable(string message , throwable cause) throwable(throwable cause)\n\n> message： 详细信息（getmessage() 提供） cause： 原因（getcause() 提供）\n\n方法\n\n返回                    方法                                              说明\nvoid                  addsuppressed(throwable exception)              追加指定异常(有抑制的异常的作用)\nthrowable             fillinstacktrace()                              执行堆栈跟踪\nthrowable             getcause()                                      获取原因，未知 null\nstring                getlocalizedmessage()                           创建此可抛出的本地化描述\nstring                getmessage()                                    获取 异常详细，未知 null\nstacktraceelement[]   getstacktrace()                                 获取堆栈跟踪信息的数组\nthrowable[]           getsuppressed()                                 获取所有被抑制的异常的数组\nthrowable             initcause(throwable cause)                      更改原因\nvoid                  printstacktrace()                               异常打印至错误流\nvoid                  printstacktrace(printstream s)                  异常打印至字节流\nvoid                  printstacktrace(printwriter s)                  异常打印至字符流\nvoid                  setstacktrace(stacktraceelement[] stacktrace)   设置堆栈元素\nstring                tostring()                                      简短描述错误\n\n点击代码示例*（throwable操作）\n\n\n# 常见异常\n\n异常类                               说明\nclasscastexception                类型转换异常类\nclassnotfoundexception            没找到相应类异常\narithmeticexception               算术条件异常\narrayindexoutofboundsexception    数组索引越界异常\narraystoreexception               数组中包含不兼容的值抛出的异常\nsqlexception                      操作数据库异常类\nnullpointerexception              空指针异常\nnosuchfieldexception              字段未找到异常\nnosuchmethodexception             方法未找到抛出的异常\nnumberformatexception             字符串转换为数字抛出的异常\nnegativearraysizeexception        数组长度为负异常\nstringindexoutofboundsexception   字符串索引超出范围抛出的异常\nioexception                       操作输入流和输出流时异常\nillegalaccessexception            不允许访问某类异常\ninstantiationexception            当应用程序试图使用class类中的newinstance()方法创建一个类的实例，而指定的类对象无法被实例化时，抛出该异常\neofexception                      文件已结束异常\nfilenotfoundexception             文件未找到异常\n\n\n# 捕捉异常\n\n\n# try-catch 异常\n\ntry{\n   被捕获代码的区块\n}catch(异常类型 e){\n   对异常处理的区块\n}catch(异常类型 e){\n   对异常处理的区块\n}catch(异常类型 e){\n   对异常处理的区块\n}finally{\n    最后运行的区块\n}\n\n\n> try： 语句用来存放可能发生异常的语句 catch： 激发被捕获的异常类型 finally： 异常处理的最后运行的区域\n\nfinally语句不会执行情况：\n\n * 在finally语句块中发生了异常\n * 在前面的代码中使用了 system.exit()（退出程序）\n * 程序所在的线程死亡（运行时终止程序）\n * 关闭cpu\n\n点击代码示例* （try-catch 异常捕捉）\n\n\n# try-with-resources异常\n\ntry-with-resources异常是jdk9的新功能，\n\n * try 块没有发生异常，自动调用 close 方法\n * try 块 发生异常，然后自动调用 close()方法，如果 close 也发生异常，close() 方法的异常会在catch 中被压制，但是你可以在catch块中，用 throwable.getsuppressed 方法来获取到压制异常的数组\n\n点击代码示例* （try-with-resources 异常）\n\n\n# 自定义异常\n\n创建api中没有的异常，自定条件的异常\n\n> 使用步骤：\n> \n>  1. 创建自定义异常类\n>  2. 在方法中通过 throw 关键字 抛出异常对象\n>  3. 如果在当前抛出异常的方法中处理异常，可以使用 try-catch语句块捕获并处理，否则在方法的声明处通过 throws关键字 指明要抛出给方法调用者的异常\n>  4. 在出现异常方法的调用者中捕获并处理异常\n\nclass 自定义异常类 extends 已有的异常类{···}\n\n\n点击代码示例* （自定义异常）\n\n\n# 抛出异常\n\n方法出现异常，又不想在当前方法处理，则可以用 throws、throw 关键字 在方法中抛出异常\n\n\n# throws 抛出异常\n\nthrows将代码中可能产生的异常交给上一级处理，直到处理异常 try-catch 语句调用 ，否则调用的那个方法也要加抛出的关键字已经方法类（一般使用于方法传参异常）\n\npublic void 方法名() throws 异常类型1,...,异常类型n{  }\n\n\n被调用时：\n\ntry{\n    方法名();\n}catch(异常类型 e){\n    e.printstacktrace();\n}\n\n\n点击代码示例* （throws 抛出异常）\n\n\n# throw 抛出异常\n\n手动制造异常。程序运行到throw语句时立即终止程序，不会执行后面的语句\n\n使用throw抛出异常的前提\n\n点击代码示例* （throw 抛出异常）\n\n\n# 异常的使用原则\n\n提高程序的安全性，控制流程状况以及异常修复！\n\n * 不要怱略捕捉到的异常\n * 不要过度使用异常\n * 不要使用过于庞大的 try-catch语句\n * 子类抛出的异常不能比父类高级（runtimeexception不受此约束）\n * 一个方法被覆盖时，覆盖它的方法必须抛出相同的异常或异常的子类\n\n\n# 代码索引\n\n\n# throwable异常\n\n点击返回*\n\n# deme类\n\npublic class demo {\n    public static void main(string[] args){\n        mytest mytest = new mytest();\n        try {\n            mytest.arithmeticexception();\n        } catch (exception e) {\n            throwable throwable = new throwable(e);\n            //追加异常\n            e.addsuppressed(new nullpointerexception());\n    \n            system.out.println("e.getmessage() => "+throwable.getmessage());\n    \n            system.out.println("e.getcause() => "+throwable.getcause());\n    \n            system.out.println("e.tostring() => "+ throwable.tostring());\n            \n            stacktraceelement[] ste = throwable.getstacktrace();\n    \n            system.out.println("所有堆栈跟踪：");\n            for(stacktraceelement tmp : ste){\n                system.out.println(tmp);\n            }\n            //打印 e 所有异常的错误流\n            e.printstacktrace();\n        }\n    }\n}\n\n\n# mytest类\n\npublic class mytest{\n    //异常测试\n    \n    //算术异常\n    public void arithmeticexception() throws arithmeticexception{\n        system.out.println("mytest : 调用 arithmeticexception()");\n        throw new arithmeticexception("arithmeticexception() : arithmeticexception!!!");\n        \n    }\n    \n    //类型转换异常类\n    public void classcastexception() throws classcastexception{\n        system.out.println("mytest : 调用 classcastexception()");\n        throw new classcastexception("classcastexception() : classcastexception!!!");\n    }\n    \n    //字段未找到异常\n    public void nosuchfieldexception() throws nosuchfieldexception{\n        system.out.println("mytest : 调用 nosuchfieldexception()");\n        throw new nosuchfieldexception("nosuchfieldexception() : nosuchfieldexception!!!");\n    }\n    \n    //空指针异常\n    public void nullpointerexception() throws nullpointerexception{\n        system.out.println("mytest : 调用 nullpointerexception()");\n        throw new nullpointerexception("nullpointerexception() : nullpointerexception!!!");\n    }\n    \n    //异常\n    public void exception()throws exception{\n        system.out.println("mytest : 调用 exception()");\n        throw new exception("exception() ： exception！！！");\n    }\n    \n}\n\n\n\n# try-catch 异常捕捉\n\n点击返回*\n\npublic class demo {\n    public static void main(string[] args) {\n        \n        try{\n            int i = 1/0;\n        }catch (exception e){\n    \n            //输出异常错误性质\n            system.out.println(e.getmessage());\n            system.out.println("--");\n    \n            //输出异常类型和性质\n            system.out.println(e.tostring());\n            system.out.println("--");\n            \n            //输出异常类型、性质、栈层（出现位置不定）\n            e.printstacktrace();\n            system.out.println("--");\n            \n        }finally{\n            system.out.println("end.....");\n        }\n        \n    }\n}\n\n/*\n\n/ by zero\n--\njava.lang.arithmeticexception: / by zero\n--\n--\nend.....\njava.lang.arithmeticexception: / by zero\n\tat demo.main(demo.java:5)\n\n*/\n\n\n\n# try-with-resources 异常\n\n点击返回*\n\n# deme类\n\npublic class demo {\n    public static void starttest(){\n        mytestb mytestb = new mytestb();\n        try(mytesta mytesta = new mytesta() ; mytestb){\n            mytesta.test();\n            //mytesta 中的 test 制造异常\n            mytestb.test();\n        }catch (exception e){\n            system.out.println("main : exception!!!");\n            system.out.println("try异常  ： ");\n            //获取try异常 ： getmessage()\n            system.out.println(e.getmessage());\n            //获取抛出异常 ： getsuppressed()\n            //throwable异常的超父类\n            throwable[] suppressed = e.getsuppressed();\n    \n            system.out.println("抛出异常 ：");\n            for(throwable tmp : suppressed){\n                system.out.println(tmp.getmessage());\n            }\n            \n        }\n    }\n    public static void main(string[] args) throws exception{\n        starttest();\n    }\n}\n\n/*\n\nmytexta : 调用 test() \nmytestb: 关闭 close()\nmytexta: 关闭 close()\nmain : exception!!!\ntry异常  ： \nmytexta : test() !!!\n抛出异常 ：\nmytestb: close() classnotfoundexception!!!\nmytexta: close() classnotfoundexception!!!\n\n*/\n\n\n# mytesta类\n\nimport java.io.ioexception;\n\npublic class mytesta implements autocloseable {\n    \n    public void test()throws ioexception{\n        system.out.println("mytexta : 调用 test() ");\n        //制造异常\n        throw new ioexception("mytexta : test() !!!");\n    }\n    \n    @override\n    public void close() throws exception {\n        //提示关闭流\n        system.out.println("mytexta: 关闭 close()");\n        //制造异常\n        throw new classnotfoundexception("mytexta: close() classnotfoundexception!!!");\n    }\n}\n\n\n# mytestb类\n\nimport java.io.ioexception;\n\npublic class mytestb implements autocloseable {\n    \n    public void test()throws ioexception{\n        system.out.println("mytestb : 调用 test() ");\n        //制造异常\n        throw new ioexception("mytestb : test() !!!");\n    }\n    \n    @override\n    public void close() throws exception {\n        //提示关闭流\n        system.out.println("mytestb: 关闭 close()");\n        //制造异常\n        throw new classnotfoundexception("mytestb: close() classnotfoundexception!!!");\n    }\n}\n\n\n\n# 自定义异常\n\n点击返回*\n\npublic class demo {\n    public static void main(string[] args) {\n        \n        orangutan xingxing = new orangutan();\n        bird niao = new bird();\n        key yaoshi = new key();\n        \n        //no.1\n        try {\n            if (!(xingxing instanceof animals)){\n                throw new customexception("非动物"+xingxing);\n            }\n            system.out.println("开始1");\n        } catch (customexception e) {\n            e.printstacktrace();\n        }\n        \n        //no.2\n        try {\n            if (!(niao instanceof animals)){\n                throw new customexception("非动物"+niao);\n            }\n            system.out.println("开始2");\n        } catch (customexception e) {\n            e.printstacktrace();\n        }\n    \n        //no.3 类型错误\n        try {\n            throw new customexception("非动物："+yaoshi);\n        } catch (customexception e) {\n            e.printstacktrace();\n        }catch (exception e){\n            e.printstacktrace();\n        }\n        \n    }\n}\n\n//动物类\nclass animals{ }\n\n//猩猩\nclass orangutan extends animals{ }\n\n//鸟\nclass bird extends animals { }\n\n//物品类\nclass items{ }\n\n//钥匙\nclass key extends items{ }\n\n//自定义异常类 继承异常类\nclass customexception extends exception{\n    \n    public customexception(string message){\n        super(message);\n    }\n    \n}\n\n/*\n\n开始1\n开始2\ncustomexception: 非动物：key@133314b\n\tat demo.main(demo.java:30)\n\n*/\n\n\n\n# throws 抛出异常\n\n点击返回*\n\npublic class demo {\n    //抛出中断异常\t\tthrows 抛出\n    public static void show() throws interruptedexception ,arithmeticexception{\n        \n        for (int i = 0; i <= 10 ; i++) {\n           system.out.println(i);\n            \n           thread.sleep(1000);\n           \n           if (i == 5){\n               i-=5;\n               int s = 1/i;\n           }\n           \n        }\n    }\n    \n    public static void (string[] args) {\n        \n        //获取方法中的异常\n        try {\n            show();\n            //终止异常\n        } catch (interruptedexception e) {\n            system.out.println("show()方法抛出终止异常");\n            //算术异常\n        }catch (arithmeticexception e) {\n            system.out.println("show()方法抛出算术异常");\n            //异常\n        }catch (exception e) {\n            system.out.println("show()方法抛出异常");\n        }\n        \n    }\n}\n\n/*\n\n0\n1\n2\n3\n4\n5\nshow()方法抛出算术异常\n\n*/\n\n\n\n# throw 抛出异常\n\n点击返回*\n\npublic class demo2 {\n    public static void main(string[] args) 想·{\n        int a = 1 , b = 0 ;\n            if (b == 0){\n                //强制中断\n                throw new nullpointerexception("b 为 0");\n            }\n            int s = a / b ;\n    \n    }\n}\n\n/*\n\njava.lang.nullpointerexception: b 为 0\n\tat demo2.main(demo2.java:7)\n\n*/\n',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Java I/O",frontmatter:{title:"Java I/O",date:"2020-02-18T00:00:00.000Z",permalink:"/backend/dampib",categories:["后端","Java基础"],tags:["Java"],author:"柏竹"},regularPath:"/01.%E5%90%8E%E7%AB%AF/01.Java%E5%9F%BA%E7%A1%80/09.IO%E6%B5%81.html",relativePath:"01.后端/01.Java基础/09.IO流.md",key:"v-004efb11",path:"/backend/dampib/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:15},{level:2,title:"输入流",slug:"输入流",normalizedTitle:"输入流",charIndex:40},{level:2,title:"输出流",slug:"输出流",normalizedTitle:"输出流",charIndex:46},{level:2,title:"File类",slug:"file类",normalizedTitle:"file类",charIndex:1097},{level:3,title:"文件操作方法",slug:"文件操作方法",normalizedTitle:"文件操作方法",charIndex:1517},{level:2,title:"字节流",slug:"字节流",normalizedTitle:"字节流",charIndex:126},{level:3,title:"字节输出流",slug:"字节输出流",normalizedTitle:"字节输出流",charIndex:687},{level:3,title:"字节输入流",slug:"字节输入流",normalizedTitle:"字节输入流",charIndex:137},{level:2,title:"字符流",slug:"字符流",normalizedTitle:"字符流",charIndex:176},{level:3,title:"字符输出流",slug:"字符输出流",normalizedTitle:"字符输出流",charIndex:4060},{level:3,title:"字符输入流",slug:"字符输入流",normalizedTitle:"字符输入流",charIndex:206},{level:2,title:"字节与字符流的转换",slug:"字节与字符流的转换",normalizedTitle:"字节与字符流的转换",charIndex:4834},{level:3,title:"输出流",slug:"输出流-2",normalizedTitle:"输出流",charIndex:46},{level:3,title:"输入流",slug:"输入流-2",normalizedTitle:"输入流",charIndex:40},{level:2,title:"缓存字节流",slug:"缓存字节流",normalizedTitle:"缓存字节流",charIndex:6041},{level:3,title:"缓存字符输出流",slug:"缓存字符输出流",normalizedTitle:"缓存字符输出流",charIndex:6097},{level:3,title:"缓存字符输入流",slug:"缓存字符输入流",normalizedTitle:"缓存字符输入流",charIndex:8317},{level:2,title:"缓存字符流",slug:"缓存字符流",normalizedTitle:"缓存字符流",charIndex:10159},{level:3,title:"缓存字符输出流",slug:"缓存字符输出流-2",normalizedTitle:"缓存字符输出流",charIndex:6097},{level:3,title:"缓存字符输入流",slug:"缓存字符输入流-2",normalizedTitle:"缓存字符输入流",charIndex:8317},{level:2,title:"数据流",slug:"数据流",normalizedTitle:"数据流",charIndex:98},{level:3,title:"数据输出流",slug:"数据输出流",normalizedTitle:"数据输出流",charIndex:12965},{level:3,title:"数据输入流",slug:"数据输入流",normalizedTitle:"数据输入流",charIndex:13504},{level:2,title:"打印流",slug:"打印流",normalizedTitle:"打印流",charIndex:15565},{level:2,title:"NIO",slug:"nio",normalizedTitle:"nio",charIndex:16190},{level:3,title:"缓存区 Buffers",slug:"缓存区-buffers",normalizedTitle:"缓存区 buffers",charIndex:16281},{level:3,title:"通道 Channels",slug:"通道-channels",normalizedTitle:"通道 channels",charIndex:16266},{level:4,title:"文件读写 FileChannel",slug:"文件读写-filechannel",normalizedTitle:"文件读写 filechannel",charIndex:18560},{level:2,title:"代码实例",slug:"代码实例",normalizedTitle:"代码实例",charIndex:21287}],headersStr:"概述 输入流 输出流 File类 文件操作方法 字节流 字节输出流 字节输入流 字符流 字符输出流 字符输入流 字节与字符流的转换 输出流 输入流 缓存字节流 缓存字符输出流 缓存字符输入流 缓存字符流 缓存字符输出流 缓存字符输入流 数据流 数据输出流 数据输入流 打印流 NIO 缓存区 Buffers 通道 Channels 文件读写 FileChannel 代码实例",content:'# Java I/O\n\n\n# 概述\n\n物质在目的地之间的转移运动称为流，可分为 输入流 、 输出流\n\n> 输入流： 程序从源中读取数据 输出流： 数据要到达的目的地\n\n主要流：\n\n文件流 缓冲流 数据流 \n\n\n# 输入流\n\nInputStream类 是字节流 的抽象类，所有字节输入流的父类 java.io.InputStream\n\nReader类 是字符流 的抽象类 ，是Unicode编码，适合处理文本，所有字符输入流的父类 java.io.Reader\n\n方法 (更多方法自行api)*\n\n返回        方法                    说明\nvoid      close()               关闭输入流\nvoid      mark(int readlimit)   标记输入流中的当前位置\nboolean   markSupported()       支持 mark和 reset方法，则true\nint       read()                从输入流读取数据，(字节)0~255范围，没有则-1\nint       read(E[] b)           从输入流读取一些 字符/字节 ，并将它们存储到缓冲区b\nvoid      reset()               将流重新定位到上次输入流调用 mark方法时的位置\nlong      skip(long n)          跳过输入流上的n个字符，返回实际跳过的字节数\n\n\n# 输出流\n\nOutputStream类 是字节流 的抽象类，所有字节输出流的父类 java.io.OutputStream\n\nWriter类 是字符流 的抽象类 ，所有字符输入流的父类 java.io.Writer\n\n方法 (更多方法自行api)*\n\n返回     方法                                 说明\nvoid   close()                            关闭流\nvoid   flush()                            完成输出清空缓冲\nvoid   write(E text)                      将指定text写入流\nvoid   write(E[] b)                       将b数组写入流\nvoid   write(E[] b , int off , int len)   将b数组中从偏移量off开始写入len个字节的流\n\n\n# File类\n\n> Class File\n> \n> java.lang.Object java.io.File\n> \n> 实现接口 Serializable、Comparable<File>\n\nFile类是代表磁盘的 文件 或者 文件夹(目录)，该类可实现创建、删除、重命名文件等操作\n\n构造方法\n\nFile(String pathname) 抽象路径目录对象(文件夹 或 文件) File(String parent , String child) 路径目录中的文件(绝对路径)\n\n> pathname： 路径名称(包含文件名) parent： 父路径字符串，例如：D://doc 或 D://doc//no1.txt child： 子路径字符串 ，例如：no1.txt\n\n注意：\n\n>  * 盘符的路径名前缀由驱动器号和 :组成\n>  * 路径分割一般用： \\ 或 //\n>  * 子路径文件一定要有后缀，如：.jpg、.txt\n\n\n# 文件操作方法\n\nFile类提供以下为常用方法 ，如果想看更多方法自行查JDK文档\n\n返回        方法                             说明\nString    getName()                      获取文件名称\nboolean   canRead()                      判断文件是否为可读\nboolean   canWrite()                     判断文件是否可写入\nboolean   exists()                       判断文件是否存在\nlong      length()                       获取文件的长度(字节为单位)\nString    getAbsolutePath()              获取文件的绝对路径\nString    getParent()                    获取文件的父路径\nboolean   isFile()                       判断文件是否存在(普通文件)\nboolean   isDirectory()                  判断文件是否为一个目录\nboolean   isHidden()                     判断文件是否为隐藏文件\nlong      lastModified()                 获取文件最后修改时间(毫秒为单位)\nboolean   createNewFile()                路径文件不存在，则创建新的空文件\nboolean   delete()                       删除子路径(最后一个)文件或文件夹\nboolean   mkdir()                        创建抽象路径名命名的目录(创建文件夹)\nboolean   mkdirs()                       创建抽象路径名命名的目录，包括任何必需但不存在的父目录(创建多层路径文件夹)\nboolean   renameTo(File dest)            重命名由此抽象路径名表示的文件(移动且替换文件)\nFile[]    listFiles()                    返回文件夹所有 子文件夹 和 文件\nFile[]    listFiles(FileFilter filter)   返回以满足条件的文件夹所有 子文件夹 和 文件\n\n点击代码示例* (File操作)\n\n\n# 字节流\n\nFileInputStream、FileOutputStream类 操作磁盘文件的字节\n\n计算机中的所有文件都是二进制形式存储的(文本、图片、···)，这些数据可以通过 字节流 与计算机底层的二进制数据进行交互！\n\n\n# 字节输出流\n\n> Class FileOutputStream\n> \n> java.lang.Object java.io.OutputStream java.io.FileOutputStream\n> \n> 实现接口：\n> \n> Closeable ， Flushable ， AutoCloseable\n\n构造方法\n\nFileOutputStream(File file) FileOutputStream(String fileName) FileOutputStream(String fileName , boolean append) FileOutputStream(File file , boolean append)\n\n> fileName： 给文件名 file： 抽象路径对象 append： 是否连续写入数据\n\n常用方法 (继承方法点击索引)\n\n返回     方法                                    说明\nvoid   write(byte[] b)                       指定字节数组写入文件\nvoid   write(byte[] b , int off , int len)   指定范围写入字节数组\nvoid   write(int b)                          将指定字节写入(字节数)\n\n点击代码示例* (字节输出流)\n\n\n# 字节输入流\n\n> Class FileInputStream\n> \n> java.lang.Object java.io.InputStream java.io.FileInputStream\n> \n> 实现接口：\n> \n> Closeable ， AutoCloseable\n\n构造方法\n\nFileInputStream(File file) FileInputStream(String fileName)\n\n> fileName： 文件名 file： 要打开阅读的文件\n\n常用方法 (继承方法点击索引)\n\n返回     方法                                   说明\nlong   length()                             返回底层文件的长度\nint    read()                               从流中读取一字节(读完则 -1 )读完指向下一个字节\nint    read(byte[] b)                       从流中读取一组字节\nint    read(byte[] b , int off , int len)   从流中读取 off 到 len 位置的字节\nvoid   seek(long pos)                       将当前流位置为所需位置\n\n点击代码示例* (字节输入流)\n\n\n# 字符流\n\n字符输入输出流可避免像字节流出现乱码现象！他们是使用方法是大致一样！\n\n\n# 字符输出流\n\n> Class FileWriter\n> \n> java.lang.Object java.io.Writer java.io.OutputStreamWriter java.io.FileWriter\n> \n> 实现接口：\n> \n> Closeable ， AutoCloseable ， Flushable ， Appendable\n\n构造方法\n\nFileWriter(File file) FileWriter(String fileName) FileWriter(String fileName , boolean append) FileWriter(File file , boolean append)\n\n> fileName： 给文件名 file： 抽象路径对象 append： 是否连续写入数据\n\n方法(继承方法点击索引) 传输形式是 以字符为单位进行传输 char\n\n点击代码示例* (字符输出流)\n\n----------------------------------------\n\n\n# 字符输入流\n\n> Class FileReader\n> \n> java.lang.Object java.io.Reader java.io.InputStreamReader java.io.FileReader\n> \n> 实现接口：\n> \n> Closeable ， AutoCloseable ， Readable\n\n构造方法\n\nFileReader (File file) FileReader (String fileName)\n\n> fileName： 文件名 file： 要打开阅读的文件\n\n方法 (继承方法点击索引) 传输形式是 以字符为单位进行传输 char\n\n点击代码示例* (字符输入流)\n\n\n# 字节与字符流的转换\n\n\n# 输出流\n\n> Class OutputStreamWriter\n> \n> java.lang.Object java.io.Writer java.io.OutputStreamWriter\n> \n> 实现接口： Closeable ， Flushable ， Appendable ， AutoCloseable\n\n构造方法\n\nOutputStreamWriter(OutputStream out) OutputStreamWriter(OutputStream out , Charset cs)\n\n> out： 字节输出流 cs： 编码名称\n\n方法 (继承方法点击索引)\n\n返回       方法                                    说明\nString   getEncoding()                         获取字符编码的名称\nvoid     write(char ch)                        写一个字符\nvoid     write(char[] ch, int off, int len)    写数组中的 off 至 len 范围的字符\nvoid     write(String str, int off, int len)   写字符串中的 off 至 len 范围的字符\n\n----------------------------------------\n\n\n# 输入流\n\n> Class InputStreamReader\n> \n> java.lang.Object java.io.Reader java.io.InputStreamReader\n> \n> 实现接口：\n> \n> Closeable ， AutoCloseable ， Readable\n\n构造方法\n\nInputStreamReader(InputStream in) InputStreamReader(InputStream in, Charset cs)\n\n> in： 字节输入流 cs： 编码名称\n\n方法 (继承方法点击索引)\n\n返回        方法                                  说明\nString    getEncoding()                       获取字符编码的名称\nint       read()                              读一个字符\nint       read(char[] ch, int off, int len)   读数组中的 off 至 len 范围的字符\nboolean   ready()                             流是否准备好被读取\n\n\n# 缓存字节流\n\n缓存是输入输出流的优化，能大大提升传输效率！\n\n传输形式\n\n文件→字节流→缓存流→目的地\n\n\n# 缓存字符输出流\n\n> Class BufferedOutputStream\n> \n> java.lang.Object java.io.OutputStream java.io.FilterOutputStream java.io.BufferedOutputStream\n\n构造方法\n\nBufferedOutputStream(OutputStream out) BufferedOutputStream(OutputStream out , int size)\n\n> out： 文件输出流 size： 缓储存大小\n\n以下代码 写入文件\n\nimport java.io.*;\n\npublic class Demo {\n    public static void main(String[] args) {\n        //文件选择大文件为好，容易体现效果\n        File field = new File("word.txt");\n        FileOutputStream out = null;\n        //创建缓存输出流\n        BufferedOutputStream buffout = null;\n        //时间记录点1\n        long a = System.currentTimeMillis();\n        \n        try {\n            out = new FileOutputStream(field,true);\n            //用缓存输出流封装输出流\n            buffout = new BufferedOutputStream(out);\n    \n            String str = new String("世界你好！\\n");\n            byte[] bytes = str.getBytes();\n            \n            //写入99999次\n            for (int i = 0; i < 99999; i++) {\n                \n                //单选程序测试\n                \n                /*\n                *\n                * 选择(1)缓存流测试速度\n                *\n                *  */\n                //使用流时是使用缓存输出流\n                buffout.write(bytes);\n                //刷新。强制将缓冲区数据写入文件中，即使缓冲区没有写满\n                // 缓存区没写满刷新传输，提升效率\n                buffout.flush();\n                \n                /*\n                 *\n                 * 选择(2)字节流测试速度\n                 *\n                 *  */\n//                out.write(bytes);\n            }\n            //时间记录点2\n            long b = System.currentTimeMillis();\n            System.out.println("运行了："+(b-a)+"mm");\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            //关闭流\n            if (out != null){\n                try {\n                    out.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (buffout != null){\n                try {\n                    buffout.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        \n    }\n}\n\n\n缓存流输出还是大文件较好，文件选择建议自选大文件为好呈现\n\n\n# 缓存字符输入流\n\n> Class BufferedInputStream\n> \n> java.lang.Object java.io.InputStream java.io.FilterInputStream java.io.BufferedInputStream\n\n构造方法\n\nBufferedInputStream(InputStream in)\n\nBufferedInputStream(InputStream in , int size)\n\n> in：文件输出流 size：缓储存大小\n\nimport java.io.*;\n\npublic class Demo2 {\n    \n    public static void main(String[] args) {\n        //文件选择大文件为好，容易体现效果\n        File field = new File("word.txt");\n        FileInputStream input= null;\n        BufferedInputStream buffin = null;\n    \n        //时间记录点1\n        long a = System.currentTimeMillis();\n        try {\n            input = new FileInputStream(field);\n            buffin = new BufferedInputStream(input);\n            \n            //缓冲区字节数组(与buffered不同)\n            byte[] bytes = new byte[1024];\n            \n            /*\n             *\n             * 选择(1)缓存流测试速度\n             *\n             *  */\n            //直到读完\n            while ((buffin.read(bytes))!= -1){ }\n    \n            /*\n             *\n             * 选择(2)字节流测试速度\n             *\n             *  */\n            //直到读完\n//            while ((input.read(bytes))!= -1){ }\n            \n            long b = System.currentTimeMillis();\n            System.out.println("运行了："+(b-a)+"mm");\n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (input != null){\n                try {\n                    input.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (buffin != null){\n                try {\n                    buffin.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    \n    }\n}\n\n\n运行结果 当然是缓存流比字节流快啦，前提是大文件！\n\n\n# 缓存字符流\n\n可以以行为单位进行 输入/输出 ，与以上的缓冲字符流大部分相同！\n\n\n# 缓存字符输出流\n\n> Class BufferedWriter\n> \n> java.lang.Object java.io.Writer java.io.BufferedWriter\n\n构造方法与以上的一样！\n\n缓存字符输出流提供独有方法：newLine() 写入一行(换行) 带分割符\n\nimport java.io.BufferedWriter;\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args) {\n        \n        File file = new File("word.txt");\n    \n        FileWriter fw= null;\n        BufferedWriter bfw = null;\n    \n        try {\n            //先创建后关闭\n            fw = new FileWriter(file);\n            bfw = new BufferedWriter(fw);\n        \n            String str = new String("世界这么大，");\n            String str2 = new String("我想去看看。");\n            \n            bfw.write(str);//写入数据\n            bfw.newLine();//创建新行\n            bfw.write(str2);//写入数据\n            \n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            //先创建后关闭\n            if (bfw != null){\n                try {\n                    bfw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (fw != null){\n                try {\n                    fw.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        \n    }\n}\n\n\n在项目创建了test.txt文件，并写入数据 "世界这么大，\\n我想去看看。"\n\n\n# 缓存字符输入流\n\n> Class BufferedReader\n> \n> java.lang.Object java.io.Reader java.io.BufferedReader\n\n缓存字符输入流提供独有方法：String readLine() 读取一个文本行\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo2 {\n    public static void main(String[] args) {\n    \n        File file = new File("word.txt");\n        \n        FileReader fr = null;\n        BufferedReader bfr = null;\n        \n        try {\n            \n            fr = new FileReader(file);\n            bfr = new BufferedReader(fr);\n            \n            String tmp = null;\n            //计数变量\n            int i = 1 ;\n            //逐行获取字符串并输出\n            while ((tmp = bfr.readLine()) != null){\n                System.out.println("第"+(i++)+"行："+tmp);\n            }\n            \n            \n        } catch (Exception e) {\n            e.printStackTrace();\n        } finally {\n            if (bfr != null){\n                try {\n                    bfr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (fr != null){\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    \n    }\n}\n\n/*\n\n第1行：世界这么大，\n第2行：我想去看看。\n\n*/\n\n\n\n# 数据流\n\n允许应用程序以与机器无关的方式从底层输入流中读取基本java数据类型\n\n\n# 数据输出流\n\n> Class DataOutputStream\n> \n> java.lang.Object java.io.OutputStream java.io.FilterOutputStream java.io.DataOutputStream\n\n构造方法\n\nDataOutputStream(OutputStream out)\n\n> out：底层输出流，保存供以后使用\n\nDataOutputStream类提供了以下独有方法\n\n修饰符    方法                        说明\nvoid   writeBoolean(boolean v)   将 boolean写入底层输出流(1字节)\nvoid   writeByte(int v)          将 byte值写入底层输出流(1字节)\nvoid   writeBytes(String s)      将字符串作为字节序列写入基础输出流\n···    ···                       ···多余自行查询 JDK文档\nvoid   writeUTF(String str)      使用 modified UTF-8编码以机器无关的方式将字符串写入基础输出流\n\n\n# 数据输入流\n\n> Class DataInputStream\n> \n> java.lang.Object java.io.InputStream java.io.FilterInputStream java.io.DataInputStream\n\n构造方法\n\nDataInputStream(InputStream in)\n\n> in：指定的输入流\n\nimport java.io.*;\n\npublic class Demo {\n    public static void main(String[] args) {\n        \n        File file = new File("word.txt");\n        \n        //创建字节流\n        FileOutputStream out = null;\n        FileInputStream inp = null;\n        //创建数据流\n        DataOutputStream dataout = null;\n        DataInputStream datainp = null;\n    \n        try {\n            out = new FileOutputStream(file);\n            dataout = new DataOutputStream(out);\n            \n            inp = new FileInputStream(file);\n            datainp = new DataInputStream(inp);\n            \n            //写入数据\n            dataout.writeUTF("使用writeUTF方法写入！");\n            dataout.writeChars("使用writeChars方法写入！");\n            dataout.writeBytes("使用writeBytes方法写入！");\n    \t\t\n            //读取数据\n            System.out.println("在输入流读取数据："+datainp.readUTF());\n            \n        } catch (FileNotFoundException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (datainp != null){\n                try {\n                    datainp.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (inp != null){\n                try {\n                    inp.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (dataout != null){\n                try {\n                    dataout.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if (out != null){\n                try {\n                    out.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    \n    }\n}\n\n/* 控制台结果\n在输入流读取数据：使用writeUTF方法写入！\n*/\n\n\n\n# 打印流\n\n> Class PrintWriter\n> \n> java.lang.Object java.io.Writer java.io.PrintWriter\n> \n> 实现接口：\n> \n> Closeable ， Flushable ， Appendable ， AutoCloseable\n\n将对象的格式表示打印到文本输出流，打印过程不需刷新！\n\n构造方法 (更多方法自行API)\n\nPrintWriter(File file) PrintWriter(OutputStream out) PrintWriter(String fileName) PrintWriter(Writer out)\n\n方法 (继承方法点击索引)\n\n返回            方法                说明\nPrintWriter   append(char ch)   指定字符追加\nboolean       checkError()      检查流是否关闭\nvoid          clearError()      清除流中的错误状态\nvoid          print(E)          写入数据(支持多类型，详细API)\nvoid          println(E)        写入数据末尾换行(支持多类型，详细API)\nvoid          write(···)        继承输入流写入的方法\n\n\n# NIO\n\nNIO支持面向缓冲区的、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作\n\nJava NIO 由以下几个核心部分组成：\n\n * 通道 Channels\n * 缓存区 Buffers\n\n\n# 缓存区 Buffers\n\n缓存区 Buffer 主要用于与 NIO 通道进行交互，数据是从通道读入缓冲区，从缓冲区写入通道中的\n\n缓存区 本质是个 读写 的内存，而内存被封装为NIO Buffer对象\n\nBuffer实现类： ByteBuffer、MappedByteBuffer、CharBuffer、DoubleBuffer、FloatBuffer、IntBuffer、LongBuffer、ShortBuffer\n\nBuffer对象属性\n\n * **capacity 容量：**Buffer 的内存块(容量)，缓冲区容量不能为负，并且创建后不能更改\n * limit 限制： 剩余可写容量的指针\n   * 在 写模式 下，最多能写入 limit个单元 的数据\n   * 在 读模式 下，最多能够读取 limit个单元 的数据，一旦切换为读，就要读完，否则会被舍弃！\n   * 当模式从 写 切换至 读 时，limit 被设置成写模式下的position值，而position重置为0\n   * limit = capacity – （position + 1）\n * position 位置： 位置操作的指针\n   * 当 写入数据 时，position会移到下入的下一个Buffer单元\n   * 当 读取数据 时，Buffer切换至模式，position会重置为0，读数据时position会下移读取可读数据\n   * position位置指标 最大值为 capacity - 1\n\nBuffer常用方法\n\n * allocate() 开辟新缓存空间\n * clear() 清缓存。limit和position为零\n * array() 获取缓存区数据\n * flip() 使缓冲区准备好新的通道写入 获取操作 序列。limit为position，position为零\n * rewind() 使缓冲区准备好重新读取已经包含的数据。limit保持不变，position为零\n\nBuffers应用步骤：\n\n 1. 分配缓存区内存 allocate(int length)静态方法\n 2. 写入数据，Buffer对象 调用put()方法 写入内存\n 3. 切换模式，切换至 读/写 ，Buffer对象 调用flip()方法（position重置为0\n 4. 读取数据，Buffer 中读取数据 get()、通过数据批获取\n 5. 清缓存，Buffer对象 调用clear()方法\n\n示例：\n\npublic static void testBuffer() {\n    //创建分配容量长度为10的字节缓冲区\n    ByteBuffer buf = ByteBuffer.allocate(10);\n    System.out.println("position="+buf.position()); //0\n    System.out.println("limit="+buf.limit()); //10\n    System.out.println("capacity="+buf.capacity()); //10\n    \n    String putMsg="abcd";\n    //将字符串转换成字节数组\n    System.out.println("将abcd字符串存储到bytebuffer");\n    buf.put(putMsg.getBytes(), 0, putMsg.getBytes().length);\n    \n    System.out.println("position="+buf.position()); //4\n    System.out.println("limit="+buf.limit()); //10\n    System.out.println("capacity="+buf.capacity()); //10\n\n    //翻转成读模式\n    System.out.println("翻转成读模式----------");\n    buf.flip();\n    \n    System.out.println("position="+buf.position()); //0\n    System.out.println("limit="+buf.limit()); //4\n    System.out.println("capacity="+buf.capacity()); //10\n    \n    byte[] cbuf = new byte[buf.limit()];\n    //从缓存区读取数据\n    System.out.println("从缓存区读取数据");\n    buf.get(cbuf, 0, cbuf.length);\n    System.out.println(new String(cbuf,0,cbuf.length));\n    // abcd\n    buf.clear();\n}\n\n\n\n# 通道 Channels\n\n通道 Channels 是针对目标文件打开的连接，而建立的一个通道\n\n * 双向通道。读写数据都是通过通道进行数据交互。但流的读写通常是单向的\n * 通道可以异步地读写\n * 通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入\n\n通道实现类：\n\n * 文件读写 FileChannel\n * UDP网络读写 DatagramChannel\n * TCP网络读写 SocketChannel\n * 监听连接的TCP ServerSocketChannel\n\n# 文件读写 FileChannel\n\nFileChannel 应用步骤：\n\n 1. 获取文件指定的 字节输入流\n 2. 流转换 FileChannel对象，字节输入流 调用getChannel()方法\n 3. 创建缓存区（类型根据情况选择\n 4. 循环读取直至为空\n    1. 每次循环都要缓存都要flip()反转 （以便控制读取范围\n    2. 每次循环读取后都要清空内存\n\n示例：\n\npublic static void testFileChannel() throws IOException {\n    //创建FileInputStream对象\n    FileInputStream fileInputStream=new FileInputStream(new File("a.txt"));\n    //获取FileChannel对象\n    FileChannel fc = fileInputStream.getChannel();\n    ByteBuffer buf=ByteBuffer.allocate(12);\n\n    while(fc.read(buf) != -1) {\n        //设置ButeBuffer为读取模式\n        buf.flip();\n        String message=new String(buf.array(),0,buf.limit());\n        System.out.print(message);\n        \n        buf.clear();\n    }\n    fileInputStream.close();\n}\n\n\n读写拷贝应用实例：\n\npublic static void testCopyFile01() throws IOException {\n    long start = System.currentTimeMillis();\n    \n    FileInputStream srcFileInputStream=new FileInputStream(new File("E:\\\\资源\\\\巨人三\\\\1.mp4"));\n    FileOutputStream destFileOutputStream=new FileOutputStream(new File("E:\\\\资源\\\\巨人三\\\\test\\\\2.mp4"));\n    //获取针对1.mp4文件的FileChannel对象\n    FileChannel fc=srcFileInputStream.getChannel();\n    FileChannel destFc=destFileOutputStream.getChannel();\n    //创建ByteBuffer对象\n    //使用非直接方式创建ByteBuffer\n    ByteBuffer buf = ByteBuffer.allocate(1024);\n    \n    while(fc.read(buf)!=-1) {\n        //配置ByteBuffer的可读模式\n        buf.flip();\n        destFc.write(buf);\n        //清除缓存区\n        buf.clear();\n    }\n    long end = System.currentTimeMillis();\n    System.out.println("耗费时间为：" + (end - start));\n    fc.close();\n    destFc.close();\n    srcFileInputStream.close();\n    destFileOutputStream.close();\n}\n\npublic static void testCopyFile02() throws IOException {\n    long start = System.currentTimeMillis();\n    \n    //建立1.mp4的通道（就是连接点）\n    FileChannel fileChannelA=FileChannel.open(Paths.get("E:\\\\资源\\\\巨人三\\\\1.mp4"), StandardOpenOption.READ);\n    FileChannel fileChannelB=FileChannel.open(Paths.get("E:\\\\资源\\\\巨人三\\\\test\\\\2.mp4"),\n            StandardOpenOption.WRITE,\n            StandardOpenOption.READ,\n            StandardOpenOption.CREATE);\n    \n    //建立fileChannelA通道的映射内存\n    MappedByteBuffer inMappedBuf = fileChannelA.map(FileChannel.MapMode.READ_ONLY, 0, fileChannelA.size());\n    //建立fileChannelB通道的映射内存\n    MappedByteBuffer outMappedBuf = fileChannelB.map(FileChannel.MapMode.READ_WRITE, 0, fileChannelA.size());\n    \n    //创建一个字节数组\n    byte[] dst = new byte[inMappedBuf.limit()];\n    inMappedBuf.get(dst);\n    outMappedBuf.put(dst);\n    \n    long end = System.currentTimeMillis();\n    System.out.println("耗费时间为：" + (end - start));\n    //关闭通道\n    fileChannelA.close();\n    fileChannelB.close();\n}\n\n\n\n# 代码实例\n\nFile操作示例 (返回*)\n\nimport java.io.IOException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class Demo {\n    public static void main(String[] args) throws IOException {\n        \n        File f = new File("src/","doc.txt");\n        //会在项目里的根路经的src文件夹里常见doc.txt文件\n        System.out.println("文件不存在，则创建新文件? "+f.createNewFile());\n        \n        System.out.println("获取文件名称："+f.getName());\n        \n        System.out.println("文件是否可读?  "+f.canRead());\n        \n        System.out.println("文件是否可写?  "+f.canWrite());\n        \n        System.out.println("判断文件是否存在? "+f.exists());\n        \n        System.out.println("输出文件长度："+f.length());\n        \n        System.out.println("输出文件路径："+f.getAbsolutePath());\n        \n        System.out.println("输出文件父路径："+f.getParent());\n        \n        System.out.println("判断文件是否存在(普通文件)？"+f.isFile());\n        \n        System.out.println("文件是否为一个目录？"+f.isDirectory());\n        \n        System.out.println("文件是否为隐藏文件？"+f.isHidden());\n        \n        System.out.println("输出文件最后修改时间戳："+f.lastModified());\n        Date date = new Date(f.lastModified());\n        SimpleDateFormat sdf = new SimpleDateFormat("yy/MM/dd HH:mm");\n        \n        System.out.println("输出文件最后修改时间："+sdf.format(date));\n        \n//        System.out.println("删除文件？"+f.delete());\n        \n        //创建的是文件夹\n        // mkdir    (创建单个)\n        // mkdirs   (创建多个)\n        System.out.println("创建抽象路径名命名的目录？"+f.mkdir());\n        \n        //创建在与项目根路经\n        File fm = new File("cs1/cs2/cs3/");\n        System.out.println("创建抽象路径名命名的目录？"+fm.mkdirs());\n    \n    \n        System.out.println("===================");\n        //listFiles方法测试\n        //项目根路经\n        File file = new File("");\n        //获取项目根路经(防止空指针异常)\n        File file2 = new File(file.getAbsolutePath());\n        //file2抽象路径必须为绝对路径否则空指针异常\n        File[] files = file2.listFiles();\n        for (File tmp : files){\n            if (tmp.isFile()){\n                System.out.println("文件："+tmp.getName());\n            }else{\n                System.out.println("文件夹："+tmp.getName());\n            }\n        }\n        \n    }\n}\n\n/*\n\n文件不存在，则创建新文件? false\n获取文件名称：doc.txt\n文件是否可读?  true\n文件是否可写?  true\n判断文件是否存在? true\n输出文件长度：0\n输出文件路径：E:\\Java\\Study\\15Chapter (输入输出流)\\15.3.2 File方法\\src\\doc.txt\n输出文件父路径：src\n判断文件是否存在(普通文件)？true\n文件是否为一个目录？false\n文件是否为隐藏文件？false\n输出文件最后修改时间戳：1594525019225\n输出文件最后修改时间：20/07/12 11:36\n创建抽象路径名命名的目录？false\n创建抽象路径名命名的目录？false\n===================\n文件夹：.idea\n文件：15.3.2 File方法.iml\n文件夹：cs1\n文件夹：out\n文件夹：src\n\n*/\n\n\n字节输出流(返回*)\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args) {\n        \n        //FileOutputStream输出流数据(写入数据)\n        //项目根路经\n        File f = new File("");\n        //获取项目根路经(防止空指针异常)\n        File file = new File(f.getAbsolutePath(),"test.txt");\n        FileOutputStream out = null;\n        \n        try {\n            out = new FileOutputStream(file,true);\n            \n            //判断文件是否存在\n            if (!file.exists()){\n                //新建文件\n                file.createNewFile();\n            }\n            \n            //将字符串转换为字节数组\n            String str = "我喜欢学习Java编程语言!";\n            byte[] bytes = str.getBytes();\n            \n            //写入数据\n            out.write(bytes);\n            \n        } catch (Exception e){\n            e.printStackTrace();\n        }finally {\n            try {\n                //关闭流\n                if (out != null){\n                    out.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        \n    }\n}\n\n/*\n\n在项目根目录 src 里的 Test.txt文件 写入内容\n\n*/\n\n\n字节输入流(返回*)\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\npublic class Demo2 {\n    public static void main(String[] args) {\n        \n        //FileInputStream字节输入流(读取文件)\n        \n        //项目根路经\n        //获取项目根路经(防止空指针异常)\n        File file = new File(new File("").getAbsolutePath(),"test.txt");\n        FileInputStream input = null;\n    \n        try {\n            input = new FileInputStream(file);\n            //判断文件是否存在\n            if (!file.exists()){\n                 //新建文件\n                file.createNewFile();\n            }\n            \n            //每次读取1KB (1字节 = 1B = 1024 KB )\n            byte[] bytes = new byte[1024];\n            //第一次读取\n            int len = input.read(bytes);\n            //存储读取的数据\n            StringBuilder src = new StringBuilder();\n            while (len != -1){\n                src.append(new String(bytes , 0 , len));\n                len = input.read(bytes);\n            }\n            System.out.println("文件内容为："+src);\n            \n        }catch (Exception e){\n            e.printStackTrace();\n        }finally {\n            try {\n                //关闭流\n                if (input != null){\n                     input.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    \n    }\n}\n\n/*\n\n在项目根目录 src 里的 Test.txt文件 读取内容\n\n*/\n\n\n字符输出流(返回*)\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.IOException;\n\npublic class Demo2 {\n    public static void main(String[] args) {\n        \n        //输出(写入)\n        \n        File file = new File("word.txt");\n        FileWriter fw = null;\n        \n        try {\n            fw = new FileWriter(file);\n            String str = new String("欢迎来到，我的世界");\n            fw.write(str);\n            fw.append(",").append("Java！");\n            \n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            try {\n                if (fw != null) {\n                    fw.close();\n                }\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n        \n        \n    }\n}\n\n/*\n\n在项目根目录 src 里的 Test.txt文件 写入内容\n\n*/\n\n\n字符输入流(返回*)\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class Demo {\n    public static void main(String[] args) {\n        \n        //输入 (读取)\n        \n        File file = new File("word.txt");\n        FileReader fr = null;\n        \n        try {\n            fr = new FileReader(file);\n            \n            char[] ch = new char[1024];\n            int len = fr.read(ch);\n            StringBuilder src = new StringBuilder();\n            while (len != -1) {\n                //循环读取\n                src.append(new String(ch, 0, len));\n                len = fr.read(ch);\n            }\n            \n            System.out.println("文件内容: " + src);\n            \n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            if (fr != null) {\n                try {\n                    fr.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        \n    }\n}\n\n/*\n\n在项目根目录 src 里的 Test.txt文件 读取内容\n\n*/\n',normalizedContent:'# java i/o\n\n\n# 概述\n\n物质在目的地之间的转移运动称为流，可分为 输入流 、 输出流\n\n> 输入流： 程序从源中读取数据 输出流： 数据要到达的目的地\n\n主要流：\n\n文件流 缓冲流 数据流 \n\n\n# 输入流\n\ninputstream类 是字节流 的抽象类，所有字节输入流的父类 java.io.inputstream\n\nreader类 是字符流 的抽象类 ，是unicode编码，适合处理文本，所有字符输入流的父类 java.io.reader\n\n方法 (更多方法自行api)*\n\n返回        方法                    说明\nvoid      close()               关闭输入流\nvoid      mark(int readlimit)   标记输入流中的当前位置\nboolean   marksupported()       支持 mark和 reset方法，则true\nint       read()                从输入流读取数据，(字节)0~255范围，没有则-1\nint       read(e[] b)           从输入流读取一些 字符/字节 ，并将它们存储到缓冲区b\nvoid      reset()               将流重新定位到上次输入流调用 mark方法时的位置\nlong      skip(long n)          跳过输入流上的n个字符，返回实际跳过的字节数\n\n\n# 输出流\n\noutputstream类 是字节流 的抽象类，所有字节输出流的父类 java.io.outputstream\n\nwriter类 是字符流 的抽象类 ，所有字符输入流的父类 java.io.writer\n\n方法 (更多方法自行api)*\n\n返回     方法                                 说明\nvoid   close()                            关闭流\nvoid   flush()                            完成输出清空缓冲\nvoid   write(e text)                      将指定text写入流\nvoid   write(e[] b)                       将b数组写入流\nvoid   write(e[] b , int off , int len)   将b数组中从偏移量off开始写入len个字节的流\n\n\n# file类\n\n> class file\n> \n> java.lang.object java.io.file\n> \n> 实现接口 serializable、comparable<file>\n\nfile类是代表磁盘的 文件 或者 文件夹(目录)，该类可实现创建、删除、重命名文件等操作\n\n构造方法\n\nfile(string pathname) 抽象路径目录对象(文件夹 或 文件) file(string parent , string child) 路径目录中的文件(绝对路径)\n\n> pathname： 路径名称(包含文件名) parent： 父路径字符串，例如：d://doc 或 d://doc//no1.txt child： 子路径字符串 ，例如：no1.txt\n\n注意：\n\n>  * 盘符的路径名前缀由驱动器号和 :组成\n>  * 路径分割一般用： \\ 或 //\n>  * 子路径文件一定要有后缀，如：.jpg、.txt\n\n\n# 文件操作方法\n\nfile类提供以下为常用方法 ，如果想看更多方法自行查jdk文档\n\n返回        方法                             说明\nstring    getname()                      获取文件名称\nboolean   canread()                      判断文件是否为可读\nboolean   canwrite()                     判断文件是否可写入\nboolean   exists()                       判断文件是否存在\nlong      length()                       获取文件的长度(字节为单位)\nstring    getabsolutepath()              获取文件的绝对路径\nstring    getparent()                    获取文件的父路径\nboolean   isfile()                       判断文件是否存在(普通文件)\nboolean   isdirectory()                  判断文件是否为一个目录\nboolean   ishidden()                     判断文件是否为隐藏文件\nlong      lastmodified()                 获取文件最后修改时间(毫秒为单位)\nboolean   createnewfile()                路径文件不存在，则创建新的空文件\nboolean   delete()                       删除子路径(最后一个)文件或文件夹\nboolean   mkdir()                        创建抽象路径名命名的目录(创建文件夹)\nboolean   mkdirs()                       创建抽象路径名命名的目录，包括任何必需但不存在的父目录(创建多层路径文件夹)\nboolean   renameto(file dest)            重命名由此抽象路径名表示的文件(移动且替换文件)\nfile[]    listfiles()                    返回文件夹所有 子文件夹 和 文件\nfile[]    listfiles(filefilter filter)   返回以满足条件的文件夹所有 子文件夹 和 文件\n\n点击代码示例* (file操作)\n\n\n# 字节流\n\nfileinputstream、fileoutputstream类 操作磁盘文件的字节\n\n计算机中的所有文件都是二进制形式存储的(文本、图片、···)，这些数据可以通过 字节流 与计算机底层的二进制数据进行交互！\n\n\n# 字节输出流\n\n> class fileoutputstream\n> \n> java.lang.object java.io.outputstream java.io.fileoutputstream\n> \n> 实现接口：\n> \n> closeable ， flushable ， autocloseable\n\n构造方法\n\nfileoutputstream(file file) fileoutputstream(string filename) fileoutputstream(string filename , boolean append) fileoutputstream(file file , boolean append)\n\n> filename： 给文件名 file： 抽象路径对象 append： 是否连续写入数据\n\n常用方法 (继承方法点击索引)\n\n返回     方法                                    说明\nvoid   write(byte[] b)                       指定字节数组写入文件\nvoid   write(byte[] b , int off , int len)   指定范围写入字节数组\nvoid   write(int b)                          将指定字节写入(字节数)\n\n点击代码示例* (字节输出流)\n\n\n# 字节输入流\n\n> class fileinputstream\n> \n> java.lang.object java.io.inputstream java.io.fileinputstream\n> \n> 实现接口：\n> \n> closeable ， autocloseable\n\n构造方法\n\nfileinputstream(file file) fileinputstream(string filename)\n\n> filename： 文件名 file： 要打开阅读的文件\n\n常用方法 (继承方法点击索引)\n\n返回     方法                                   说明\nlong   length()                             返回底层文件的长度\nint    read()                               从流中读取一字节(读完则 -1 )读完指向下一个字节\nint    read(byte[] b)                       从流中读取一组字节\nint    read(byte[] b , int off , int len)   从流中读取 off 到 len 位置的字节\nvoid   seek(long pos)                       将当前流位置为所需位置\n\n点击代码示例* (字节输入流)\n\n\n# 字符流\n\n字符输入输出流可避免像字节流出现乱码现象！他们是使用方法是大致一样！\n\n\n# 字符输出流\n\n> class filewriter\n> \n> java.lang.object java.io.writer java.io.outputstreamwriter java.io.filewriter\n> \n> 实现接口：\n> \n> closeable ， autocloseable ， flushable ， appendable\n\n构造方法\n\nfilewriter(file file) filewriter(string filename) filewriter(string filename , boolean append) filewriter(file file , boolean append)\n\n> filename： 给文件名 file： 抽象路径对象 append： 是否连续写入数据\n\n方法(继承方法点击索引) 传输形式是 以字符为单位进行传输 char\n\n点击代码示例* (字符输出流)\n\n----------------------------------------\n\n\n# 字符输入流\n\n> class filereader\n> \n> java.lang.object java.io.reader java.io.inputstreamreader java.io.filereader\n> \n> 实现接口：\n> \n> closeable ， autocloseable ， readable\n\n构造方法\n\nfilereader (file file) filereader (string filename)\n\n> filename： 文件名 file： 要打开阅读的文件\n\n方法 (继承方法点击索引) 传输形式是 以字符为单位进行传输 char\n\n点击代码示例* (字符输入流)\n\n\n# 字节与字符流的转换\n\n\n# 输出流\n\n> class outputstreamwriter\n> \n> java.lang.object java.io.writer java.io.outputstreamwriter\n> \n> 实现接口： closeable ， flushable ， appendable ， autocloseable\n\n构造方法\n\noutputstreamwriter(outputstream out) outputstreamwriter(outputstream out , charset cs)\n\n> out： 字节输出流 cs： 编码名称\n\n方法 (继承方法点击索引)\n\n返回       方法                                    说明\nstring   getencoding()                         获取字符编码的名称\nvoid     write(char ch)                        写一个字符\nvoid     write(char[] ch, int off, int len)    写数组中的 off 至 len 范围的字符\nvoid     write(string str, int off, int len)   写字符串中的 off 至 len 范围的字符\n\n----------------------------------------\n\n\n# 输入流\n\n> class inputstreamreader\n> \n> java.lang.object java.io.reader java.io.inputstreamreader\n> \n> 实现接口：\n> \n> closeable ， autocloseable ， readable\n\n构造方法\n\ninputstreamreader(inputstream in) inputstreamreader(inputstream in, charset cs)\n\n> in： 字节输入流 cs： 编码名称\n\n方法 (继承方法点击索引)\n\n返回        方法                                  说明\nstring    getencoding()                       获取字符编码的名称\nint       read()                              读一个字符\nint       read(char[] ch, int off, int len)   读数组中的 off 至 len 范围的字符\nboolean   ready()                             流是否准备好被读取\n\n\n# 缓存字节流\n\n缓存是输入输出流的优化，能大大提升传输效率！\n\n传输形式\n\n文件→字节流→缓存流→目的地\n\n\n# 缓存字符输出流\n\n> class bufferedoutputstream\n> \n> java.lang.object java.io.outputstream java.io.filteroutputstream java.io.bufferedoutputstream\n\n构造方法\n\nbufferedoutputstream(outputstream out) bufferedoutputstream(outputstream out , int size)\n\n> out： 文件输出流 size： 缓储存大小\n\n以下代码 写入文件\n\nimport java.io.*;\n\npublic class demo {\n    public static void main(string[] args) {\n        //文件选择大文件为好，容易体现效果\n        file field = new file("word.txt");\n        fileoutputstream out = null;\n        //创建缓存输出流\n        bufferedoutputstream buffout = null;\n        //时间记录点1\n        long a = system.currenttimemillis();\n        \n        try {\n            out = new fileoutputstream(field,true);\n            //用缓存输出流封装输出流\n            buffout = new bufferedoutputstream(out);\n    \n            string str = new string("世界你好！\\n");\n            byte[] bytes = str.getbytes();\n            \n            //写入99999次\n            for (int i = 0; i < 99999; i++) {\n                \n                //单选程序测试\n                \n                /*\n                *\n                * 选择(1)缓存流测试速度\n                *\n                *  */\n                //使用流时是使用缓存输出流\n                buffout.write(bytes);\n                //刷新。强制将缓冲区数据写入文件中，即使缓冲区没有写满\n                // 缓存区没写满刷新传输，提升效率\n                buffout.flush();\n                \n                /*\n                 *\n                 * 选择(2)字节流测试速度\n                 *\n                 *  */\n//                out.write(bytes);\n            }\n            //时间记录点2\n            long b = system.currenttimemillis();\n            system.out.println("运行了："+(b-a)+"mm");\n        } catch (filenotfoundexception e) {\n            e.printstacktrace();\n        } catch (ioexception e) {\n            e.printstacktrace();\n        } finally {\n            //关闭流\n            if (out != null){\n                try {\n                    out.close();\n                } catch (ioexception e) {\n                    e.printstacktrace();\n                }\n            }\n            if (buffout != null){\n                try {\n                    buffout.close();\n                } catch (ioexception e) {\n                    e.printstacktrace();\n                }\n            }\n        }\n        \n    }\n}\n\n\n缓存流输出还是大文件较好，文件选择建议自选大文件为好呈现\n\n\n# 缓存字符输入流\n\n> class bufferedinputstream\n> \n> java.lang.object java.io.inputstream java.io.filterinputstream java.io.bufferedinputstream\n\n构造方法\n\nbufferedinputstream(inputstream in)\n\nbufferedinputstream(inputstream in , int size)\n\n> in：文件输出流 size：缓储存大小\n\nimport java.io.*;\n\npublic class demo2 {\n    \n    public static void main(string[] args) {\n        //文件选择大文件为好，容易体现效果\n        file field = new file("word.txt");\n        fileinputstream input= null;\n        bufferedinputstream buffin = null;\n    \n        //时间记录点1\n        long a = system.currenttimemillis();\n        try {\n            input = new fileinputstream(field);\n            buffin = new bufferedinputstream(input);\n            \n            //缓冲区字节数组(与buffered不同)\n            byte[] bytes = new byte[1024];\n            \n            /*\n             *\n             * 选择(1)缓存流测试速度\n             *\n             *  */\n            //直到读完\n            while ((buffin.read(bytes))!= -1){ }\n    \n            /*\n             *\n             * 选择(2)字节流测试速度\n             *\n             *  */\n            //直到读完\n//            while ((input.read(bytes))!= -1){ }\n            \n            long b = system.currenttimemillis();\n            system.out.println("运行了："+(b-a)+"mm");\n        } catch (filenotfoundexception e) {\n            e.printstacktrace();\n        } catch (ioexception e) {\n            e.printstacktrace();\n        } finally {\n            if (input != null){\n                try {\n                    input.close();\n                } catch (ioexception e) {\n                    e.printstacktrace();\n                }\n            }\n            if (buffin != null){\n                try {\n                    buffin.close();\n                } catch (ioexception e) {\n                    e.printstacktrace();\n                }\n            }\n        }\n    \n    }\n}\n\n\n运行结果 当然是缓存流比字节流快啦，前提是大文件！\n\n\n# 缓存字符流\n\n可以以行为单位进行 输入/输出 ，与以上的缓冲字符流大部分相同！\n\n\n# 缓存字符输出流\n\n> class bufferedwriter\n> \n> java.lang.object java.io.writer java.io.bufferedwriter\n\n构造方法与以上的一样！\n\n缓存字符输出流提供独有方法：newline() 写入一行(换行) 带分割符\n\nimport java.io.bufferedwriter;\nimport java.io.file;\nimport java.io.filewriter;\nimport java.io.ioexception;\n\npublic class demo {\n    public static void main(string[] args) {\n        \n        file file = new file("word.txt");\n    \n        filewriter fw= null;\n        bufferedwriter bfw = null;\n    \n        try {\n            //先创建后关闭\n            fw = new filewriter(file);\n            bfw = new bufferedwriter(fw);\n        \n            string str = new string("世界这么大，");\n            string str2 = new string("我想去看看。");\n            \n            bfw.write(str);//写入数据\n            bfw.newline();//创建新行\n            bfw.write(str2);//写入数据\n            \n        } catch (ioexception e) {\n            e.printstacktrace();\n        } finally {\n            //先创建后关闭\n            if (bfw != null){\n                try {\n                    bfw.close();\n                } catch (ioexception e) {\n                    e.printstacktrace();\n                }\n            }\n            if (fw != null){\n                try {\n                    fw.close();\n                } catch (ioexception e) {\n                    e.printstacktrace();\n                }\n            }\n        }\n        \n    }\n}\n\n\n在项目创建了test.txt文件，并写入数据 "世界这么大，\\n我想去看看。"\n\n\n# 缓存字符输入流\n\n> class bufferedreader\n> \n> java.lang.object java.io.reader java.io.bufferedreader\n\n缓存字符输入流提供独有方法：string readline() 读取一个文本行\n\nimport java.io.bufferedreader;\nimport java.io.file;\nimport java.io.filereader;\nimport java.io.ioexception;\n\npublic class demo2 {\n    public static void main(string[] args) {\n    \n        file file = new file("word.txt");\n        \n        filereader fr = null;\n        bufferedreader bfr = null;\n        \n        try {\n            \n            fr = new filereader(file);\n            bfr = new bufferedreader(fr);\n            \n            string tmp = null;\n            //计数变量\n            int i = 1 ;\n            //逐行获取字符串并输出\n            while ((tmp = bfr.readline()) != null){\n                system.out.println("第"+(i++)+"行："+tmp);\n            }\n            \n            \n        } catch (exception e) {\n            e.printstacktrace();\n        } finally {\n            if (bfr != null){\n                try {\n                    bfr.close();\n                } catch (ioexception e) {\n                    e.printstacktrace();\n                }\n            }\n            if (fr != null){\n                try {\n                    fr.close();\n                } catch (ioexception e) {\n                    e.printstacktrace();\n                }\n            }\n        }\n    \n    }\n}\n\n/*\n\n第1行：世界这么大，\n第2行：我想去看看。\n\n*/\n\n\n\n# 数据流\n\n允许应用程序以与机器无关的方式从底层输入流中读取基本java数据类型\n\n\n# 数据输出流\n\n> class dataoutputstream\n> \n> java.lang.object java.io.outputstream java.io.filteroutputstream java.io.dataoutputstream\n\n构造方法\n\ndataoutputstream(outputstream out)\n\n> out：底层输出流，保存供以后使用\n\ndataoutputstream类提供了以下独有方法\n\n修饰符    方法                        说明\nvoid   writeboolean(boolean v)   将 boolean写入底层输出流(1字节)\nvoid   writebyte(int v)          将 byte值写入底层输出流(1字节)\nvoid   writebytes(string s)      将字符串作为字节序列写入基础输出流\n···    ···                       ···多余自行查询 jdk文档\nvoid   writeutf(string str)      使用 modified utf-8编码以机器无关的方式将字符串写入基础输出流\n\n\n# 数据输入流\n\n> class datainputstream\n> \n> java.lang.object java.io.inputstream java.io.filterinputstream java.io.datainputstream\n\n构造方法\n\ndatainputstream(inputstream in)\n\n> in：指定的输入流\n\nimport java.io.*;\n\npublic class demo {\n    public static void main(string[] args) {\n        \n        file file = new file("word.txt");\n        \n        //创建字节流\n        fileoutputstream out = null;\n        fileinputstream inp = null;\n        //创建数据流\n        dataoutputstream dataout = null;\n        datainputstream datainp = null;\n    \n        try {\n            out = new fileoutputstream(file);\n            dataout = new dataoutputstream(out);\n            \n            inp = new fileinputstream(file);\n            datainp = new datainputstream(inp);\n            \n            //写入数据\n            dataout.writeutf("使用writeutf方法写入！");\n            dataout.writechars("使用writechars方法写入！");\n            dataout.writebytes("使用writebytes方法写入！");\n    \t\t\n            //读取数据\n            system.out.println("在输入流读取数据："+datainp.readutf());\n            \n        } catch (filenotfoundexception e) {\n            e.printstacktrace();\n        } catch (ioexception e) {\n            e.printstacktrace();\n        } finally {\n            if (datainp != null){\n                try {\n                    datainp.close();\n                } catch (ioexception e) {\n                    e.printstacktrace();\n                }\n            }\n            if (inp != null){\n                try {\n                    inp.close();\n                } catch (ioexception e) {\n                    e.printstacktrace();\n                }\n            }\n            if (dataout != null){\n                try {\n                    dataout.close();\n                } catch (ioexception e) {\n                    e.printstacktrace();\n                }\n            }\n            if (out != null){\n                try {\n                    out.close();\n                } catch (ioexception e) {\n                    e.printstacktrace();\n                }\n            }\n        }\n    \n    }\n}\n\n/* 控制台结果\n在输入流读取数据：使用writeutf方法写入！\n*/\n\n\n\n# 打印流\n\n> class printwriter\n> \n> java.lang.object java.io.writer java.io.printwriter\n> \n> 实现接口：\n> \n> closeable ， flushable ， appendable ， autocloseable\n\n将对象的格式表示打印到文本输出流，打印过程不需刷新！\n\n构造方法 (更多方法自行api)\n\nprintwriter(file file) printwriter(outputstream out) printwriter(string filename) printwriter(writer out)\n\n方法 (继承方法点击索引)\n\n返回            方法                说明\nprintwriter   append(char ch)   指定字符追加\nboolean       checkerror()      检查流是否关闭\nvoid          clearerror()      清除流中的错误状态\nvoid          print(e)          写入数据(支持多类型，详细api)\nvoid          println(e)        写入数据末尾换行(支持多类型，详细api)\nvoid          write(···)        继承输入流写入的方法\n\n\n# nio\n\nnio支持面向缓冲区的、基于通道的io操作。nio将以更加高效的方式进行文件的读写操作\n\njava nio 由以下几个核心部分组成：\n\n * 通道 channels\n * 缓存区 buffers\n\n\n# 缓存区 buffers\n\n缓存区 buffer 主要用于与 nio 通道进行交互，数据是从通道读入缓冲区，从缓冲区写入通道中的\n\n缓存区 本质是个 读写 的内存，而内存被封装为nio buffer对象\n\nbuffer实现类： bytebuffer、mappedbytebuffer、charbuffer、doublebuffer、floatbuffer、intbuffer、longbuffer、shortbuffer\n\nbuffer对象属性\n\n * **capacity 容量：**buffer 的内存块(容量)，缓冲区容量不能为负，并且创建后不能更改\n * limit 限制： 剩余可写容量的指针\n   * 在 写模式 下，最多能写入 limit个单元 的数据\n   * 在 读模式 下，最多能够读取 limit个单元 的数据，一旦切换为读，就要读完，否则会被舍弃！\n   * 当模式从 写 切换至 读 时，limit 被设置成写模式下的position值，而position重置为0\n   * limit = capacity – （position + 1）\n * position 位置： 位置操作的指针\n   * 当 写入数据 时，position会移到下入的下一个buffer单元\n   * 当 读取数据 时，buffer切换至模式，position会重置为0，读数据时position会下移读取可读数据\n   * position位置指标 最大值为 capacity - 1\n\nbuffer常用方法\n\n * allocate() 开辟新缓存空间\n * clear() 清缓存。limit和position为零\n * array() 获取缓存区数据\n * flip() 使缓冲区准备好新的通道写入 获取操作 序列。limit为position，position为零\n * rewind() 使缓冲区准备好重新读取已经包含的数据。limit保持不变，position为零\n\nbuffers应用步骤：\n\n 1. 分配缓存区内存 allocate(int length)静态方法\n 2. 写入数据，buffer对象 调用put()方法 写入内存\n 3. 切换模式，切换至 读/写 ，buffer对象 调用flip()方法（position重置为0\n 4. 读取数据，buffer 中读取数据 get()、通过数据批获取\n 5. 清缓存，buffer对象 调用clear()方法\n\n示例：\n\npublic static void testbuffer() {\n    //创建分配容量长度为10的字节缓冲区\n    bytebuffer buf = bytebuffer.allocate(10);\n    system.out.println("position="+buf.position()); //0\n    system.out.println("limit="+buf.limit()); //10\n    system.out.println("capacity="+buf.capacity()); //10\n    \n    string putmsg="abcd";\n    //将字符串转换成字节数组\n    system.out.println("将abcd字符串存储到bytebuffer");\n    buf.put(putmsg.getbytes(), 0, putmsg.getbytes().length);\n    \n    system.out.println("position="+buf.position()); //4\n    system.out.println("limit="+buf.limit()); //10\n    system.out.println("capacity="+buf.capacity()); //10\n\n    //翻转成读模式\n    system.out.println("翻转成读模式----------");\n    buf.flip();\n    \n    system.out.println("position="+buf.position()); //0\n    system.out.println("limit="+buf.limit()); //4\n    system.out.println("capacity="+buf.capacity()); //10\n    \n    byte[] cbuf = new byte[buf.limit()];\n    //从缓存区读取数据\n    system.out.println("从缓存区读取数据");\n    buf.get(cbuf, 0, cbuf.length);\n    system.out.println(new string(cbuf,0,cbuf.length));\n    // abcd\n    buf.clear();\n}\n\n\n\n# 通道 channels\n\n通道 channels 是针对目标文件打开的连接，而建立的一个通道\n\n * 双向通道。读写数据都是通过通道进行数据交互。但流的读写通常是单向的\n * 通道可以异步地读写\n * 通道中的数据总是要先读到一个buffer，或者总是要从一个buffer中写入\n\n通道实现类：\n\n * 文件读写 filechannel\n * udp网络读写 datagramchannel\n * tcp网络读写 socketchannel\n * 监听连接的tcp serversocketchannel\n\n# 文件读写 filechannel\n\nfilechannel 应用步骤：\n\n 1. 获取文件指定的 字节输入流\n 2. 流转换 filechannel对象，字节输入流 调用getchannel()方法\n 3. 创建缓存区（类型根据情况选择\n 4. 循环读取直至为空\n    1. 每次循环都要缓存都要flip()反转 （以便控制读取范围\n    2. 每次循环读取后都要清空内存\n\n示例：\n\npublic static void testfilechannel() throws ioexception {\n    //创建fileinputstream对象\n    fileinputstream fileinputstream=new fileinputstream(new file("a.txt"));\n    //获取filechannel对象\n    filechannel fc = fileinputstream.getchannel();\n    bytebuffer buf=bytebuffer.allocate(12);\n\n    while(fc.read(buf) != -1) {\n        //设置butebuffer为读取模式\n        buf.flip();\n        string message=new string(buf.array(),0,buf.limit());\n        system.out.print(message);\n        \n        buf.clear();\n    }\n    fileinputstream.close();\n}\n\n\n读写拷贝应用实例：\n\npublic static void testcopyfile01() throws ioexception {\n    long start = system.currenttimemillis();\n    \n    fileinputstream srcfileinputstream=new fileinputstream(new file("e:\\\\资源\\\\巨人三\\\\1.mp4"));\n    fileoutputstream destfileoutputstream=new fileoutputstream(new file("e:\\\\资源\\\\巨人三\\\\test\\\\2.mp4"));\n    //获取针对1.mp4文件的filechannel对象\n    filechannel fc=srcfileinputstream.getchannel();\n    filechannel destfc=destfileoutputstream.getchannel();\n    //创建bytebuffer对象\n    //使用非直接方式创建bytebuffer\n    bytebuffer buf = bytebuffer.allocate(1024);\n    \n    while(fc.read(buf)!=-1) {\n        //配置bytebuffer的可读模式\n        buf.flip();\n        destfc.write(buf);\n        //清除缓存区\n        buf.clear();\n    }\n    long end = system.currenttimemillis();\n    system.out.println("耗费时间为：" + (end - start));\n    fc.close();\n    destfc.close();\n    srcfileinputstream.close();\n    destfileoutputstream.close();\n}\n\npublic static void testcopyfile02() throws ioexception {\n    long start = system.currenttimemillis();\n    \n    //建立1.mp4的通道（就是连接点）\n    filechannel filechannela=filechannel.open(paths.get("e:\\\\资源\\\\巨人三\\\\1.mp4"), standardopenoption.read);\n    filechannel filechannelb=filechannel.open(paths.get("e:\\\\资源\\\\巨人三\\\\test\\\\2.mp4"),\n            standardopenoption.write,\n            standardopenoption.read,\n            standardopenoption.create);\n    \n    //建立filechannela通道的映射内存\n    mappedbytebuffer inmappedbuf = filechannela.map(filechannel.mapmode.read_only, 0, filechannela.size());\n    //建立filechannelb通道的映射内存\n    mappedbytebuffer outmappedbuf = filechannelb.map(filechannel.mapmode.read_write, 0, filechannela.size());\n    \n    //创建一个字节数组\n    byte[] dst = new byte[inmappedbuf.limit()];\n    inmappedbuf.get(dst);\n    outmappedbuf.put(dst);\n    \n    long end = system.currenttimemillis();\n    system.out.println("耗费时间为：" + (end - start));\n    //关闭通道\n    filechannela.close();\n    filechannelb.close();\n}\n\n\n\n# 代码实例\n\nfile操作示例 (返回*)\n\nimport java.io.ioexception;\nimport java.text.simpledateformat;\nimport java.util.date;\n\npublic class demo {\n    public static void main(string[] args) throws ioexception {\n        \n        file f = new file("src/","doc.txt");\n        //会在项目里的根路经的src文件夹里常见doc.txt文件\n        system.out.println("文件不存在，则创建新文件? "+f.createnewfile());\n        \n        system.out.println("获取文件名称："+f.getname());\n        \n        system.out.println("文件是否可读?  "+f.canread());\n        \n        system.out.println("文件是否可写?  "+f.canwrite());\n        \n        system.out.println("判断文件是否存在? "+f.exists());\n        \n        system.out.println("输出文件长度："+f.length());\n        \n        system.out.println("输出文件路径："+f.getabsolutepath());\n        \n        system.out.println("输出文件父路径："+f.getparent());\n        \n        system.out.println("判断文件是否存在(普通文件)？"+f.isfile());\n        \n        system.out.println("文件是否为一个目录？"+f.isdirectory());\n        \n        system.out.println("文件是否为隐藏文件？"+f.ishidden());\n        \n        system.out.println("输出文件最后修改时间戳："+f.lastmodified());\n        date date = new date(f.lastmodified());\n        simpledateformat sdf = new simpledateformat("yy/mm/dd hh:mm");\n        \n        system.out.println("输出文件最后修改时间："+sdf.format(date));\n        \n//        system.out.println("删除文件？"+f.delete());\n        \n        //创建的是文件夹\n        // mkdir    (创建单个)\n        // mkdirs   (创建多个)\n        system.out.println("创建抽象路径名命名的目录？"+f.mkdir());\n        \n        //创建在与项目根路经\n        file fm = new file("cs1/cs2/cs3/");\n        system.out.println("创建抽象路径名命名的目录？"+fm.mkdirs());\n    \n    \n        system.out.println("===================");\n        //listfiles方法测试\n        //项目根路经\n        file file = new file("");\n        //获取项目根路经(防止空指针异常)\n        file file2 = new file(file.getabsolutepath());\n        //file2抽象路径必须为绝对路径否则空指针异常\n        file[] files = file2.listfiles();\n        for (file tmp : files){\n            if (tmp.isfile()){\n                system.out.println("文件："+tmp.getname());\n            }else{\n                system.out.println("文件夹："+tmp.getname());\n            }\n        }\n        \n    }\n}\n\n/*\n\n文件不存在，则创建新文件? false\n获取文件名称：doc.txt\n文件是否可读?  true\n文件是否可写?  true\n判断文件是否存在? true\n输出文件长度：0\n输出文件路径：e:\\java\\study\\15chapter (输入输出流)\\15.3.2 file方法\\src\\doc.txt\n输出文件父路径：src\n判断文件是否存在(普通文件)？true\n文件是否为一个目录？false\n文件是否为隐藏文件？false\n输出文件最后修改时间戳：1594525019225\n输出文件最后修改时间：20/07/12 11:36\n创建抽象路径名命名的目录？false\n创建抽象路径名命名的目录？false\n===================\n文件夹：.idea\n文件：15.3.2 file方法.iml\n文件夹：cs1\n文件夹：out\n文件夹：src\n\n*/\n\n\n字节输出流(返回*)\n\nimport java.io.file;\nimport java.io.fileoutputstream;\nimport java.io.ioexception;\n\npublic class demo {\n    public static void main(string[] args) {\n        \n        //fileoutputstream输出流数据(写入数据)\n        //项目根路经\n        file f = new file("");\n        //获取项目根路经(防止空指针异常)\n        file file = new file(f.getabsolutepath(),"test.txt");\n        fileoutputstream out = null;\n        \n        try {\n            out = new fileoutputstream(file,true);\n            \n            //判断文件是否存在\n            if (!file.exists()){\n                //新建文件\n                file.createnewfile();\n            }\n            \n            //将字符串转换为字节数组\n            string str = "我喜欢学习java编程语言!";\n            byte[] bytes = str.getbytes();\n            \n            //写入数据\n            out.write(bytes);\n            \n        } catch (exception e){\n            e.printstacktrace();\n        }finally {\n            try {\n                //关闭流\n                if (out != null){\n                    out.close();\n                }\n            } catch (ioexception e) {\n                e.printstacktrace();\n            }\n        }\n        \n    }\n}\n\n/*\n\n在项目根目录 src 里的 test.txt文件 写入内容\n\n*/\n\n\n字节输入流(返回*)\n\nimport java.io.file;\nimport java.io.fileinputstream;\nimport java.io.ioexception;\n\npublic class demo2 {\n    public static void main(string[] args) {\n        \n        //fileinputstream字节输入流(读取文件)\n        \n        //项目根路经\n        //获取项目根路经(防止空指针异常)\n        file file = new file(new file("").getabsolutepath(),"test.txt");\n        fileinputstream input = null;\n    \n        try {\n            input = new fileinputstream(file);\n            //判断文件是否存在\n            if (!file.exists()){\n                 //新建文件\n                file.createnewfile();\n            }\n            \n            //每次读取1kb (1字节 = 1b = 1024 kb )\n            byte[] bytes = new byte[1024];\n            //第一次读取\n            int len = input.read(bytes);\n            //存储读取的数据\n            stringbuilder src = new stringbuilder();\n            while (len != -1){\n                src.append(new string(bytes , 0 , len));\n                len = input.read(bytes);\n            }\n            system.out.println("文件内容为："+src);\n            \n        }catch (exception e){\n            e.printstacktrace();\n        }finally {\n            try {\n                //关闭流\n                if (input != null){\n                     input.close();\n                }\n            } catch (ioexception e) {\n                e.printstacktrace();\n            }\n        }\n    \n    }\n}\n\n/*\n\n在项目根目录 src 里的 test.txt文件 读取内容\n\n*/\n\n\n字符输出流(返回*)\n\nimport java.io.file;\nimport java.io.filewriter;\nimport java.io.ioexception;\n\npublic class demo2 {\n    public static void main(string[] args) {\n        \n        //输出(写入)\n        \n        file file = new file("word.txt");\n        filewriter fw = null;\n        \n        try {\n            fw = new filewriter(file);\n            string str = new string("欢迎来到，我的世界");\n            fw.write(str);\n            fw.append(",").append("java！");\n            \n        } catch (ioexception e) {\n            e.printstacktrace();\n        } finally {\n            try {\n                if (fw != null) {\n                    fw.close();\n                }\n            } catch (ioexception e) {\n                e.printstacktrace();\n            }\n        }\n        \n        \n    }\n}\n\n/*\n\n在项目根目录 src 里的 test.txt文件 写入内容\n\n*/\n\n\n字符输入流(返回*)\n\nimport java.io.file;\nimport java.io.filereader;\nimport java.io.ioexception;\n\npublic class demo {\n    public static void main(string[] args) {\n        \n        //输入 (读取)\n        \n        file file = new file("word.txt");\n        filereader fr = null;\n        \n        try {\n            fr = new filereader(file);\n            \n            char[] ch = new char[1024];\n            int len = fr.read(ch);\n            stringbuilder src = new stringbuilder();\n            while (len != -1) {\n                //循环读取\n                src.append(new string(ch, 0, len));\n                len = fr.read(ch);\n            }\n            \n            system.out.println("文件内容: " + src);\n            \n        } catch (ioexception e) {\n            e.printstacktrace();\n        } finally {\n            if (fr != null) {\n                try {\n                    fr.close();\n                } catch (ioexception e) {\n                    e.printstacktrace();\n                }\n            }\n        }\n        \n    }\n}\n\n/*\n\n在项目根目录 src 里的 test.txt文件 读取内容\n\n*/\n',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"枚举",frontmatter:{title:"枚举",date:"2020-02-18T00:00:00.000Z",permalink:"/backend/r3608t",categories:["后端","Java基础"],tags:["Java"],author:"柏竹"},regularPath:"/01.%E5%90%8E%E7%AB%AF/01.Java%E5%9F%BA%E7%A1%80/11.%E6%9E%9A%E4%B8%BE.html",relativePath:"01.后端/01.Java基础/11.枚举.md",key:"v-1fde75d5",path:"/backend/r3608t/",headers:[{level:2,title:"枚举中的构造方法",slug:"枚举中的构造方法",normalizedTitle:"枚举中的构造方法",charIndex:155},{level:2,title:"常量设置",slug:"常量设置",normalizedTitle:"常量设置",charIndex:369},{level:2,title:"接口实现",slug:"接口实现",normalizedTitle:"接口实现",charIndex:716},{level:2,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:161},{level:2,title:"代码实例",slug:"代码实例",normalizedTitle:"代码实例",charIndex:1932}],headersStr:"枚举中的构造方法 常量设置 接口实现 方法 代码实例",content:'# 枚举\n\n> Class Enum<E extends Enum <E> > java.lang.Object java.lang.Enum <E>\n\n枚举是一种特殊的数据类型，也是常量的集合，主要作用是限制指定内容\n\n特点：\n\n * 类型安全\n * 可以和程序其他部分完美交交互\n * 运行效率高\n\n\n# 枚举中的构造方法\n\n在枚举类型中添加构造方法前提该构造方法必须为private权限修饰符\n\npublic enum Constants{//Constants枚举名称\n    Constants_A,\nConstants_B;\n    private String name;\n    private Constants(String name){\n        name.this = name;\n    }\n}\n\n\n\n# 常量设置\n\n当定义枚举类型时，每个枚举类型的成员都可以看做实例，类型默认修饰为 final、public、static ，当使用时直接调用对应的名称即可\n\npublic enum Level{//Constants枚举名称\n\tLOW(30) , MEDIUM(15) , HIGH(7) , URGENT(1);\n\t    \n\tprivate int levelValue;\n   \t// 有参构造器\n\tprivate Level(int levelValue) {\n\t\tthis.levelValue = levelValue;\n\t}\n    // 获取枚举数据nam\n\tpublic int getLevelValue() {\n\t\treturn levelValue;\n\t}\n}\n\n\n\n# 接口实现\n\n枚举已经继承了Java.lang.Enum类，Java 不支持多继承，所以枚举对象不能再继承其他类\n\npublic interface Lshow(){\n    void show();\n}\npublic enum Level implements Lshow(){\n    \n    LOW(100){\n        public void show(){\n            ···\n        }\n    },\n    //注意：每个常量要有逗号分隔\n    URGENT(1){\n        public void show(){\n            ···\n        }\n    }\n    \n    private int levelValue;\n    private Level(int levelValue) {\n    \tthis.levelValue = levelValue;\n    }\n    public int getLevelValue() {\n    \treturn levelValue;\n    }\n}\n\n\n\n# 方法\n\n返回                            方法                                                说明\nint                           compareTo(<E> o)                                  获取 两个枚举常量比较的顺序\nint                           ordinal()                                         获取 枚举常量的索引位置\nClass<?>                      getDeclaringClass()                               获取 枚举常量的类型对应的Class对象\nString                        name()                                            获取 枚举常量的名称\nstatic<T extends Enum<T>> T   static valueOf(Class<T> enumType , String name)   获取 指定枚举类型的枚举常量\n\n注意：\n\n * 枚举属性不要试图修改（一般定义的都是常量）\n * 枚举类默认继承 java.lang.Enum类\n * 枚举类不能有子类，因枚举类默认被final修饰\n * 只能有private构造方法 switch中使用枚举时，直接使用常量名，不用携带类名\n * 不能定义name属性，因自带name属性\n\n\n# 代码实例\n\nclass Demo {\n    enum ELevel {\n        /**\n         * LOW : 最大 ； URGENT : 最小\n         */\n        LOW(100), URGENT(1);\n        \n        private int value;\n        ELevel(int value){\n            this.value = value;\n        }\n        public int getValue() {\n            return value;\n        }\n    }\n    \n    interface LLevel {\n        final int LOW = 100;\n        final int URGENT = 1;\n    }\n    \n    /**接口使用*/\n    public void showL(int l){\n        switch (l){\n            case LLevel.URGENT :\n                System.out.println("URGENT");\n                break;\n            case LLevel.LOW :\n                System.out.println("LOW");\n                break;\n            default:\n                System.out.println("错误");\n        }\n    }\n    \n    /**枚举使用*/\n    public void showE(ELevel e){\n        switch (e){\n            case URGENT:\n                System.out.println("URGENT");\n                break;\n            case LOW:\n                System.out.println("LOW");\n                break;\n            default:\n                System.out.println("错误");\n        }\n    }\n    \n    public static void main(String[] args) {\n        Demo d = new Demo();\n        d.showL(LLevel.URGENT);\n        d.showE(ELevel.LOW);\n        \n         System.out.println("ELevel.LOW.name() : " + ELevel.LOW.name());\n        System.out.println("ELevel.URGENT.ordinal() : " + ELevel.URGENT.ordinal());\n        System.out.println("Enum.valueOf(ELevel.class  , \\"URGENT\\") : " + \tEnum.valueOf(ELevel.class , "URGENT"));\n    }\n}\n',normalizedContent:'# 枚举\n\n> class enum<e extends enum <e> > java.lang.object java.lang.enum <e>\n\n枚举是一种特殊的数据类型，也是常量的集合，主要作用是限制指定内容\n\n特点：\n\n * 类型安全\n * 可以和程序其他部分完美交交互\n * 运行效率高\n\n\n# 枚举中的构造方法\n\n在枚举类型中添加构造方法前提该构造方法必须为private权限修饰符\n\npublic enum constants{//constants枚举名称\n    constants_a,\nconstants_b;\n    private string name;\n    private constants(string name){\n        name.this = name;\n    }\n}\n\n\n\n# 常量设置\n\n当定义枚举类型时，每个枚举类型的成员都可以看做实例，类型默认修饰为 final、public、static ，当使用时直接调用对应的名称即可\n\npublic enum level{//constants枚举名称\n\tlow(30) , medium(15) , high(7) , urgent(1);\n\t    \n\tprivate int levelvalue;\n   \t// 有参构造器\n\tprivate level(int levelvalue) {\n\t\tthis.levelvalue = levelvalue;\n\t}\n    // 获取枚举数据nam\n\tpublic int getlevelvalue() {\n\t\treturn levelvalue;\n\t}\n}\n\n\n\n# 接口实现\n\n枚举已经继承了java.lang.enum类，java 不支持多继承，所以枚举对象不能再继承其他类\n\npublic interface lshow(){\n    void show();\n}\npublic enum level implements lshow(){\n    \n    low(100){\n        public void show(){\n            ···\n        }\n    },\n    //注意：每个常量要有逗号分隔\n    urgent(1){\n        public void show(){\n            ···\n        }\n    }\n    \n    private int levelvalue;\n    private level(int levelvalue) {\n    \tthis.levelvalue = levelvalue;\n    }\n    public int getlevelvalue() {\n    \treturn levelvalue;\n    }\n}\n\n\n\n# 方法\n\n返回                            方法                                                说明\nint                           compareto(<e> o)                                  获取 两个枚举常量比较的顺序\nint                           ordinal()                                         获取 枚举常量的索引位置\nclass<?>                      getdeclaringclass()                               获取 枚举常量的类型对应的class对象\nstring                        name()                                            获取 枚举常量的名称\nstatic<t extends enum<t>> t   static valueof(class<t> enumtype , string name)   获取 指定枚举类型的枚举常量\n\n注意：\n\n * 枚举属性不要试图修改（一般定义的都是常量）\n * 枚举类默认继承 java.lang.enum类\n * 枚举类不能有子类，因枚举类默认被final修饰\n * 只能有private构造方法 switch中使用枚举时，直接使用常量名，不用携带类名\n * 不能定义name属性，因自带name属性\n\n\n# 代码实例\n\nclass demo {\n    enum elevel {\n        /**\n         * low : 最大 ； urgent : 最小\n         */\n        low(100), urgent(1);\n        \n        private int value;\n        elevel(int value){\n            this.value = value;\n        }\n        public int getvalue() {\n            return value;\n        }\n    }\n    \n    interface llevel {\n        final int low = 100;\n        final int urgent = 1;\n    }\n    \n    /**接口使用*/\n    public void showl(int l){\n        switch (l){\n            case llevel.urgent :\n                system.out.println("urgent");\n                break;\n            case llevel.low :\n                system.out.println("low");\n                break;\n            default:\n                system.out.println("错误");\n        }\n    }\n    \n    /**枚举使用*/\n    public void showe(elevel e){\n        switch (e){\n            case urgent:\n                system.out.println("urgent");\n                break;\n            case low:\n                system.out.println("low");\n                break;\n            default:\n                system.out.println("错误");\n        }\n    }\n    \n    public static void main(string[] args) {\n        demo d = new demo();\n        d.showl(llevel.urgent);\n        d.showe(elevel.low);\n        \n         system.out.println("elevel.low.name() : " + elevel.low.name());\n        system.out.println("elevel.urgent.ordinal() : " + elevel.urgent.ordinal());\n        system.out.println("enum.valueof(elevel.class  , \\"urgent\\") : " + \tenum.valueof(elevel.class , "urgent"));\n    }\n}\n',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Java异常",frontmatter:{title:"Java异常",date:"2020-02-18T00:00:00.000Z",permalink:"/backend/g25p48",categories:["后端","Java基础"],tags:["Java"],author:"柏竹"},regularPath:"/01.%E5%90%8E%E7%AB%AF/01.Java%E5%9F%BA%E7%A1%80/07.Swing%20%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1.html",relativePath:"01.后端/01.Java基础/07.Swing 程序设计.md",key:"v-22ffbd7d",path:"/backend/g25p48/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:16},{level:2,title:"Swing包",slug:"swing包",normalizedTitle:"swing包",charIndex:149},{level:2,title:"窗体",slug:"窗体",normalizedTitle:"窗体",charIndex:334},{level:3,title:"JFrame 窗体",slug:"jframe-窗体",normalizedTitle:"jframe 窗体",charIndex:974},{level:3,title:"JDialog 窗体",slug:"jdialog-窗体",normalizedTitle:"jdialog 窗体",charIndex:2647},{level:3,title:"窗体关闭规则",slug:"窗体关闭规则",normalizedTitle:"窗体关闭规则",charIndex:726},{level:2,title:"图标",slug:"图标",normalizedTitle:"图标",charIndex:4890},{level:3,title:"JLable 标签",slug:"jlable-标签",normalizedTitle:"jlable 标签",charIndex:4897},{level:3,title:"图标使用",slug:"图标使用",normalizedTitle:"图标使用",charIndex:7100},{level:2,title:"常用布局管理器",slug:"常用布局管理器",normalizedTitle:"常用布局管理器",charIndex:8711},{level:3,title:"绝对布局",slug:"绝对布局",normalizedTitle:"绝对布局",charIndex:8820},{level:3,title:"FlowLayout 流布局",slug:"flowlayout-流布局",normalizedTitle:"flowlayout 流布局",charIndex:9774},{level:3,title:"BorderLayout 边界布局",slug:"borderlayout-边界布局",normalizedTitle:"borderlayout 边界布局",charIndex:11172},{level:3,title:"GridLayout 网格布局",slug:"gridlayout-网格布局",normalizedTitle:"gridlayout 网格布局",charIndex:12613},{level:3,title:"GridBagLayout 网格组布局",slug:"gridbaglayout-网格组布局",normalizedTitle:"gridbaglayout 网格组布局",charIndex:13733},{level:4,title:"GridBagConstraints属性",slug:"gridbagconstraints属性",normalizedTitle:"gridbagconstraints属性",charIndex:14453},{level:2,title:"常用面板",slug:"常用面板",normalizedTitle:"常用面板",charIndex:28126},{level:3,title:"JPanel 面板",slug:"jpanel-面板",normalizedTitle:"jpanel 面板",charIndex:28135},{level:3,title:"JScrollPane 面板",slug:"jscrollpane-面板",normalizedTitle:"jscrollpane 面板",charIndex:30070},{level:2,title:"组件",slug:"组件",normalizedTitle:"组件",charIndex:79},{level:3,title:"按钮组件",slug:"按钮组件",normalizedTitle:"按钮组件",charIndex:9333},{level:4,title:"JButton 按钮",slug:"jbutton-按钮",normalizedTitle:"jbutton 按钮",charIndex:31585},{level:4,title:"JRadioButton 单选按钮",slug:"jradiobutton-单选按钮",normalizedTitle:"jradiobutton 单选按钮",charIndex:33569},{level:4,title:"JCheckBox 复选框",slug:"jcheckbox-复选框",normalizedTitle:"jcheckbox 复选框",charIndex:35809},{level:3,title:"列表组件",slug:"列表组件",normalizedTitle:"列表组件",charIndex:37672},{level:4,title:"JComboBox下拉列表框",slug:"jcombobox下拉列表框",normalizedTitle:"jcombobox下拉列表框",charIndex:37680},{level:4,title:"JList列表框",slug:"jlist列表框",normalizedTitle:"jlist列表框",charIndex:41182},{level:3,title:"文本组件",slug:"文本组件",normalizedTitle:"文本组件",charIndex:44096},{level:4,title:"JTextField文本框",slug:"jtextfield文本框",normalizedTitle:"jtextfield文本框",charIndex:44104},{level:4,title:"JPasswordField密码框",slug:"jpasswordfield密码框",normalizedTitle:"jpasswordfield密码框",charIndex:45987},{level:4,title:"JTextArea文本域",slug:"jtextarea文本域",normalizedTitle:"jtextarea文本域",charIndex:46564},{level:3,title:"事件监听器",slug:"事件监听器",normalizedTitle:"事件监听器",charIndex:48189},{level:4,title:"ActionEvent动作事件",slug:"actionevent动作事件",normalizedTitle:"actionevent动作事件",charIndex:48353},{level:4,title:"FocusEvent焦点事件监听器",slug:"focusevent焦点事件监听器",normalizedTitle:"focusevent焦点事件监听器",charIndex:51997}],headersStr:"概述 Swing包 窗体 JFrame 窗体 JDialog 窗体 窗体关闭规则 图标 JLable 标签 图标使用 常用布局管理器 绝对布局 FlowLayout 流布局 BorderLayout 边界布局 GridLayout 网格布局 GridBagLayout 网格组布局 GridBagConstraints属性 常用面板 JPanel 面板 JScrollPane 面板 组件 按钮组件 JButton 按钮 JRadioButton 单选按钮 JCheckBox 复选框 列表组件 JComboBox下拉列表框 JList列表框 文本组件 JTextField文本框 JPasswordField密码框 JTextArea文本域 事件监听器 ActionEvent动作事件 FocusEvent焦点事件监听器",content:'# Swing程序设计\n\n\n# 概述\n\nSwing为GUI(图形用户界面)提供开发工具包，使用Swing开发的应用程序可以统一应用程序在不同平台上运行的GUI组件显示风格，因为在Swing组件可以跨平台指定统一风格和外观\n\n> 特点：\n> \n>  * 轻量级组件\n>  * 可插入外观组件\n\n\n# Swing包\n\n使用Swing组件前，先了解层次结构和继承关系\n\n常用的Swing组件\n\n组件名称                  说明\nJButton（按钮）           按钮可以带些图片或文字\nJCheckBox（多选按钮）       复选框组件\nJComboBox（下拉框）        代表下拉列表框，可以在下拉显示区域显示多个选项\nJFrame（窗体）            Swing的框架类\nJDialog（对话框）          Swing版本的对话框\nJLable（标签）            标签组件（显示文字的容器）\nJRadioButton（单选按钮）    Swing的单选按钮\nJList（列表框）            显示一系列条目的组件\nJTextField（文本框）       文本框\nJPasswordField（密码框）   密码框\nJTextArea（文本域）        Swing的文本区域\nJOptionPane（小对话框）     对话框\nJPanel（面板）            单纯的容器，无属性\n\n\n# 窗体\n\n窗体常用方法\n\nsetTitle（String title）  窗体标题为title字符串\n\nsetDefaultCloseOperation（int a）  窗体关闭规则\n\nsetSize（width,height） 窗体大小\n\nsetLocation（x，y） 窗体坐标\n\nsetBounds（x，y, width , height） 窗体坐标，大小 （像素）\n\nsetVisible（boolean b） 窗体是否显示，默认不可见（false）\n\nsetResizable（boolean b） 窗体是否可以调整大小，默认可以调整大小\n\nsetContentPane（容器）  重新加载容器\n\ngetContentPane（） 获取窗体容器\n\n\n# JFrame 窗体\n\n> Class JFrame\n> \n> java.lang.Object java.awt.Component java.awt.Container java.awt.Window java.awt.Frame javax.swing.JFrame\n\nJFrame窗体拥有计算机基本组件，最大化，最小化，关闭等组件\n\n构造方法\n\nJFrame（）\n\nJFrame（Starting title）\n\n> **title：**窗体标题\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class Demo {\n    public static void main(String[] args) {\n        //123为标题\n        JFrame f = new JFrame("123");\n        //窗体显示\n        f.setVisible(true);\n        \n        //窗口关闭规则\n        f.setDefaultCloseOperation(3);\n//        f.setSize(330,220);//大小\n//        f.setLocation(202,202);//坐标\n        //坐标，大小 （x , y , width , height）单位：像素\n        f.setBounds(200,200 , 300,300);\n    \n        //获取窗体容器\n        Container c = f.getContentPane();\n        //背景颜色\n        c.setBackground(Color.CYAN);\n        //标签内容\n        JLabel l = new JLabel("这是一个窗体！！");\n        //添加组件\n        c.add(l);\n        \n    }\n}\n\n\n也可以\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class Demo2 extends JFrame {\n    \n    public Demo2(){\n        //窗体显示\n        setVisible(true);\n    \n        //窗口关闭规则\n        setDefaultCloseOperation(3);\n//        f.setSize(330,220);//大小\n//        f.setLocation(202,202);//坐标\n        //坐标，大小 （x , y , width , height）单位：像素\n        setBounds(200,200 , 300,300);\n    \n        //获取窗体容器\n        Container c = getContentPane();\n        //背景颜色\n        c.setBackground(Color.CYAN);\n        //标签内容\n        JLabel l = new JLabel("这是一个窗体！！");\n        //添加组件\n        c.add(l);\n        //删除组件\n        c.remove(l);\n        //验证容器中的组件\n        c.validate();\n        //重新载入容器\n        setContentPane(c);\n    }\n    \n    \n    public static void main(String[] args) {\n        new Demo2();\n    }\n}\n\n\n运行结果\n\n\n# JDialog 窗体\n\n> Class JDialog\n> \n> java.lang.Object java.awt.Component java.awt.Container java.awt.Window java.awt.Dialog javax.swing.JDialog\n\nJDialog窗体是Swing的对话框，是从一个窗体中弹出另一个窗体，它继承了AWT组件中的\n\n在一个类继承窗体类时，可以在构造方法中使用 super关键字 可调用回窗体类的参数填充\n\n构造方法\n\nJDialog（）\n\nJDialog（Frame f）\n\nJDialog（Frame f , boolean model）\n\nJDialog（Frame f , String title）\n\nJDialog（Frame f , String title , boolean model）\n\n> **f：**需要指定的父窗体 **model：**指定类型的对话框（是否约束父窗体） **title：**对话框的标题\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.*;\n\n//JFrame父窗体类\nclass Parentform extends JFrame {\n    \n    JButton btn;\n    public Parentform(){\n        //为父类添加标题\n        super("JFrame父窗体的标题");\n        //窗体关闭规则\n        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //窗体显示\n        setVisible(true);\n        //窗体坐标，大小\n        setBounds(300,230,400,340);\n        //获取窗体容器\n        Container c = getContentPane();\n        //布局设置，使用流布局\n        c.setLayout(new FlowLayout());\n        //使类的btn共享到以下类输出\n        this.btn = new JButton("对话框");\n        //添加组件\n        c.add(btn);\n    }\n    public JButton btn(){\n        //输出组件添加动作监听\n        return btn;\n    }\n}\n\n//对话框类\nclass Dialog extends JDialog{\n    public Dialog(Parentform p){\n        //参数顺序： 1.父窗体对象 ， 2.对话框标题 ，3.是否堵塞父窗体\n        super(p,"123对话框",true);\n        //获取对话框容器\n        Container c = getContentPane();\n        //对话框添加标签（内容）\n        c.add(new JLabel("这是对话框！"));\n        //对话框坐标，大小\n        setBounds(360,300,120,100);\n    }\n}\n\npublic class Demo {\n    public static void main(String[] args) {\n        //实例JFrame父窗体类\n        Parentform p = new Parentform();\n        \n        //添加动作监听\n        p.btn().addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                //实例对话框类，并获取p父窗体对象\n                Dialog d = new Dialog(p);\n                //显示对话框\n                d.setVisible(true);\n            }\n        });\n        //也可以  p.btn().addActionListener(e -> new Dialog());\n    }\n}\n\n\n运行结果\n\n\n# 窗体关闭规则\n\n窗体的关闭规则是需要到 setDefaultCloseOperation（）方法来选择关闭方式的\n\n关闭类型                  说明           定义\nDO_NOTHING_ON_CLOSE   无任何操作        0\nHIDE_ON_CLOSE（默认）     隐藏窗体，不停止程序   1\nDISPOSE_ON_CLOSE      释放窗体资源       2\nEXIT_ON_CLOSE         隐藏窗体，停止程序    3\n\n\n# 图标\n\n\n# JLable 标签\n\n> Class JLabel\n> \n> java.lang.Object java.awt.Component java.awt.Container javax.swing.JComponent javax.swing.JLabel\n\n可以显示只读文本、图像，但不能产生任何类型的事件，只是简单的显示文本和图像，还可以设置标签上文本的对齐方式\n\n构造方法\n\nJLable（） \n\nJLable（String text）\n\nJLable（Icon icon）\n\nJLable（Icon icon , int aligment）  \n\nJLable（String text , int aligment）\n\nJLable（String text , Icon icon , int aligment）\n\n> **text：**标识性，文字标签 **icon：**图标对象 **aligment：**设置对齐方式\n\n常用方法\n\n修饰符、类型   方法                              说明\nvoid     setText（String text）            定义组件内容（更改）\nString   getText（）                       返回标签显示的文本字符串\nvoid     setIcon（Icon icon）              添加图片文件\nvoid     setSize（int With ，int Height）   标签大小设置\n\n￼构造方法的实践例子：（图片文件在src路径里）\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.net.URL;\n\n//JFrame父窗体类\nclass Parentform extends JFrame {\n\n    public Parentform(){\n        //为父类添加标题\n        super("JFrame父窗体的标题");\n        //窗体关闭规则\n        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //窗体坐标，大小\n        setBounds(200,0,620,800);\n        //获取窗体容器\n        Container c = getContentPane();\n        //布局设置，使用流布局\n        c.setLayout(new FlowLayout());\n        \n        \n        JLabel no1 = new JLabel();\n        JLabel no2 = new JLabel("标签内容");\n        \n        //获取图片的方法（方法1）\n        //获取当前类所在的路径\n        URL url = Demo.class.getResource("1.jpg");\n        //获取相应路径下的文件（图片）\n        Icon icon = new ImageIcon(url);\n        JLabel no3 = new JLabel(icon);\n        \n        //获取图片的（方法2）\n        Icon icon2 = new ImageIcon("src/1.jpg");\n        JLabel no4 = new JLabel("显示图片",icon2, SwingConstants.LEFT);\n        \n        //更改标签内容\n        no2.setText("更改标签内容");\n        //获取标签内容\n        System.out.println(no2.getText());\n    \n        //在窗体显示图片路径\n        JLabel jl = new JLabel("获取图片路径："+url.toString());\n        c.add(jl);\n        \n        //自选打开\n//        c.add(no1);\n//        c.add(no2);\n//        c.add(no3);\n        c.add(no4);\n        \n        //显示在后面或者刷新组件\n        //容器组件重新验证\n        c.validate();\n        //窗体显示\n        setVisible(true);\n    }\n}\n\npublic class Demo {\n    public static void main(String[] args) {\n        new Parentform();\n    }\n}\n\n\n运行结果\n\n> 注意：\n> \n> java.lang.Class类中的 getResource（）方法 可以获取资源文件的URL路径\n\n\n# 图标使用\n\n创建图标\n\n创建图标使用到 java.awt.Graphics类 提供的功能来实现\n\n在Swing中是通过Icon接口来实现创建图标，使用Icon接口必须实现以下3个方法：\n\n修饰符、类型   方法                                                 说明\nint      getIconHeight（）                                    获取图标高\nint      getIconWidth（）                                     获取图标宽\nvoid     paintIcon（Component c, Graphics g, int x, int y）   指定坐标位置画图\n\nimport javax.swing.*;\nimport java.awt.*;\n\n//JFrame父窗体类\nclass Parentform extends JFrame {\n    \n    public Parentform(){\n        //为父类添加标题\n        super("JFrame父窗体的标题");\n        //窗体关闭规则\n        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //窗体显示\n        setVisible(true);\n        //窗体坐标，大小\n        setBounds(300,230,300,200);\n        //获取窗体容器\n        Container c = getContentPane();\n    }\n\n}\n\n//绘图图标类\n//引入Icon接口\nclass DrawIcon implements Icon{\n    // 声明图标的宽\n    private int W;\n    // 声明图标的高\n    private int H;\n    \n    //获取数据\n    public DrawIcon(int W , int H){\n        this.W = W ;\n        this.H = H ;\n    }\n    \n    // 实现paintIcon()方法\n    @Override\n    public void paintIcon(Component c, Graphics g, int x, int y) {\n        // 绘制一个圆形\n        g.fillOval(x , y , W , H);\n    }\n    \n    @Override\n    public int getIconWidth() {\n        return this.W;\n    }\n    \n    @Override\n    public int getIconHeight() {\n        return this.H;\n    }\n}\n\npublic class Demo {\n    public static void main(String[] args) {\n        DrawIcon icon = new DrawIcon(23, 23);\n        // 创建一个标签，并设置标签上的文字在标签正中间\n        JLabel j = new JLabel("测试", icon, SwingConstants.CENTER);\n        Parentform jf = new Parentform();\n        jf.add(j);\n    }\n}\n\n\n运行结果\n\n\n# 常用布局管理器\n\n布局管理就是用于指定组件的摆放位置的。每种布局管理器都有自己的摆放风格。管理组件在容器中的位置和大小\n\n需要该方法来定义窗体或面板布局\n\n窗体或面板的对象.setLayout(布局类型);\n\n\n\n# 绝对布局\n\n绝对布局是指定组件在容器中的固定大小和位置\n\nimport javax.swing.*;\nimport java.awt.*;\n\n//JFrame父窗体类\nclass Parentform extends JFrame {\n    \n    public Parentform(){\n        //为父类添加标题\n        super("JFrame父窗体的标题");\n        //窗体关闭规则\n        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //窗体显示\n        setVisible(true);\n        //窗体坐标，大小\n        setBounds(300,230,300,200);\n        //获取窗体容器\n        Container c = getContentPane();\n        \n        //取消默认布局 ， 更改为绝对布局\n        setLayout(null);\n        \n        //创建按钮组件\n        JButton b1 = new JButton("按钮1") , b2 = new JButton("按钮2");\n        \n        //给按钮组件添加坐标、大小\n        b1.setBounds(10,10,70,40);\n        b2.setBounds(112,64,92,60);\n        \n        //添加按钮组件\n        c.add(b1);\n        c.add(b2);\n    }\n    \n}\n\npublic class Demo {\n    public static void main(String[] args) {\n        Parentform jf = new Parentform();\n    }\n}\n\n\n运行结果\n\n> 注意：\n> \n> 绝对布局的窗口组件大小都是固定的，不随窗体大小更改而变化\n> \n> 组件坐标是以窗体左上角为基点的\n\n\n# FlowLayout 流布局\n\n> Class FlowLayout\n> \n> java.lang.Object java.awt.FlowLayout\n\n流布局管理器 ，像流水一样从左到右摆放组件，直到占完所有空间，组件是默认居中排列\n\n构造方法\n\nFlowLayout（） \n\nFlowLayout（int alignment）\n\nFlowLayout（int alignment , int horizGap , int vertGap）  \n\n> **alignment：**摆放方式 **horizGap：**组件之间的水平间距 **vertGap：**组件之间的垂直间距\n\nALIGNMENT参数的摆放设置    说明      定义\nFlowLayout.LEFT     左对齐排列   0\nFlowLayout.CENTER   居中排列    1\nFlowLayout.RIGHT    右对齐排列   2\n\nhorizGap ： 组件与组件之间的水平间距（像素）\n\nvertGap ： 组件与组件之间的垂直间距（像素）\n\nimport javax.swing.*;\nimport java.awt.*;\n\n//JFrame父窗体类\nclass Parentform extends JFrame {\n    \n    public Parentform(){\n        //为父类添加标题\n        super("JFrame父窗体的标题");\n        //窗体关闭规则\n        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //窗体坐标，大小\n        setBounds(300,230,300,200);\n        //获取窗体容器\n        Container c = getContentPane();\n        \n        //流布局\n        //参数测试，自行选择\n//        setLayout(new FlowLayout());\n//        setLayout(new FlowLayout(0));//左对齐\n//        setLayout(new FlowLayout(1));//居中对齐（默认）\n//        setLayout(new FlowLayout(2));//右对齐\n        setLayout(new FlowLayout(1 , 20, 20));//居中对齐（默认）\n        \n        //创建添加按钮组件\n        for (int i = 0; i < 10; i++) {\n            c.add(new JButton("按钮"+i));\n        }\n        \n        //窗体显示\n        setVisible(true);\n    }\n}\n\npublic class Demo {\n    public static void main(String[] args) {\n        new Parentform();\n    }\n}\n\n\n运行结果\n\n\n# BorderLayout 边界布局\n\n> Class BorderLayout\n> \n> java.lang.Object java.awt.BorderLayout\n\n边界布局把容器的的布局分为五个位置：上下左右中5个区域 。设置该布局管理器是可无视，因默认是边界布局\n\n在容器add（）方法添加组件时可设置区域\n\n成员变量                  说明\nBorderLayout.NORTH    顶端\nBorderLayout.SOUTH    底端\nBorderLayout.EAST     右端\nBorderLayout.WEST     左端\nBorderLayout.CENTER   中间\n\nimport javax.swing.*;\nimport java.awt.*;\n\n//JFrame父窗体类\nclass Parentform extends JFrame {\n    \n    public Parentform(){\n        //为父类添加标题\n        super("JFrame父窗体的标题");\n        //窗体关闭规则\n        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //窗体坐标，大小\n        setBounds(300,230,300,200);\n        //获取窗体容器\n        Container c = getContentPane();\n        \n        //设置边界布局\n        c.setLayout(new BorderLayout());//可被注释，因本身就是边界布局\n        \n        //边界布局\n        JButton\n                b1 = new JButton("中"),\n                b2 = new JButton("东"),\n                b3 = new JButton("南"),\n                b4 = new JButton("西"),\n                b5 = new JButton("北");\n                \n        c.add(b1 , BorderLayout.CENTER);\n        c.add(b2 , BorderLayout.EAST);\n        c.add(b3 , BorderLayout.SOUTH);\n        c.add(b4 , BorderLayout.WEST);\n        c.add(b5 , BorderLayout.NORTH);\n    \n        c.add(new JButton("覆盖中") , BorderLayout.CENTER);\n        \n        //窗体显示\n        setVisible(true);\n    }\n    \n}\n\npublic class Demo {\n    public static void main(String[] args) {\n        new Parentform();\n    }\n}\n\n\n运行结果\n\n\n# GridLayout 网格布局\n\n> Class GridLayout\n> \n> java.lang.Object java.awt.GridLayout\n\n网格布局管理器是将容器划分为网格，组件是按照 行 和 列 进行布局\n\n每个组件大小一样，排序默认从左到右，从上到下的顺序排列，窗体大小的改变，组件也会跟随改变\n\n构造方法\n\nGridLayout（int rows , int columns）\n\nGridLayout（int rows , int columns , int horizGap , int veritGap）\n\n> rows： 行个数 columns：列个数 horizGap：组件水平间距 veritGap：组件垂直间距\n\nimport javax.swing.*;\nimport java.awt.*;\n\n//JFrame父窗体类\nclass Parentform extends JFrame {\n    \n    public Parentform(){\n        //为父类添加标题\n        super("JFrame父窗体的标题");\n        //窗体关闭规则\n        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //窗体坐标，大小\n        setBounds(300,230,300,200);\n        //获取窗体容器\n        Container c = getContentPane();\n        \n        //设置\n//        c.setLayout(new GridLayout(3,4));//3行4列（布局满无间隙）\n        //3行4列，组件间隙为12px（行数，列数，水平，垂直）\n        c.setLayout(new GridLayout(3,4,12,12));\n    \n        for (int i = 0; i < 20; i++) {\n            c.add(new JButton("按钮"+i));\n        }\n        \n        //窗体显示\n        setVisible(true);\n    }\n    \n}\n\npublic class Demo {\n    public static void main(String[] args) {\n        new Parentform();\n    }\n}\n\n\n运行结果\n\n\n# GridBagLayout 网格组布局\n\n> Class GridBagLayout\n> \n> java.lang.Object java.awt.GridBagLayout\n\n实现了动态矩形网格，由无限个矩形单元格组成，每行每列的高宽以行列最大像素的组件为准，每个组件都与GridBagConstraints类关联（用来约束）\n\n以下是使用流程：\n\nimport java.awt.GridBagConstraints类 为使用 GridBagLayou类布局 的约束\n\n> Class GridBagConstraints\n> \n> java.lang.Object java.awt.GridBagConstraints\n\nGridBagConstraints约束\n\nGRIDBAGCONSTRAINTS属性   说明\ngridx                  组件坐标X（网格）\ngridy                  组件坐标Y（网格）\ngridwidth              组件占用行数\ngridheight             组件占用列数\nanchor                 组件在的方位\nfill                   组件填充方式\ninsets                 组件与单元格边缘的最小距离\nipadx                  组件的首先大小 X\nipady                  组件的首先大小 Y\nweightx                单元格最大宽\nweighty                单元格最大高\n\n以下代码是自选GridBagConstraints属性约束测试\n\nimport javax.swing.*;\nimport java.awt.*;\n\n//JFrame父窗体类\nclass Parentform extends JFrame {\n    \n    //添加彩色面板\n    JPanel p1 = new JPanel();\n    JPanel p2 = new JPanel();\n    JPanel p3 = new JPanel();\n    JPanel p4 = new JPanel();\n    JPanel p5 = new JPanel();\n    \n    Container c;\n    public Parentform(){\n        //为父类添加标题\n        super("JFrame父窗体的标题");\n        //窗体关闭规则\n        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //窗体坐标，大小\n        setBounds(300,230,800,550);\n        this.c = getContentPane();\n        \n        //颜色面板\n        this.p1.setBackground(Color.CYAN);\n        this.p2.setBackground(Color.GREEN);\n        this.p3.setBackground(Color.CYAN);\n        this.p4.setBackground(Color.GREEN);\n        this.p5.setBackground(Color.CYAN);\n    }\n    \n    //坐标矩阵\n    public void init(){\n        \n        for (int i = 0; i < 10; i++) {\n            GridBagConstraints g = new GridBagConstraints();\n            GridBagConstraints g2 = new GridBagConstraints();\n            g.gridx = i;\n            g.gridy = 0;\n            g2.gridx = 0;\n            g2.gridy = i;\n            //空格用来填充\n            c.add(new JButton("   " + i + "    "),g);\n            c.add(new JButton("   " + i + "    "),g2);\n        }\n        \n    }\n    \n}\n\n//组件约束类\nclass Components {\n    \n    //颜色面板调用约束方法\n    public GridBagConstraints JPl1() {\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        g.gridx = 1;\n        g.gridy = 1;\n        g.gridwidth = 2;\n        g.gridheight = 2;\n        g.fill = GridBagConstraints.BOTH;\n        return g;\n    }\n    public GridBagConstraints JPl2() {\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        g.gridx = 3;\n        g.gridy = 1;\n        g.gridwidth = 2;\n        g.gridheight = 2;\n        g.fill = GridBagConstraints.BOTH;\n        return g;\n    }\n    public GridBagConstraints JPl3() {\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        g.gridx = 5;\n        g.gridy = 1;\n        g.gridwidth = 2;\n        g.gridheight = 2;\n        g.fill = GridBagConstraints.BOTH;\n        return g;\n    }\n    public GridBagConstraints JPl4() {\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        g.gridx = 7;\n        g.gridy = 1;\n        g.gridwidth = 2;\n        g.gridheight = 2;\n        g.fill = GridBagConstraints.BOTH;\n        return g;\n    }\n    //weightx ，weighty属性（专属颜色面板）\n    public GridBagConstraints JPl5() {\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        g.gridx = 2;\n        g.gridy = 2;\n        g.fill = GridBagConstraints.BOTH;\n        return g;\n    }\n    public GridBagConstraints JPl6() {\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        g.gridx = 4;\n        g.gridy = 2;\n        g.fill = GridBagConstraints.BOTH;\n        return g;\n    }\n    public GridBagConstraints JPl7() {\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        g.gridx = 6;\n        g.gridy = 2;\n        g.fill = GridBagConstraints.BOTH;\n        return g;\n    }\n    public GridBagConstraints JPl8() {\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        g.gridx = 2;\n        g.gridy = 4;\n        g.fill = GridBagConstraints.BOTH;\n        return g;\n    }\n    public GridBagConstraints JPl9() {\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        g.gridx = 2;\n        g.gridy = 6;\n        g.fill = GridBagConstraints.BOTH;\n        return g;\n    }\n    \n    \n    //组件约束方法\n    \n    //GridBagConstraints约束测试（1）\n    //gridx和gridy属性\n    public GridBagConstraints GBC1() {\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        //设置组件坐标位置\n        g.gridx = 1;\n        g.gridy = 1;\n        return g;\n    }\n    public GridBagConstraints GBC2() {\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        //设置组件坐标位置\n        g.gridx = 2;\n        g.gridy = 2;\n        return g;\n    }\n    public GridBagConstraints GBC3() {\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        //设置组件坐标位置\n        g.gridx = 3;\n        g.gridy = 3;\n        return g;\n    }\n    \n    \n    //GridBagConstraints约束测试（2）\n    //gridwidth和gridheight属性\n    public GridBagConstraints GBC4(){\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        //设置组件坐标位置\n        g.gridx = 1;\n        g.gridy = 1;\n        g.gridwidth = 1;\n        g.gridheight = 1;\n        return g;\n    }\n    public GridBagConstraints GBC5(){\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        //设置组件坐标位置\n        g.gridx = 3;\n        g.gridy = 1;\n        g.gridwidth = 2;\n        g.gridheight = 2;\n        return g;\n    }\n    public GridBagConstraints GBC6(){\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        //设置组件坐标位置\n        g.gridx = 5;\n        g.gridy = 1;\n        g.gridwidth = 2;\n        g.gridheight = 1;\n        return g;\n    }\n    \n    \n    //GridBagConstraints约束测试（3）\n    //fill属性\n    public GridBagConstraints GBC7(){\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        //设置组件坐标位置\n        g.gridx = 1;\n        g.gridy = 1;\n        g.gridwidth = 2;\n        g.gridheight = 2;\n        //默认无填充NONE\n        g.fill = GridBagConstraints.NONE; //(0)\n        return g;\n    }\n    public GridBagConstraints GBC8(){\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        //设置组件坐标位置\n        g.gridx = 3;\n        g.gridy = 1;\n        g.gridwidth = 2;\n        g.gridheight = 2;\n        //水平填充HORIZONTAL\n        g.fill = GridBagConstraints.HORIZONTAL; //(2)\n        return g;\n    }\n    public GridBagConstraints GBC9(){\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        //设置组件坐标位置\n        g.gridx = 5;\n        g.gridy = 1;\n        g.gridwidth = 2;\n        g.gridheight = 2;\n        //垂直填充VERTICAL\n        g.fill = GridBagConstraints.VERTICAL; //(3)\n        return g;\n    }\n    public GridBagConstraints GBC10(){\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        //设置组件坐标位置\n        g.gridx = 7;\n        g.gridy = 1;\n        g.gridwidth = 2;\n        g.gridheight = 2;\n        //填充BOTH\n        g.fill = GridBagConstraints.BOTH; //(1)\n        return g;\n    }\n    \n    \n    //GridBagConstraints约束测试（4）\n    //anchor属性\n    public GridBagConstraints GBC11(){\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        //设置组件坐标位置\n        g.gridx = 1;\n        g.gridy = 1;\n        g.gridwidth = 2;\n        g.gridheight = 2;\n        //左上\n        g.anchor = GridBagConstraints.NORTHWEST;\n        return g;\n    }\n    public GridBagConstraints GBC12(){\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        //设置组件坐标位置\n        g.gridx = 3;\n        g.gridy = 1;\n        g.gridwidth = 2;\n        g.gridheight = 2;\n        //右下\n        g.anchor = GridBagConstraints.SOUTHEAST;\n        return g;\n    }\n    public GridBagConstraints GBC13(){\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        //设置组件坐标位置\n        g.gridx = 5;\n        g.gridy = 1;\n        g.gridwidth = 2;\n        g.gridheight = 2;\n        //右\n        g.anchor = GridBagConstraints.EAST;\n        return g;\n    }\n    public GridBagConstraints GBC14(){\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        //设置组件坐标位置\n        g.gridx = 7;\n        g.gridy = 1;\n        g.gridwidth = 2;\n        g.gridheight = 2;\n        //下\n        g.anchor = GridBagConstraints.SOUTH; //(1)\n        return g;\n    }\n    \n    \n    //GridBagConstraints约束测试（5）\n    //insets属性\n    public GridBagConstraints GBC15(){\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        //设置组件坐标位置\n        g.gridx = 1;\n        g.gridy = 1;\n        //设置边距距离\n        g.insets = new Insets(5,5,5,5);\n        return g;\n    }\n    public GridBagConstraints GBC16(){\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        //设置组件坐标位置\n        g.gridx = 2;\n        g.gridy = 2;\n        //设置边距距离\n        g.insets = new Insets(12,12,12,12);\n        return g;\n    }\n    \n    \n    //GridBagConstraints约束测试（6）\n    //ipadx , ipady 属性\n    public GridBagConstraints GBC17(){\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        //设置组件坐标位置\n        g.gridx = 1;\n        g.gridy = 1;\n        //设置组件大小\n        g.ipadx = 10;\n        g.ipady = 10;\n        return g;\n    }\n    public GridBagConstraints GBC18(){\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        //设置组件坐标位置\n        g.gridx = 3;\n        g.gridy = 1;\n        //设置组件大小\n        g.ipadx = -10;\n        g.ipady = -10;\n        return g;\n    }\n    \n    \n    //GridBagConstraints约束测试（6）\n    //weightx , weighty 属性\n    public GridBagConstraints GBC19(){\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        //设置组件坐标位置\n        g.gridx = 2;\n        g.gridy = 2;\n        //设置单元格最大宽高\n        g.weightx = 10;\n        g.weighty = 10;\n        return g;\n    }\n    public GridBagConstraints GBC20(){\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        //设置组件坐标位置\n        g.gridx = 4;\n        g.gridy = 2;\n        //设置单元格最大宽高\n        g.weightx = 5;\n        g.weighty = 1;\n        return g;\n    }\n    public GridBagConstraints GBC21(){\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        //设置组件坐标位置\n        g.gridx = 6;\n        g.gridy = 2;\n        //设置单元格最大宽高\n        g.weightx = 2;\n        g.weighty = 1;\n        return g;\n    }\n    public GridBagConstraints GBC22(){\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        //设置组件坐标位置\n        g.gridx = 2;\n        g.gridy = 4;\n        //设置单元格最大宽高\n        g.weightx = 1;\n        g.weighty = 5;\n        return g;\n    }\n    public GridBagConstraints GBC23(){\n        //实例化约束条件\n        GridBagConstraints g = new GridBagConstraints();\n        //设置组件坐标位置\n        g.gridx = 2;\n        g.gridy = 6;\n        //设置单元格最大宽高\n        g.weightx = 2;\n        g.weighty = 2;\n        return g;\n    }\n    \n}\n\npublic class Demo {\n    public static void main(String[] args) {\n        //实例化JFrame窗体类\n        Parentform jf = new Parentform();\n        //实例化组件约束类\n        Components zj = new Components();\n        \n        //创建jf窗体容器\n        Container c = jf.getContentPane();\n        //设置容器布局为网格组布局\n        c.setLayout(new GridBagLayout());\n        \n        //坐标矩阵\n        jf.init();\n        \n        //自选约束测试\n        \n        //约束测试（1）\n        //添加组件 和 组件约束\n        //gridx和gridy属性\n        c.add(new JButton("按钮1") , zj.GBC1());\n        c.add(new JButton("按钮2") , zj.GBC2());\n        c.add(new JButton("按钮3") , zj.GBC3());\n    \n        \n        //约束测试（2）\n        //gridwidth和gridheight属性\n//        c.add(new JButton("按钮1") , zj.GBC4());\n//        c.add(new JButton("按钮2") , zj.GBC5());\n//        c.add(new JButton("按钮3") , zj.GBC6());\n//        //添加颜色面板\n//        c.add(jf.p1,zj.JPl1());\n//        c.add(jf.p2,zj.JPl2());\n//        c.add(jf.p3,zj.JPl3());\n    \n        \n        //约束测试（3）\n        //fill属性\n//        c.add(new JButton("按钮1") , zj.GBC7());\n//        c.add(new JButton("按钮2") , zj.GBC8());\n//        c.add(new JButton("按钮3") , zj.GBC9());\n//        c.add(new JButton("按钮3") , zj.GBC10());\n    \n        \n        //约束测试（4）\n        //anchor属性\n//        c.add(new JButton("按钮1") , zj.GBC11());\n//        c.add(new JButton("按钮2") , zj.GBC12());\n//        c.add(new JButton("按钮3") , zj.GBC13());\n//        c.add(new JButton("按钮3") , zj.GBC14());\n//        //添加颜色面板\n//        c.add(jf.p1,zj.JPl1());\n//        c.add(jf.p2,zj.JPl2());\n//        c.add(jf.p3,zj.JPl3());\n//        c.add(jf.p4,zj.JPl4());\n    \n        \n        //约束测试（5）\n        //inset属性\n//        c.add(new JButton("按钮1") , zj.GBC15());\n//        c.add(new JButton("按钮2") , zj.GBC16());\n    \n        \n        //约束测试（6）\n        //ipadx , ipady 属性\n//        c.add(new JButton("按钮1") , zj.GBC17());\n//        c.add(new JButton("按钮2") , zj.GBC18());\n//        //添加颜色面板\n//        c.add(jf.p1,zj.JPl1());\n//        c.add(jf.p2,zj.JPl2());\n    \n    \n        //约束测试（7）\n        //weightx , weighty 属性\n//        c.add(new JButton("x,y:10") , zj.GBC19());\n//        c.add(new JButton("x :５") , zj.GBC20());\n//        c.add(new JButton("x : 2") , zj.GBC21());\n//        c.add(new JButton("y : 5") , zj.GBC22());\n//        c.add(new JButton("y : 2") , zj.GBC23());\n//        //添加颜色面板\n//        c.add(jf.p1,zj.JPl5());\n//        c.add(jf.p2,zj.JPl6());\n//        c.add(jf.p3,zj.JPl7());\n//        c.add(jf.p4,zj.JPl8());\n//        c.add(jf.p5,zj.JPl9());\n\n        //窗体显示\n        jf.setVisible(true);\n    }\n}\n\n\n# GridBagConstraints属性\n\ngridx , gridy属性\n\n该属性用来设置组件起始点所在单元格的索引位置，gridx设置X轴的索引值，gridy设置Y轴的索引值\n\n该属性的运行结果：\n\ngridwidth , gridheight属性\n\n该属性用来设置组件占用网格组的行数和行数\n\n该属性的运行结果：\n\nfill属性\n\n该属性用来设置组件填充方式，填充单元格最大的范围\n\nFILL属性的静态常量   说明        定义数\nNONE          不填充（默认）   0\nHORIZONTAL    水平填充      2\nVERTICAL      垂直填充      3\nBOTH          填满        1\n\n该属性的运行结果：\n\nanchor属性\n\n该属性用来设置组件在单元格的显示区域\n\nANCHOR属性的静态常量   说明\nNORTHWEST       左上\nNORTH           上\nNORTHEAST       右上\nWEST            左\nCENTER          中\nEAST            右\nSOUTHWEST       左下\nSOUTH           下\nSOUTHEAST       右下\n\n该属性的运行结果：\n\ninset属性\n\n该属性用来设置组件四周与单元格边缘之间的最小距离\n\nInsets类 仅限于一个构造方法Insets（int top , int left , int bottom , int right），上左下右来设置边缘距离，默认为没有距离\n\n该属性的运行结果：\n\nipadx , ipady 属性\n\n该属性用来修改组件的大小，ipadx修改组件宽度，ipady修改组件的高度，正数为加大，负数为缩小\n\n该属性的运行结果：\n\nweightx , weighty 属性\n\n该属性用来设置网格组的每一行和每一列对额外空间的分布方式，分配是以百分比形式分配！！\n\n该属性的运行结果：\n\n\n# 常用面板\n\n\n# JPanel 面板\n\n> Class JPanel\n> \n> java.lang.Object java.awt.Component java.awt.Container javax.swing.JComponent javax.swing.JPanel\n\nJPanel面板可聚集一些组件进行布局，JPanel面板也是容器，因继承 java.awt.Container类\n\nimport javax.swing.*;\nimport java.awt.*;\n\n//JFrame父窗体类\nclass Parentform extends JFrame {\n    \n    public Parentform(){\n        //为父类添加标题\n        super("JFrame父窗体的标题");\n        //窗体关闭规则\n        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //窗体坐标，大小\n        setBounds(300,230,800,550);\n        //获取窗体容器\n        Container c = getContentPane();\n        //窗体设置网格布局行2，列2，水平间距10px，垂直间距10px\n        setLayout(new GridLayout(2,2,10,10));\n        \n        //该面板可视为容器使用\n        JPanel p1 = new JPanel();\n        JPanel p2 = new JPanel();\n        JPanel p3 = new JPanel();\n        JPanel p4 = new JPanel();\n        \n        //为添加面板边框\n        p1.setBorder(BorderFactory.createTitledBorder("面板1"));\n        p2.setBorder(BorderFactory.createTitledBorder("面板2"));\n        p3.setBorder(BorderFactory.createTitledBorder("面板3"));\n        p4.setBorder(BorderFactory.createTitledBorder("面板4"));\n        \n        \n        //面板1 添加标签并居中\n        p1.add(new JLabel("容器测试"),BorderLayout.CENTER);\n        //面板2 添加按钮\n        p2.setLayout(new FlowLayout());//流布局\n        p2.add(new JButton("按钮1"));\n        p2.add(new JButton("按钮2"));\n        p2.add(new JButton("按钮3"));\n        p2.add(new JButton("按钮4"));\n        \n        p3.setLayout(new GridLayout(1,4 , 10,10));\n        p3.add(new JButton("按钮1"));\n        p3.add(new JButton("按钮2"));\n        p3.add(new JButton("按钮3"));\n        p3.add(new JButton("按钮4"));\n        \n        p4.add(new JLabel("面板4 测试"),BorderLayout.CENTER);\n        \n        //添加面板\n        c.add(p1);\n        c.add(p2);\n        c.add(p3);\n        c.add(p4);\n        \n        //窗体显示\n        setVisible(true);\n    }\n}\n\npublic class Demo {\n    \n    public static void main(String[] args) {\n        new Parentform();\n    }\n    \n}\n\n\n运行结果\n\n\n# JScrollPane 面板\n\n> Class JScrollPane\n> \n> java.lang.Object java.awt.Component java.awt.Container javax.swing.JComponent javax.swing.JScrollPane\n\nJScrollPane面板是带滚动条的面板，也是容器，但JScrollPane面板只能放一个组件，不能布局。但可以通过放一个JPanel面板实现多组件插入！！\n\nimport javax.swing.*;\nimport java.awt.*;\n\n//JFrame父窗体类\nclass Parentform extends JFrame {\n    \n    public Parentform(){\n        //为父类添加标题\n        super("JFrame父窗体的标题");\n        //窗体关闭规则\n        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //窗体坐标，大小\n        setBounds(300,230,800,550);\n        //获取窗体容器\n        Container c = getContentPane();\n        \n        //文本域\n        JTextArea area = new JTextArea();\n        //创建添加滚动面板\n        JScrollPane js = new JScrollPane(area);\n\n        c.add(js);\n        \n        //窗体显示\n        setVisible(true);\n    }\n}\n\npublic class Demo {\n    \n    public static void main(String[] args) {\n        new Parentform();\n    }\n    \n}\n\n\n运行结果\n\n\n# 组件\n\n通用抽象窗口工具包（AWT）容器对象是可以包含其他AWT组件的组件\n\n构造方法\n\nContainer（） 创建新的容器\n\n常用方法\n\n修饰符、类型        方法                                           说明\nContainer     add（Component comp)                          将指定的组件附加到此容器的后面\nContainer     add（Component comp, int index）               在给定的位置将指定的组件添加到此容器\nvoid          addContainerListener（ContainerListener l）    添加指定的容器侦听器以从此容器接收容器事\nint           getComponentCount（）                          获取此面板中的组件数量\ncomponent[]   getComponents（）                              获取此容器中的所有组件\nvoid          validate（）                                   验证此容器及其所有子组件（刷新组件）\n\n\n# 按钮组件\n\n# JButton 按钮\n\n> Class JButton\n> \n> java.long.Object java.awt.Component java.awt.Container javax.swing.JComponent javax.swing.AbstractButton javax.swing.JButton\n\n能获取用户点击\n\n构造方法\n\nJButton（） \n\nJButton（String text）\n\nJButton（lcon icon）\n\nJButton（String text , lcon icon）\n\n> **text：**表示标签，标识性文字 **icon：**图标\n\n常用方法\n\njavax.swing.AbstractButton类 里的方法 ，由于方法较多自行查询API\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\n//JFrame父窗体类\nclass Parentform extends JFrame {\n    \n    public Parentform(){\n        //为父类添加标题\n        super("JFrame父窗体的标题");\n        //窗体关闭规则\n        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //窗体坐标，大小\n        setBounds(300,230,800,550);\n        //获取窗体容器\n        Container c = getContentPane();\n        //网格布局\n        setLayout(new GridLayout(3,2,10,10));\n        \n        JButton[] b = new JButton[6];\n        for (int i = 0; i < b.length ; i++) {\n            b[i] = new JButton();\n            c.add(b[i]);\n        }\n        \n        //设置按钮不可用\n        b[0].setText("不可用");\n        b[0].setEnabled(false);\n        \n        //设置按钮背景色\n        b[1].setText("有背景色");\n        b[1].setBackground(Color.pink);\n    \n        b[2].setText("无边框");\n        b[2].setBorderPainted(false);\n        \n        b[3].setText("有边框");\n        b[3].setBorder(BorderFactory.createLineBorder(Color.RED));\n        \n        Icon icon = new ImageIcon("src/imageButtoo.jpg");\n        //给按钮设置图片\n        b[4].setIcon(icon);\n        //鼠标悬停提示\n        b[4].setToolTipText("图片按钮");\n        \n        b[5].setText("可点击");\n        b[5].addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                JOptionPane.showMessageDialog(Parentform.this,"点击按钮");\n            }\n        });\n        \n        //窗体显示\n        setVisible(true);\n    }\n}\n\npublic class Demo {\n    \n    public static void main(String[] args) {\n        new Parentform();\n    }\n    \n}\n\n\n运行结果\n\n# JRadioButton 单选按钮\n\n> Class JRadioButton\n> \n> java.lang.Object java.awt.Component java.awt.Container javax.swing.JComponent javax.swing.AbstractButton javax.swing.JToggleButton javax.swing.JRadioButton\n\n显示圆形图标的按钮，旁边有说明性文字，默认情况单选按钮是单独存在的，因此需要按钮组将多个按钮放在一起使得按钮有单选效果，方法在javax.swing.AbstractButton类中\n\n构造方法\n\nJRadioButton（）\n\nJRadioButton（Icon icon）\n\nJRadioButton（Icon icon , boolean selected）\n\nJRadioButton（String text）\n\nJRadioButton（String text , Icon icon）\n\nJRadioButton（String text , Icon icon , boolean selected）\n\n> **icon：**图标对象 **selected：**是否选中 true：选中 **text：**标示性文字\n\n按钮组\n\n> Class ButtonGroup\n> \n> java.lang.Object javax.swing.ButtonGroup\n\n用于为一组按钮设置排除范围，意味着其中一个打开，则关闭组中的其他按钮\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\n//JFrame父窗体类\nclass Parentform extends JFrame {\n    \n    public Parentform(){\n        //为父类添加标题\n        super("JFrame父窗体的标题");\n        //窗体关闭规则\n        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //窗体坐标，大小\n        setBounds(300,230,800,550);\n        //获取窗体容器\n        Container c = getContentPane();\n        setLayout(new FlowLayout());\n        \n        JRadioButton no1 = new JRadioButton("按钮No.1");\n        JRadioButton no2 = new JRadioButton("按钮No.2");\n        JRadioButton no3 = new JRadioButton("按钮No.3",true);\n        \n        //默认选中\n//        no1.setSelected(true);\n        //按钮组\n        ButtonGroup group = new ButtonGroup();\n        group.add(no1);\n        group.add(no2);\n        group.add(no3);\n        \n        c.add(no1);\n        c.add(no2);\n        c.add(no3);\n    \n        JButton jb = new JButton("打印");\n        jb.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                System.out.println(no1.getText()+"按钮1："+no1.isSelected());\n                System.out.println(no2.getText()+"按钮1："+no2.isSelected());\n                System.out.println(no3.getText()+"按钮1："+no3.isSelected());\n                group.clearSelection();//清除选中（刷新）\n            }\n        });\n        c.add(jb);\n        //窗体显示\n        setVisible(true);\n    }\n}\n\npublic class Demo {\n    public static void main(String[] args) {\n        new Parentform();\n    }\n}\n\n\n运行结果\n\n# JCheckBox 复选框\n\n> Class JCheckBox\n> \n> java.lang.Object java.awt.Component java.awt.Container javax.swing.JComponent javax.swing.AbstractButton javax.swing.JToggleButton javax.swing.JCheckBox\n\n显示方块的图标，旁边有说明性文字，可多选设置，属性设置来源 javax.swing.AbstractButton类\n\n构造方法\n\nJCheckBox（）\n\nJCheckBox（Icon icon , boolean checked）\n\nJCheckBox（String text , boolean chccked）\n\n> **icon：**图标对象 **checked：**是否选中 true：选中 **text：**标示性文字\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\n//JFrame父窗体类\nclass Parentform extends JFrame {\n    \n    public Parentform(){\n        //为父类添加标题\n        super("JFrame父窗体的标题");\n        //窗体关闭规则\n        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //窗体坐标，大小\n        setBounds(300,230,800,550);\n        //获取窗体容器\n        Container c = getContentPane();\n        setLayout(new FlowLayout());\n        \n        JCheckBox no1 = new JCheckBox("按钮No.1");\n        JCheckBox no2 = new JCheckBox("按钮No.2",true);\n        JCheckBox no3 = new JCheckBox("按钮No.3",false);\n        \n        //默认选中\n//        no1.setSelected(true);\n//        no2.setSelected(true);\n        \n        c.add(no1);\n        c.add(no2);\n        c.add(no3);\n        \n        JButton jb = new JButton("打印");\n        jb.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                System.out.println(no1.getText()+"按钮1："+no1.isSelected());\n                System.out.println(no2.getText()+"按钮1："+no2.isSelected());\n                System.out.println(no3.getText()+"按钮1："+no3.isSelected());\n                System.out.println();\n            }\n        });\n        c.add(jb);\n        \n        //窗体显示\n        setVisible(true);\n    }\n}\n\npublic class Demo {\n    public static void main(String[] args) {\n        new Parentform();\n    }\n}\n\n\n运行结果\n\n\n# 列表组件\n\n# JComboBox下拉列表框\n\nJComboBox下拉表框\n\n> Class JComboBox\n> \n> java.lang.Object java.awt.Component java.awt.Container javax.swing.JComponent javax.swing.JComboBox\n\n带条状的显示区，具有下拉功能\n\n构造方法\n\nJComboBox（）\n\nJComboBox（ComboBoxModel dataModel）\n\nJComboBox（Object[] arrayDate）\n\nJComboBox（Vector vector）\n\n> **dataModel：**模型 **arrayDate：**数组 **vector：**动态数组\n> \n> Vector 类型实现了一个动态数组。和 数组 很相似，但是两者是不同的：\n> \n>  * Vector 是同步访问的\n>  * Vector 包含了许多传统的方法，这些方法不属于集合框架\n\nJComboBox模型\n\n将下拉列表框中的项目封装为ComboBoxModel（接口 / 模型）\n\n初始化JComboBox对象时向上转型为ComboBoxModel 接口类型，必须实现以下两种方法：\n\n（void）setSelectedItem（Object item） 用于设置下拉列表框中的选中项\n\n（Object）getSelectedItem（） 用于返回下拉列表框中的选中项\n\n继承 AbstractLisModel类 也有两个重要的操作：\n\ngetSize（）  返回列表的长度\n\ngetElementAt（int index）  返回指定的索引处的值\n\n如果想实现调用接口，自定义一个实现 ComboBoxModel接口 并继承 AbstractLisModel类 的类，这样可以重写或实现该类的重要方法，初始化JComboBox对象时向上转型为ComboBoxModel 接口类型即可\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\n//JFrame父窗体类\nclass Parentform extends JFrame {\n    \n    public Parentform(){\n        //为父类添加标题\n        super("JFrame父窗体的标题");\n        //窗体关闭规则\n        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //窗体坐标，大小\n        setBounds(300,230,800,550);\n        //获取窗体容器\n        Container c = getContentPane();\n        setLayout(new FlowLayout());\n        \n//        //初始化对象（1）\n//        JComboBox<String> comboBox = new JComboBox<>();\n//        //像下拉列表添加数据\n//        comboBox.addItem("No.1");\n//        comboBox.addItem("No.2");\n//        comboBox.addItem("No.3");\n        \n//        //初始化对象（2）数组载入\n//        String[] str = new String[]{"No.1","No.2","No.3"};\n//        JComboBox<String> comboBox = new JComboBox<>(str);\n    \n        //初始化对象（3）调用接口\n        //向上转型为ComboBoxModel接口\n        ComboBoxModel com = new MyComboBox();\n        JComboBox comboBox = new JComboBox(com);\n       \n        comboBox.setBounds(21,21,80,20);\n        \n        JButton btn = new JButton("打印");\n        btn.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                System.out.println("选中索引为："+comboBox.getSelectedIndex());\n                System.out.println("选中的值为："+comboBox.getSelectedItem());\n                System.out.println("---测试2---");\n                System.out.println("下拉列表框中的个数："+com.getSize());\n                System.out.println("获取下拉列表框的项目："+com.getSelectedItem());\n                System.out.println("查看下拉列表框索引2 : "+com.getElementAt(2));\n                \n            }\n        });\n        \n        c.add(comboBox);\n        c.add(btn);\n        //窗体显示\n        setVisible(true);\n    }\n}\n\npublic class Demo {\n    public static void main(String[] args) {\n        new Parentform();\n    }\n}\n\n//用于提供接口获取信息\n//模型类 继承 AbstractListModel类 ，实现ComboBoxModel接口\nclass MyComboBox extends AbstractListModel <String> implements ComboBoxModel<String>{\n    \n     String g = null;\n     String[] str = new String[]{"No.1","No.2","No.3"};\n\n    //设置下拉列表框项目\n    @Override\n    public void setSelectedItem(Object anItem) {\n        this.g = (String)anItem;\n    }\n    \n    //获取下拉列表框的项目（数据获取来源）\n    @Override\n    public Object getSelectedItem() {\n        return this.g;\n    }\n    \n    //返回下拉列表框的数目\n    @Override\n    public int getSize() {\n        return str.length;\n    }\n    \n    //返回索引值\n    @Override\n    public String getElementAt(int index) {\n        \n        if (index < str.length){\n            return str[index];\n        }else{\n            return null;\n        }\n        \n    }\n}\n\n\n运行结果\n\n# JList列表框\n\n> Class JList\n> \n> java.lang.Object java.awt.Component java.awt.Container javax.swing.JComponent javax.swing.JList\n\n列表框无需按钮激活，直接将内容展示出来，大小属性的列表框会限制内容展示，可用滚动面板弥补内容缺失的展示，可多选\n\n构造方法\n\nJLsit（）\n\nJLsit（Object[] listData）\n\nJLsit（Vector listData）\n\nJLsit（ListModel dataModel）\n\n> **listData：**数组 **dataModel：**模型\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.util.Vector;\n\n//JFrame父窗体类\nclass Parentform extends JFrame {\n    \n    public Parentform(){\n        //为父类添加标题\n        super("JFrame父窗体的标题");\n        //窗体关闭规则\n        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //窗体坐标，大小\n        setBounds(300,230,140,180);\n        //获取窗体容器\n        Container c = getContentPane();\n        setLayout(null);//new FlowLayout()\n\n//        //初始化对象（1）\n//        Vector<String> con = new Vector<String>();\n//        JList<String> jl = new JList<>(con);\n//        //像下拉列表添加数据\n//        con.add("No.1");\n//        con.add("No.2");\n//        con.add("No.3");\n//        con.add("No.4");\n//        con.add("No.5");\n//        con.add("No.6");\n//        con.add("No.7");\n//        con.add("No.8");\n//        JScrollPane js = new JScrollPane(jl);\n        \n\n//        //初始化对象（2）\n//        String[] str = new String[]{"No.1","No.2","No.3","No.4","No.5","No.6","No.7","No.8"};\n//        JList<String> jl = new JList<>(str);\n//        JScrollPane js = new JScrollPane(jl);\n        \n        //初始化对象（3）\n        //向上转型为ListModel 接口\n        ListModel LM = new MyListModel();\n        JList<String> jl = new JList<>(LM);\n        JScrollPane js = new JScrollPane(jl);\n        \n        JButton btn = new JButton("打印");\n        btn.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                java.util.List<String> values = jl.getSelectedValuesList();\n                for (String tmp : values){\n                    System.out.println("选中的索引"+ jl.getAnchorSelectionIndex() +"的值为："+tmp+"\\t");\n                }\n                System.out.println("中项目有："+LM.getSize());\n                System.out.println("---END---");\n            }\n        });\n    \n        js.setBounds(21,21,80,80);\n        btn.setBounds(120,21,60,30);\n        c.add(js);\n        c.add(btn);\n        //窗体显示\n        setVisible(true);\n    }\n}\n\npublic class Demo {\n    public static void main(String[] args) {\n        new Parentform();\n    }\n}\n\n//用于提供接口获取信息\nclass MyListModel extends AbstractListModel <String>{\n    \n    private String[] str = new String[]{"No.1","No.2","No.3","No.4","No.5","No.6","No.7","No.8"};\n    \n    @Override\n    public int getSize() {\n        return this.str.length;\n    }\n    \n    @Override\n    public String getElementAt(int index) {\n        \n        if (index < str.length){\n            return str[index];\n        }else{\n            return null;\n        }\n        \n    }\n}\n\n\n运行结果\n\n\n# 文本组件\n\n# JTextField文本框\n\n> Class JTextField\n> \n> java.lang.Object java.awt.Component java.awt.Container javax.swing.JComponent javax.swing.text.JTextComponent javax.swing.JTextField\n\n用来显示或编辑一个单行文本\n\n构造方法\n\nJTextField（） \n\nJTextField（String text）\n\nJTextField（int fieldwidth）\n\nJTextField（String text , int fieldwidth）\n\nJTextField（Document docModel , String text , int fieldWidth）\n\n> **text：**默认内容 **fieldwidth：**字体数的行长 **docModel：**文本组件的模型\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\n//JFrame父窗体类\nclass Parentform extends JFrame {\n    \n    public Parentform(){\n        //为父类添加标题\n        super("JFrame父窗体的标题");\n        //窗体关闭规则\n        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //窗体坐标，大小\n        setBounds(300,230,140,180);\n        //获取窗体容器\n        Container c = getContentPane();\n        setLayout(new FlowLayout());\n        \n        //创建文本框对象（1）\n//        JTextField jt = new JTextField();\n//        jt.setColumns(20);\n    \n        //创建文本框对象（2）\n//        JTextField jt = new JTextField("测试");\n    \n        //创建文本框对象（3）\n//        JTextField jt = new JTextField(20);\n    \n        //创建文本框对象（4）\n//        JTextField jt = new JTextField("测试" , 20);\n    \n        //创建文本框对象（5）\n        JTextField jt = new JTextField("测试" , 20);\n        \n        JButton btn = new JButton("确认");\n        btn.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                //获取内容\n                System.out.println("内容为："+jt.getText());\n                jt.setText("");//覆盖内容（清空效果）\n                jt.requestFocus();//获取焦点\n            }\n        });\n        \n        c.add(jt);\n        c.add(btn);\n        //窗体显示\n        setVisible(true);\n    }\n}\n\n\npublic class Demo {\n    public static void main(String[] args) {\n        new Parentform();\n    }\n}\n\n\n运行结果\n\n# JPasswordField密码框\n\n> Class JPasswordField\n> \n> java.lang.Object java.awt.Component java.awt.Container javax.swing.JComponent javax.swing.text.JTextComponent javax.swing.JTextField javax.swing.JPasswordField\n\n密码框与文本框定义和用法基本相同，有用户输入的字符串有字符加密功能\n\n构造方法\n\nJPasswordField（） \n\nJPasswordField（String text）\n\nJPasswordField（int fieldwidth）\n\nJPasswordField（String text , int fieldwidth）\n\nJPasswordField（Document docModel , String text , int fieldWidth）\n\n> **text：**默认内容 **fieldwidth：**字体数的行长 **docModel：**文本组件的模型\n\n用法与上面JTextFidle文本框例子一样\n\nJPasswordField提供了一个setEchoChar（） 方法，可输入框中的加密回显字符\n\n# JTextArea文本域\n\n> Class JTextArea\n> \n> java.lang.Object java.awt.Component java.awt.Container javax.swing.JComponent javax.swing.text.JTextComponent javax.swing.JTextArea\n\n能支持多行字符的输入\n\n构造方法\n\nJTextArea（） \n\nJTextArea（String text）\n\nJTextArea（int rows , int columns）\n\nJTextArea（Document doc）\n\nJTextArea（Document doc , String text , int rows , int columns）\n\n> **text：**默认定义的内容 rows： 行数 **columns：**列数 **doc：**文本组件模型\n\n提供方法\n\nsetLineWrap（boolean Newline）  字符到达边缘自动换行\n\nimport javax.swing.*;\nimport java.awt.*;\n\n//JFrame父窗体类\nclass Parentform extends JFrame {\n    \n    public Parentform(){\n        //为父类添加标题\n        super("JFrame父窗体的标题");\n        //窗体关闭规则\n        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //窗体坐标，大小\n        setBounds(300,230,140,180);\n        //获取窗体容器\n        Container c = getContentPane();\n        setLayout(new FlowLayout());\n    \n        //创建文本框对象（1）\n//        JTextArea area = new JTextArea();\n//        area.setRows(5);\n//        area.setColumns(20);\n    \n        //创建文本框对象（2）\n//        JTextArea area = new JTextArea("测试");\n//        area.setRows(5);\n//        area.setColumns(20);\n    \n        //创建文本框对象（3）\n        JTextArea area = new JTextArea(5,10);\n        \n        //到达边缘自动换行\n        area.setLineWrap(true);\n       //定义默认内容\n        area.setText("测试");\n        //内容里后面追加内容\n        area.append("123");\n        //索引位置追加内容\n        area.insert("测试2",5);\n        \n        JScrollPane js = new JScrollPane(area);\n        c.add(js);\n        //窗体显示\n        setVisible(true);\n    }\n}\n\n\npublic class Demo {\n    public static void main(String[] args) {\n        new Parentform();\n    }\n}\n\n\n运行结果\n\n\n# 事件监听器\n\n事件监听器，实质上是一个 实现特定类型监听器接口 的类对象，事件源 在用户做出相应动作 来产生事件对象\n\n方法\n\naddActionListener（ActionListener Act）  添加事件监听器\n\nremoveActionListener（ActionListener Act） 删除事件监听器\n\n# ActionEvent动作事件\n\n> Class ActionEvent\n> \n> java.lang.Object java.util.EventObject java.awt.AWTEvent java.awt.event.ActionEvent\n\n组件定义的动作发生的语义事件。 当发生组件特定操作（例如被按下）时，此事件由组件生成的\n\n使用例子：\n\n//ActionListener()  事件响应类(匿名使用\n事件源组件.addActionListener(new ActionListener() {\n    @Override\n    //事件反应方法（重写）\n    public void actionsPerformed(ActionEvent e) {\n\t\t//响应代码\n    }\n});\n\n\n个人登录练习：\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\n//JFrame父窗体类\nclass Parentform extends JFrame {\n    public Parentform(){\n        //为父类添加标题\n        super("JFrame父窗体的标题");\n        //窗体关闭规则\n        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //窗体坐标，大小\n        setBounds(300,230,300,220);\n        //获取窗体容器\n        Container c = getContentPane();\n        setLayout(null);\n        \n        JLabel bq = new JLabel("组件选择状态");\n        bq.setBounds(70 , 150,120,30);\n//        jb.setBounds(70,110,140,40);\n        c.add(bq);\n        \n        JLabel jl = new JLabel("账号：");\n        jl.setBounds(20,20,40,30);\n        c.add(jl);\n        \n        JTextField jt = new JTextField();\n        jt.setBounds(70,20,180,30);\n        //以下是三个属性是必要的，连写的缘故\n        jt.setFont(new Font("微软雅黑",Font.PLAIN,20));\n        c.add(jt);\n        //添加动作事件监听器\n        //addActionListener 添加监听的方法\n        //ActionListener()  事件响应类\n        jt.addActionListener(new ActionListener() {\n            //匿名内部类\n            //ActionEvent：动作事件类 ，可获取组件触发···\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                bq.setText("账号文本框选中以回车");\n            }\n        });\n        \n        \n        JLabel jl2 = new JLabel("密码：");\n        jl2.setBounds(20,70,40,30);\n        c.add(jl2);\n        \n        JPasswordField jpf = new JPasswordField();\n        jpf.setBounds(70,70,180,30);\n        jpf.setFont(new Font("微软雅黑",Font.PLAIN,20));\n        c.add(jpf);\n    \n        //触发按钮立即实例jbAdl类 ，因jbAdl类继承了ActionListener类\n        jbAdl jba =  new jbAdl(bq);\n        //添加事件监听器\n        jpf.addActionListener(jba);\n        \n        //删除事件监听器（自选控件）\n        jpf.removeActionListener(jba);\n        \n        JButton jb = new JButton("登录");\n        jb.setBounds(70,110,140,40);\n        c.add(jb);\n        Parentform jftmp = this;\n        //匿名类形式触发动作事件\n        jb.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                bq.setText("点击了按钮");\n                if (jpf.getText().equals("123")){\n                    new Dialog(jftmp,true);\n                }else{\n                    new Dialog(jftmp,false);\n                }\n\n            }\n        });\n        jb.addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n        \n            }\n        });\n        \n        //窗体显示\n        setVisible(true);\n    }\n}\n\nclass Dialog extends JDialog{\n    public Dialog(Parentform p , boolean Happening){\n        //参数顺序： 1.父窗体对象 ， 2.对话框标题 ，3.是否堵塞父窗体\n        super(p,"消息",true);\n        //获取对话框容器\n        Container c = getContentPane();\n        if (Happening){\n            c.add(new JLabel("登录成功"));\n        }else{\n            c.add(new JLabel("密码错误"));\n        }\n        //对话框坐标，大小\n        setBounds(360,300,120,100);\n        setVisible(true);\n    }\n}\n\n//思路2 外部事件相应\nclass jbAdl implements ActionListener{\n\n    JLabel c;\n    \n    public jbAdl(JLabel c ){\n        this.c = c;\n    }\n    @Override\n    public void actionPerformed(ActionEvent e) {\n        c.setText("密码框选中以回车");\n    }\n}\n\npublic class Demo {\n    public static void main(String[] args) {\n        new Parentform();\n    }\n}\n\n\n运行结果\n\n# FocusEvent焦点事件监听器\n\n> Class FocusEvent java.lang.Object java.util.EventObject java.awt.AWTEvent java.awt.event.ComponentEvent java.awt.event.FocusEvent\n\n以光标视为焦点，失去或激活都会触发事件\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.FocusEvent;\nimport java.awt.event.FocusListener;\n\nclass Parentform extends JFrame{\n    public Parentform(){\n        //为父类添加标题\n        super("JFrame父窗体的标题");\n        //窗体关闭规则\n        setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);\n        //窗体坐标，大小\n        setBounds(300,230,300,220);\n        //获取窗体容器\n        Container c = getContentPane();\n        setLayout(null);\n    \n        JTextField jt = new JTextField();\n        JTextField jt2 = new JTextField();\n        JTextField jt3 = new JTextField();\n        jt.setBounds(20,20,180,30);\n        jt2.setBounds(20,60,180,30);\n        jt3.setBounds(20,100,180,30);\n        \n        //直接调用类，因 fet类 继承FocusEvent类\n        jt.addFocusListener(new fet());\n        jt2.addFocusListener(new fet());\n        jt3.addFocusListener(new fet());\n        \n        c.add(jt);\n        c.add(jt2);\n        c.add(jt3);\n        \n        //窗体显示\n        setVisible(true);\n    }\n}\n\n// 继承FocusEvent类\nclass fet implements FocusListener {\n    \n    //获取焦点时的相应\n    @Override\n    public void focusGained(FocusEvent e) {\n        //获取触发组件\n        JTextField tmp = (JTextField) e.getSource();\n        //给获取焦点的文本框设置绿色边框\n        tmp.setBorder(BorderFactory.createLineBorder(Color.green));\n    }\n    \n    //失去焦点时的相应\n    @Override\n    public void focusLost(FocusEvent e) {\n        //获取触发组件\n        JTextField tmp = (JTextField) e.getSource();\n        //给获取焦点的文本框设置绿色边框\n        tmp.setBorder(BorderFactory.createLineBorder(Color.red));\n    }\n}\n\n\npublic class Demo {\n    public static void main(String[] args) {\n        new Parentform();\n    }\n}\n\n\n运行结果',normalizedContent:'# swing程序设计\n\n\n# 概述\n\nswing为gui(图形用户界面)提供开发工具包，使用swing开发的应用程序可以统一应用程序在不同平台上运行的gui组件显示风格，因为在swing组件可以跨平台指定统一风格和外观\n\n> 特点：\n> \n>  * 轻量级组件\n>  * 可插入外观组件\n\n\n# swing包\n\n使用swing组件前，先了解层次结构和继承关系\n\n常用的swing组件\n\n组件名称                  说明\njbutton（按钮）           按钮可以带些图片或文字\njcheckbox（多选按钮）       复选框组件\njcombobox（下拉框）        代表下拉列表框，可以在下拉显示区域显示多个选项\njframe（窗体）            swing的框架类\njdialog（对话框）          swing版本的对话框\njlable（标签）            标签组件（显示文字的容器）\njradiobutton（单选按钮）    swing的单选按钮\njlist（列表框）            显示一系列条目的组件\njtextfield（文本框）       文本框\njpasswordfield（密码框）   密码框\njtextarea（文本域）        swing的文本区域\njoptionpane（小对话框）     对话框\njpanel（面板）            单纯的容器，无属性\n\n\n# 窗体\n\n窗体常用方法\n\nsettitle（string title）  窗体标题为title字符串\n\nsetdefaultcloseoperation（int a）  窗体关闭规则\n\nsetsize（width,height） 窗体大小\n\nsetlocation（x，y） 窗体坐标\n\nsetbounds（x，y, width , height） 窗体坐标，大小 （像素）\n\nsetvisible（boolean b） 窗体是否显示，默认不可见（false）\n\nsetresizable（boolean b） 窗体是否可以调整大小，默认可以调整大小\n\nsetcontentpane（容器）  重新加载容器\n\ngetcontentpane（） 获取窗体容器\n\n\n# jframe 窗体\n\n> class jframe\n> \n> java.lang.object java.awt.component java.awt.container java.awt.window java.awt.frame javax.swing.jframe\n\njframe窗体拥有计算机基本组件，最大化，最小化，关闭等组件\n\n构造方法\n\njframe（）\n\njframe（starting title）\n\n> **title：**窗体标题\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class demo {\n    public static void main(string[] args) {\n        //123为标题\n        jframe f = new jframe("123");\n        //窗体显示\n        f.setvisible(true);\n        \n        //窗口关闭规则\n        f.setdefaultcloseoperation(3);\n//        f.setsize(330,220);//大小\n//        f.setlocation(202,202);//坐标\n        //坐标，大小 （x , y , width , height）单位：像素\n        f.setbounds(200,200 , 300,300);\n    \n        //获取窗体容器\n        container c = f.getcontentpane();\n        //背景颜色\n        c.setbackground(color.cyan);\n        //标签内容\n        jlabel l = new jlabel("这是一个窗体！！");\n        //添加组件\n        c.add(l);\n        \n    }\n}\n\n\n也可以\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class demo2 extends jframe {\n    \n    public demo2(){\n        //窗体显示\n        setvisible(true);\n    \n        //窗口关闭规则\n        setdefaultcloseoperation(3);\n//        f.setsize(330,220);//大小\n//        f.setlocation(202,202);//坐标\n        //坐标，大小 （x , y , width , height）单位：像素\n        setbounds(200,200 , 300,300);\n    \n        //获取窗体容器\n        container c = getcontentpane();\n        //背景颜色\n        c.setbackground(color.cyan);\n        //标签内容\n        jlabel l = new jlabel("这是一个窗体！！");\n        //添加组件\n        c.add(l);\n        //删除组件\n        c.remove(l);\n        //验证容器中的组件\n        c.validate();\n        //重新载入容器\n        setcontentpane(c);\n    }\n    \n    \n    public static void main(string[] args) {\n        new demo2();\n    }\n}\n\n\n运行结果\n\n\n# jdialog 窗体\n\n> class jdialog\n> \n> java.lang.object java.awt.component java.awt.container java.awt.window java.awt.dialog javax.swing.jdialog\n\njdialog窗体是swing的对话框，是从一个窗体中弹出另一个窗体，它继承了awt组件中的\n\n在一个类继承窗体类时，可以在构造方法中使用 super关键字 可调用回窗体类的参数填充\n\n构造方法\n\njdialog（）\n\njdialog（frame f）\n\njdialog（frame f , boolean model）\n\njdialog（frame f , string title）\n\njdialog（frame f , string title , boolean model）\n\n> **f：**需要指定的父窗体 **model：**指定类型的对话框（是否约束父窗体） **title：**对话框的标题\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.*;\n\n//jframe父窗体类\nclass parentform extends jframe {\n    \n    jbutton btn;\n    public parentform(){\n        //为父类添加标题\n        super("jframe父窗体的标题");\n        //窗体关闭规则\n        setdefaultcloseoperation(windowconstants.exit_on_close);\n        //窗体显示\n        setvisible(true);\n        //窗体坐标，大小\n        setbounds(300,230,400,340);\n        //获取窗体容器\n        container c = getcontentpane();\n        //布局设置，使用流布局\n        c.setlayout(new flowlayout());\n        //使类的btn共享到以下类输出\n        this.btn = new jbutton("对话框");\n        //添加组件\n        c.add(btn);\n    }\n    public jbutton btn(){\n        //输出组件添加动作监听\n        return btn;\n    }\n}\n\n//对话框类\nclass dialog extends jdialog{\n    public dialog(parentform p){\n        //参数顺序： 1.父窗体对象 ， 2.对话框标题 ，3.是否堵塞父窗体\n        super(p,"123对话框",true);\n        //获取对话框容器\n        container c = getcontentpane();\n        //对话框添加标签（内容）\n        c.add(new jlabel("这是对话框！"));\n        //对话框坐标，大小\n        setbounds(360,300,120,100);\n    }\n}\n\npublic class demo {\n    public static void main(string[] args) {\n        //实例jframe父窗体类\n        parentform p = new parentform();\n        \n        //添加动作监听\n        p.btn().addactionlistener(new actionlistener() {\n            @override\n            public void actionperformed(actionevent e) {\n                //实例对话框类，并获取p父窗体对象\n                dialog d = new dialog(p);\n                //显示对话框\n                d.setvisible(true);\n            }\n        });\n        //也可以  p.btn().addactionlistener(e -> new dialog());\n    }\n}\n\n\n运行结果\n\n\n# 窗体关闭规则\n\n窗体的关闭规则是需要到 setdefaultcloseoperation（）方法来选择关闭方式的\n\n关闭类型                  说明           定义\ndo_nothing_on_close   无任何操作        0\nhide_on_close（默认）     隐藏窗体，不停止程序   1\ndispose_on_close      释放窗体资源       2\nexit_on_close         隐藏窗体，停止程序    3\n\n\n# 图标\n\n\n# jlable 标签\n\n> class jlabel\n> \n> java.lang.object java.awt.component java.awt.container javax.swing.jcomponent javax.swing.jlabel\n\n可以显示只读文本、图像，但不能产生任何类型的事件，只是简单的显示文本和图像，还可以设置标签上文本的对齐方式\n\n构造方法\n\njlable（） \n\njlable（string text）\n\njlable（icon icon）\n\njlable（icon icon , int aligment）  \n\njlable（string text , int aligment）\n\njlable（string text , icon icon , int aligment）\n\n> **text：**标识性，文字标签 **icon：**图标对象 **aligment：**设置对齐方式\n\n常用方法\n\n修饰符、类型   方法                              说明\nvoid     settext（string text）            定义组件内容（更改）\nstring   gettext（）                       返回标签显示的文本字符串\nvoid     seticon（icon icon）              添加图片文件\nvoid     setsize（int with ，int height）   标签大小设置\n\n￼构造方法的实践例子：（图片文件在src路径里）\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.net.url;\n\n//jframe父窗体类\nclass parentform extends jframe {\n\n    public parentform(){\n        //为父类添加标题\n        super("jframe父窗体的标题");\n        //窗体关闭规则\n        setdefaultcloseoperation(windowconstants.exit_on_close);\n        //窗体坐标，大小\n        setbounds(200,0,620,800);\n        //获取窗体容器\n        container c = getcontentpane();\n        //布局设置，使用流布局\n        c.setlayout(new flowlayout());\n        \n        \n        jlabel no1 = new jlabel();\n        jlabel no2 = new jlabel("标签内容");\n        \n        //获取图片的方法（方法1）\n        //获取当前类所在的路径\n        url url = demo.class.getresource("1.jpg");\n        //获取相应路径下的文件（图片）\n        icon icon = new imageicon(url);\n        jlabel no3 = new jlabel(icon);\n        \n        //获取图片的（方法2）\n        icon icon2 = new imageicon("src/1.jpg");\n        jlabel no4 = new jlabel("显示图片",icon2, swingconstants.left);\n        \n        //更改标签内容\n        no2.settext("更改标签内容");\n        //获取标签内容\n        system.out.println(no2.gettext());\n    \n        //在窗体显示图片路径\n        jlabel jl = new jlabel("获取图片路径："+url.tostring());\n        c.add(jl);\n        \n        //自选打开\n//        c.add(no1);\n//        c.add(no2);\n//        c.add(no3);\n        c.add(no4);\n        \n        //显示在后面或者刷新组件\n        //容器组件重新验证\n        c.validate();\n        //窗体显示\n        setvisible(true);\n    }\n}\n\npublic class demo {\n    public static void main(string[] args) {\n        new parentform();\n    }\n}\n\n\n运行结果\n\n> 注意：\n> \n> java.lang.class类中的 getresource（）方法 可以获取资源文件的url路径\n\n\n# 图标使用\n\n创建图标\n\n创建图标使用到 java.awt.graphics类 提供的功能来实现\n\n在swing中是通过icon接口来实现创建图标，使用icon接口必须实现以下3个方法：\n\n修饰符、类型   方法                                                 说明\nint      geticonheight（）                                    获取图标高\nint      geticonwidth（）                                     获取图标宽\nvoid     painticon（component c, graphics g, int x, int y）   指定坐标位置画图\n\nimport javax.swing.*;\nimport java.awt.*;\n\n//jframe父窗体类\nclass parentform extends jframe {\n    \n    public parentform(){\n        //为父类添加标题\n        super("jframe父窗体的标题");\n        //窗体关闭规则\n        setdefaultcloseoperation(windowconstants.exit_on_close);\n        //窗体显示\n        setvisible(true);\n        //窗体坐标，大小\n        setbounds(300,230,300,200);\n        //获取窗体容器\n        container c = getcontentpane();\n    }\n\n}\n\n//绘图图标类\n//引入icon接口\nclass drawicon implements icon{\n    // 声明图标的宽\n    private int w;\n    // 声明图标的高\n    private int h;\n    \n    //获取数据\n    public drawicon(int w , int h){\n        this.w = w ;\n        this.h = h ;\n    }\n    \n    // 实现painticon()方法\n    @override\n    public void painticon(component c, graphics g, int x, int y) {\n        // 绘制一个圆形\n        g.filloval(x , y , w , h);\n    }\n    \n    @override\n    public int geticonwidth() {\n        return this.w;\n    }\n    \n    @override\n    public int geticonheight() {\n        return this.h;\n    }\n}\n\npublic class demo {\n    public static void main(string[] args) {\n        drawicon icon = new drawicon(23, 23);\n        // 创建一个标签，并设置标签上的文字在标签正中间\n        jlabel j = new jlabel("测试", icon, swingconstants.center);\n        parentform jf = new parentform();\n        jf.add(j);\n    }\n}\n\n\n运行结果\n\n\n# 常用布局管理器\n\n布局管理就是用于指定组件的摆放位置的。每种布局管理器都有自己的摆放风格。管理组件在容器中的位置和大小\n\n需要该方法来定义窗体或面板布局\n\n窗体或面板的对象.setlayout(布局类型);\n\n\n\n# 绝对布局\n\n绝对布局是指定组件在容器中的固定大小和位置\n\nimport javax.swing.*;\nimport java.awt.*;\n\n//jframe父窗体类\nclass parentform extends jframe {\n    \n    public parentform(){\n        //为父类添加标题\n        super("jframe父窗体的标题");\n        //窗体关闭规则\n        setdefaultcloseoperation(windowconstants.exit_on_close);\n        //窗体显示\n        setvisible(true);\n        //窗体坐标，大小\n        setbounds(300,230,300,200);\n        //获取窗体容器\n        container c = getcontentpane();\n        \n        //取消默认布局 ， 更改为绝对布局\n        setlayout(null);\n        \n        //创建按钮组件\n        jbutton b1 = new jbutton("按钮1") , b2 = new jbutton("按钮2");\n        \n        //给按钮组件添加坐标、大小\n        b1.setbounds(10,10,70,40);\n        b2.setbounds(112,64,92,60);\n        \n        //添加按钮组件\n        c.add(b1);\n        c.add(b2);\n    }\n    \n}\n\npublic class demo {\n    public static void main(string[] args) {\n        parentform jf = new parentform();\n    }\n}\n\n\n运行结果\n\n> 注意：\n> \n> 绝对布局的窗口组件大小都是固定的，不随窗体大小更改而变化\n> \n> 组件坐标是以窗体左上角为基点的\n\n\n# flowlayout 流布局\n\n> class flowlayout\n> \n> java.lang.object java.awt.flowlayout\n\n流布局管理器 ，像流水一样从左到右摆放组件，直到占完所有空间，组件是默认居中排列\n\n构造方法\n\nflowlayout（） \n\nflowlayout（int alignment）\n\nflowlayout（int alignment , int horizgap , int vertgap）  \n\n> **alignment：**摆放方式 **horizgap：**组件之间的水平间距 **vertgap：**组件之间的垂直间距\n\nalignment参数的摆放设置    说明      定义\nflowlayout.left     左对齐排列   0\nflowlayout.center   居中排列    1\nflowlayout.right    右对齐排列   2\n\nhorizgap ： 组件与组件之间的水平间距（像素）\n\nvertgap ： 组件与组件之间的垂直间距（像素）\n\nimport javax.swing.*;\nimport java.awt.*;\n\n//jframe父窗体类\nclass parentform extends jframe {\n    \n    public parentform(){\n        //为父类添加标题\n        super("jframe父窗体的标题");\n        //窗体关闭规则\n        setdefaultcloseoperation(windowconstants.exit_on_close);\n        //窗体坐标，大小\n        setbounds(300,230,300,200);\n        //获取窗体容器\n        container c = getcontentpane();\n        \n        //流布局\n        //参数测试，自行选择\n//        setlayout(new flowlayout());\n//        setlayout(new flowlayout(0));//左对齐\n//        setlayout(new flowlayout(1));//居中对齐（默认）\n//        setlayout(new flowlayout(2));//右对齐\n        setlayout(new flowlayout(1 , 20, 20));//居中对齐（默认）\n        \n        //创建添加按钮组件\n        for (int i = 0; i < 10; i++) {\n            c.add(new jbutton("按钮"+i));\n        }\n        \n        //窗体显示\n        setvisible(true);\n    }\n}\n\npublic class demo {\n    public static void main(string[] args) {\n        new parentform();\n    }\n}\n\n\n运行结果\n\n\n# borderlayout 边界布局\n\n> class borderlayout\n> \n> java.lang.object java.awt.borderlayout\n\n边界布局把容器的的布局分为五个位置：上下左右中5个区域 。设置该布局管理器是可无视，因默认是边界布局\n\n在容器add（）方法添加组件时可设置区域\n\n成员变量                  说明\nborderlayout.north    顶端\nborderlayout.south    底端\nborderlayout.east     右端\nborderlayout.west     左端\nborderlayout.center   中间\n\nimport javax.swing.*;\nimport java.awt.*;\n\n//jframe父窗体类\nclass parentform extends jframe {\n    \n    public parentform(){\n        //为父类添加标题\n        super("jframe父窗体的标题");\n        //窗体关闭规则\n        setdefaultcloseoperation(windowconstants.exit_on_close);\n        //窗体坐标，大小\n        setbounds(300,230,300,200);\n        //获取窗体容器\n        container c = getcontentpane();\n        \n        //设置边界布局\n        c.setlayout(new borderlayout());//可被注释，因本身就是边界布局\n        \n        //边界布局\n        jbutton\n                b1 = new jbutton("中"),\n                b2 = new jbutton("东"),\n                b3 = new jbutton("南"),\n                b4 = new jbutton("西"),\n                b5 = new jbutton("北");\n                \n        c.add(b1 , borderlayout.center);\n        c.add(b2 , borderlayout.east);\n        c.add(b3 , borderlayout.south);\n        c.add(b4 , borderlayout.west);\n        c.add(b5 , borderlayout.north);\n    \n        c.add(new jbutton("覆盖中") , borderlayout.center);\n        \n        //窗体显示\n        setvisible(true);\n    }\n    \n}\n\npublic class demo {\n    public static void main(string[] args) {\n        new parentform();\n    }\n}\n\n\n运行结果\n\n\n# gridlayout 网格布局\n\n> class gridlayout\n> \n> java.lang.object java.awt.gridlayout\n\n网格布局管理器是将容器划分为网格，组件是按照 行 和 列 进行布局\n\n每个组件大小一样，排序默认从左到右，从上到下的顺序排列，窗体大小的改变，组件也会跟随改变\n\n构造方法\n\ngridlayout（int rows , int columns）\n\ngridlayout（int rows , int columns , int horizgap , int veritgap）\n\n> rows： 行个数 columns：列个数 horizgap：组件水平间距 veritgap：组件垂直间距\n\nimport javax.swing.*;\nimport java.awt.*;\n\n//jframe父窗体类\nclass parentform extends jframe {\n    \n    public parentform(){\n        //为父类添加标题\n        super("jframe父窗体的标题");\n        //窗体关闭规则\n        setdefaultcloseoperation(windowconstants.exit_on_close);\n        //窗体坐标，大小\n        setbounds(300,230,300,200);\n        //获取窗体容器\n        container c = getcontentpane();\n        \n        //设置\n//        c.setlayout(new gridlayout(3,4));//3行4列（布局满无间隙）\n        //3行4列，组件间隙为12px（行数，列数，水平，垂直）\n        c.setlayout(new gridlayout(3,4,12,12));\n    \n        for (int i = 0; i < 20; i++) {\n            c.add(new jbutton("按钮"+i));\n        }\n        \n        //窗体显示\n        setvisible(true);\n    }\n    \n}\n\npublic class demo {\n    public static void main(string[] args) {\n        new parentform();\n    }\n}\n\n\n运行结果\n\n\n# gridbaglayout 网格组布局\n\n> class gridbaglayout\n> \n> java.lang.object java.awt.gridbaglayout\n\n实现了动态矩形网格，由无限个矩形单元格组成，每行每列的高宽以行列最大像素的组件为准，每个组件都与gridbagconstraints类关联（用来约束）\n\n以下是使用流程：\n\nimport java.awt.gridbagconstraints类 为使用 gridbaglayou类布局 的约束\n\n> class gridbagconstraints\n> \n> java.lang.object java.awt.gridbagconstraints\n\ngridbagconstraints约束\n\ngridbagconstraints属性   说明\ngridx                  组件坐标x（网格）\ngridy                  组件坐标y（网格）\ngridwidth              组件占用行数\ngridheight             组件占用列数\nanchor                 组件在的方位\nfill                   组件填充方式\ninsets                 组件与单元格边缘的最小距离\nipadx                  组件的首先大小 x\nipady                  组件的首先大小 y\nweightx                单元格最大宽\nweighty                单元格最大高\n\n以下代码是自选gridbagconstraints属性约束测试\n\nimport javax.swing.*;\nimport java.awt.*;\n\n//jframe父窗体类\nclass parentform extends jframe {\n    \n    //添加彩色面板\n    jpanel p1 = new jpanel();\n    jpanel p2 = new jpanel();\n    jpanel p3 = new jpanel();\n    jpanel p4 = new jpanel();\n    jpanel p5 = new jpanel();\n    \n    container c;\n    public parentform(){\n        //为父类添加标题\n        super("jframe父窗体的标题");\n        //窗体关闭规则\n        setdefaultcloseoperation(windowconstants.exit_on_close);\n        //窗体坐标，大小\n        setbounds(300,230,800,550);\n        this.c = getcontentpane();\n        \n        //颜色面板\n        this.p1.setbackground(color.cyan);\n        this.p2.setbackground(color.green);\n        this.p3.setbackground(color.cyan);\n        this.p4.setbackground(color.green);\n        this.p5.setbackground(color.cyan);\n    }\n    \n    //坐标矩阵\n    public void init(){\n        \n        for (int i = 0; i < 10; i++) {\n            gridbagconstraints g = new gridbagconstraints();\n            gridbagconstraints g2 = new gridbagconstraints();\n            g.gridx = i;\n            g.gridy = 0;\n            g2.gridx = 0;\n            g2.gridy = i;\n            //空格用来填充\n            c.add(new jbutton("   " + i + "    "),g);\n            c.add(new jbutton("   " + i + "    "),g2);\n        }\n        \n    }\n    \n}\n\n//组件约束类\nclass components {\n    \n    //颜色面板调用约束方法\n    public gridbagconstraints jpl1() {\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        g.gridx = 1;\n        g.gridy = 1;\n        g.gridwidth = 2;\n        g.gridheight = 2;\n        g.fill = gridbagconstraints.both;\n        return g;\n    }\n    public gridbagconstraints jpl2() {\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        g.gridx = 3;\n        g.gridy = 1;\n        g.gridwidth = 2;\n        g.gridheight = 2;\n        g.fill = gridbagconstraints.both;\n        return g;\n    }\n    public gridbagconstraints jpl3() {\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        g.gridx = 5;\n        g.gridy = 1;\n        g.gridwidth = 2;\n        g.gridheight = 2;\n        g.fill = gridbagconstraints.both;\n        return g;\n    }\n    public gridbagconstraints jpl4() {\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        g.gridx = 7;\n        g.gridy = 1;\n        g.gridwidth = 2;\n        g.gridheight = 2;\n        g.fill = gridbagconstraints.both;\n        return g;\n    }\n    //weightx ，weighty属性（专属颜色面板）\n    public gridbagconstraints jpl5() {\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        g.gridx = 2;\n        g.gridy = 2;\n        g.fill = gridbagconstraints.both;\n        return g;\n    }\n    public gridbagconstraints jpl6() {\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        g.gridx = 4;\n        g.gridy = 2;\n        g.fill = gridbagconstraints.both;\n        return g;\n    }\n    public gridbagconstraints jpl7() {\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        g.gridx = 6;\n        g.gridy = 2;\n        g.fill = gridbagconstraints.both;\n        return g;\n    }\n    public gridbagconstraints jpl8() {\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        g.gridx = 2;\n        g.gridy = 4;\n        g.fill = gridbagconstraints.both;\n        return g;\n    }\n    public gridbagconstraints jpl9() {\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        g.gridx = 2;\n        g.gridy = 6;\n        g.fill = gridbagconstraints.both;\n        return g;\n    }\n    \n    \n    //组件约束方法\n    \n    //gridbagconstraints约束测试（1）\n    //gridx和gridy属性\n    public gridbagconstraints gbc1() {\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        //设置组件坐标位置\n        g.gridx = 1;\n        g.gridy = 1;\n        return g;\n    }\n    public gridbagconstraints gbc2() {\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        //设置组件坐标位置\n        g.gridx = 2;\n        g.gridy = 2;\n        return g;\n    }\n    public gridbagconstraints gbc3() {\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        //设置组件坐标位置\n        g.gridx = 3;\n        g.gridy = 3;\n        return g;\n    }\n    \n    \n    //gridbagconstraints约束测试（2）\n    //gridwidth和gridheight属性\n    public gridbagconstraints gbc4(){\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        //设置组件坐标位置\n        g.gridx = 1;\n        g.gridy = 1;\n        g.gridwidth = 1;\n        g.gridheight = 1;\n        return g;\n    }\n    public gridbagconstraints gbc5(){\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        //设置组件坐标位置\n        g.gridx = 3;\n        g.gridy = 1;\n        g.gridwidth = 2;\n        g.gridheight = 2;\n        return g;\n    }\n    public gridbagconstraints gbc6(){\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        //设置组件坐标位置\n        g.gridx = 5;\n        g.gridy = 1;\n        g.gridwidth = 2;\n        g.gridheight = 1;\n        return g;\n    }\n    \n    \n    //gridbagconstraints约束测试（3）\n    //fill属性\n    public gridbagconstraints gbc7(){\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        //设置组件坐标位置\n        g.gridx = 1;\n        g.gridy = 1;\n        g.gridwidth = 2;\n        g.gridheight = 2;\n        //默认无填充none\n        g.fill = gridbagconstraints.none; //(0)\n        return g;\n    }\n    public gridbagconstraints gbc8(){\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        //设置组件坐标位置\n        g.gridx = 3;\n        g.gridy = 1;\n        g.gridwidth = 2;\n        g.gridheight = 2;\n        //水平填充horizontal\n        g.fill = gridbagconstraints.horizontal; //(2)\n        return g;\n    }\n    public gridbagconstraints gbc9(){\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        //设置组件坐标位置\n        g.gridx = 5;\n        g.gridy = 1;\n        g.gridwidth = 2;\n        g.gridheight = 2;\n        //垂直填充vertical\n        g.fill = gridbagconstraints.vertical; //(3)\n        return g;\n    }\n    public gridbagconstraints gbc10(){\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        //设置组件坐标位置\n        g.gridx = 7;\n        g.gridy = 1;\n        g.gridwidth = 2;\n        g.gridheight = 2;\n        //填充both\n        g.fill = gridbagconstraints.both; //(1)\n        return g;\n    }\n    \n    \n    //gridbagconstraints约束测试（4）\n    //anchor属性\n    public gridbagconstraints gbc11(){\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        //设置组件坐标位置\n        g.gridx = 1;\n        g.gridy = 1;\n        g.gridwidth = 2;\n        g.gridheight = 2;\n        //左上\n        g.anchor = gridbagconstraints.northwest;\n        return g;\n    }\n    public gridbagconstraints gbc12(){\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        //设置组件坐标位置\n        g.gridx = 3;\n        g.gridy = 1;\n        g.gridwidth = 2;\n        g.gridheight = 2;\n        //右下\n        g.anchor = gridbagconstraints.southeast;\n        return g;\n    }\n    public gridbagconstraints gbc13(){\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        //设置组件坐标位置\n        g.gridx = 5;\n        g.gridy = 1;\n        g.gridwidth = 2;\n        g.gridheight = 2;\n        //右\n        g.anchor = gridbagconstraints.east;\n        return g;\n    }\n    public gridbagconstraints gbc14(){\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        //设置组件坐标位置\n        g.gridx = 7;\n        g.gridy = 1;\n        g.gridwidth = 2;\n        g.gridheight = 2;\n        //下\n        g.anchor = gridbagconstraints.south; //(1)\n        return g;\n    }\n    \n    \n    //gridbagconstraints约束测试（5）\n    //insets属性\n    public gridbagconstraints gbc15(){\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        //设置组件坐标位置\n        g.gridx = 1;\n        g.gridy = 1;\n        //设置边距距离\n        g.insets = new insets(5,5,5,5);\n        return g;\n    }\n    public gridbagconstraints gbc16(){\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        //设置组件坐标位置\n        g.gridx = 2;\n        g.gridy = 2;\n        //设置边距距离\n        g.insets = new insets(12,12,12,12);\n        return g;\n    }\n    \n    \n    //gridbagconstraints约束测试（6）\n    //ipadx , ipady 属性\n    public gridbagconstraints gbc17(){\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        //设置组件坐标位置\n        g.gridx = 1;\n        g.gridy = 1;\n        //设置组件大小\n        g.ipadx = 10;\n        g.ipady = 10;\n        return g;\n    }\n    public gridbagconstraints gbc18(){\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        //设置组件坐标位置\n        g.gridx = 3;\n        g.gridy = 1;\n        //设置组件大小\n        g.ipadx = -10;\n        g.ipady = -10;\n        return g;\n    }\n    \n    \n    //gridbagconstraints约束测试（6）\n    //weightx , weighty 属性\n    public gridbagconstraints gbc19(){\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        //设置组件坐标位置\n        g.gridx = 2;\n        g.gridy = 2;\n        //设置单元格最大宽高\n        g.weightx = 10;\n        g.weighty = 10;\n        return g;\n    }\n    public gridbagconstraints gbc20(){\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        //设置组件坐标位置\n        g.gridx = 4;\n        g.gridy = 2;\n        //设置单元格最大宽高\n        g.weightx = 5;\n        g.weighty = 1;\n        return g;\n    }\n    public gridbagconstraints gbc21(){\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        //设置组件坐标位置\n        g.gridx = 6;\n        g.gridy = 2;\n        //设置单元格最大宽高\n        g.weightx = 2;\n        g.weighty = 1;\n        return g;\n    }\n    public gridbagconstraints gbc22(){\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        //设置组件坐标位置\n        g.gridx = 2;\n        g.gridy = 4;\n        //设置单元格最大宽高\n        g.weightx = 1;\n        g.weighty = 5;\n        return g;\n    }\n    public gridbagconstraints gbc23(){\n        //实例化约束条件\n        gridbagconstraints g = new gridbagconstraints();\n        //设置组件坐标位置\n        g.gridx = 2;\n        g.gridy = 6;\n        //设置单元格最大宽高\n        g.weightx = 2;\n        g.weighty = 2;\n        return g;\n    }\n    \n}\n\npublic class demo {\n    public static void main(string[] args) {\n        //实例化jframe窗体类\n        parentform jf = new parentform();\n        //实例化组件约束类\n        components zj = new components();\n        \n        //创建jf窗体容器\n        container c = jf.getcontentpane();\n        //设置容器布局为网格组布局\n        c.setlayout(new gridbaglayout());\n        \n        //坐标矩阵\n        jf.init();\n        \n        //自选约束测试\n        \n        //约束测试（1）\n        //添加组件 和 组件约束\n        //gridx和gridy属性\n        c.add(new jbutton("按钮1") , zj.gbc1());\n        c.add(new jbutton("按钮2") , zj.gbc2());\n        c.add(new jbutton("按钮3") , zj.gbc3());\n    \n        \n        //约束测试（2）\n        //gridwidth和gridheight属性\n//        c.add(new jbutton("按钮1") , zj.gbc4());\n//        c.add(new jbutton("按钮2") , zj.gbc5());\n//        c.add(new jbutton("按钮3") , zj.gbc6());\n//        //添加颜色面板\n//        c.add(jf.p1,zj.jpl1());\n//        c.add(jf.p2,zj.jpl2());\n//        c.add(jf.p3,zj.jpl3());\n    \n        \n        //约束测试（3）\n        //fill属性\n//        c.add(new jbutton("按钮1") , zj.gbc7());\n//        c.add(new jbutton("按钮2") , zj.gbc8());\n//        c.add(new jbutton("按钮3") , zj.gbc9());\n//        c.add(new jbutton("按钮3") , zj.gbc10());\n    \n        \n        //约束测试（4）\n        //anchor属性\n//        c.add(new jbutton("按钮1") , zj.gbc11());\n//        c.add(new jbutton("按钮2") , zj.gbc12());\n//        c.add(new jbutton("按钮3") , zj.gbc13());\n//        c.add(new jbutton("按钮3") , zj.gbc14());\n//        //添加颜色面板\n//        c.add(jf.p1,zj.jpl1());\n//        c.add(jf.p2,zj.jpl2());\n//        c.add(jf.p3,zj.jpl3());\n//        c.add(jf.p4,zj.jpl4());\n    \n        \n        //约束测试（5）\n        //inset属性\n//        c.add(new jbutton("按钮1") , zj.gbc15());\n//        c.add(new jbutton("按钮2") , zj.gbc16());\n    \n        \n        //约束测试（6）\n        //ipadx , ipady 属性\n//        c.add(new jbutton("按钮1") , zj.gbc17());\n//        c.add(new jbutton("按钮2") , zj.gbc18());\n//        //添加颜色面板\n//        c.add(jf.p1,zj.jpl1());\n//        c.add(jf.p2,zj.jpl2());\n    \n    \n        //约束测试（7）\n        //weightx , weighty 属性\n//        c.add(new jbutton("x,y:10") , zj.gbc19());\n//        c.add(new jbutton("x :５") , zj.gbc20());\n//        c.add(new jbutton("x : 2") , zj.gbc21());\n//        c.add(new jbutton("y : 5") , zj.gbc22());\n//        c.add(new jbutton("y : 2") , zj.gbc23());\n//        //添加颜色面板\n//        c.add(jf.p1,zj.jpl5());\n//        c.add(jf.p2,zj.jpl6());\n//        c.add(jf.p3,zj.jpl7());\n//        c.add(jf.p4,zj.jpl8());\n//        c.add(jf.p5,zj.jpl9());\n\n        //窗体显示\n        jf.setvisible(true);\n    }\n}\n\n\n# gridbagconstraints属性\n\ngridx , gridy属性\n\n该属性用来设置组件起始点所在单元格的索引位置，gridx设置x轴的索引值，gridy设置y轴的索引值\n\n该属性的运行结果：\n\ngridwidth , gridheight属性\n\n该属性用来设置组件占用网格组的行数和行数\n\n该属性的运行结果：\n\nfill属性\n\n该属性用来设置组件填充方式，填充单元格最大的范围\n\nfill属性的静态常量   说明        定义数\nnone          不填充（默认）   0\nhorizontal    水平填充      2\nvertical      垂直填充      3\nboth          填满        1\n\n该属性的运行结果：\n\nanchor属性\n\n该属性用来设置组件在单元格的显示区域\n\nanchor属性的静态常量   说明\nnorthwest       左上\nnorth           上\nnortheast       右上\nwest            左\ncenter          中\neast            右\nsouthwest       左下\nsouth           下\nsoutheast       右下\n\n该属性的运行结果：\n\ninset属性\n\n该属性用来设置组件四周与单元格边缘之间的最小距离\n\ninsets类 仅限于一个构造方法insets（int top , int left , int bottom , int right），上左下右来设置边缘距离，默认为没有距离\n\n该属性的运行结果：\n\nipadx , ipady 属性\n\n该属性用来修改组件的大小，ipadx修改组件宽度，ipady修改组件的高度，正数为加大，负数为缩小\n\n该属性的运行结果：\n\nweightx , weighty 属性\n\n该属性用来设置网格组的每一行和每一列对额外空间的分布方式，分配是以百分比形式分配！！\n\n该属性的运行结果：\n\n\n# 常用面板\n\n\n# jpanel 面板\n\n> class jpanel\n> \n> java.lang.object java.awt.component java.awt.container javax.swing.jcomponent javax.swing.jpanel\n\njpanel面板可聚集一些组件进行布局，jpanel面板也是容器，因继承 java.awt.container类\n\nimport javax.swing.*;\nimport java.awt.*;\n\n//jframe父窗体类\nclass parentform extends jframe {\n    \n    public parentform(){\n        //为父类添加标题\n        super("jframe父窗体的标题");\n        //窗体关闭规则\n        setdefaultcloseoperation(windowconstants.exit_on_close);\n        //窗体坐标，大小\n        setbounds(300,230,800,550);\n        //获取窗体容器\n        container c = getcontentpane();\n        //窗体设置网格布局行2，列2，水平间距10px，垂直间距10px\n        setlayout(new gridlayout(2,2,10,10));\n        \n        //该面板可视为容器使用\n        jpanel p1 = new jpanel();\n        jpanel p2 = new jpanel();\n        jpanel p3 = new jpanel();\n        jpanel p4 = new jpanel();\n        \n        //为添加面板边框\n        p1.setborder(borderfactory.createtitledborder("面板1"));\n        p2.setborder(borderfactory.createtitledborder("面板2"));\n        p3.setborder(borderfactory.createtitledborder("面板3"));\n        p4.setborder(borderfactory.createtitledborder("面板4"));\n        \n        \n        //面板1 添加标签并居中\n        p1.add(new jlabel("容器测试"),borderlayout.center);\n        //面板2 添加按钮\n        p2.setlayout(new flowlayout());//流布局\n        p2.add(new jbutton("按钮1"));\n        p2.add(new jbutton("按钮2"));\n        p2.add(new jbutton("按钮3"));\n        p2.add(new jbutton("按钮4"));\n        \n        p3.setlayout(new gridlayout(1,4 , 10,10));\n        p3.add(new jbutton("按钮1"));\n        p3.add(new jbutton("按钮2"));\n        p3.add(new jbutton("按钮3"));\n        p3.add(new jbutton("按钮4"));\n        \n        p4.add(new jlabel("面板4 测试"),borderlayout.center);\n        \n        //添加面板\n        c.add(p1);\n        c.add(p2);\n        c.add(p3);\n        c.add(p4);\n        \n        //窗体显示\n        setvisible(true);\n    }\n}\n\npublic class demo {\n    \n    public static void main(string[] args) {\n        new parentform();\n    }\n    \n}\n\n\n运行结果\n\n\n# jscrollpane 面板\n\n> class jscrollpane\n> \n> java.lang.object java.awt.component java.awt.container javax.swing.jcomponent javax.swing.jscrollpane\n\njscrollpane面板是带滚动条的面板，也是容器，但jscrollpane面板只能放一个组件，不能布局。但可以通过放一个jpanel面板实现多组件插入！！\n\nimport javax.swing.*;\nimport java.awt.*;\n\n//jframe父窗体类\nclass parentform extends jframe {\n    \n    public parentform(){\n        //为父类添加标题\n        super("jframe父窗体的标题");\n        //窗体关闭规则\n        setdefaultcloseoperation(windowconstants.exit_on_close);\n        //窗体坐标，大小\n        setbounds(300,230,800,550);\n        //获取窗体容器\n        container c = getcontentpane();\n        \n        //文本域\n        jtextarea area = new jtextarea();\n        //创建添加滚动面板\n        jscrollpane js = new jscrollpane(area);\n\n        c.add(js);\n        \n        //窗体显示\n        setvisible(true);\n    }\n}\n\npublic class demo {\n    \n    public static void main(string[] args) {\n        new parentform();\n    }\n    \n}\n\n\n运行结果\n\n\n# 组件\n\n通用抽象窗口工具包（awt）容器对象是可以包含其他awt组件的组件\n\n构造方法\n\ncontainer（） 创建新的容器\n\n常用方法\n\n修饰符、类型        方法                                           说明\ncontainer     add（component comp)                          将指定的组件附加到此容器的后面\ncontainer     add（component comp, int index）               在给定的位置将指定的组件添加到此容器\nvoid          addcontainerlistener（containerlistener l）    添加指定的容器侦听器以从此容器接收容器事\nint           getcomponentcount（）                          获取此面板中的组件数量\ncomponent[]   getcomponents（）                              获取此容器中的所有组件\nvoid          validate（）                                   验证此容器及其所有子组件（刷新组件）\n\n\n# 按钮组件\n\n# jbutton 按钮\n\n> class jbutton\n> \n> java.long.object java.awt.component java.awt.container javax.swing.jcomponent javax.swing.abstractbutton javax.swing.jbutton\n\n能获取用户点击\n\n构造方法\n\njbutton（） \n\njbutton（string text）\n\njbutton（lcon icon）\n\njbutton（string text , lcon icon）\n\n> **text：**表示标签，标识性文字 **icon：**图标\n\n常用方法\n\njavax.swing.abstractbutton类 里的方法 ，由于方法较多自行查询api\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.actionevent;\nimport java.awt.event.actionlistener;\n\n//jframe父窗体类\nclass parentform extends jframe {\n    \n    public parentform(){\n        //为父类添加标题\n        super("jframe父窗体的标题");\n        //窗体关闭规则\n        setdefaultcloseoperation(windowconstants.exit_on_close);\n        //窗体坐标，大小\n        setbounds(300,230,800,550);\n        //获取窗体容器\n        container c = getcontentpane();\n        //网格布局\n        setlayout(new gridlayout(3,2,10,10));\n        \n        jbutton[] b = new jbutton[6];\n        for (int i = 0; i < b.length ; i++) {\n            b[i] = new jbutton();\n            c.add(b[i]);\n        }\n        \n        //设置按钮不可用\n        b[0].settext("不可用");\n        b[0].setenabled(false);\n        \n        //设置按钮背景色\n        b[1].settext("有背景色");\n        b[1].setbackground(color.pink);\n    \n        b[2].settext("无边框");\n        b[2].setborderpainted(false);\n        \n        b[3].settext("有边框");\n        b[3].setborder(borderfactory.createlineborder(color.red));\n        \n        icon icon = new imageicon("src/imagebuttoo.jpg");\n        //给按钮设置图片\n        b[4].seticon(icon);\n        //鼠标悬停提示\n        b[4].settooltiptext("图片按钮");\n        \n        b[5].settext("可点击");\n        b[5].addactionlistener(new actionlistener() {\n            @override\n            public void actionperformed(actionevent e) {\n                joptionpane.showmessagedialog(parentform.this,"点击按钮");\n            }\n        });\n        \n        //窗体显示\n        setvisible(true);\n    }\n}\n\npublic class demo {\n    \n    public static void main(string[] args) {\n        new parentform();\n    }\n    \n}\n\n\n运行结果\n\n# jradiobutton 单选按钮\n\n> class jradiobutton\n> \n> java.lang.object java.awt.component java.awt.container javax.swing.jcomponent javax.swing.abstractbutton javax.swing.jtogglebutton javax.swing.jradiobutton\n\n显示圆形图标的按钮，旁边有说明性文字，默认情况单选按钮是单独存在的，因此需要按钮组将多个按钮放在一起使得按钮有单选效果，方法在javax.swing.abstractbutton类中\n\n构造方法\n\njradiobutton（）\n\njradiobutton（icon icon）\n\njradiobutton（icon icon , boolean selected）\n\njradiobutton（string text）\n\njradiobutton（string text , icon icon）\n\njradiobutton（string text , icon icon , boolean selected）\n\n> **icon：**图标对象 **selected：**是否选中 true：选中 **text：**标示性文字\n\n按钮组\n\n> class buttongroup\n> \n> java.lang.object javax.swing.buttongroup\n\n用于为一组按钮设置排除范围，意味着其中一个打开，则关闭组中的其他按钮\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.actionevent;\nimport java.awt.event.actionlistener;\n\n//jframe父窗体类\nclass parentform extends jframe {\n    \n    public parentform(){\n        //为父类添加标题\n        super("jframe父窗体的标题");\n        //窗体关闭规则\n        setdefaultcloseoperation(windowconstants.exit_on_close);\n        //窗体坐标，大小\n        setbounds(300,230,800,550);\n        //获取窗体容器\n        container c = getcontentpane();\n        setlayout(new flowlayout());\n        \n        jradiobutton no1 = new jradiobutton("按钮no.1");\n        jradiobutton no2 = new jradiobutton("按钮no.2");\n        jradiobutton no3 = new jradiobutton("按钮no.3",true);\n        \n        //默认选中\n//        no1.setselected(true);\n        //按钮组\n        buttongroup group = new buttongroup();\n        group.add(no1);\n        group.add(no2);\n        group.add(no3);\n        \n        c.add(no1);\n        c.add(no2);\n        c.add(no3);\n    \n        jbutton jb = new jbutton("打印");\n        jb.addactionlistener(new actionlistener() {\n            @override\n            public void actionperformed(actionevent e) {\n                system.out.println(no1.gettext()+"按钮1："+no1.isselected());\n                system.out.println(no2.gettext()+"按钮1："+no2.isselected());\n                system.out.println(no3.gettext()+"按钮1："+no3.isselected());\n                group.clearselection();//清除选中（刷新）\n            }\n        });\n        c.add(jb);\n        //窗体显示\n        setvisible(true);\n    }\n}\n\npublic class demo {\n    public static void main(string[] args) {\n        new parentform();\n    }\n}\n\n\n运行结果\n\n# jcheckbox 复选框\n\n> class jcheckbox\n> \n> java.lang.object java.awt.component java.awt.container javax.swing.jcomponent javax.swing.abstractbutton javax.swing.jtogglebutton javax.swing.jcheckbox\n\n显示方块的图标，旁边有说明性文字，可多选设置，属性设置来源 javax.swing.abstractbutton类\n\n构造方法\n\njcheckbox（）\n\njcheckbox（icon icon , boolean checked）\n\njcheckbox（string text , boolean chccked）\n\n> **icon：**图标对象 **checked：**是否选中 true：选中 **text：**标示性文字\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.actionevent;\nimport java.awt.event.actionlistener;\n\n//jframe父窗体类\nclass parentform extends jframe {\n    \n    public parentform(){\n        //为父类添加标题\n        super("jframe父窗体的标题");\n        //窗体关闭规则\n        setdefaultcloseoperation(windowconstants.exit_on_close);\n        //窗体坐标，大小\n        setbounds(300,230,800,550);\n        //获取窗体容器\n        container c = getcontentpane();\n        setlayout(new flowlayout());\n        \n        jcheckbox no1 = new jcheckbox("按钮no.1");\n        jcheckbox no2 = new jcheckbox("按钮no.2",true);\n        jcheckbox no3 = new jcheckbox("按钮no.3",false);\n        \n        //默认选中\n//        no1.setselected(true);\n//        no2.setselected(true);\n        \n        c.add(no1);\n        c.add(no2);\n        c.add(no3);\n        \n        jbutton jb = new jbutton("打印");\n        jb.addactionlistener(new actionlistener() {\n            @override\n            public void actionperformed(actionevent e) {\n                system.out.println(no1.gettext()+"按钮1："+no1.isselected());\n                system.out.println(no2.gettext()+"按钮1："+no2.isselected());\n                system.out.println(no3.gettext()+"按钮1："+no3.isselected());\n                system.out.println();\n            }\n        });\n        c.add(jb);\n        \n        //窗体显示\n        setvisible(true);\n    }\n}\n\npublic class demo {\n    public static void main(string[] args) {\n        new parentform();\n    }\n}\n\n\n运行结果\n\n\n# 列表组件\n\n# jcombobox下拉列表框\n\njcombobox下拉表框\n\n> class jcombobox\n> \n> java.lang.object java.awt.component java.awt.container javax.swing.jcomponent javax.swing.jcombobox\n\n带条状的显示区，具有下拉功能\n\n构造方法\n\njcombobox（）\n\njcombobox（comboboxmodel datamodel）\n\njcombobox（object[] arraydate）\n\njcombobox（vector vector）\n\n> **datamodel：**模型 **arraydate：**数组 **vector：**动态数组\n> \n> vector 类型实现了一个动态数组。和 数组 很相似，但是两者是不同的：\n> \n>  * vector 是同步访问的\n>  * vector 包含了许多传统的方法，这些方法不属于集合框架\n\njcombobox模型\n\n将下拉列表框中的项目封装为comboboxmodel（接口 / 模型）\n\n初始化jcombobox对象时向上转型为comboboxmodel 接口类型，必须实现以下两种方法：\n\n（void）setselecteditem（object item） 用于设置下拉列表框中的选中项\n\n（object）getselecteditem（） 用于返回下拉列表框中的选中项\n\n继承 abstractlismodel类 也有两个重要的操作：\n\ngetsize（）  返回列表的长度\n\ngetelementat（int index）  返回指定的索引处的值\n\n如果想实现调用接口，自定义一个实现 comboboxmodel接口 并继承 abstractlismodel类 的类，这样可以重写或实现该类的重要方法，初始化jcombobox对象时向上转型为comboboxmodel 接口类型即可\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.actionevent;\nimport java.awt.event.actionlistener;\n\n//jframe父窗体类\nclass parentform extends jframe {\n    \n    public parentform(){\n        //为父类添加标题\n        super("jframe父窗体的标题");\n        //窗体关闭规则\n        setdefaultcloseoperation(windowconstants.exit_on_close);\n        //窗体坐标，大小\n        setbounds(300,230,800,550);\n        //获取窗体容器\n        container c = getcontentpane();\n        setlayout(new flowlayout());\n        \n//        //初始化对象（1）\n//        jcombobox<string> combobox = new jcombobox<>();\n//        //像下拉列表添加数据\n//        combobox.additem("no.1");\n//        combobox.additem("no.2");\n//        combobox.additem("no.3");\n        \n//        //初始化对象（2）数组载入\n//        string[] str = new string[]{"no.1","no.2","no.3"};\n//        jcombobox<string> combobox = new jcombobox<>(str);\n    \n        //初始化对象（3）调用接口\n        //向上转型为comboboxmodel接口\n        comboboxmodel com = new mycombobox();\n        jcombobox combobox = new jcombobox(com);\n       \n        combobox.setbounds(21,21,80,20);\n        \n        jbutton btn = new jbutton("打印");\n        btn.addactionlistener(new actionlistener() {\n            @override\n            public void actionperformed(actionevent e) {\n                system.out.println("选中索引为："+combobox.getselectedindex());\n                system.out.println("选中的值为："+combobox.getselecteditem());\n                system.out.println("---测试2---");\n                system.out.println("下拉列表框中的个数："+com.getsize());\n                system.out.println("获取下拉列表框的项目："+com.getselecteditem());\n                system.out.println("查看下拉列表框索引2 : "+com.getelementat(2));\n                \n            }\n        });\n        \n        c.add(combobox);\n        c.add(btn);\n        //窗体显示\n        setvisible(true);\n    }\n}\n\npublic class demo {\n    public static void main(string[] args) {\n        new parentform();\n    }\n}\n\n//用于提供接口获取信息\n//模型类 继承 abstractlistmodel类 ，实现comboboxmodel接口\nclass mycombobox extends abstractlistmodel <string> implements comboboxmodel<string>{\n    \n     string g = null;\n     string[] str = new string[]{"no.1","no.2","no.3"};\n\n    //设置下拉列表框项目\n    @override\n    public void setselecteditem(object anitem) {\n        this.g = (string)anitem;\n    }\n    \n    //获取下拉列表框的项目（数据获取来源）\n    @override\n    public object getselecteditem() {\n        return this.g;\n    }\n    \n    //返回下拉列表框的数目\n    @override\n    public int getsize() {\n        return str.length;\n    }\n    \n    //返回索引值\n    @override\n    public string getelementat(int index) {\n        \n        if (index < str.length){\n            return str[index];\n        }else{\n            return null;\n        }\n        \n    }\n}\n\n\n运行结果\n\n# jlist列表框\n\n> class jlist\n> \n> java.lang.object java.awt.component java.awt.container javax.swing.jcomponent javax.swing.jlist\n\n列表框无需按钮激活，直接将内容展示出来，大小属性的列表框会限制内容展示，可用滚动面板弥补内容缺失的展示，可多选\n\n构造方法\n\njlsit（）\n\njlsit（object[] listdata）\n\njlsit（vector listdata）\n\njlsit（listmodel datamodel）\n\n> **listdata：**数组 **datamodel：**模型\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.actionevent;\nimport java.awt.event.actionlistener;\nimport java.util.vector;\n\n//jframe父窗体类\nclass parentform extends jframe {\n    \n    public parentform(){\n        //为父类添加标题\n        super("jframe父窗体的标题");\n        //窗体关闭规则\n        setdefaultcloseoperation(windowconstants.exit_on_close);\n        //窗体坐标，大小\n        setbounds(300,230,140,180);\n        //获取窗体容器\n        container c = getcontentpane();\n        setlayout(null);//new flowlayout()\n\n//        //初始化对象（1）\n//        vector<string> con = new vector<string>();\n//        jlist<string> jl = new jlist<>(con);\n//        //像下拉列表添加数据\n//        con.add("no.1");\n//        con.add("no.2");\n//        con.add("no.3");\n//        con.add("no.4");\n//        con.add("no.5");\n//        con.add("no.6");\n//        con.add("no.7");\n//        con.add("no.8");\n//        jscrollpane js = new jscrollpane(jl);\n        \n\n//        //初始化对象（2）\n//        string[] str = new string[]{"no.1","no.2","no.3","no.4","no.5","no.6","no.7","no.8"};\n//        jlist<string> jl = new jlist<>(str);\n//        jscrollpane js = new jscrollpane(jl);\n        \n        //初始化对象（3）\n        //向上转型为listmodel 接口\n        listmodel lm = new mylistmodel();\n        jlist<string> jl = new jlist<>(lm);\n        jscrollpane js = new jscrollpane(jl);\n        \n        jbutton btn = new jbutton("打印");\n        btn.addactionlistener(new actionlistener() {\n            @override\n            public void actionperformed(actionevent e) {\n                java.util.list<string> values = jl.getselectedvalueslist();\n                for (string tmp : values){\n                    system.out.println("选中的索引"+ jl.getanchorselectionindex() +"的值为："+tmp+"\\t");\n                }\n                system.out.println("中项目有："+lm.getsize());\n                system.out.println("---end---");\n            }\n        });\n    \n        js.setbounds(21,21,80,80);\n        btn.setbounds(120,21,60,30);\n        c.add(js);\n        c.add(btn);\n        //窗体显示\n        setvisible(true);\n    }\n}\n\npublic class demo {\n    public static void main(string[] args) {\n        new parentform();\n    }\n}\n\n//用于提供接口获取信息\nclass mylistmodel extends abstractlistmodel <string>{\n    \n    private string[] str = new string[]{"no.1","no.2","no.3","no.4","no.5","no.6","no.7","no.8"};\n    \n    @override\n    public int getsize() {\n        return this.str.length;\n    }\n    \n    @override\n    public string getelementat(int index) {\n        \n        if (index < str.length){\n            return str[index];\n        }else{\n            return null;\n        }\n        \n    }\n}\n\n\n运行结果\n\n\n# 文本组件\n\n# jtextfield文本框\n\n> class jtextfield\n> \n> java.lang.object java.awt.component java.awt.container javax.swing.jcomponent javax.swing.text.jtextcomponent javax.swing.jtextfield\n\n用来显示或编辑一个单行文本\n\n构造方法\n\njtextfield（） \n\njtextfield（string text）\n\njtextfield（int fieldwidth）\n\njtextfield（string text , int fieldwidth）\n\njtextfield（document docmodel , string text , int fieldwidth）\n\n> **text：**默认内容 **fieldwidth：**字体数的行长 **docmodel：**文本组件的模型\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.actionevent;\nimport java.awt.event.actionlistener;\n\n//jframe父窗体类\nclass parentform extends jframe {\n    \n    public parentform(){\n        //为父类添加标题\n        super("jframe父窗体的标题");\n        //窗体关闭规则\n        setdefaultcloseoperation(windowconstants.exit_on_close);\n        //窗体坐标，大小\n        setbounds(300,230,140,180);\n        //获取窗体容器\n        container c = getcontentpane();\n        setlayout(new flowlayout());\n        \n        //创建文本框对象（1）\n//        jtextfield jt = new jtextfield();\n//        jt.setcolumns(20);\n    \n        //创建文本框对象（2）\n//        jtextfield jt = new jtextfield("测试");\n    \n        //创建文本框对象（3）\n//        jtextfield jt = new jtextfield(20);\n    \n        //创建文本框对象（4）\n//        jtextfield jt = new jtextfield("测试" , 20);\n    \n        //创建文本框对象（5）\n        jtextfield jt = new jtextfield("测试" , 20);\n        \n        jbutton btn = new jbutton("确认");\n        btn.addactionlistener(new actionlistener() {\n            @override\n            public void actionperformed(actionevent e) {\n                //获取内容\n                system.out.println("内容为："+jt.gettext());\n                jt.settext("");//覆盖内容（清空效果）\n                jt.requestfocus();//获取焦点\n            }\n        });\n        \n        c.add(jt);\n        c.add(btn);\n        //窗体显示\n        setvisible(true);\n    }\n}\n\n\npublic class demo {\n    public static void main(string[] args) {\n        new parentform();\n    }\n}\n\n\n运行结果\n\n# jpasswordfield密码框\n\n> class jpasswordfield\n> \n> java.lang.object java.awt.component java.awt.container javax.swing.jcomponent javax.swing.text.jtextcomponent javax.swing.jtextfield javax.swing.jpasswordfield\n\n密码框与文本框定义和用法基本相同，有用户输入的字符串有字符加密功能\n\n构造方法\n\njpasswordfield（） \n\njpasswordfield（string text）\n\njpasswordfield（int fieldwidth）\n\njpasswordfield（string text , int fieldwidth）\n\njpasswordfield（document docmodel , string text , int fieldwidth）\n\n> **text：**默认内容 **fieldwidth：**字体数的行长 **docmodel：**文本组件的模型\n\n用法与上面jtextfidle文本框例子一样\n\njpasswordfield提供了一个setechochar（） 方法，可输入框中的加密回显字符\n\n# jtextarea文本域\n\n> class jtextarea\n> \n> java.lang.object java.awt.component java.awt.container javax.swing.jcomponent javax.swing.text.jtextcomponent javax.swing.jtextarea\n\n能支持多行字符的输入\n\n构造方法\n\njtextarea（） \n\njtextarea（string text）\n\njtextarea（int rows , int columns）\n\njtextarea（document doc）\n\njtextarea（document doc , string text , int rows , int columns）\n\n> **text：**默认定义的内容 rows： 行数 **columns：**列数 **doc：**文本组件模型\n\n提供方法\n\nsetlinewrap（boolean newline）  字符到达边缘自动换行\n\nimport javax.swing.*;\nimport java.awt.*;\n\n//jframe父窗体类\nclass parentform extends jframe {\n    \n    public parentform(){\n        //为父类添加标题\n        super("jframe父窗体的标题");\n        //窗体关闭规则\n        setdefaultcloseoperation(windowconstants.exit_on_close);\n        //窗体坐标，大小\n        setbounds(300,230,140,180);\n        //获取窗体容器\n        container c = getcontentpane();\n        setlayout(new flowlayout());\n    \n        //创建文本框对象（1）\n//        jtextarea area = new jtextarea();\n//        area.setrows(5);\n//        area.setcolumns(20);\n    \n        //创建文本框对象（2）\n//        jtextarea area = new jtextarea("测试");\n//        area.setrows(5);\n//        area.setcolumns(20);\n    \n        //创建文本框对象（3）\n        jtextarea area = new jtextarea(5,10);\n        \n        //到达边缘自动换行\n        area.setlinewrap(true);\n       //定义默认内容\n        area.settext("测试");\n        //内容里后面追加内容\n        area.append("123");\n        //索引位置追加内容\n        area.insert("测试2",5);\n        \n        jscrollpane js = new jscrollpane(area);\n        c.add(js);\n        //窗体显示\n        setvisible(true);\n    }\n}\n\n\npublic class demo {\n    public static void main(string[] args) {\n        new parentform();\n    }\n}\n\n\n运行结果\n\n\n# 事件监听器\n\n事件监听器，实质上是一个 实现特定类型监听器接口 的类对象，事件源 在用户做出相应动作 来产生事件对象\n\n方法\n\naddactionlistener（actionlistener act）  添加事件监听器\n\nremoveactionlistener（actionlistener act） 删除事件监听器\n\n# actionevent动作事件\n\n> class actionevent\n> \n> java.lang.object java.util.eventobject java.awt.awtevent java.awt.event.actionevent\n\n组件定义的动作发生的语义事件。 当发生组件特定操作（例如被按下）时，此事件由组件生成的\n\n使用例子：\n\n//actionlistener()  事件响应类(匿名使用\n事件源组件.addactionlistener(new actionlistener() {\n    @override\n    //事件反应方法（重写）\n    public void actionsperformed(actionevent e) {\n\t\t//响应代码\n    }\n});\n\n\n个人登录练习：\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.actionevent;\nimport java.awt.event.actionlistener;\n\n//jframe父窗体类\nclass parentform extends jframe {\n    public parentform(){\n        //为父类添加标题\n        super("jframe父窗体的标题");\n        //窗体关闭规则\n        setdefaultcloseoperation(windowconstants.exit_on_close);\n        //窗体坐标，大小\n        setbounds(300,230,300,220);\n        //获取窗体容器\n        container c = getcontentpane();\n        setlayout(null);\n        \n        jlabel bq = new jlabel("组件选择状态");\n        bq.setbounds(70 , 150,120,30);\n//        jb.setbounds(70,110,140,40);\n        c.add(bq);\n        \n        jlabel jl = new jlabel("账号：");\n        jl.setbounds(20,20,40,30);\n        c.add(jl);\n        \n        jtextfield jt = new jtextfield();\n        jt.setbounds(70,20,180,30);\n        //以下是三个属性是必要的，连写的缘故\n        jt.setfont(new font("微软雅黑",font.plain,20));\n        c.add(jt);\n        //添加动作事件监听器\n        //addactionlistener 添加监听的方法\n        //actionlistener()  事件响应类\n        jt.addactionlistener(new actionlistener() {\n            //匿名内部类\n            //actionevent：动作事件类 ，可获取组件触发···\n            @override\n            public void actionperformed(actionevent e) {\n                bq.settext("账号文本框选中以回车");\n            }\n        });\n        \n        \n        jlabel jl2 = new jlabel("密码：");\n        jl2.setbounds(20,70,40,30);\n        c.add(jl2);\n        \n        jpasswordfield jpf = new jpasswordfield();\n        jpf.setbounds(70,70,180,30);\n        jpf.setfont(new font("微软雅黑",font.plain,20));\n        c.add(jpf);\n    \n        //触发按钮立即实例jbadl类 ，因jbadl类继承了actionlistener类\n        jbadl jba =  new jbadl(bq);\n        //添加事件监听器\n        jpf.addactionlistener(jba);\n        \n        //删除事件监听器（自选控件）\n        jpf.removeactionlistener(jba);\n        \n        jbutton jb = new jbutton("登录");\n        jb.setbounds(70,110,140,40);\n        c.add(jb);\n        parentform jftmp = this;\n        //匿名类形式触发动作事件\n        jb.addactionlistener(new actionlistener() {\n            @override\n            public void actionperformed(actionevent e) {\n                bq.settext("点击了按钮");\n                if (jpf.gettext().equals("123")){\n                    new dialog(jftmp,true);\n                }else{\n                    new dialog(jftmp,false);\n                }\n\n            }\n        });\n        jb.addactionlistener(new actionlistener() {\n            @override\n            public void actionperformed(actionevent e) {\n        \n            }\n        });\n        \n        //窗体显示\n        setvisible(true);\n    }\n}\n\nclass dialog extends jdialog{\n    public dialog(parentform p , boolean happening){\n        //参数顺序： 1.父窗体对象 ， 2.对话框标题 ，3.是否堵塞父窗体\n        super(p,"消息",true);\n        //获取对话框容器\n        container c = getcontentpane();\n        if (happening){\n            c.add(new jlabel("登录成功"));\n        }else{\n            c.add(new jlabel("密码错误"));\n        }\n        //对话框坐标，大小\n        setbounds(360,300,120,100);\n        setvisible(true);\n    }\n}\n\n//思路2 外部事件相应\nclass jbadl implements actionlistener{\n\n    jlabel c;\n    \n    public jbadl(jlabel c ){\n        this.c = c;\n    }\n    @override\n    public void actionperformed(actionevent e) {\n        c.settext("密码框选中以回车");\n    }\n}\n\npublic class demo {\n    public static void main(string[] args) {\n        new parentform();\n    }\n}\n\n\n运行结果\n\n# focusevent焦点事件监听器\n\n> class focusevent java.lang.object java.util.eventobject java.awt.awtevent java.awt.event.componentevent java.awt.event.focusevent\n\n以光标视为焦点，失去或激活都会触发事件\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.focusevent;\nimport java.awt.event.focuslistener;\n\nclass parentform extends jframe{\n    public parentform(){\n        //为父类添加标题\n        super("jframe父窗体的标题");\n        //窗体关闭规则\n        setdefaultcloseoperation(windowconstants.exit_on_close);\n        //窗体坐标，大小\n        setbounds(300,230,300,220);\n        //获取窗体容器\n        container c = getcontentpane();\n        setlayout(null);\n    \n        jtextfield jt = new jtextfield();\n        jtextfield jt2 = new jtextfield();\n        jtextfield jt3 = new jtextfield();\n        jt.setbounds(20,20,180,30);\n        jt2.setbounds(20,60,180,30);\n        jt3.setbounds(20,100,180,30);\n        \n        //直接调用类，因 fet类 继承focusevent类\n        jt.addfocuslistener(new fet());\n        jt2.addfocuslistener(new fet());\n        jt3.addfocuslistener(new fet());\n        \n        c.add(jt);\n        c.add(jt2);\n        c.add(jt3);\n        \n        //窗体显示\n        setvisible(true);\n    }\n}\n\n// 继承focusevent类\nclass fet implements focuslistener {\n    \n    //获取焦点时的相应\n    @override\n    public void focusgained(focusevent e) {\n        //获取触发组件\n        jtextfield tmp = (jtextfield) e.getsource();\n        //给获取焦点的文本框设置绿色边框\n        tmp.setborder(borderfactory.createlineborder(color.green));\n    }\n    \n    //失去焦点时的相应\n    @override\n    public void focuslost(focusevent e) {\n        //获取触发组件\n        jtextfield tmp = (jtextfield) e.getsource();\n        //给获取焦点的文本框设置绿色边框\n        tmp.setborder(borderfactory.createlineborder(color.red));\n    }\n}\n\n\npublic class demo {\n    public static void main(string[] args) {\n        new parentform();\n    }\n}\n\n\n运行结果',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Java反射",frontmatter:{title:"Java反射",date:"2020-02-18T00:00:00.000Z",permalink:"/backend/y0rkxc",categories:["后端","Java基础"],tags:["Java"],author:"柏竹"},regularPath:"/01.%E5%90%8E%E7%AB%AF/01.Java%E5%9F%BA%E7%A1%80/10.%E5%8F%8D%E5%B0%84.html",relativePath:"01.后端/01.Java基础/10.反射.md",key:"v-e9056132",path:"/backend/y0rkxc/",headers:[{level:2,title:"类加载",slug:"类加载",normalizedTitle:"类加载",charIndex:13},{level:3,title:"类的生命周期",slug:"类的生命周期",normalizedTitle:"类的生命周期",charIndex:21},{level:2,title:"加载器",slug:"加载器",normalizedTitle:"加载器",charIndex:748},{level:3,title:"启动类加载器",slug:"启动类加载器",normalizedTitle:"启动类加载器",charIndex:808},{level:3,title:"扩展类加载器",slug:"扩展类加载器",normalizedTitle:"扩展类加载器",charIndex:839},{level:3,title:"应用类加载器",slug:"应用类加载器",normalizedTitle:"应用类加载器",charIndex:870},{level:3,title:"双亲委派",slug:"双亲委派",normalizedTitle:"双亲委派",charIndex:1607},{level:2,title:"反射",slug:"反射",normalizedTitle:"反射",charIndex:6},{level:3,title:"类对象",slug:"类对象",normalizedTitle:"类对象",charIndex:300},{level:3,title:"构造方法",slug:"构造方法",normalizedTitle:"构造方法",charIndex:3778},{level:3,title:"属性",slug:"属性",normalizedTitle:"属性",charIndex:613},{level:3,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:616},{level:3,title:"注解",slug:"注解",normalizedTitle:"注解",charIndex:14882},{level:4,title:"Book类",slug:"book类",normalizedTitle:"book类",charIndex:16158},{level:4,title:"注解MyAnnotationField",slug:"注解myannotationfield",normalizedTitle:"注解myannotationfield",charIndex:17888},{level:4,title:"注解MyAnnotationTable",slug:"注解myannotationtable",normalizedTitle:"注解myannotationtable",charIndex:18389},{level:2,title:"加载配置文件",slug:"加载配置文件",normalizedTitle:"加载配置文件",charIndex:18773}],headersStr:"类加载 类的生命周期 加载器 启动类加载器 扩展类加载器 应用类加载器 双亲委派 反射 类对象 构造方法 属性 方法 注解 Book类 注解MyAnnotationField 注解MyAnnotationTable 加载配置文件",content:'# Java反射\n\n\n# 类加载\n\n\n# 类的生命周期\n\n类一共有7生命周期的阶段分别为：\n\n 1. 加载\n    \n    * 通过类的 全限定名 找到 .class字节码文件，加载至JVM中\n    * JVM 在内存中生成该类的Class对象，作为入口(JVM不管多少次使用该类，而 JVM 只会生成一个该对象的Class对象)\n\n 2. 验证\n    \n    * 文件格式：检验是否符合 .class文件、头文件等\n    * 元数据：(以下说明)\n    * 字节码：检验 代码 语句/逻辑 是否符合\n    * 字符引用：检验 类路径/修饰符的使用 是否符合\n\n 3. 准备 如果该类有类对象(类被加载生成的Class对象)，则开始为该类进行分配内存空间以及赋予初始化的值。例如：\n    \n    // 该阶段是 赋予的值是初始值0，而不是赋值18\n    public static int age = 18;\n    // 因为常量，赋予的值不是初始值，而是赋值18\n    public static final int  age = 18;\n    \n\n 4. 解析 将常量池的 符号引用 替换为 直接引用\n\n 5. 初始化\n    \n    * 执行类构造器\n    * 如果有 静态变量，静态代码块，则在上一阶段被执行\n    * 如果有 父类，则先执行其父类的构造器\n\n 6. 使用 调用实例的 属性/方法\n\n 7. 卸载 JVM垃圾回收\n\n> 元数据：\n> \n>  1. 是否有父类\n>  2. 是否继承了不允许被继承的类 (final修饰)\n>  3. 如果该类不是抽象类，是否实现其 父类/接口 中的实现方法\n>  4. 类中的 字段/方法 是否无误\n\n\n# 加载器\n\n负责把 .class字节码文件 加载到 JVM内存 中，并且生成对象\n\nJVM中默认有三种类加载器：\n\n * 启动类加载器 BootstrapClassLoader\n * 扩展类加载器 ExtensionClassLoader\n * 应用类加载器 App ClassLoader\n\n\n# 启动类加载器\n\n启动类加载器 BootstrapClassLoader，Java类加载器是根据类全限定名(包含有包路径)来读取类的 二进制字节流 到 JVM 中，然后加载到JVM的内存中\n\n * 主要加载 jre/lib 核心库\n * 通过 C++ 进行创建（本地系统语言代码）\n * 开发者不能直接 调用该库进行操作\n\n\n# 扩展类加载器\n\n扩展类加载器 ExtensionClassLoader 是Java编写，且它的父类加载器是启动类加载器 由 sun.misc.Launcher$ExtClassLoader类 实现，主要加载 JAVA_HOME/lib/ext 目录中的类库(也可以更改系统里的环境变量，指定路径目录)\n\n * 主要加载 lib/ext 下的库文件\n * 通过 Java执行\n * 开发者 可以使用标准扩展类加载器\n\n\n# 应用类加载器\n\n应用类加载器 App ClassLoader，且它的父类加载器是 扩展类加载器 由 sun.misc.Launcher$AppClassLoader类 实现，主要加载应用程序 java -classpath/-Djava.class.path 目录下所有 jar和class文件\n\n * 主要加载 开发者 自己编写的类\n * 通过 Java执行\n\n类加载器间的关系\n\n * 启动类加载器，由C++实现，没有父类\n * 扩展类加载器，由Java实现，父类加载器 启动类加载器\n * 应用类加载器，由Java实现，父类加载器 扩展类加载器\n\n类加载器的唯一性\n\nJVM中有两个类，判断两类是否相同，前提两类是同一个加载器加载的！否则它们不是同一个类\n\n\n# 双亲委派\n\n\n\n它们并非是通常的类继承关系，而是采用组合关系来复用父类加载器的方式加载！\n\n工作原理\n\n类加载器收到类加载请求，它并不会自己去加载，而是把请求委托给父类的加载器去执行加载，如果父类加载器还存在有父类加载器，则进一步向上委托，以此传递请求委托，直至 顶层的启动类加载器。如果顶层加载器加载失败，则将请求返回给 子加载器 尝试自己去加载，依旧向下传递委托。如果加载器完成类加载，则直接成功返回，无需传递请求！委派的好处就是避免有些类被重复加载\n\n> 故事描述： (坑爹)\n> \n> 他爸生有两个儿子，儿子特别懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子只好自己想办法去完成。。。\n\n顶层类加载器是ClassLoader类 , 是一个抽象类，loadClass()方法是ClassLoader类自己实现的，该方法中的逻辑就是双亲委派模式的实现，代码示例：\n\nprotected synchronized Class<?> loadClass(String name , boolean resolve) throws ClassNotFoundException{\n    //检查是否被加载\n    Class c = findLoadedClass(name);\n    //如果没加载，则调用父类加载器\n    if(c == null){\n        try{\n            //父类加载器不为空\n            if(this.parent != null){\n                // 请求委托给父类\n                c = this.parent.c(name , false);\n            }else{\n                //父类加载器为空，则使用启动类加载器（执行到这里代表加载到顶层加载器）\n                c = findBootstrapClassOrNull(name);\n            }\n        }catch(ClassNotFoundException e){\n            //如果父类加载器加载失败，则抛回给子类运行\n            c = findClass(name);\n        }\n    }\n    if(resolve){\n        resolveClass(c);\n    }\n    return c;\n}\n\n\n\n# 反射\n\nJava反射机制，可以在程序中访问 已经写好类和方法 的Java对象的描述，实现访问、检测、修改Java本身的信息 等功能\n\n * 运行中获取\n * 解析类\n * 操作类\n\n\n# 类对象\n\njava.lang.Class<T> 类对象 是描述类的类\n\n> 获取对象类的类的前提，必须该类在运行时已经加载至内存(JVM在加载器会自动加载)\n\n获取类对象的方式\n\n 1. 静态方法 ==Class.forName(全限定名)==\n 2. 对象方法 ==实例对象.getClass()==\n 3. 对象属性 ==实例对象.class==\n\n> 注意：\n> \n>  * 在调用时, 如果类在内存中不存在, 则会加载到内存! 如果类已经在内存中存在, 不会重复加载, 而是重复利用 !\n>  * Class类对象 不管获取多少个相同的对象，它们的地址始终都是一样\n\npackage com.sans;\n\n// 类的获取\npublic class Demo {\n    public static void main(String[] args) throws ClassNotFoundException {\n       \n        Class class1 = Class.forName("com.sans.People");\n        Class class2 = com.sans.People.class;\n        People people = new People();\n        Class class3 = people.getClass();\n    \n        System.out.println(class1);\n        System.out.println(class2);\n        System.out.println(class3);\n        \n        // 比较地址\n        System.out.println(class1 == class2);\n        System.out.println(class1 == class3);\n        System.out.println(class2 == class3);\n    }\n}\nclass People{}\n\n/** 控制台结果\n class com.sans.People\n class com.sans.People\n class com.sans.People\n true\n true\n true\n */\n\n\n\n# 构造方法\n\njava.lang.reflect.Constructor<T> 反射应用的 构造方法 对象\n\n获取构造方法 的前提 需要获取指定类的对象。通过类对象的方法获取构造方法\n\n获取构造方法：\n\n返回              方法                                                      说明\nConstructor     ==getConstructor(Class<?>···parameterTypes)==           获取 权限为public的指定构造方法\n                示例：==getConstructor(int.class,String.class)==\nConstructor[]   ==getConstructors()==                                   获取 所有权限为public的构造方法\nConstructor     ==getDeclaredConstructor(Class<?>···parameterTypes)==   获取 所有权限的单个构造方法\nConstructor[]   ==getDeclaredConstructors()==                           获取 所有权限的全部构造方法，按声明顺序排列(所有权限)\n\nConstructor类 常用方法： (获取更多方法自行API)\n\n返回         方法                                    说明\nString     ==getName()==                         获取 构造方法的名字\nClass[]    ==getParameterTypes()==               获取 构造方法参数类型的数组\nboolean    ==isVarArgs()==                       是否带有可变数量的参数\nClass[]    ==getExceptionTypes()==               获取 构造方法可能抛出的异常类型\nObject T   ==newInstance(Object··· initargs)==   指定参数创建 该类对象的构造方法。如方法无参，则创建无参的构造方法\nvoid       ==setAccessible(boolean bool)==       是否无视访问权限检查\n\n通过 java.lang.reflect.Modifier类 来解析部分无法识别 构造方法 的信息，比如==getModifiers()== 返回的值是需要解析的\n\npackage com.sans.constructor;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        \n        Class<Student> sClass = (Class<Student>) Class.forName("com.sans.constructor.Student");\n        \n        //No.1 获取无参\n        Constructor<Student> c1 = sClass.getConstructor();\n        Student s = c1.newInstance();\n        System.out.println(s);\n        \n        System.out.println("==============");\n        \n        //No.2 获取指定参数类型的\n        Constructor<Student> c2 = sClass.getConstructor(String.class , int.class);\n        Student s2 = c2.newInstance("张三" , 22);\n        System.out.println(s2);\n        \n        System.out.println("==============");\n        \n        //No.3 获取所有权限及构造方法\n        Constructor<Student>[] c3 = (Constructor<Student>[]) sClass.getDeclaredConstructors();\n        Student s3;\n        for (Constructor<Student> container : c3) {\n            System.out.println(container);\n        }\n        \n        \n    }\n}\n\nclass Student {\n    String name;\n    int age;\n    \n    public Student(){}\n    \n    private Student(String...strs){\n        for (String s : strs) {\n            System.out.println(s);\n        }\n    }\n    \n    public Student(String name , int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    @Override\n    public String toString() {\n        return "Student{" +\n                "name=\'" + name + \'\\\'\' +\n                ", age=" + age +\n                \'}\';\n    }\n}\n\n/*\t控制台结果\n\nStudent{name=\'null\', age=0}\n==============\nStudent{name=\'张三\', age=22}\n==============\npublic com.sans.constructor.Student(java.lang.String,int)\nprivate com.sans.constructor.Student(java.lang.String[])\npublic com.sans.constructor.Student()\n\n*/\n\n\n\n# 属性\n\njava.lang.reflect.Field 反射应用的 属性 对象 通过方法访问成员变量，将返回Field类型对象，每个Field对象代表一个成员变量 **注意： ** 属性必须要有修饰符修饰才可以获取类属性\n\n获取属性\n\n返回        方法                                  说明\nField     ==getField(String name)==           获取 指定属性\nField     ==getDeclaredField(String name)==   获取 所有权限的 指定属性\nField[]   ==getFields()==                     获取 所有属性\nField[]   ==getDeclaredFields()==             获取 所有权限的全部属性，按声明顺序排列\n\nField类 常用方法 (获取更多方法自行API)\n\n返回       方法                                   说明\nString   ==getName()==                        获取 属性名\nclass    ==getType()==                        获取 该是属性类型的class对象\nObject   ==get(Object obj)==                  指定对象obj中成员变量的值进行返回\nvoid     ==set(Object obj , Object value)==   指定对象obj中成员变量的值置为value\nvoid     ==setAccessible(boolean flag)==      设置是否忽略权限限制直接访问私有成员\nint      ==getModifiers()==                   获取该成员变量修饰符的整型\n\npackage com.sans.field;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        \n        // 反射实例对象\n        Class<Person> aClass = (Class<Person>) Class.forName("com.sans.field.Person");\n        Constructor<Person> ct = aClass.getConstructor(String.class, int.class, String.class);\n        Object o = ct.newInstance("柏竹" , 20 , "18122335634");\n        \n        //No.1 直接获取\n        Field name = aClass.getField("name");\n        System.out.println(name);\n        \n        System.out.println("=============");\n        \n        //No.2 获取所有权限 获取手机号码 private获取\n        Field phoneNumber = aClass.getDeclaredField("phoneNumber");\n        // 无视权限访问\n        phoneNumber.setAccessible(true);\n        System.out.println(phoneNumber);\n        \n        System.out.println("=============");\n        \n        //No.3 获取 所有属性\n        //无法访问私有属性\n        for (Field tmp : aClass.getFields()) {\n            System.out.println(tmp);\n        }\n        \n        System.out.println("=============");\n        \n        /*\n         * 方法使用\n         * */\n        System.out.println("------获取属性名");\n        System.out.println(" ["+phoneNumber.getName()+"] ");\n        \n        System.out.println("------获取属性类型");\n        System.out.println(" ["+phoneNumber.getType()+"] ");\n        \n        System.out.println("------获取属性值");\n        System.out.println(" ["+phoneNumber.get(o)+"] ");\n        \n        System.out.println("------设置属性值");\n        phoneNumber.set(o , "18122334455");\n        System.out.println(" ["+o+"] ");\n    }\n}\n\nclass Person{\n    public String name;\n    public int age;\n    private String phoneNumber;\n    \n    public Person() {\n    }\n    \n    public Person(String name , int age , String phoneNumber) {\n        this.name = name;\n        this.age = age;\n        this.phoneNumber = phoneNumber;\n    }\n    \n    @Override\n    public String toString() {\n        return "Person{" +\n                "name=\'" + name + \'\\\'\' +\n                ", age=" + age +\n                ", phoneNumber=" + phoneNumber +\n                \'}\';\n    }\n}\n\n/* 控制台结果\n\npublic java.lang.String com.sans.field.Person.name\n=============\nprivate java.lang.String com.sans.field.Person.phoneNumber\n=============\npublic java.lang.String com.sans.field.Person.name\npublic int com.sans.field.Person.age\n=============\n------获取属性名\n [phoneNumber] \n------获取属性类型\n [class java.lang.String] \n------获取属性值\n [18122335634] \n------设置属性值\n [Person{name=\'柏竹\', age=20, phoneNumber=18122334455}] \n\n*/\n\n\n\n# 方法\n\njava.lang.reflect.Method 反射应用的 方法 对象\n\n通过类的方法访问方法，将返回Method类型对象，每个Method对象代表一个方法\n\n获取类的方法\n\n返回         方法                                                        说明\nMethod     ==getMethod(String name , Class<?>····parameterTypes)==   获取指定方法\nMethod     ==getDeclaredMethod(String name ,                         获取所有权限的 指定方法\n           Class<?>····parameterTypes)==\nMethod[]   ==ethods()==                                              获取所有权限的指定方法\nMethod[]   ==getDeclaredMethods()==                                  获取 所有权限的全部方法，按声明顺序排列\n\nMethod类 常用方法 (获取更多方法自行API)\n\n返回        方法                                         说明\nString    ==getName()==                              获取方法名称\nClass[]   ==getParameterTypes()==                    获取参数的类型\nClass     ==getReturnType()==                        获取方法返回的类型\nClass[]   ==getExceptionTypes()==                    返回方法抛出的异常类型\nObject    ==invoke(Object obj , Object ... args)==   指定参数args指定obj方法(obj 类/方法)？\nBoolean   ==isVarArgs()==                            带有可变数量的参数，则true\nint       ==getModifiers()==                         获取方法的修饰符(呈现形式整数)\nvoid      ==setAccessible(boolean bool)==            是否无视访问权限检查\n\npackage com.sans.method;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\n\npublic class Test {\n    public static void main(String[] args) throws Exception {\n        \n        Class<Person> aClass = (Class<Person>) Class.forName("com.sans.method.Person");\n        //获取 类构造方法\n        Constructor<Person> constructor = aClass.getConstructor(String.class , int.class);\n        //获取 类实例的对象\n        Object o = constructor.newInstance("柏竹" , 20);\n        \n        /*No.1\n         * 直接获取\n         * */\n        Method setName = aClass.getMethod("setName" , String.class);\n        Method getName = aClass.getMethod("getName");\n        System.out.println(setName);\n        System.out.println(getName);\n        \n        System.out.println("===================");\n        \n        /*No.2\n         *   获取所有权限 获取setAge()方法\n         * */\n        Method setAge = aClass.getDeclaredMethod("setAge", int.class);\n        System.out.println(setAge);\n        \n        System.out.println("===================");\n        \n        /*No.3\n         *   获取所有方法\n         * */\n        Method[] methods = aClass.getDeclaredMethods();\n        //无视权限进行测试使用\n        for (Method tmp : methods) {\n            System.out.println(tmp);\n        }\n        \n        System.out.println("===================");\n        \n        /*\n         * 方法使用\n         * */\n        System.out.println("\\n-----模拟使用方法");\n        //获取 该方法所有权限\n        setAge.setAccessible(true);\n        System.out.println("使用前 ： "+o);\n        setAge.invoke(o , 24);\n        System.out.println("使用后 ： "+o);\n        \n        System.out.println("\\n-----获取方法名");\n        System.out.println(" ["+setAge.getName()+"] ");\n        \n        System.out.println("\\n-----获取方法参数类型");\n        Method test = aClass.getMethod("test", String.class, int[].class);\n        for (Class tmp : test.getParameterTypes()) {\n            System.out.println(" ["+tmp+"] ");\n        }\n        \n        System.out.println("\\n-----获取方法返回类型");\n        System.out.println(" ["+getName.getReturnType()+"] ");\n        \n    }\n}\n\nclass Person{\n    String name;\n    int age;\n    \n    public Person() {\n    }\n    \n    public Person(String name , int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    public String getName() {\n        return name;\n    }\n    \n    public void setName(String name) {\n        this.name = name;\n    }\n    \n    public int getAge() {\n        return age;\n    }\n    \n    /**\n     * 私有修饰\n     * @param age\n     */\n    private void setAge(int age) {\n        this.age = age;\n    }\n    \n    public void test(String str , int...numAll){\n        System.out.println("参数方法测试");\n    }\n    \n    @Override\n    public String toString() {\n        return "person{" +\n                "name=\'" + name + \'\\\'\' +\n                ", age=" + age +\n                \'}\';\n    }\n}\n\n/*\n\npublic void com.sans.method.Person.setName(java.lang.String)\npublic java.lang.String com.sans.method.Person.getName()\n===================\nprivate void com.sans.method.Person.setAge(int)\n===================\nprivate void com.sans.method.Person.setAge(int)\npublic int com.sans.method.Person.getAge()\npublic java.lang.String com.sans.method.Person.toString()\npublic java.lang.String com.sans.method.Person.getName()\npublic void com.sans.method.Person.setName(java.lang.String)\npublic void com.sans.method.Person.test(java.lang.String,int[])\n===================\n\n-----模拟使用方法\n使用前 ： person{name=\'柏竹\', age=20}\n使用后 ： person{name=\'柏竹\', age=24}\n\n-----获取方法名\n [setAge] \n\n-----获取方法参数类型\n [class java.lang.String] \n [class [I] \n\n-----获取方法返回类型\n [class java.lang.String] \n\n*/\n\n\n\n# 注解\n\njava.text.Annotation 类型未了解，可前去网址了解：点击了解\n\n访问的前提注解要有该注解@Retention(RetentionPolicy.RUNTIME)\n\n获取注解\n\n返回             方法                                         说明\nAnnotation     ==getAnnotation(Class annotationClass)==   获取指定的Annotation，不存在则返回null\nAnnotation[]   ==getAnnotations()==                       获取所有的Annotation\n\npackage kkb;\n\nimport java.lang.reflect.Field;\n\npublic class Demo {\n    public static void main(String[] args) throws Exception {\n        Class<Book> aClass = (Class<Book>) Class.forName("kkb.Book");\n        \n        //通过反射 表详细\n        MyAnnotationTable at = aClass.getAnnotation(MyAnnotationTable.class);\n        String value = at.tableName();\n        System.out.println("表名 : " + value);\n        \n        //属性\n        for (Field tmp : aClass.getDeclaredFields()) {\n            MyAnnotationField af = tmp.getAnnotation(MyAnnotationField.class);\n            System.out.println(tmp.getName() +\n                    "属性 ， 对应数据库中的字段为 : "+ af.name()+\n                    " ， 数据类型 ： "+af.type()+\n                    " , 数据长度 ： "+af.length()\n            );\n        }\n    }\n}\n/*\n\n表名 : test_Book\nid属性 ， 对应数据库中的字段为 : id ， 数据类型 ： int , 数据长度 ： 20\nname属性 ， 对应数据库中的字段为 : name ， 数据类型 ： varchar , 数据长度 ： 50\ninfo属性 ， 对应数据库中的字段为 : info ， 数据类型 ： varchar , 数据长度 ： 200\n\n*/\n\n\n# Book类\n\npackage kkb;\n\nimport java.util.Objects;\n\n/**\n * @Author: 柏竹\n * @Description: 一个简洁主义...\n * @Date_Created_in: 2021-03-06 16:44\n * @Modified_By:\n * @Project： 数据\n */\n@MyAnnotationTable(tableName = "test_Book")\npublic class Book {\n    @MyAnnotationField(name = "id" , type = "int" , length = 20)\n    private int id;\n    @MyAnnotationField(name = "name" , type = "varchar" , length = 50)\n    private String name;\n    @MyAnnotationField(name = "info" , type = "varchar" , length = 200)\n    private String info;\n    \n    public Book() {\n    }\n    \n    public Book(int id , String name , String info) {\n        this.id = id;\n        this.name = name;\n        this.info = info;\n    }\n    \n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Book book = (Book) o;\n        return id == book.id &&\n                Objects.equals(name , book.name) &&\n                Objects.equals(info , book.info);\n    }\n    \n    @Override\n    public int hashCode() {\n        return Objects.hash(id , name , info);\n    }\n    \n    public int getId() {\n        return id;\n    }\n    \n    public void setId(int id) {\n        this.id = id;\n    }\n    \n    public String getName() {\n        return name;\n    }\n    \n    public void setName(String name) {\n        this.name = name;\n    }\n    \n    public String getInfo() {\n        return info;\n    }\n    \n    public void setInfo(String info) {\n        this.info = info;\n    }\n    \n    @Override\n    public String toString() {\n        return "Book{" +\n                "id=" + id +\n                ", name=\'" + name + \'\\\'\' +\n                ", info=\'" + info + \'\\\'\' +\n                \'}\';\n    }\n}\n\n\n# 注解MyAnnotationField\n\npackage kkb;\n\nimport java.lang.annotation.*;\n\n/**\n * @Author: 柏竹\n * @Description: 一个简洁主义...\n * @Date_Created_in: 2021-03-06 16:34\n * @Modified_By:\n * @Project： 字段\n */\n@Inherited\n@Documented\n@Target (ElementType.FIELD)\n@Retention (RetentionPolicy.RUNTIME)\npublic @interface MyAnnotationField {\n    /**\n     * 列名\n     * @return\n     */\n    String name();\n    /**\n     * 类型\n     * @return\n     */\n    String type();\n    /**\n     * 数据长度\n     * @return\n     */\n    int length();\n}\n\n\n# 注解MyAnnotationTable\n\npackage kkb;\n\nimport java.lang.annotation.*;\n\n/**\n * @Author: 柏竹\n * @Description: 一个简洁主义...\n * @Date_Created_in: 2021-03-06 16:32\n * @Modified_By:\n * @Project： 表名\n */\n@Inherited\n@Documented\n@Target(ElementType.TYPE)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface MyAnnotationTable {\n    /**\n     * 表名称\n     * @return\n     */\n    String tableName();\n}\n\n\n\n# 加载配置文件\n\n给项目添加根路径： 项目右键 -> 新建文件夹 -> 设置名 source -> 右键创建的文件夹 -> 标记项目为 -> 资源 根 即可\n\n\n\n一般类加载器 加载资源文件默认是src路径下的文件，但是当项目存在 资源根 加载文件这就是该文件夹设置的根！\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\n\npublic class Demo {\n    public static void main(String[] args) throws IOException {\n        InputStream is = Demo.class.getClassLoader().getResourceAsStream("test.txt");\n        BufferedReader br = null;\n        if (is != null) {\n            br = new BufferedReader(new InputStreamReader(is));\n        }\n        if (br != null){\n            System.out.println(br.readLine());\n            br.close();\n        }\n    }\n}\n',normalizedContent:'# java反射\n\n\n# 类加载\n\n\n# 类的生命周期\n\n类一共有7生命周期的阶段分别为：\n\n 1. 加载\n    \n    * 通过类的 全限定名 找到 .class字节码文件，加载至jvm中\n    * jvm 在内存中生成该类的class对象，作为入口(jvm不管多少次使用该类，而 jvm 只会生成一个该对象的class对象)\n\n 2. 验证\n    \n    * 文件格式：检验是否符合 .class文件、头文件等\n    * 元数据：(以下说明)\n    * 字节码：检验 代码 语句/逻辑 是否符合\n    * 字符引用：检验 类路径/修饰符的使用 是否符合\n\n 3. 准备 如果该类有类对象(类被加载生成的class对象)，则开始为该类进行分配内存空间以及赋予初始化的值。例如：\n    \n    // 该阶段是 赋予的值是初始值0，而不是赋值18\n    public static int age = 18;\n    // 因为常量，赋予的值不是初始值，而是赋值18\n    public static final int  age = 18;\n    \n\n 4. 解析 将常量池的 符号引用 替换为 直接引用\n\n 5. 初始化\n    \n    * 执行类构造器\n    * 如果有 静态变量，静态代码块，则在上一阶段被执行\n    * 如果有 父类，则先执行其父类的构造器\n\n 6. 使用 调用实例的 属性/方法\n\n 7. 卸载 jvm垃圾回收\n\n> 元数据：\n> \n>  1. 是否有父类\n>  2. 是否继承了不允许被继承的类 (final修饰)\n>  3. 如果该类不是抽象类，是否实现其 父类/接口 中的实现方法\n>  4. 类中的 字段/方法 是否无误\n\n\n# 加载器\n\n负责把 .class字节码文件 加载到 jvm内存 中，并且生成对象\n\njvm中默认有三种类加载器：\n\n * 启动类加载器 bootstrapclassloader\n * 扩展类加载器 extensionclassloader\n * 应用类加载器 app classloader\n\n\n# 启动类加载器\n\n启动类加载器 bootstrapclassloader，java类加载器是根据类全限定名(包含有包路径)来读取类的 二进制字节流 到 jvm 中，然后加载到jvm的内存中\n\n * 主要加载 jre/lib 核心库\n * 通过 c++ 进行创建（本地系统语言代码）\n * 开发者不能直接 调用该库进行操作\n\n\n# 扩展类加载器\n\n扩展类加载器 extensionclassloader 是java编写，且它的父类加载器是启动类加载器 由 sun.misc.launcher$extclassloader类 实现，主要加载 java_home/lib/ext 目录中的类库(也可以更改系统里的环境变量，指定路径目录)\n\n * 主要加载 lib/ext 下的库文件\n * 通过 java执行\n * 开发者 可以使用标准扩展类加载器\n\n\n# 应用类加载器\n\n应用类加载器 app classloader，且它的父类加载器是 扩展类加载器 由 sun.misc.launcher$appclassloader类 实现，主要加载应用程序 java -classpath/-djava.class.path 目录下所有 jar和class文件\n\n * 主要加载 开发者 自己编写的类\n * 通过 java执行\n\n类加载器间的关系\n\n * 启动类加载器，由c++实现，没有父类\n * 扩展类加载器，由java实现，父类加载器 启动类加载器\n * 应用类加载器，由java实现，父类加载器 扩展类加载器\n\n类加载器的唯一性\n\njvm中有两个类，判断两类是否相同，前提两类是同一个加载器加载的！否则它们不是同一个类\n\n\n# 双亲委派\n\n\n\n它们并非是通常的类继承关系，而是采用组合关系来复用父类加载器的方式加载！\n\n工作原理\n\n类加载器收到类加载请求，它并不会自己去加载，而是把请求委托给父类的加载器去执行加载，如果父类加载器还存在有父类加载器，则进一步向上委托，以此传递请求委托，直至 顶层的启动类加载器。如果顶层加载器加载失败，则将请求返回给 子加载器 尝试自己去加载，依旧向下传递委托。如果加载器完成类加载，则直接成功返回，无需传递请求！委派的好处就是避免有些类被重复加载\n\n> 故事描述： (坑爹)\n> \n> 他爸生有两个儿子，儿子特别懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子只好自己想办法去完成。。。\n\n顶层类加载器是classloader类 , 是一个抽象类，loadclass()方法是classloader类自己实现的，该方法中的逻辑就是双亲委派模式的实现，代码示例：\n\nprotected synchronized class<?> loadclass(string name , boolean resolve) throws classnotfoundexception{\n    //检查是否被加载\n    class c = findloadedclass(name);\n    //如果没加载，则调用父类加载器\n    if(c == null){\n        try{\n            //父类加载器不为空\n            if(this.parent != null){\n                // 请求委托给父类\n                c = this.parent.c(name , false);\n            }else{\n                //父类加载器为空，则使用启动类加载器（执行到这里代表加载到顶层加载器）\n                c = findbootstrapclassornull(name);\n            }\n        }catch(classnotfoundexception e){\n            //如果父类加载器加载失败，则抛回给子类运行\n            c = findclass(name);\n        }\n    }\n    if(resolve){\n        resolveclass(c);\n    }\n    return c;\n}\n\n\n\n# 反射\n\njava反射机制，可以在程序中访问 已经写好类和方法 的java对象的描述，实现访问、检测、修改java本身的信息 等功能\n\n * 运行中获取\n * 解析类\n * 操作类\n\n\n# 类对象\n\njava.lang.class<t> 类对象 是描述类的类\n\n> 获取对象类的类的前提，必须该类在运行时已经加载至内存(jvm在加载器会自动加载)\n\n获取类对象的方式\n\n 1. 静态方法 ==class.forname(全限定名)==\n 2. 对象方法 ==实例对象.getclass()==\n 3. 对象属性 ==实例对象.class==\n\n> 注意：\n> \n>  * 在调用时, 如果类在内存中不存在, 则会加载到内存! 如果类已经在内存中存在, 不会重复加载, 而是重复利用 !\n>  * class类对象 不管获取多少个相同的对象，它们的地址始终都是一样\n\npackage com.sans;\n\n// 类的获取\npublic class demo {\n    public static void main(string[] args) throws classnotfoundexception {\n       \n        class class1 = class.forname("com.sans.people");\n        class class2 = com.sans.people.class;\n        people people = new people();\n        class class3 = people.getclass();\n    \n        system.out.println(class1);\n        system.out.println(class2);\n        system.out.println(class3);\n        \n        // 比较地址\n        system.out.println(class1 == class2);\n        system.out.println(class1 == class3);\n        system.out.println(class2 == class3);\n    }\n}\nclass people{}\n\n/** 控制台结果\n class com.sans.people\n class com.sans.people\n class com.sans.people\n true\n true\n true\n */\n\n\n\n# 构造方法\n\njava.lang.reflect.constructor<t> 反射应用的 构造方法 对象\n\n获取构造方法 的前提 需要获取指定类的对象。通过类对象的方法获取构造方法\n\n获取构造方法：\n\n返回              方法                                                      说明\nconstructor     ==getconstructor(class<?>···parametertypes)==           获取 权限为public的指定构造方法\n                示例：==getconstructor(int.class,string.class)==\nconstructor[]   ==getconstructors()==                                   获取 所有权限为public的构造方法\nconstructor     ==getdeclaredconstructor(class<?>···parametertypes)==   获取 所有权限的单个构造方法\nconstructor[]   ==getdeclaredconstructors()==                           获取 所有权限的全部构造方法，按声明顺序排列(所有权限)\n\nconstructor类 常用方法： (获取更多方法自行api)\n\n返回         方法                                    说明\nstring     ==getname()==                         获取 构造方法的名字\nclass[]    ==getparametertypes()==               获取 构造方法参数类型的数组\nboolean    ==isvarargs()==                       是否带有可变数量的参数\nclass[]    ==getexceptiontypes()==               获取 构造方法可能抛出的异常类型\nobject t   ==newinstance(object··· initargs)==   指定参数创建 该类对象的构造方法。如方法无参，则创建无参的构造方法\nvoid       ==setaccessible(boolean bool)==       是否无视访问权限检查\n\n通过 java.lang.reflect.modifier类 来解析部分无法识别 构造方法 的信息，比如==getmodifiers()== 返回的值是需要解析的\n\npackage com.sans.constructor;\n\nimport java.lang.reflect.constructor;\nimport java.lang.reflect.invocationtargetexception;\n\npublic class test {\n    public static void main(string[] args) throws exception {\n        \n        class<student> sclass = (class<student>) class.forname("com.sans.constructor.student");\n        \n        //no.1 获取无参\n        constructor<student> c1 = sclass.getconstructor();\n        student s = c1.newinstance();\n        system.out.println(s);\n        \n        system.out.println("==============");\n        \n        //no.2 获取指定参数类型的\n        constructor<student> c2 = sclass.getconstructor(string.class , int.class);\n        student s2 = c2.newinstance("张三" , 22);\n        system.out.println(s2);\n        \n        system.out.println("==============");\n        \n        //no.3 获取所有权限及构造方法\n        constructor<student>[] c3 = (constructor<student>[]) sclass.getdeclaredconstructors();\n        student s3;\n        for (constructor<student> container : c3) {\n            system.out.println(container);\n        }\n        \n        \n    }\n}\n\nclass student {\n    string name;\n    int age;\n    \n    public student(){}\n    \n    private student(string...strs){\n        for (string s : strs) {\n            system.out.println(s);\n        }\n    }\n    \n    public student(string name , int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    @override\n    public string tostring() {\n        return "student{" +\n                "name=\'" + name + \'\\\'\' +\n                ", age=" + age +\n                \'}\';\n    }\n}\n\n/*\t控制台结果\n\nstudent{name=\'null\', age=0}\n==============\nstudent{name=\'张三\', age=22}\n==============\npublic com.sans.constructor.student(java.lang.string,int)\nprivate com.sans.constructor.student(java.lang.string[])\npublic com.sans.constructor.student()\n\n*/\n\n\n\n# 属性\n\njava.lang.reflect.field 反射应用的 属性 对象 通过方法访问成员变量，将返回field类型对象，每个field对象代表一个成员变量 **注意： ** 属性必须要有修饰符修饰才可以获取类属性\n\n获取属性\n\n返回        方法                                  说明\nfield     ==getfield(string name)==           获取 指定属性\nfield     ==getdeclaredfield(string name)==   获取 所有权限的 指定属性\nfield[]   ==getfields()==                     获取 所有属性\nfield[]   ==getdeclaredfields()==             获取 所有权限的全部属性，按声明顺序排列\n\nfield类 常用方法 (获取更多方法自行api)\n\n返回       方法                                   说明\nstring   ==getname()==                        获取 属性名\nclass    ==gettype()==                        获取 该是属性类型的class对象\nobject   ==get(object obj)==                  指定对象obj中成员变量的值进行返回\nvoid     ==set(object obj , object value)==   指定对象obj中成员变量的值置为value\nvoid     ==setaccessible(boolean flag)==      设置是否忽略权限限制直接访问私有成员\nint      ==getmodifiers()==                   获取该成员变量修饰符的整型\n\npackage com.sans.field;\n\nimport java.lang.reflect.constructor;\nimport java.lang.reflect.field;\n\npublic class test {\n    public static void main(string[] args) throws exception {\n        \n        // 反射实例对象\n        class<person> aclass = (class<person>) class.forname("com.sans.field.person");\n        constructor<person> ct = aclass.getconstructor(string.class, int.class, string.class);\n        object o = ct.newinstance("柏竹" , 20 , "18122335634");\n        \n        //no.1 直接获取\n        field name = aclass.getfield("name");\n        system.out.println(name);\n        \n        system.out.println("=============");\n        \n        //no.2 获取所有权限 获取手机号码 private获取\n        field phonenumber = aclass.getdeclaredfield("phonenumber");\n        // 无视权限访问\n        phonenumber.setaccessible(true);\n        system.out.println(phonenumber);\n        \n        system.out.println("=============");\n        \n        //no.3 获取 所有属性\n        //无法访问私有属性\n        for (field tmp : aclass.getfields()) {\n            system.out.println(tmp);\n        }\n        \n        system.out.println("=============");\n        \n        /*\n         * 方法使用\n         * */\n        system.out.println("------获取属性名");\n        system.out.println(" ["+phonenumber.getname()+"] ");\n        \n        system.out.println("------获取属性类型");\n        system.out.println(" ["+phonenumber.gettype()+"] ");\n        \n        system.out.println("------获取属性值");\n        system.out.println(" ["+phonenumber.get(o)+"] ");\n        \n        system.out.println("------设置属性值");\n        phonenumber.set(o , "18122334455");\n        system.out.println(" ["+o+"] ");\n    }\n}\n\nclass person{\n    public string name;\n    public int age;\n    private string phonenumber;\n    \n    public person() {\n    }\n    \n    public person(string name , int age , string phonenumber) {\n        this.name = name;\n        this.age = age;\n        this.phonenumber = phonenumber;\n    }\n    \n    @override\n    public string tostring() {\n        return "person{" +\n                "name=\'" + name + \'\\\'\' +\n                ", age=" + age +\n                ", phonenumber=" + phonenumber +\n                \'}\';\n    }\n}\n\n/* 控制台结果\n\npublic java.lang.string com.sans.field.person.name\n=============\nprivate java.lang.string com.sans.field.person.phonenumber\n=============\npublic java.lang.string com.sans.field.person.name\npublic int com.sans.field.person.age\n=============\n------获取属性名\n [phonenumber] \n------获取属性类型\n [class java.lang.string] \n------获取属性值\n [18122335634] \n------设置属性值\n [person{name=\'柏竹\', age=20, phonenumber=18122334455}] \n\n*/\n\n\n\n# 方法\n\njava.lang.reflect.method 反射应用的 方法 对象\n\n通过类的方法访问方法，将返回method类型对象，每个method对象代表一个方法\n\n获取类的方法\n\n返回         方法                                                        说明\nmethod     ==getmethod(string name , class<?>····parametertypes)==   获取指定方法\nmethod     ==getdeclaredmethod(string name ,                         获取所有权限的 指定方法\n           class<?>····parametertypes)==\nmethod[]   ==ethods()==                                              获取所有权限的指定方法\nmethod[]   ==getdeclaredmethods()==                                  获取 所有权限的全部方法，按声明顺序排列\n\nmethod类 常用方法 (获取更多方法自行api)\n\n返回        方法                                         说明\nstring    ==getname()==                              获取方法名称\nclass[]   ==getparametertypes()==                    获取参数的类型\nclass     ==getreturntype()==                        获取方法返回的类型\nclass[]   ==getexceptiontypes()==                    返回方法抛出的异常类型\nobject    ==invoke(object obj , object ... args)==   指定参数args指定obj方法(obj 类/方法)？\nboolean   ==isvarargs()==                            带有可变数量的参数，则true\nint       ==getmodifiers()==                         获取方法的修饰符(呈现形式整数)\nvoid      ==setaccessible(boolean bool)==            是否无视访问权限检查\n\npackage com.sans.method;\n\nimport java.lang.reflect.constructor;\nimport java.lang.reflect.method;\n\npublic class test {\n    public static void main(string[] args) throws exception {\n        \n        class<person> aclass = (class<person>) class.forname("com.sans.method.person");\n        //获取 类构造方法\n        constructor<person> constructor = aclass.getconstructor(string.class , int.class);\n        //获取 类实例的对象\n        object o = constructor.newinstance("柏竹" , 20);\n        \n        /*no.1\n         * 直接获取\n         * */\n        method setname = aclass.getmethod("setname" , string.class);\n        method getname = aclass.getmethod("getname");\n        system.out.println(setname);\n        system.out.println(getname);\n        \n        system.out.println("===================");\n        \n        /*no.2\n         *   获取所有权限 获取setage()方法\n         * */\n        method setage = aclass.getdeclaredmethod("setage", int.class);\n        system.out.println(setage);\n        \n        system.out.println("===================");\n        \n        /*no.3\n         *   获取所有方法\n         * */\n        method[] methods = aclass.getdeclaredmethods();\n        //无视权限进行测试使用\n        for (method tmp : methods) {\n            system.out.println(tmp);\n        }\n        \n        system.out.println("===================");\n        \n        /*\n         * 方法使用\n         * */\n        system.out.println("\\n-----模拟使用方法");\n        //获取 该方法所有权限\n        setage.setaccessible(true);\n        system.out.println("使用前 ： "+o);\n        setage.invoke(o , 24);\n        system.out.println("使用后 ： "+o);\n        \n        system.out.println("\\n-----获取方法名");\n        system.out.println(" ["+setage.getname()+"] ");\n        \n        system.out.println("\\n-----获取方法参数类型");\n        method test = aclass.getmethod("test", string.class, int[].class);\n        for (class tmp : test.getparametertypes()) {\n            system.out.println(" ["+tmp+"] ");\n        }\n        \n        system.out.println("\\n-----获取方法返回类型");\n        system.out.println(" ["+getname.getreturntype()+"] ");\n        \n    }\n}\n\nclass person{\n    string name;\n    int age;\n    \n    public person() {\n    }\n    \n    public person(string name , int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    public string getname() {\n        return name;\n    }\n    \n    public void setname(string name) {\n        this.name = name;\n    }\n    \n    public int getage() {\n        return age;\n    }\n    \n    /**\n     * 私有修饰\n     * @param age\n     */\n    private void setage(int age) {\n        this.age = age;\n    }\n    \n    public void test(string str , int...numall){\n        system.out.println("参数方法测试");\n    }\n    \n    @override\n    public string tostring() {\n        return "person{" +\n                "name=\'" + name + \'\\\'\' +\n                ", age=" + age +\n                \'}\';\n    }\n}\n\n/*\n\npublic void com.sans.method.person.setname(java.lang.string)\npublic java.lang.string com.sans.method.person.getname()\n===================\nprivate void com.sans.method.person.setage(int)\n===================\nprivate void com.sans.method.person.setage(int)\npublic int com.sans.method.person.getage()\npublic java.lang.string com.sans.method.person.tostring()\npublic java.lang.string com.sans.method.person.getname()\npublic void com.sans.method.person.setname(java.lang.string)\npublic void com.sans.method.person.test(java.lang.string,int[])\n===================\n\n-----模拟使用方法\n使用前 ： person{name=\'柏竹\', age=20}\n使用后 ： person{name=\'柏竹\', age=24}\n\n-----获取方法名\n [setage] \n\n-----获取方法参数类型\n [class java.lang.string] \n [class [i] \n\n-----获取方法返回类型\n [class java.lang.string] \n\n*/\n\n\n\n# 注解\n\njava.text.annotation 类型未了解，可前去网址了解：点击了解\n\n访问的前提注解要有该注解@retention(retentionpolicy.runtime)\n\n获取注解\n\n返回             方法                                         说明\nannotation     ==getannotation(class annotationclass)==   获取指定的annotation，不存在则返回null\nannotation[]   ==getannotations()==                       获取所有的annotation\n\npackage kkb;\n\nimport java.lang.reflect.field;\n\npublic class demo {\n    public static void main(string[] args) throws exception {\n        class<book> aclass = (class<book>) class.forname("kkb.book");\n        \n        //通过反射 表详细\n        myannotationtable at = aclass.getannotation(myannotationtable.class);\n        string value = at.tablename();\n        system.out.println("表名 : " + value);\n        \n        //属性\n        for (field tmp : aclass.getdeclaredfields()) {\n            myannotationfield af = tmp.getannotation(myannotationfield.class);\n            system.out.println(tmp.getname() +\n                    "属性 ， 对应数据库中的字段为 : "+ af.name()+\n                    " ， 数据类型 ： "+af.type()+\n                    " , 数据长度 ： "+af.length()\n            );\n        }\n    }\n}\n/*\n\n表名 : test_book\nid属性 ， 对应数据库中的字段为 : id ， 数据类型 ： int , 数据长度 ： 20\nname属性 ， 对应数据库中的字段为 : name ， 数据类型 ： varchar , 数据长度 ： 50\ninfo属性 ， 对应数据库中的字段为 : info ， 数据类型 ： varchar , 数据长度 ： 200\n\n*/\n\n\n# book类\n\npackage kkb;\n\nimport java.util.objects;\n\n/**\n * @author: 柏竹\n * @description: 一个简洁主义...\n * @date_created_in: 2021-03-06 16:44\n * @modified_by:\n * @project： 数据\n */\n@myannotationtable(tablename = "test_book")\npublic class book {\n    @myannotationfield(name = "id" , type = "int" , length = 20)\n    private int id;\n    @myannotationfield(name = "name" , type = "varchar" , length = 50)\n    private string name;\n    @myannotationfield(name = "info" , type = "varchar" , length = 200)\n    private string info;\n    \n    public book() {\n    }\n    \n    public book(int id , string name , string info) {\n        this.id = id;\n        this.name = name;\n        this.info = info;\n    }\n    \n    @override\n    public boolean equals(object o) {\n        if (this == o) return true;\n        if (o == null || getclass() != o.getclass()) return false;\n        book book = (book) o;\n        return id == book.id &&\n                objects.equals(name , book.name) &&\n                objects.equals(info , book.info);\n    }\n    \n    @override\n    public int hashcode() {\n        return objects.hash(id , name , info);\n    }\n    \n    public int getid() {\n        return id;\n    }\n    \n    public void setid(int id) {\n        this.id = id;\n    }\n    \n    public string getname() {\n        return name;\n    }\n    \n    public void setname(string name) {\n        this.name = name;\n    }\n    \n    public string getinfo() {\n        return info;\n    }\n    \n    public void setinfo(string info) {\n        this.info = info;\n    }\n    \n    @override\n    public string tostring() {\n        return "book{" +\n                "id=" + id +\n                ", name=\'" + name + \'\\\'\' +\n                ", info=\'" + info + \'\\\'\' +\n                \'}\';\n    }\n}\n\n\n# 注解myannotationfield\n\npackage kkb;\n\nimport java.lang.annotation.*;\n\n/**\n * @author: 柏竹\n * @description: 一个简洁主义...\n * @date_created_in: 2021-03-06 16:34\n * @modified_by:\n * @project： 字段\n */\n@inherited\n@documented\n@target (elementtype.field)\n@retention (retentionpolicy.runtime)\npublic @interface myannotationfield {\n    /**\n     * 列名\n     * @return\n     */\n    string name();\n    /**\n     * 类型\n     * @return\n     */\n    string type();\n    /**\n     * 数据长度\n     * @return\n     */\n    int length();\n}\n\n\n# 注解myannotationtable\n\npackage kkb;\n\nimport java.lang.annotation.*;\n\n/**\n * @author: 柏竹\n * @description: 一个简洁主义...\n * @date_created_in: 2021-03-06 16:32\n * @modified_by:\n * @project： 表名\n */\n@inherited\n@documented\n@target(elementtype.type)\n@retention(retentionpolicy.runtime)\npublic @interface myannotationtable {\n    /**\n     * 表名称\n     * @return\n     */\n    string tablename();\n}\n\n\n\n# 加载配置文件\n\n给项目添加根路径： 项目右键 -> 新建文件夹 -> 设置名 source -> 右键创建的文件夹 -> 标记项目为 -> 资源 根 即可\n\n\n\n一般类加载器 加载资源文件默认是src路径下的文件，但是当项目存在 资源根 加载文件这就是该文件夹设置的根！\n\nimport java.io.bufferedreader;\nimport java.io.ioexception;\nimport java.io.inputstream;\n\npublic class demo {\n    public static void main(string[] args) throws ioexception {\n        inputstream is = demo.class.getclassloader().getresourceasstream("test.txt");\n        bufferedreader br = null;\n        if (is != null) {\n            br = new bufferedreader(new inputstreamreader(is));\n        }\n        if (br != null){\n            system.out.println(br.readline());\n            br.close();\n        }\n    }\n}\n',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"泛型",frontmatter:{title:"泛型",date:"2020-02-18T00:00:00.000Z",permalink:"/backend/v3dlns",categories:["后端","Java基础"],tags:["Java"],author:"柏竹"},regularPath:"/01.%E5%90%8E%E7%AB%AF/01.Java%E5%9F%BA%E7%A1%80/12.%E6%B3%9B%E5%9E%8B.html",relativePath:"01.后端/01.Java基础/12.泛型.md",key:"v-2adb23eb",path:"/backend/v3dlns/",headers:[{level:2,title:"泛型的用法",slug:"泛型的用法",normalizedTitle:"泛型的用法",charIndex:982},{level:3,title:"泛型类声明多个类型",slug:"泛型类声明多个类型",normalizedTitle:"泛型类声明多个类型",charIndex:992},{level:3,title:"泛型类声明数组类型",slug:"泛型类声明数组类型",normalizedTitle:"泛型类声明数组类型",charIndex:1137},{level:3,title:"集合类声明容器的元素",slug:"集合类声明容器的元素",normalizedTitle:"集合类声明容器的元素",charIndex:1214},{level:2,title:"泛型高级用法",slug:"泛型高级用法",normalizedTitle:"泛型高级用法",charIndex:3424},{level:3,title:"限制泛型可用类型",slug:"限制泛型可用类型",normalizedTitle:"限制泛型可用类型",charIndex:3435},{level:3,title:"使用类型通配符",slug:"使用类型通配符",normalizedTitle:"使用类型通配符",charIndex:3543},{level:3,title:"泛型继承",slug:"泛型继承",normalizedTitle:"泛型继承",charIndex:3678}],headersStr:"泛型的用法 泛型类声明多个类型 泛型类声明数组类型 集合类声明容器的元素 泛型高级用法 限制泛型可用类型 使用类型通配符 泛型继承",content:'# 泛型\n\n泛型是将使用了类型具体化，像方法中获取参数类型一样，泛型所定义的类型是抽象化，在对象实例化时才开始定义泛型的具体类型\n\n在向下转型时，一般是要强制更改类型才能使用，但这一过程遗漏风险很大，因此使用泛型可在实例化时定义类型的使用可以防止出现异常\n\n> 泛型定义规范： E：集合（Element） K：关键字（Key） N：数字（Number） T：类型（Type） V：值（Value）\n\nclass 类名<T>{ }\n\n\n例子：\n\npublic class Demo <T>{\n    //利用泛型传的类型定义对象\n    T name;\n    float fraction;\n    \n    //名称\n    public void SetName(T newdata){\n        this.name = newdata ;\n    }\n    public T GetName(){\n        return name;\n    }\n        \n    //分数\n    public void SetFraction(float newdata){\n        this.fraction = newdata ;\n    }\n    public Object GetFraction(){\n        return fraction;\n    }\n    \n    public static void main(String[] args) {\n        Demo<String , Integer> d = new Demo<>();\n        \n        d.SetName("Tan");\n        String name = d.GetName();\n        System.out.println("名称："+name);\n    \n        d.SetFraction(80.5F);\n        //向下转型\n        float f = (float)d.GetFraction();\n        System.out.println("成绩："+f);\n        \n    }\n}\n\n\n运行结果\n\n名称：Tan\n成绩：80.5\n\n\n\n# 泛型的用法\n\n\n# 泛型类声明多个类型\n\n定义泛型类时声明多个类型（泛型个数要和实例化时的个数一致）\n\nclass Myclass<T, ··· >{ }\n\n\n实例化时：\n\nMyclass<String , Integer , Boolean, ··· > c = new Myclass<>();\n\n\n\n# 泛型类声明数组类型\n\n定义泛型类时也可以声明数组类型\n\nclass Myclass<T>{ \n\tT[] array = new T[n];\n}\n\n\n\n# 集合类声明容器的元素\n\n定义泛型类时，使用 K 和 V 两个字符代表容器中的 键 和 值\n\n集合定义有\n\n集合类         泛型定义\nArrayList   ArrayList<E>\nHashMap     HashMap<K , V>\nHashSet     HashSet<E>\nVector      Vector<E>\n\n例子：（泛型常规用法）\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class Demo2 {\n    \n    public static void main(String[] args) {\n        \n        GenericsUse1<String , Boolean , String> grid1 = new GenericsUse1<>("Jck" , true , "22");\n        GenericsUse2<String> grid2 = new GenericsUse2<>();\n        GenericsUse3<Integer , Object> grid3 = new GenericsUse3<>();\n        \n        System.out.println("泛型类声明多个类型：（变量返回）");\n        System.out.println(grid1.toString());\n        \n        String[] array = {"成员1","成员2","成员3"};\n        grid2.ObtainArray(array);\n        grid2.outarray();\n        \n        grid3.put(1 , "Sans12");\n        grid3.put(2 , 3.23);\n        grid3.put(3 , new Object());\n        System.out.println("\\n通过键获取值：");\n        System.out.println("K（1）："+grid3.Getvalue(1));\n        System.out.println("K（2）："+grid3.Getvalue(2));\n        System.out.println("K（3）："+grid3.Getvalue(3));\n  \n    }\n}\n\n//泛型类声明多个类型\nclass GenericsUse1<T , T2 , string>{\n    \n    T no1;\n    T2 no2;\n    string no3;\n    \n    public GenericsUse1(T no1 , T2 no2 , string no3){\n        this.no1 = no1;\n        this.no2 = no2;\n        this.no3 = no3;\n    }\n    \n    @Override\n    public String toString() {\n        return "GenericsUse1{" +\n                "no1=" + no1 +\n                ", no2=" + no2 +\n                ", no3=" + no3 +\n                \'}\';\n    }\n}\n\n//泛型类声明数组类型\nclass GenericsUse2<T>{\n    T[] array;\n    \n    public void ObtainArray(T[] array){\n        this.array = array;\n    }\n    \n    public void outarray(){\n        System.out.println("\\n遍历：");\n        for (T tmp : array){\n            System.out.println(tmp);\n        }\n    }\n    \n}\n\n//集合类声明容器的元素\nclass GenericsUse3<K , V>{\n    private Map<K , V> hashMap = new HashMap<>();\n    \n    //存入集合的方法\n    public void put(K k , V v ){\n        hashMap.put(k , v);\n    }\n    \n    public V Getvalue(K k){\n        return hashMap.get(k);\n    }\n    \n}\n\n\n运行结果\n\n泛型类声明多个类型：（变量返回）\nGenericsUse1{no1=Jck, no2=true, no3=22}\n\n遍历：\n成员1\n成员2\n成员3\n\n通过键获取值：\nK（1）：Sans12\nK（2）：3.23\nK（3）：java.lang.Object@4d405ef7\n\n\n\n# 泛型高级用法\n\n\n# 限制泛型可用类型\n\n默认是所有类型都可以实例化。extends关键字 可在泛型中限于指定类型及该类型的子类的使用\n\nclass 类名称<T extends List>{  } //限制于List集合及子类\n\n\n\n# 使用类型通配符\n\n限制泛型类型，限制泛型对象的使用 ，声明时需要 ? 表示通配符\n\nA<?>a;\n//泛型必须是List的子类，且不能增加和改写\nA<? extends List>a;  \n//泛型必须是List的父类\nA<? super List>a;\t \n\n\n\n# 泛型继承\n\n泛型类的继承\n\nclass ExtendClass<T>{  }\nclass SubClass<T> extends ExtendClass<T>{  }\n\n\n泛型接口的继承\n\ninterface TestInterface<T>{  }\nclass SubClass<T> implements TestInterface<T>{  }\n\n\n继承可能出现的情况： 全部继承、部分继承、实现父类泛型、不实现父类泛型\n\n//全部继承\nclass Father<T1 , T2>{  }\nclass Child<T1 , T2 , T3> extends Father<T1 , T2>{  }\n\n//部分继承\nclass Father<T1 , T2>{  }\nclass Child<T1 , A , B> extends Father<T1 , T2>{  }\n\n//实现父类泛型\nclass Father<Integer , String>{  }\nclass Child<A , B> extends Father<Integer , String>{  }\n\n//不实现父类泛型\nclass Father<T , String>{}\n// T 则默认为 Object\nclass Child extends Father{}\n\n\n例子：（高级泛型）\n\nimport java.util.*;\n\npublic class Demo3 {\n    public static void main(String[] args) {\n        //限制泛型可用类型\n        ListClass1<ArrayList> array1 = new ListClass1<>();\n        ListClass1<LinkedList> array2 = new ListClass1<>();\n        //错误调试\n//        ListClass<HashMap> array3 = new ListClass<>();\n    \n    \n        //使用类型通配符\n        List <String> list1 = new ArrayList<>();\n        List <? extends List> list2 = new ArrayList<ArrayList>(); //下界\n        List <? super List> list3 = new ArrayList<Object>();        //上界\n        List<?> list4 ;\n        \n        //list2.add("123");     //不能被添加\n        //list3.add("123");     //不能被添加\n        \n        list1.add("No.1");\n        list4 = list1;\n        System.out.println("list1："+list1.get(0));\n        System.out.println("list4："+list4.get(0));\n        list1.set(0 , "No.233");\n        //list4.set(0 , "No.233");    //不能修改\n        //list4.add("No.2");          //不能添加\n        System.out.println("list1："+list1.get(0));\n        System.out.println("list4："+list4.get(0));\n    \n        //泛型继承\n        GenericsUse4<Integer , Boolean , String , Float> grid4 = new GenericsUse4<>(23 , true , "mane" , 3.14);\n        System.out.println();\n        System.out.println(grid4.toString());\n    }\n}\n\n//限制泛型可用类型\nclass ListClass1<T extends List>{  }\n\n/*\n *\n * 继承泛型\n *\n *  */\n\n//接口\ninterface TestInterface<T4>{\n\n}\n\n//部分继承 T1、T2\nclass GenericsUse4<T1 , T2  , T3 , T4>  GenericsUse1<T1 , T2 , String> implements TestInterface<T4>{\n    \n    //T4为独有泛型\n    public GenericsUse4(T1 no1, T2 no2, String no3, double v) {\n        super(no1, no2, no3);\n    }\n    \n}\n\n/**运行结果\n\nlist1：No.1\nlist4：No.1\nlist1：No.233\nlist4：No.233\n\nGenericsUse1{no1=23, no2=true, no3=mane}\n\n*/\n\n\n注意：\n\n> 在编译之后程序会采取去泛型化的措施 只在编译阶段有效\n> \n> 在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加 类型检查和类型转换的方法 泛型信息不会进入到运行时阶段\n\n----------------------------------------\n\n以上是个人学习后写出来的代码分享，如果有问题可在下面留言！',normalizedContent:'# 泛型\n\n泛型是将使用了类型具体化，像方法中获取参数类型一样，泛型所定义的类型是抽象化，在对象实例化时才开始定义泛型的具体类型\n\n在向下转型时，一般是要强制更改类型才能使用，但这一过程遗漏风险很大，因此使用泛型可在实例化时定义类型的使用可以防止出现异常\n\n> 泛型定义规范： e：集合（element） k：关键字（key） n：数字（number） t：类型（type） v：值（value）\n\nclass 类名<t>{ }\n\n\n例子：\n\npublic class demo <t>{\n    //利用泛型传的类型定义对象\n    t name;\n    float fraction;\n    \n    //名称\n    public void setname(t newdata){\n        this.name = newdata ;\n    }\n    public t getname(){\n        return name;\n    }\n        \n    //分数\n    public void setfraction(float newdata){\n        this.fraction = newdata ;\n    }\n    public object getfraction(){\n        return fraction;\n    }\n    \n    public static void main(string[] args) {\n        demo<string , integer> d = new demo<>();\n        \n        d.setname("tan");\n        string name = d.getname();\n        system.out.println("名称："+name);\n    \n        d.setfraction(80.5f);\n        //向下转型\n        float f = (float)d.getfraction();\n        system.out.println("成绩："+f);\n        \n    }\n}\n\n\n运行结果\n\n名称：tan\n成绩：80.5\n\n\n\n# 泛型的用法\n\n\n# 泛型类声明多个类型\n\n定义泛型类时声明多个类型（泛型个数要和实例化时的个数一致）\n\nclass myclass<t, ··· >{ }\n\n\n实例化时：\n\nmyclass<string , integer , boolean, ··· > c = new myclass<>();\n\n\n\n# 泛型类声明数组类型\n\n定义泛型类时也可以声明数组类型\n\nclass myclass<t>{ \n\tt[] array = new t[n];\n}\n\n\n\n# 集合类声明容器的元素\n\n定义泛型类时，使用 k 和 v 两个字符代表容器中的 键 和 值\n\n集合定义有\n\n集合类         泛型定义\narraylist   arraylist<e>\nhashmap     hashmap<k , v>\nhashset     hashset<e>\nvector      vector<e>\n\n例子：（泛型常规用法）\n\nimport java.util.hashmap;\nimport java.util.map;\n\npublic class demo2 {\n    \n    public static void main(string[] args) {\n        \n        genericsuse1<string , boolean , string> grid1 = new genericsuse1<>("jck" , true , "22");\n        genericsuse2<string> grid2 = new genericsuse2<>();\n        genericsuse3<integer , object> grid3 = new genericsuse3<>();\n        \n        system.out.println("泛型类声明多个类型：（变量返回）");\n        system.out.println(grid1.tostring());\n        \n        string[] array = {"成员1","成员2","成员3"};\n        grid2.obtainarray(array);\n        grid2.outarray();\n        \n        grid3.put(1 , "sans12");\n        grid3.put(2 , 3.23);\n        grid3.put(3 , new object());\n        system.out.println("\\n通过键获取值：");\n        system.out.println("k（1）："+grid3.getvalue(1));\n        system.out.println("k（2）："+grid3.getvalue(2));\n        system.out.println("k（3）："+grid3.getvalue(3));\n  \n    }\n}\n\n//泛型类声明多个类型\nclass genericsuse1<t , t2 , string>{\n    \n    t no1;\n    t2 no2;\n    string no3;\n    \n    public genericsuse1(t no1 , t2 no2 , string no3){\n        this.no1 = no1;\n        this.no2 = no2;\n        this.no3 = no3;\n    }\n    \n    @override\n    public string tostring() {\n        return "genericsuse1{" +\n                "no1=" + no1 +\n                ", no2=" + no2 +\n                ", no3=" + no3 +\n                \'}\';\n    }\n}\n\n//泛型类声明数组类型\nclass genericsuse2<t>{\n    t[] array;\n    \n    public void obtainarray(t[] array){\n        this.array = array;\n    }\n    \n    public void outarray(){\n        system.out.println("\\n遍历：");\n        for (t tmp : array){\n            system.out.println(tmp);\n        }\n    }\n    \n}\n\n//集合类声明容器的元素\nclass genericsuse3<k , v>{\n    private map<k , v> hashmap = new hashmap<>();\n    \n    //存入集合的方法\n    public void put(k k , v v ){\n        hashmap.put(k , v);\n    }\n    \n    public v getvalue(k k){\n        return hashmap.get(k);\n    }\n    \n}\n\n\n运行结果\n\n泛型类声明多个类型：（变量返回）\ngenericsuse1{no1=jck, no2=true, no3=22}\n\n遍历：\n成员1\n成员2\n成员3\n\n通过键获取值：\nk（1）：sans12\nk（2）：3.23\nk（3）：java.lang.object@4d405ef7\n\n\n\n# 泛型高级用法\n\n\n# 限制泛型可用类型\n\n默认是所有类型都可以实例化。extends关键字 可在泛型中限于指定类型及该类型的子类的使用\n\nclass 类名称<t extends list>{  } //限制于list集合及子类\n\n\n\n# 使用类型通配符\n\n限制泛型类型，限制泛型对象的使用 ，声明时需要 ? 表示通配符\n\na<?>a;\n//泛型必须是list的子类，且不能增加和改写\na<? extends list>a;  \n//泛型必须是list的父类\na<? super list>a;\t \n\n\n\n# 泛型继承\n\n泛型类的继承\n\nclass extendclass<t>{  }\nclass subclass<t> extends extendclass<t>{  }\n\n\n泛型接口的继承\n\ninterface testinterface<t>{  }\nclass subclass<t> implements testinterface<t>{  }\n\n\n继承可能出现的情况： 全部继承、部分继承、实现父类泛型、不实现父类泛型\n\n//全部继承\nclass father<t1 , t2>{  }\nclass child<t1 , t2 , t3> extends father<t1 , t2>{  }\n\n//部分继承\nclass father<t1 , t2>{  }\nclass child<t1 , a , b> extends father<t1 , t2>{  }\n\n//实现父类泛型\nclass father<integer , string>{  }\nclass child<a , b> extends father<integer , string>{  }\n\n//不实现父类泛型\nclass father<t , string>{}\n// t 则默认为 object\nclass child extends father{}\n\n\n例子：（高级泛型）\n\nimport java.util.*;\n\npublic class demo3 {\n    public static void main(string[] args) {\n        //限制泛型可用类型\n        listclass1<arraylist> array1 = new listclass1<>();\n        listclass1<linkedlist> array2 = new listclass1<>();\n        //错误调试\n//        listclass<hashmap> array3 = new listclass<>();\n    \n    \n        //使用类型通配符\n        list <string> list1 = new arraylist<>();\n        list <? extends list> list2 = new arraylist<arraylist>(); //下界\n        list <? super list> list3 = new arraylist<object>();        //上界\n        list<?> list4 ;\n        \n        //list2.add("123");     //不能被添加\n        //list3.add("123");     //不能被添加\n        \n        list1.add("no.1");\n        list4 = list1;\n        system.out.println("list1："+list1.get(0));\n        system.out.println("list4："+list4.get(0));\n        list1.set(0 , "no.233");\n        //list4.set(0 , "no.233");    //不能修改\n        //list4.add("no.2");          //不能添加\n        system.out.println("list1："+list1.get(0));\n        system.out.println("list4："+list4.get(0));\n    \n        //泛型继承\n        genericsuse4<integer , boolean , string , float> grid4 = new genericsuse4<>(23 , true , "mane" , 3.14);\n        system.out.println();\n        system.out.println(grid4.tostring());\n    }\n}\n\n//限制泛型可用类型\nclass listclass1<t extends list>{  }\n\n/*\n *\n * 继承泛型\n *\n *  */\n\n//接口\ninterface testinterface<t4>{\n\n}\n\n//部分继承 t1、t2\nclass genericsuse4<t1 , t2  , t3 , t4>  genericsuse1<t1 , t2 , string> implements testinterface<t4>{\n    \n    //t4为独有泛型\n    public genericsuse4(t1 no1, t2 no2, string no3, double v) {\n        super(no1, no2, no3);\n    }\n    \n}\n\n/**运行结果\n\nlist1：no.1\nlist4：no.1\nlist1：no.233\nlist4：no.233\n\ngenericsuse1{no1=23, no2=true, no3=mane}\n\n*/\n\n\n注意：\n\n> 在编译之后程序会采取去泛型化的措施 只在编译阶段有效\n> \n> 在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加 类型检查和类型转换的方法 泛型信息不会进入到运行时阶段\n\n----------------------------------------\n\n以上是个人学习后写出来的代码分享，如果有问题可在下面留言！',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Java网络通信",frontmatter:{title:"Java网络通信",date:"2020-02-18T00:00:00.000Z",permalink:"/backend/pwb68r",categories:["后端","Java基础"],tags:["Java"],author:"柏竹"},regularPath:"/01.%E5%90%8E%E7%AB%AF/01.Java%E5%9F%BA%E7%A1%80/14.%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1.html",relativePath:"01.后端/01.Java基础/14.网络通信.md",key:"v-8c5f91b2",path:"/backend/pwb68r/",headers:[{level:2,title:"IP地址",slug:"ip地址",normalizedTitle:"ip地址",charIndex:15},{level:2,title:"TCP程序设计",slug:"tcp程序设计",normalizedTitle:"tcp程序设计",charIndex:604},{level:3,title:"服务器套接字",slug:"服务器套接字",normalizedTitle:"服务器套接字",charIndex:769},{level:3,title:"客户端套接字",slug:"客户端套接字",normalizedTitle:"客户端套接字",charIndex:861},{level:2,title:"UDP程序设计",slug:"udp程序设计",normalizedTitle:"udp程序设计",charIndex:2262},{level:3,title:"数据包",slug:"数据包",normalizedTitle:"数据包",charIndex:2314},{level:3,title:"数据包套接字",slug:"数据包套接字",normalizedTitle:"数据包套接字",charIndex:4238},{level:3,title:"组播套接字",slug:"组播套接字",normalizedTitle:"组播套接字",charIndex:4738},{level:2,title:"代码索引",slug:"代码索引",normalizedTitle:"代码索引",charIndex:5257},{level:3,title:"IP操作",slug:"ip操作",normalizedTitle:"ip操作",charIndex:594},{level:3,title:"TCP信息交互",slug:"tcp信息交互",normalizedTitle:"tcp信息交互",charIndex:2249},{level:3,title:"UDP信息发放",slug:"udp信息发放",normalizedTitle:"udp信息发放",charIndex:4725},{level:3,title:"组播发放",slug:"组播发放",normalizedTitle:"组播发放",charIndex:5247},{level:3,title:"TCP多线程访问",slug:"tcp多线程访问",normalizedTitle:"tcp多线程访问",charIndex:17297}],headersStr:"IP地址 TCP程序设计 服务器套接字 客户端套接字 UDP程序设计 数据包 数据包套接字 组播套接字 代码索引 IP操作 TCP信息交互 UDP信息发放 组播发放 TCP多线程访问",content:'# Java网络通信\n\n\n# IP地址\n\n> Class InetAddress\n> \n> java.lang.Object java.net.InetAddress\n\n该类表示Internet协议（IP）地址。IP地址是由IP使用的32位或128位无符号数字，一般IPv4格式范围：0.0.0.0~255.255.255.255 特殊IP地址：本地回送地址 不进行网络传输 127.0.0.1 返回本地\n\nInetAddress类常用方法\n\n返回              方法                           说明\nString          getHostName()                获取IP地址的主机名\nString          getHostAddress()             获取IP地址字符串\nInetAddress     getByName(String host)       获取与Host对应的InetAddress对象\nInetAddress     getLocalHost()               返回本主机的InetAddress对象\nInetAddress[]   getAllByName(String host)    获取指定主机的所有地址\n\n其余的方法自查API\n\n点击代码示例* （IP操作）\n\n\n# TCP程序设计\n\nTCP网络设计是利用Socket类（套接字）编写通信程序。 PS：套接字可以比作是一个连接装置（工具，像用电器必须要插插头连接才能使用！！\n\nTCP协议进行通信应用程序分为 服务器程序 、 客户机程序\n\n实现流程\n\n> 1. 创建服务器  实例 `ServerSocket()对象`\n> 2. 等待连接客户端 用服务器套接字 `accept()方法`\n> 3. 连接客户端 实例 `Socket()对象` \n> 4. 发送信息 或 接收信息 （信息交互的是**字节流**）\n>    发送信息：用客户端套接字 `getOutputStream()方法` 进行输出\n>    接收信息 ：用客户端套接字 `getInputStream()方法` 进行输入\n\n\n# 服务器套接字\n\n> Class ServerSocket\n> \n> java.lang.Object java.net.ServerSocket\n\nServerSocket类 实现了服务器套接字。等待通过网络进入的请求。服务器会根据该请求执行一些操作，然后可能将结果返回给请求者\n\n构造方法\n\nServerSocket() ServerSocket(int port) ServerSocket(int port, int backlog) ServerSocket(int port, int backlog, InetAddress bindAddr)\n\n> port： 端口号 backlog： 请求进入连接队列的最大长度 bindAddr： 服务器将绑定到的本地InetAddress\n\n方法\n\n修饰符           方法                             说明\nSocket        accept()                       等待客户端的连接，连接则创建套接字\nboolean       isBound()                      判断ServerSocket的绑定状态\nInetAddress   getInetAddress()               获取服务器套接字的本地地址\nboolean       isClosed()                     获取服务器套接字的关闭状态\nvoid          close()                        关闭服务器套接字\nvoid          bind(SocketAddress endpoint)   将ServerSocket绑定到特定地址（IP地址、端口号）\n\n其余的方法自查API\n\n\n# 客户端套接字\n\n> Class Socket java.lang.Object java.net.Socket\n\nSocket类 实现客户端套接字， 套接字是两台机器之间通讯的端点\n\n构造方法\n\nSocket()  Socket(IntetAddress address , int port) Socket(String host , int port) \n\n> IntetAddress： IP地址 port： 端口号 host： 主机地址\n\n方法\n\n修饰符            方法                   说明\nInputStream    getInputStream()     获取套接字输入流\nOutputStream   getOutputStream()    获取套接字输出流\nboolean        isConnected()        查看套接字是否连接\nvoid           close()              关闭套接字\nInetAddress    getInetAddress()     返回连接主机的地址\n\n其余的方法自查API\n\n点击代码示例* （TCP信息交互）\n\n\n# UDP程序设计\n\nUDP通讯方式，输出快、支持多人，但数据不能保证完好接收。UDP通信模式是将数据打包（数据包），然后接收人接收数据包查看。（其原理类似于电台广播的发放与收音机的接收！\n\n实现流程\n\n> 发送端：\n> \n>  1. 实例UDP DatagramSocket()对象\n>  2. 实例数据包 DatagramPacket()对象 （必须全参实例，否则无法接收）\n>  3. 广播式发送 DatagramSocket.send(DatagramPacket data)方法\n> \n> 接收端：\n> \n>  1. 实例UDP DatagramSocket()对象 绑定端口号 （对应 数据包 中的端口号）\n>  2. 实例数据包 DatagramPacket()对象 （获取信息为前提，参数随意）\n>  3. DatagramPacket类的receive()方法接收UDP包\n>  4. 接收数据包 DatagramSocket.receive(DatagramPacket data)方法 进行接收\n>  5. 获取字节包中的字节内容 DatagramPacket.getData() （最后进行转换即可）\n\nPS：receive()方法接收数据并返回，如未接收到数据，则阻塞至收到为止！！\n\n\n# 数据包\n\n> Class DatagramPacket\n> \n> java.lang.Object java.net.DatagramPacket\n\n数据包用于实现无连接分组传送服务（类似于快递运送的包裹\n\n构造方法\n\nDatagramPacket(byte[] bt, int len) DatagramPacket(byte[] bt,int off , int len) DatagramPacket(byte[] bt ,int len ,InetAddress address ,int port) DatagramPacket(byte[] bt ,int off ,int len ,InetAddress address ,int port)\n\n> bt： 发送数据（字节流） off： 有效数据 在数组中的起始点 len： 有效数据 在数组中的长度 address： 指定IP（InetAddress 实例对象） port： 端口号\n\n方法\n\n返回              方法                                            说明\nInetAddress     getAddress()                                  获取 对方主机 IP对象\nbyte[]          getData()                                     获取 数据包\nint             getLength()                                   获取 数据包的长度\nint             getOffset()                                   获取 数据包 起始偏移量\nint             getPort()                                     获取 对方主机 端口\nSocketAddress   getSocketAddress()                            获取 发送方的主机 IP地址 和 端口\nvoid            setAddress(InetAddress iaddr)                 设置 发送至对方主机 IP\nvoid            setData(byte[] buf)                           设置 数据包的数据缓冲区\nvoid            setData(byte[] buf, int offset, int length)   设置 数据包的数据缓冲区，指定范围的有效数据\nvoid            setLength(int length)                         设置数据包的长度\nvoid            setPort(int iport)                            设置 发送至对方主机 端口号\nvoid            setSocketAddress(SocketAddress address)       设置 发送至对方主机 SocketAddress对象\n\n\n# 数据包套接字\n\n> Class DatagramSocket\n> \n> java.lang.Object java.net.DatagramSocket\n\n数据包套接字用于 发送 和 接收 数据包的套接字（类似于运送快递的快递员\n\n构造方法\n\nDatagramSocket()  DatagramSocket(int port) DatagramSocket(int port , InetAddress addr)\n\n> port： 端口号 address： IP地址\n\n方法\n\n修饰符    方法                           说明\nvoid   bind(SocketAddress addr)     绑定地址和端口\nvoid   close()                      关闭数据套接字\nvoid   receive(DatagramPacket p)    套接字接收数据包（有堵塞效果）\nvoid   send(DatagramPacket p)       套接字发送数据包\n\n其余的方法自查API\n\n点击代码示例* （UDP信息发放）\n\n\n# 组播套接字\n\n> Class MulticastSocket\n> \n> java.lang.Object java.net.DatagramSocket java.net.MulticastSocket\n\n播组发送消息时，向该主机和端口发送消息，接收者在播放的前提才能接收到消息\n\n构造方法\n\nMulticastSocket() MulticastSocket(int port)  MulticastSocket(SocketAddress bindaddr)\n\n> port： 端口号 bindaddr： SocketAddress对象\n\n方法\n\n返回            方法                              说明\nvoid          joinGroup(InetAddress addr)     加入广播组\nvoid          leaveGroup(InetAdderss addr)    离开广播组\nInetAdderss   getInterface()                  获取数据包接口的IP地址\n\n更多方法自行API\n\n点击代码示例* （组播发放）\n\n\n# 代码索引\n\n\n# IP操作\n\n（返回*）\n\nimport java.net.InetAddress;\nimport java.net.UnknownHostException;\n\npublic class Address {\n    public static void main(String[] args) {\n        try {\n            InetAddress myip = InetAddress.getLocalHost();\n            System.out.println("本机名："+myip.getHostName());\n            System.out.println("本机IP："+myip.getHostAddress());\n\n            //获取百度的所有IP地址\n            InetAddress baiduip[] = InetAddress.getAllByName("www.baidu.com");\n            for(InetAddress tmp : baiduip){\n                System.out.println("IP："+tmp.getHostAddress());\n            }\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        }\n\n    }\n}\n\n\n/*\n* \n* 运行结果：\n* 本机名：LAPTOP-GDSLL8RB\n* 本机IP：192.168.43.84\n* IP：14.215.177.38\n* IP：14.215.177.39\n* \n* */\n\n\n\n# TCP信息交互\n\n（返回*）\n\n服务端：\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.ServerSocket;\nimport java.net.Socket;\n\npublic class MyServer {\n    \n    /**\n     * server - 服务器对象\n     * reader - 接收用户信息（缓冲字符输入流）\n     * writer - 输出内容（文本输出流）\n     * socket - 套接字（进行与客户端数据交互的渠道）\n     * count - 记录目前用户数\n     */\n    private ServerSocket server = null;\n    private BufferedReader reader = null;\n    private PrintWriter writer = null;\n    private Socket socket = null;\n    private int count = 0;\n    \n    public static void main(String[] args) {\n        new MyServer().serverStart();\n    }\n    \n    private void serverStart() {\n        try {\n            server = new ServerSocket(8848);\n            System.out.println("服务器已创建！ ");\n            System.out.println("等待客户端连接。。。");\n            socket = server.accept();\n            count++;\n            System.out.println("一个用户连接！");\n    \n            /**发送内容\n             *  利用字节输出流实例 文本流对象\n             */\n            writer = new PrintWriter(socket.getOutputStream());\n            //注意 ： 如果没有及时刷新缓存则会发出的是 空\n            writer.println("欢迎连接本服务器！！！ ");\n            //刷新\n            writer.flush();\n    \n            /** 接收内容\n             * 形式： 缓存字符流 <- 字符流 <- 字节流\n             */\n            reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            System.out.println("客户端 : " + reader.readLine());\n            \n        } catch (IOException e) {\n            e.printStackTrace();\n        } finally {\n            //关闭流\n            if (reader != null) {\n                try {\n                    reader.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        \n    }\n}\n\n/*\n\n服务器已创建！ \n等待客户端连接。。。\n一个用户连接！\n客户端 : 好久不见！\n\n*/\n\n\n客户端：\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.net.Socket;\n\npublic class MyClient {\n    \n    /**\n     * writer - 输出内容（文本输出流）\n     * reader - 接收用户信息（缓冲字符输入流）\n     * socket - 套接字（进行与客户端数据交互的渠道）\n     */\n    private PrintWriter writer = null;\n    private BufferedReader reader = null;\n    private Socket socket = null;\n    \n    private void clientStart() {\n        try {\n            socket = new Socket("127.0.0.1" , 8848);\n            writer = new PrintWriter(socket.getOutputStream());\n            reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            \n            //客户端我写的个简写版的\n            printReceiving();\n            printAndSend("好久不见！");\n            \n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    \n    }\n    \n    //接收内容\n    private void printReceiving() {\n        try {\n            System.out.println("服务端 : " + reader.readLine());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    //发送内容\n    private void printAndSend(String scr) {\n        writer.println(scr);\n        writer.flush();\n    }\n    \n    public static void main(String[] args) {\n        new MyClient().clientStart();\n    }\n}\n\n/*\n\n服务端 : 欢迎连接本服务器！！！ \n\n*/\n\n\n\n# UDP信息发放\n\n（返回*）\n\n发送端：\n\npackage kkb;\nimport java.io.IOException;\nimport java.net.*;\n\n// UDP 广播 （发送方\n\npublic class MyBroadcast extends Thread {\n    \n    /**\n     * data - 数据包\n     * socket - 数据包套接字\n     * portPacket - 数据包标签 端口号\n     * ipPacket - 数据包标签 IP\n     */\n    private DatagramPacket data = null;\n    private DatagramSocket socket = null;\n    private int portPacket  = 4399;\n    private InetAddress ipPacket = null;\n    \n    \n    public MyBroadcast() {\n        try {\n            ipPacket = InetAddress.getByName("127.0.0.1");\n            socket = new DatagramSocket();\n            System.out.println("UDP服务器已启动！");\n        } catch (SocketException | UnknownHostException e) {\n            e.printStackTrace();\n        }\n    }\n    \n\n    @Override\n    public void run() {\n        printAndSend("欢迎来到 柏竹 FM广播间！！！");\n        while(true){\n            try {\n                Thread.sleep(3000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            printAndSend("今天天气是晴天！");\n        }\n        \n    }\n    \n    //广播内容\n    private void printAndSend(String src) {\n        byte[] bt = src.getBytes();\n        data = new DatagramPacket(bt ,  bt.length , ipPacket , portPacket);\n        try {\n            socket.send(data);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public static void main(String[] args) {\n        new MyBroadcast().start();\n    }\n}\n\n/*\n*\n* UDP服务器已启动！\n*\n* */\n\n\n接收端：\n\npackage kkb;\n\n// UDP 广播 （接收方\n\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\nimport java.net.SocketException;\n\npublic class MyReceiveUil extends Thread{\n    \n    /**\n     * data - 数据包\n     * socket - 数据包套接字\n     */\n    private DatagramSocket socket = null;\n    private int port= 4399;\n    \n    public MyReceiveUil(){\n        try {\n            socket = new DatagramSocket(port);\n        } catch (SocketException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    @Override\n    public void run() {\n        while (true){\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            printData(getData());\n        }\n    }\n    \n    private void printData(DatagramPacket data) {\n        try {\n            socket.receive(data);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        String scr = new String(data.getData() , 0 , data.getLength());\n        System.out.println(scr);\n    }\n    \n    private DatagramPacket getData() {\n        byte[] bt = new byte[1024];\n        return new DatagramPacket(bt , bt.length);\n    }\n    \n    \n    public static void main(String[] args) {\n        new MyReceiveUil().start();\n    }\n}\n\n/*\n \n 欢迎来到 柏竹 FM广播间！！！\n今天天气是晴天！\n今天天气是晴天！\n·····\n\n */\n\n\n\n# 组播发放\n\n（返回*）\n\n发送报：\n\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.InetAddress;\nimport java.net.MulticastSocket;\nimport java.net.UnknownHostException;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n//UDP广播 （发送报\n\npublic class UdpBroadcastTest extends Thread{\n\n    //广播类\n    private MulticastSocket socket;\n    //端口号\n    private int port = 2233;\n    //广播组IP\n    private InetAddress group;\n\n    public UdpBroadcastTest(){\n        try {\n            //给定IP地址\n            group = InetAddress.getByName("224.233.2.1");\n            socket = new MulticastSocket(port);\n                socket.joinGroup(group);\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void run() {\n        //数据包\n        DatagramPacket packet;\n        while (true) {\n            SimpleDateFormat date = new SimpleDateFormat("HH:mm:ss");\n            String scr =  "["+ date.format(new Date())+ "] 今天天气晴天！！";\n            byte[] bt = scr.getBytes();\n            packet = new DatagramPacket(bt , bt.length , group , port);\n            try {\n                socket.send(packet);\n                Thread.sleep(2000);\n            } catch (IOException e) {\n                e.printStackTrace();\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        new UdpBroadcastTest().start();\n    }\n}\n\n/*运行结果为窗体形式*/\n\n\n接收报：\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.InetAddress;\nimport java.net.MulticastSocket;\nimport java.net.UnknownHostException;\n\n//UDP广播 （接收报\n\npublic class UdpReceiveTest extends JFrame implements Runnable,ActionListener {\n\n    //初始化数值\n    //广播类\n    private MulticastSocket socket = null;\n    //广播地址组\n    private InetAddress group = null;\n    private int port = 2233;\n    private JButton\n        ince = new JButton("开始接收"),\n        stop = new JButton("停止接收");\n    //文本域\n    private JTextArea\n            inceAr = new JTextArea(10,10),\n            inced = new JTextArea(10,10);\n    private JScrollPane\n            jspinceAr = null,\n            jspinced = null;\n    private Thread t;\n    //广播关闭 （开关\n    private boolean ReceiveSwitch = false;\n    private Container c = getContentPane();\n\n    public UdpReceiveTest(){\n        super("广播数据报");\n        t = new Thread(this);\n        setDefaultCloseOperation(3);\n        setBounds(400 , 300 , 500 , 380);\n\n        //聚集作用的面板（按钮\n        ince.addActionListener(this);\n        stop.addActionListener(this);\n        JPanel north = new JPanel();\n        north.add(ince);\n        north.add(stop);\n        c.add(north , BorderLayout.NORTH);\n\n        //聚集作用的面板（文本域\n        inceAr.setForeground(Color.blue);\n        inceAr.setFont(new Font("微软雅黑",Font.PLAIN,16));\n        inced.setFont(new Font("微软雅黑",Font.PLAIN,16));\n        //自动换行+换行不断字\n        inceAr.setLineWrap(true);\n        inced.setLineWrap(true);\n        inceAr.setWrapStyleWord(true);\n        inced.setWrapStyleWord(true);\n        //文本域 改至滚动面板\n        jspinceAr = new JScrollPane(inceAr);\n        jspinced = new JScrollPane(inced);\n        JPanel center = new JPanel();\n        center.add(jspinceAr);\n        center.add(jspinced);\n        c.add(center , BorderLayout.CENTER);\n\n        //验证所有组件 （刷新作用\n        c.validate();\n\n        try {\n            group = InetAddress.getByName("224.233.2.1");\n            socket = new MulticastSocket(port);\n            socket.joinGroup(group);\n        } catch (UnknownHostException e) {\n            e.printStackTrace();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        setVisible(true);\n    }\n\n    @Override\n    public void run() {\n        while (true){\n            byte data[] = new byte[1024];\n            DatagramPacket packet = null;\n            String scr = null;\n            packet = new DatagramPacket(data , data.length , group , port);\n            try {\n                //从此套接字接收数据报包\n                socket.receive(packet);\n                //获取数据\n                scr = new String(packet.getData() , 0 , packet.getLength());\n                inceAr.setText("正在接收广播内容：\\n"+scr);\n                inced.append(scr+"\\n");\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if(ReceiveSwitch){\n                break;\n            }\n        }\n    }\n\n    @Override\n    public void actionPerformed(ActionEvent e){\n        //if点击开始\n        if(e.getSource() == ince){\n            ince.setBackground(Color.blue);\n            stop.setBackground(Color.yellow);\n            //判断线程是否已创建\n            if(!(t.isAlive())){\n                t = new Thread(this);\n            }\n            t.start();\n            ReceiveSwitch = false;\n        }\n        //if点击停止\n        if(e.getSource() == stop){\n            stop.setBackground(Color.red);\n            ince.setBackground(Color.white);\n            ReceiveSwitch = true;\n        }\n    }\n\n    public static void main(String[] args) {\n        new UdpReceiveTest();\n    }\n}\n\n/*运行结果为窗体形式*/\n\n\n\n# TCP多线程访问\n\n服务端：\n\nimport java.io.*;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.util.concurrent.ExecutorService;\nimport static java.util.concurrent.Executors.*;\npublic class MyServer extends Thread{\n    \n    private ServerSocket server = null;\n    private Socket socket = null;\n    private ExecutorService service = null;\n    private int count = 0;\n    \n    public MyServer() {\n        try {\n            server = new ServerSocket(9959);\n            service = newCachedThreadPool();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        System.out.println("启动...");\n    }\n    \n    @Override\n    public void run() {\n        \n        while (true){\n            \n            try {\n                socket = server.accept();\n                System.out.println("一个客户连接");\n                count++;\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            \n            service.execute(() -> {\n                BufferedReader reader = null;\n                PrintWriter writer = null;\n                int n = count;\n                try {\n                    reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n                while (true){\n                    try {\n                        System.out.println(" 家长" + n + " : "+reader.readLine());\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            });\n            \n            \n        }\n        \n    }\n    \n    public static void main(String[] args) {\n        new MyServer().start();\n    }\n}\n\n/*\n\n启动...\n一个客户连接\n 家长1 : 你哪里人啊 ！？\n一个客户连接\n 家长2 : 你多大啦 ！？\n一个客户连接\n 家长3 : 你成绩多少分 ！？\n 家长2 : 你多大啦 ！？\n 家长1 : 你哪里人啊 ！？\n 家长2 : 你多大啦 ！？\n 家长3 : 你成绩多少分 ！？\n  。。。。。。\n\n*/\n\n\n客户端 1：\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.net.Socket;\n\npublic class Client1 extends Thread{\n    \n    private Socket socket = null;\n    private PrintWriter writer = null;\n    \n    public Client1() {\n        try {\n            socket = new Socket("127.0.0.1" , 9959);\n            writer = new PrintWriter(socket.getOutputStream());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    @Override\n    public void run() {\n        while (true){\n            writer.println("你哪里人啊 ！？");\n            writer.flush();\n            try {\n                Thread.sleep(10000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println("out");\n        }\n    }\n    \n    public static void main(String[] args) {\n        new Client1().start();\n    }\n}\n\n\n客户端 2：\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.net.Socket;\n\npublic class Client2 extends Thread{\n    \n    private Socket socket = null;\n    private PrintWriter writer = null;\n    \n    public Client2() {\n        try {\n            socket = new Socket("127.0.0.1" , 9959);\n            writer = new PrintWriter(socket.getOutputStream());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    @Override\n    public void run() {\n        while (true){\n            writer.println("你多大啦 ！？");\n            writer.flush();\n            try {\n                Thread.sleep(5000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println("out");\n        }\n    }\n    \n    public static void main(String[] args) {\n        new Client2().start();\n    }\n}\n\n\n客户端 3：\n\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.net.Socket;\n\npublic class Client3 extends Thread{\n    \n    private Socket socket = null;\n    private PrintWriter writer = null;\n    \n    public Client3() {\n        try {\n            socket = new Socket("127.0.0.1" , 9959);\n            writer = new PrintWriter(socket.getOutputStream());\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    @Override\n    public void run() {\n        while (true){\n            writer.println("你成绩多少分 ！？");\n            writer.flush();\n            try {\n                Thread.sleep(12000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n            System.out.println("out");\n        } \n    }\n    \n    public static void main(String[] args) {\n        new Client3().start();\n    }\n}\n',normalizedContent:'# java网络通信\n\n\n# ip地址\n\n> class inetaddress\n> \n> java.lang.object java.net.inetaddress\n\n该类表示internet协议（ip）地址。ip地址是由ip使用的32位或128位无符号数字，一般ipv4格式范围：0.0.0.0~255.255.255.255 特殊ip地址：本地回送地址 不进行网络传输 127.0.0.1 返回本地\n\ninetaddress类常用方法\n\n返回              方法                           说明\nstring          gethostname()                获取ip地址的主机名\nstring          gethostaddress()             获取ip地址字符串\ninetaddress     getbyname(string host)       获取与host对应的inetaddress对象\ninetaddress     getlocalhost()               返回本主机的inetaddress对象\ninetaddress[]   getallbyname(string host)    获取指定主机的所有地址\n\n其余的方法自查api\n\n点击代码示例* （ip操作）\n\n\n# tcp程序设计\n\ntcp网络设计是利用socket类（套接字）编写通信程序。 ps：套接字可以比作是一个连接装置（工具，像用电器必须要插插头连接才能使用！！\n\ntcp协议进行通信应用程序分为 服务器程序 、 客户机程序\n\n实现流程\n\n> 1. 创建服务器  实例 `serversocket()对象`\n> 2. 等待连接客户端 用服务器套接字 `accept()方法`\n> 3. 连接客户端 实例 `socket()对象` \n> 4. 发送信息 或 接收信息 （信息交互的是**字节流**）\n>    发送信息：用客户端套接字 `getoutputstream()方法` 进行输出\n>    接收信息 ：用客户端套接字 `getinputstream()方法` 进行输入\n\n\n# 服务器套接字\n\n> class serversocket\n> \n> java.lang.object java.net.serversocket\n\nserversocket类 实现了服务器套接字。等待通过网络进入的请求。服务器会根据该请求执行一些操作，然后可能将结果返回给请求者\n\n构造方法\n\nserversocket() serversocket(int port) serversocket(int port, int backlog) serversocket(int port, int backlog, inetaddress bindaddr)\n\n> port： 端口号 backlog： 请求进入连接队列的最大长度 bindaddr： 服务器将绑定到的本地inetaddress\n\n方法\n\n修饰符           方法                             说明\nsocket        accept()                       等待客户端的连接，连接则创建套接字\nboolean       isbound()                      判断serversocket的绑定状态\ninetaddress   getinetaddress()               获取服务器套接字的本地地址\nboolean       isclosed()                     获取服务器套接字的关闭状态\nvoid          close()                        关闭服务器套接字\nvoid          bind(socketaddress endpoint)   将serversocket绑定到特定地址（ip地址、端口号）\n\n其余的方法自查api\n\n\n# 客户端套接字\n\n> class socket java.lang.object java.net.socket\n\nsocket类 实现客户端套接字， 套接字是两台机器之间通讯的端点\n\n构造方法\n\nsocket()  socket(intetaddress address , int port) socket(string host , int port) \n\n> intetaddress： ip地址 port： 端口号 host： 主机地址\n\n方法\n\n修饰符            方法                   说明\ninputstream    getinputstream()     获取套接字输入流\noutputstream   getoutputstream()    获取套接字输出流\nboolean        isconnected()        查看套接字是否连接\nvoid           close()              关闭套接字\ninetaddress    getinetaddress()     返回连接主机的地址\n\n其余的方法自查api\n\n点击代码示例* （tcp信息交互）\n\n\n# udp程序设计\n\nudp通讯方式，输出快、支持多人，但数据不能保证完好接收。udp通信模式是将数据打包（数据包），然后接收人接收数据包查看。（其原理类似于电台广播的发放与收音机的接收！\n\n实现流程\n\n> 发送端：\n> \n>  1. 实例udp datagramsocket()对象\n>  2. 实例数据包 datagrampacket()对象 （必须全参实例，否则无法接收）\n>  3. 广播式发送 datagramsocket.send(datagrampacket data)方法\n> \n> 接收端：\n> \n>  1. 实例udp datagramsocket()对象 绑定端口号 （对应 数据包 中的端口号）\n>  2. 实例数据包 datagrampacket()对象 （获取信息为前提，参数随意）\n>  3. datagrampacket类的receive()方法接收udp包\n>  4. 接收数据包 datagramsocket.receive(datagrampacket data)方法 进行接收\n>  5. 获取字节包中的字节内容 datagrampacket.getdata() （最后进行转换即可）\n\nps：receive()方法接收数据并返回，如未接收到数据，则阻塞至收到为止！！\n\n\n# 数据包\n\n> class datagrampacket\n> \n> java.lang.object java.net.datagrampacket\n\n数据包用于实现无连接分组传送服务（类似于快递运送的包裹\n\n构造方法\n\ndatagrampacket(byte[] bt, int len) datagrampacket(byte[] bt,int off , int len) datagrampacket(byte[] bt ,int len ,inetaddress address ,int port) datagrampacket(byte[] bt ,int off ,int len ,inetaddress address ,int port)\n\n> bt： 发送数据（字节流） off： 有效数据 在数组中的起始点 len： 有效数据 在数组中的长度 address： 指定ip（inetaddress 实例对象） port： 端口号\n\n方法\n\n返回              方法                                            说明\ninetaddress     getaddress()                                  获取 对方主机 ip对象\nbyte[]          getdata()                                     获取 数据包\nint             getlength()                                   获取 数据包的长度\nint             getoffset()                                   获取 数据包 起始偏移量\nint             getport()                                     获取 对方主机 端口\nsocketaddress   getsocketaddress()                            获取 发送方的主机 ip地址 和 端口\nvoid            setaddress(inetaddress iaddr)                 设置 发送至对方主机 ip\nvoid            setdata(byte[] buf)                           设置 数据包的数据缓冲区\nvoid            setdata(byte[] buf, int offset, int length)   设置 数据包的数据缓冲区，指定范围的有效数据\nvoid            setlength(int length)                         设置数据包的长度\nvoid            setport(int iport)                            设置 发送至对方主机 端口号\nvoid            setsocketaddress(socketaddress address)       设置 发送至对方主机 socketaddress对象\n\n\n# 数据包套接字\n\n> class datagramsocket\n> \n> java.lang.object java.net.datagramsocket\n\n数据包套接字用于 发送 和 接收 数据包的套接字（类似于运送快递的快递员\n\n构造方法\n\ndatagramsocket()  datagramsocket(int port) datagramsocket(int port , inetaddress addr)\n\n> port： 端口号 address： ip地址\n\n方法\n\n修饰符    方法                           说明\nvoid   bind(socketaddress addr)     绑定地址和端口\nvoid   close()                      关闭数据套接字\nvoid   receive(datagrampacket p)    套接字接收数据包（有堵塞效果）\nvoid   send(datagrampacket p)       套接字发送数据包\n\n其余的方法自查api\n\n点击代码示例* （udp信息发放）\n\n\n# 组播套接字\n\n> class multicastsocket\n> \n> java.lang.object java.net.datagramsocket java.net.multicastsocket\n\n播组发送消息时，向该主机和端口发送消息，接收者在播放的前提才能接收到消息\n\n构造方法\n\nmulticastsocket() multicastsocket(int port)  multicastsocket(socketaddress bindaddr)\n\n> port： 端口号 bindaddr： socketaddress对象\n\n方法\n\n返回            方法                              说明\nvoid          joingroup(inetaddress addr)     加入广播组\nvoid          leavegroup(inetadderss addr)    离开广播组\ninetadderss   getinterface()                  获取数据包接口的ip地址\n\n更多方法自行api\n\n点击代码示例* （组播发放）\n\n\n# 代码索引\n\n\n# ip操作\n\n（返回*）\n\nimport java.net.inetaddress;\nimport java.net.unknownhostexception;\n\npublic class address {\n    public static void main(string[] args) {\n        try {\n            inetaddress myip = inetaddress.getlocalhost();\n            system.out.println("本机名："+myip.gethostname());\n            system.out.println("本机ip："+myip.gethostaddress());\n\n            //获取百度的所有ip地址\n            inetaddress baiduip[] = inetaddress.getallbyname("www.baidu.com");\n            for(inetaddress tmp : baiduip){\n                system.out.println("ip："+tmp.gethostaddress());\n            }\n        } catch (unknownhostexception e) {\n            e.printstacktrace();\n        }\n\n    }\n}\n\n\n/*\n* \n* 运行结果：\n* 本机名：laptop-gdsll8rb\n* 本机ip：192.168.43.84\n* ip：14.215.177.38\n* ip：14.215.177.39\n* \n* */\n\n\n\n# tcp信息交互\n\n（返回*）\n\n服务端：\n\nimport java.io.bufferedreader;\nimport java.io.ioexception;\nimport java.io.inputstreamreader;\nimport java.io.printwriter;\nimport java.net.serversocket;\nimport java.net.socket;\n\npublic class myserver {\n    \n    /**\n     * server - 服务器对象\n     * reader - 接收用户信息（缓冲字符输入流）\n     * writer - 输出内容（文本输出流）\n     * socket - 套接字（进行与客户端数据交互的渠道）\n     * count - 记录目前用户数\n     */\n    private serversocket server = null;\n    private bufferedreader reader = null;\n    private printwriter writer = null;\n    private socket socket = null;\n    private int count = 0;\n    \n    public static void main(string[] args) {\n        new myserver().serverstart();\n    }\n    \n    private void serverstart() {\n        try {\n            server = new serversocket(8848);\n            system.out.println("服务器已创建！ ");\n            system.out.println("等待客户端连接。。。");\n            socket = server.accept();\n            count++;\n            system.out.println("一个用户连接！");\n    \n            /**发送内容\n             *  利用字节输出流实例 文本流对象\n             */\n            writer = new printwriter(socket.getoutputstream());\n            //注意 ： 如果没有及时刷新缓存则会发出的是 空\n            writer.println("欢迎连接本服务器！！！ ");\n            //刷新\n            writer.flush();\n    \n            /** 接收内容\n             * 形式： 缓存字符流 <- 字符流 <- 字节流\n             */\n            reader = new bufferedreader(new inputstreamreader(socket.getinputstream()));\n            system.out.println("客户端 : " + reader.readline());\n            \n        } catch (ioexception e) {\n            e.printstacktrace();\n        } finally {\n            //关闭流\n            if (reader != null) {\n                try {\n                    reader.close();\n                } catch (ioexception e) {\n                    e.printstacktrace();\n                }\n            }\n        }\n        \n    }\n}\n\n/*\n\n服务器已创建！ \n等待客户端连接。。。\n一个用户连接！\n客户端 : 好久不见！\n\n*/\n\n\n客户端：\n\nimport java.io.bufferedreader;\nimport java.io.ioexception;\nimport java.io.inputstreamreader;\nimport java.io.printwriter;\nimport java.net.socket;\n\npublic class myclient {\n    \n    /**\n     * writer - 输出内容（文本输出流）\n     * reader - 接收用户信息（缓冲字符输入流）\n     * socket - 套接字（进行与客户端数据交互的渠道）\n     */\n    private printwriter writer = null;\n    private bufferedreader reader = null;\n    private socket socket = null;\n    \n    private void clientstart() {\n        try {\n            socket = new socket("127.0.0.1" , 8848);\n            writer = new printwriter(socket.getoutputstream());\n            reader = new bufferedreader(new inputstreamreader(socket.getinputstream()));\n            \n            //客户端我写的个简写版的\n            printreceiving();\n            printandsend("好久不见！");\n            \n        } catch (ioexception e) {\n            e.printstacktrace();\n        }\n    \n    }\n    \n    //接收内容\n    private void printreceiving() {\n        try {\n            system.out.println("服务端 : " + reader.readline());\n        } catch (ioexception e) {\n            e.printstacktrace();\n        }\n    }\n    \n    //发送内容\n    private void printandsend(string scr) {\n        writer.println(scr);\n        writer.flush();\n    }\n    \n    public static void main(string[] args) {\n        new myclient().clientstart();\n    }\n}\n\n/*\n\n服务端 : 欢迎连接本服务器！！！ \n\n*/\n\n\n\n# udp信息发放\n\n（返回*）\n\n发送端：\n\npackage kkb;\nimport java.io.ioexception;\nimport java.net.*;\n\n// udp 广播 （发送方\n\npublic class mybroadcast extends thread {\n    \n    /**\n     * data - 数据包\n     * socket - 数据包套接字\n     * portpacket - 数据包标签 端口号\n     * ippacket - 数据包标签 ip\n     */\n    private datagrampacket data = null;\n    private datagramsocket socket = null;\n    private int portpacket  = 4399;\n    private inetaddress ippacket = null;\n    \n    \n    public mybroadcast() {\n        try {\n            ippacket = inetaddress.getbyname("127.0.0.1");\n            socket = new datagramsocket();\n            system.out.println("udp服务器已启动！");\n        } catch (socketexception | unknownhostexception e) {\n            e.printstacktrace();\n        }\n    }\n    \n\n    @override\n    public void run() {\n        printandsend("欢迎来到 柏竹 fm广播间！！！");\n        while(true){\n            try {\n                thread.sleep(3000);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n            printandsend("今天天气是晴天！");\n        }\n        \n    }\n    \n    //广播内容\n    private void printandsend(string src) {\n        byte[] bt = src.getbytes();\n        data = new datagrampacket(bt ,  bt.length , ippacket , portpacket);\n        try {\n            socket.send(data);\n        } catch (ioexception e) {\n            e.printstacktrace();\n        }\n    }\n    \n    public static void main(string[] args) {\n        new mybroadcast().start();\n    }\n}\n\n/*\n*\n* udp服务器已启动！\n*\n* */\n\n\n接收端：\n\npackage kkb;\n\n// udp 广播 （接收方\n\nimport java.io.ioexception;\nimport java.net.datagrampacket;\nimport java.net.datagramsocket;\nimport java.net.socketexception;\n\npublic class myreceiveuil extends thread{\n    \n    /**\n     * data - 数据包\n     * socket - 数据包套接字\n     */\n    private datagramsocket socket = null;\n    private int port= 4399;\n    \n    public myreceiveuil(){\n        try {\n            socket = new datagramsocket(port);\n        } catch (socketexception e) {\n            e.printstacktrace();\n        }\n    }\n    \n    @override\n    public void run() {\n        while (true){\n            try {\n                thread.sleep(1000);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n            printdata(getdata());\n        }\n    }\n    \n    private void printdata(datagrampacket data) {\n        try {\n            socket.receive(data);\n        } catch (ioexception e) {\n            e.printstacktrace();\n        }\n        string scr = new string(data.getdata() , 0 , data.getlength());\n        system.out.println(scr);\n    }\n    \n    private datagrampacket getdata() {\n        byte[] bt = new byte[1024];\n        return new datagrampacket(bt , bt.length);\n    }\n    \n    \n    public static void main(string[] args) {\n        new myreceiveuil().start();\n    }\n}\n\n/*\n \n 欢迎来到 柏竹 fm广播间！！！\n今天天气是晴天！\n今天天气是晴天！\n·····\n\n */\n\n\n\n# 组播发放\n\n（返回*）\n\n发送报：\n\nimport java.io.ioexception;\nimport java.net.datagrampacket;\nimport java.net.inetaddress;\nimport java.net.multicastsocket;\nimport java.net.unknownhostexception;\nimport java.text.simpledateformat;\nimport java.util.date;\n\n//udp广播 （发送报\n\npublic class udpbroadcasttest extends thread{\n\n    //广播类\n    private multicastsocket socket;\n    //端口号\n    private int port = 2233;\n    //广播组ip\n    private inetaddress group;\n\n    public udpbroadcasttest(){\n        try {\n            //给定ip地址\n            group = inetaddress.getbyname("224.233.2.1");\n            socket = new multicastsocket(port);\n                socket.joingroup(group);\n        } catch (unknownhostexception e) {\n            e.printstacktrace();\n        } catch (ioexception e) {\n            e.printstacktrace();\n        }\n    }\n\n    @override\n    public void run() {\n        //数据包\n        datagrampacket packet;\n        while (true) {\n            simpledateformat date = new simpledateformat("hh:mm:ss");\n            string scr =  "["+ date.format(new date())+ "] 今天天气晴天！！";\n            byte[] bt = scr.getbytes();\n            packet = new datagrampacket(bt , bt.length , group , port);\n            try {\n                socket.send(packet);\n                thread.sleep(2000);\n            } catch (ioexception e) {\n                e.printstacktrace();\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        }\n    }\n\n    public static void main(string[] args) {\n        new udpbroadcasttest().start();\n    }\n}\n\n/*运行结果为窗体形式*/\n\n\n接收报：\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.actionevent;\nimport java.awt.event.actionlistener;\nimport java.io.ioexception;\nimport java.net.datagrampacket;\nimport java.net.inetaddress;\nimport java.net.multicastsocket;\nimport java.net.unknownhostexception;\n\n//udp广播 （接收报\n\npublic class udpreceivetest extends jframe implements runnable,actionlistener {\n\n    //初始化数值\n    //广播类\n    private multicastsocket socket = null;\n    //广播地址组\n    private inetaddress group = null;\n    private int port = 2233;\n    private jbutton\n        ince = new jbutton("开始接收"),\n        stop = new jbutton("停止接收");\n    //文本域\n    private jtextarea\n            incear = new jtextarea(10,10),\n            inced = new jtextarea(10,10);\n    private jscrollpane\n            jspincear = null,\n            jspinced = null;\n    private thread t;\n    //广播关闭 （开关\n    private boolean receiveswitch = false;\n    private container c = getcontentpane();\n\n    public udpreceivetest(){\n        super("广播数据报");\n        t = new thread(this);\n        setdefaultcloseoperation(3);\n        setbounds(400 , 300 , 500 , 380);\n\n        //聚集作用的面板（按钮\n        ince.addactionlistener(this);\n        stop.addactionlistener(this);\n        jpanel north = new jpanel();\n        north.add(ince);\n        north.add(stop);\n        c.add(north , borderlayout.north);\n\n        //聚集作用的面板（文本域\n        incear.setforeground(color.blue);\n        incear.setfont(new font("微软雅黑",font.plain,16));\n        inced.setfont(new font("微软雅黑",font.plain,16));\n        //自动换行+换行不断字\n        incear.setlinewrap(true);\n        inced.setlinewrap(true);\n        incear.setwrapstyleword(true);\n        inced.setwrapstyleword(true);\n        //文本域 改至滚动面板\n        jspincear = new jscrollpane(incear);\n        jspinced = new jscrollpane(inced);\n        jpanel center = new jpanel();\n        center.add(jspincear);\n        center.add(jspinced);\n        c.add(center , borderlayout.center);\n\n        //验证所有组件 （刷新作用\n        c.validate();\n\n        try {\n            group = inetaddress.getbyname("224.233.2.1");\n            socket = new multicastsocket(port);\n            socket.joingroup(group);\n        } catch (unknownhostexception e) {\n            e.printstacktrace();\n        } catch (ioexception e) {\n            e.printstacktrace();\n        }\n        setvisible(true);\n    }\n\n    @override\n    public void run() {\n        while (true){\n            byte data[] = new byte[1024];\n            datagrampacket packet = null;\n            string scr = null;\n            packet = new datagrampacket(data , data.length , group , port);\n            try {\n                //从此套接字接收数据报包\n                socket.receive(packet);\n                //获取数据\n                scr = new string(packet.getdata() , 0 , packet.getlength());\n                incear.settext("正在接收广播内容：\\n"+scr);\n                inced.append(scr+"\\n");\n            } catch (ioexception e) {\n                e.printstacktrace();\n            }\n            if(receiveswitch){\n                break;\n            }\n        }\n    }\n\n    @override\n    public void actionperformed(actionevent e){\n        //if点击开始\n        if(e.getsource() == ince){\n            ince.setbackground(color.blue);\n            stop.setbackground(color.yellow);\n            //判断线程是否已创建\n            if(!(t.isalive())){\n                t = new thread(this);\n            }\n            t.start();\n            receiveswitch = false;\n        }\n        //if点击停止\n        if(e.getsource() == stop){\n            stop.setbackground(color.red);\n            ince.setbackground(color.white);\n            receiveswitch = true;\n        }\n    }\n\n    public static void main(string[] args) {\n        new udpreceivetest();\n    }\n}\n\n/*运行结果为窗体形式*/\n\n\n\n# tcp多线程访问\n\n服务端：\n\nimport java.io.*;\nimport java.net.serversocket;\nimport java.net.socket;\nimport java.util.concurrent.executorservice;\nimport static java.util.concurrent.executors.*;\npublic class myserver extends thread{\n    \n    private serversocket server = null;\n    private socket socket = null;\n    private executorservice service = null;\n    private int count = 0;\n    \n    public myserver() {\n        try {\n            server = new serversocket(9959);\n            service = newcachedthreadpool();\n        } catch (ioexception e) {\n            e.printstacktrace();\n        }\n        system.out.println("启动...");\n    }\n    \n    @override\n    public void run() {\n        \n        while (true){\n            \n            try {\n                socket = server.accept();\n                system.out.println("一个客户连接");\n                count++;\n            } catch (ioexception e) {\n                e.printstacktrace();\n            }\n            \n            service.execute(() -> {\n                bufferedreader reader = null;\n                printwriter writer = null;\n                int n = count;\n                try {\n                    reader = new bufferedreader(new inputstreamreader(socket.getinputstream()));\n                } catch (ioexception e) {\n                    e.printstacktrace();\n                }\n                while (true){\n                    try {\n                        system.out.println(" 家长" + n + " : "+reader.readline());\n                    } catch (ioexception e) {\n                        e.printstacktrace();\n                    }\n                }\n            });\n            \n            \n        }\n        \n    }\n    \n    public static void main(string[] args) {\n        new myserver().start();\n    }\n}\n\n/*\n\n启动...\n一个客户连接\n 家长1 : 你哪里人啊 ！？\n一个客户连接\n 家长2 : 你多大啦 ！？\n一个客户连接\n 家长3 : 你成绩多少分 ！？\n 家长2 : 你多大啦 ！？\n 家长1 : 你哪里人啊 ！？\n 家长2 : 你多大啦 ！？\n 家长3 : 你成绩多少分 ！？\n  。。。。。。\n\n*/\n\n\n客户端 1：\n\nimport java.io.ioexception;\nimport java.io.printwriter;\nimport java.net.socket;\n\npublic class client1 extends thread{\n    \n    private socket socket = null;\n    private printwriter writer = null;\n    \n    public client1() {\n        try {\n            socket = new socket("127.0.0.1" , 9959);\n            writer = new printwriter(socket.getoutputstream());\n        } catch (ioexception e) {\n            e.printstacktrace();\n        }\n    }\n    \n    @override\n    public void run() {\n        while (true){\n            writer.println("你哪里人啊 ！？");\n            writer.flush();\n            try {\n                thread.sleep(10000);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n            system.out.println("out");\n        }\n    }\n    \n    public static void main(string[] args) {\n        new client1().start();\n    }\n}\n\n\n客户端 2：\n\nimport java.io.ioexception;\nimport java.io.printwriter;\nimport java.net.socket;\n\npublic class client2 extends thread{\n    \n    private socket socket = null;\n    private printwriter writer = null;\n    \n    public client2() {\n        try {\n            socket = new socket("127.0.0.1" , 9959);\n            writer = new printwriter(socket.getoutputstream());\n        } catch (ioexception e) {\n            e.printstacktrace();\n        }\n    }\n    \n    @override\n    public void run() {\n        while (true){\n            writer.println("你多大啦 ！？");\n            writer.flush();\n            try {\n                thread.sleep(5000);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n            system.out.println("out");\n        }\n    }\n    \n    public static void main(string[] args) {\n        new client2().start();\n    }\n}\n\n\n客户端 3：\n\nimport java.io.ioexception;\nimport java.io.printwriter;\nimport java.net.socket;\n\npublic class client3 extends thread{\n    \n    private socket socket = null;\n    private printwriter writer = null;\n    \n    public client3() {\n        try {\n            socket = new socket("127.0.0.1" , 9959);\n            writer = new printwriter(socket.getoutputstream());\n        } catch (ioexception e) {\n            e.printstacktrace();\n        }\n    }\n    \n    @override\n    public void run() {\n        while (true){\n            writer.println("你成绩多少分 ！？");\n            writer.flush();\n            try {\n                thread.sleep(12000);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n            system.out.println("out");\n        } \n    }\n    \n    public static void main(string[] args) {\n        new client3().start();\n    }\n}\n',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Java线程",frontmatter:{title:"Java线程",date:"2020-02-18T00:00:00.000Z",permalink:"/backend/zvajuy",categories:["后端","Java基础"],tags:["Java"],author:"柏竹"},regularPath:"/01.%E5%90%8E%E7%AB%AF/01.Java%E5%9F%BA%E7%A1%80/13.%E7%BA%BF%E7%A8%8B.html",relativePath:"01.后端/01.Java基础/13.线程.md",key:"v-031c20de",path:"/backend/zvajuy/",headers:[{level:2,title:"线程与进程",slug:"线程与进程",normalizedTitle:"线程与进程",charIndex:13},{level:2,title:"线程实现",slug:"线程实现",normalizedTitle:"线程实现",charIndex:457},{level:3,title:"Thread类",slug:"thread类",normalizedTitle:"thread类",charIndex:487},{level:3,title:"Runnable接口",slug:"runnable接口",normalizedTitle:"runnable接口",charIndex:498},{level:3,title:"Callable接口",slug:"callable接口",normalizedTitle:"callable接口",charIndex:512},{level:3,title:"线程应用总结",slug:"线程应用总结",normalizedTitle:"线程应用总结",charIndex:2870},{level:2,title:"线程控制",slug:"线程控制",normalizedTitle:"线程控制",charIndex:3139},{level:3,title:"线程休眠",slug:"线程休眠",normalizedTitle:"线程休眠",charIndex:3148},{level:3,title:"线程加入",slug:"线程加入",normalizedTitle:"线程加入",charIndex:254},{level:3,title:"线程后台",slug:"线程后台",normalizedTitle:"线程后台",charIndex:4814},{level:3,title:"线程唤醒",slug:"线程唤醒",normalizedTitle:"线程唤醒",charIndex:5844},{level:3,title:"线程礼让",slug:"线程礼让",normalizedTitle:"线程礼让",charIndex:8864},{level:3,title:"线程优先级",slug:"线程优先级",normalizedTitle:"线程优先级",charIndex:10080},{level:2,title:"线程生命周期",slug:"线程生命周期",normalizedTitle:"线程生命周期",charIndex:10320},{level:2,title:"线程同步",slug:"线程同步",normalizedTitle:"线程同步",charIndex:10981},{level:3,title:"synchronized 关键字 隐式锁",slug:"synchronized-关键字-隐式锁",normalizedTitle:"synchronized 关键字 隐式锁",charIndex:11059},{level:4,title:"同步块",slug:"同步块",normalizedTitle:"同步块",charIndex:11204},{level:4,title:"同步方法",slug:"同步方法",normalizedTitle:"同步方法",charIndex:11437},{level:3,title:"Lock 接口 显示锁",slug:"lock-接口-显示锁",normalizedTitle:"lock 接口 显示锁",charIndex:11587},{level:3,title:"同步锁总结",slug:"同步锁总结",normalizedTitle:"同步锁总结",charIndex:12769},{level:2,title:"线程池",slug:"线程池",normalizedTitle:"线程池",charIndex:2836},{level:3,title:"缓存线程池 newCachedThreadPool",slug:"缓存线程池-newcachedthreadpool",normalizedTitle:"缓存线程池 newcachedthreadpool",charIndex:13218},{level:3,title:"定长线程池 newFixedThreadPool",slug:"定长线程池-newfixedthreadpool",normalizedTitle:"定长线程池 newfixedthreadpool",charIndex:13369},{level:3,title:"单线程线程池 newSingleThreadExecutor",slug:"单线程线程池-newsinglethreadexecutor",normalizedTitle:"单线程线程池 newsinglethreadexecutor",charIndex:13627},{level:3,title:"定时线程池 newScheduledThreadPool",slug:"定时线程池-newscheduledthreadpool",normalizedTitle:"定时线程池 newscheduledthreadpool",charIndex:13752},{level:2,title:"代码索引",slug:"代码索引",normalizedTitle:"代码索引",charIndex:13932},{level:4,title:"File操作",slug:"file操作",normalizedTitle:"file操作",charIndex:13940},{level:4,title:"Runnable操作",slug:"runnable操作",normalizedTitle:"runnable操作",charIndex:2025},{level:4,title:"Callable操作",slug:"callable操作",normalizedTitle:"callable操作",charIndex:16804},{level:4,title:"synchronized安全线程",slug:"synchronized安全线程",normalizedTitle:"synchronized安全线程",charIndex:11416},{level:4,title:"synchronized方法安全线程",slug:"synchronized方法安全线程",normalizedTitle:"synchronized方法安全线程",charIndex:11563},{level:4,title:"ReentrantLock安全线程",slug:"reentrantlock安全线程",normalizedTitle:"reentrantlock安全线程",charIndex:12746},{level:4,title:"线程优先级",slug:"线程优先级-2",normalizedTitle:"线程优先级",charIndex:10080},{level:4,title:"缓存线程池",slug:"缓存线程池",normalizedTitle:"缓存线程池",charIndex:13218},{level:4,title:"定长线程池",slug:"定长线程池",normalizedTitle:"定长线程池",charIndex:13369},{level:4,title:"单线程线程池",slug:"单线程线程池",normalizedTitle:"单线程线程池",charIndex:13627},{level:4,title:"周期性任务定长线程池",slug:"周期性任务定长线程池",normalizedTitle:"周期性任务定长线程池",charIndex:13805}],headersStr:"线程与进程 线程实现 Thread类 Runnable接口 Callable接口 线程应用总结 线程控制 线程休眠 线程加入 线程后台 线程唤醒 线程礼让 线程优先级 线程生命周期 线程同步 synchronized 关键字 隐式锁 同步块 同步方法 Lock 接口 显示锁 同步锁总结 线程池 缓存线程池 newCachedThreadPool 定长线程池 newFixedThreadPool 单线程线程池 newSingleThreadExecutor 定时线程池 newScheduledThreadPool 代码索引 File操作 Runnable操作 Callable操作 synchronized安全线程 synchronized方法安全线程 ReentrantLock安全线程 线程优先级 缓存线程池 定长线程池 单线程线程池 周期性任务定长线程池",content:'# Java线程\n\n\n# 线程与进程\n\n线程 是进程中的执行过程，一个进程包含有多个线程，并发执行\n\n进程 是一个运行的应用程序，每个进程都有自己独立的内存空间\n\n> 一个程序运行后至少有一个进程，一个进程里可包含多个线程！\n\n进程特点：\n\n * 独立性： 进程是系统中独立存在的实体，他可以拥有自己的独立资源，每个进程都有自己的独立空间，未经进程本身的允许，用户线程不可以直接访问其他线程的地址空间\n * 动态性： 进程与程序的区别在于，程序只是一个静态的指令集合，而进程是一个正在系统中活动的指令集合，即线程加入了时间的概念。进程具有自己的声明周期和不同的状态，这些概念而程序都不具备有\n * 并发性： 多个进程可以在单个处理器上进行并发执行，而且多个线程之间是互不干扰的\n\n> 并发相关概念\n> \n>  * 并发： 同一时刻只能执行一条指令\n>  * 并行： 同一时刻执行多条不同指令\n>  * 同步： 执行完上条线程才能执行下条线程（类似接力）\n>  * 异步： 线程之间互不等待，线程启动即执行\n\n\n# 线程实现\n\n实现线程线程主要有\n\n * java.lang.Thread类\n * Runnable接口\n * Callable接口\n\n\n# Thread类\n\nThread类中实例化的对象代表线程，启动需要Thread实例\n\n构造方法\n\n构造方法                                    说明\nThread()                                -\nThread(String name)                     指定线程名称\nThread(Runnable target)                 \nThread(Runnable target , String name)   \n\n常用方法\n\n修饰符            方法                             说明\nThread         currentThread()                返回对当前正在执行的线程对象的引用\nlong           getId()                        返回线程标识符\nString         getName()                      返回线程名称\nint            getPriority()                  返回线程的优先级\nThread.State   getState()                     返回线程的状态\nvoid           interrupt()                    中断线程\nboolean        isAlive()                      线程是否运行\nboolean        isInterrupted()                线程是否被中断\nvoid           run()                          调用该Runnable对象的run方法\nvoid           start()                        线程开始执行run方法\nvoid           sleep(long ms)                 线程以指定的毫秒数暂停(等待)\nvoid           join()                         在线程中加入另一个线程\nboolean        interrupted()                  中断线程\nvoid           setPriority(int newPriority)   设置线程的优先级newPriority的范围(1-10)\nvoid           setDaemon(boolean on)          是否设置守护线程。守护线程：主线程结束，子线程也跟着结束\nString         toString()                     返回线程的字符串表示、线程的名、优先级、线程组\n\n点击代码示例* (Thread操作)\n\n\n# Runnable接口\n\n线程一般通过Thread类创建的。但 Runnable接口 也可以实现进程\n\n优点\n\n * 适合多线程同时执行相同的任务\n * 可多个相同程序处理统一资源 （资源共享\n * 不受 类的单继承约束\n\n实现方式\n\n * ==Thread(Runnable target)==\n * ==Thread(Runnable target , String name)==\n\n点击代码示例* (Runnable操作)\n\n\n# Callable接口\n\nRunnable接口 比 Callable接口 少了 线程结束无返回值 和 不能抛出异常 ，而 Callable接口 正是弥补这一缺陷！\n\n特点：\n\n * 不能共享资源\n * 线程执行完毕有返回值\n * 线程可抛出异常\n\n应用步骤：\n\n 1. 设计一个类， 实现Callable接口\n 2. 重写 Call() 方法（类似于 Thread中的run）\n 3. 创建实例 FutureTask对象 进行封装 实现Callable的类\n 4. 创建实例 Thread对象 再次封装 FutureTask对象\n 5. Thread对象 start() 启用线程\n 6. 线程执行结束后 ，FutureTask对象可通过 get() 获取 Call() 方法的返回值\n\n> PS： FutureTask类 和 Callable接口 都需要泛型 否则应用可能报错 （泛型也意味着返回类型）\n\n//1. 编写 Callable接口 ， 实现 call抽象方法\nclass MyCallable implements Callable<T>{\n    @Ovrride\n    public <T> call() throws Exception{\n        return T;\n    }\n}\n//2. 创建FutureTask对象，并传入第一步编写的Callable类对象\nFutureTask<T> future = new FutureTask<>(callable);\n//3. 通过Thread，启动线程\nnew Thread(future).start();\n//4. 获取返回值，FutureTask对象中的get()方法获取返回值(此方法有堵塞效果)\nfuture.get();\n\n\nFutureTask类 说明：用于异步获取执行结果或取消执行任务的作用(线程池的核心)\n\n点击代码示例* (Runnable操作)\n\n\n# 线程应用总结\n\n      THREAD   RUNNABLE        CALLABLE\n类型    类        接口              接口\n实现    单继承实现    可多实现继承          可多实现继承\n返回    无        无               有\n回调    方法直接调用   调用Thread的静态方法   调用Thread的静态方法\n复杂度   简单       简单              复杂\n推荐用   N        Y               Y\n\n\n# 线程控制\n\n\n# 线程休眠\n\nsleep(long ms) 方法 停止多少秒。它可能会抛出InterruptedException异常，所以放在try-catch块中。暂停后醒来，不能保证它能立即运行！\n\n//休眠1s\nThread.sleep(1000); \n\n\n\n# 线程加入\n\n在多个线程并行的过程中，某个线程被join()方法执行，其他需要等待join线程完成才能结束\n\n修饰符    方法                                  说明\nvoid   ==join()==                          等待这个线程死亡\nvoid   ==join(long millis)==               等待这个线程死亡，最长时间为millisms\nvoid   ==join(long millis , int nanos)==   等待最多millisms 加上这个线程死亡的nanos纳秒\n\n> **注意：**线程在被启动后 join()方法 才有效！\n\n/** Join线程\n * 但在某个过程其他线程在执行流中调用其他线程的join()方法时，调用线程被堵塞，直到join线程执行完为止\n * 等待这个线程死掉,才执行(此方法的调用与调用的行为方式完全相同)\n */\npublic class JoinThread extends Thread {\n    public JoinThread(String name) {\n        super(name);\n    }\n    @Override\n    public void run() {\n        for (int i = 0 ; i < 100 ; i++) {\n            if (i == 99) System.out.println(getName() + " : " + i);\n        }\n    }\n    \n    /** 测试原理\n     *  创建多个线程，让任意一线程 join加入\n     *      1. main线程 和 newThread线程 并行启动，分别循环100次\n     *      2. main线程循环到 10 jion线程 加入，并 jion() 执行\n     * 结论：\n     * 线程完毕顺序：newThread -> join -> main\n     */\n    public static void main(String[] args) throws InterruptedException {\n        new JoinThread("newThread").start();\n        for (int i = 0 ; i < 100 ; i++) {\n            if (i == 10) {\n                JoinThread jt = new JoinThread("Join线程");\n                jt.start();\n                /**\n                 * 优先执行\n                 */\n                jt.join();\n            }\n            if (i == 99) System.out.println(Thread.currentThread().getName() + " : " + i);\n        }\n    }\n}\n/** 控制台结果\n *  newThread : 99\n *  Join线程 : 99\n *  main : 99\n */\n\n\n> newThread线程 并非与 main线程 并行启动。join线程 是在 main线程 内设置的因此 main线程 需要等待 join线程 跑完\n\n\n# 线程后台\n\n后台线程是在所有前台的线程都死亡后，后台线程会自动死亡，后台线程的主要任务是为其他线程提供服务的（如：JVM垃圾回收线程(后台线程)\n\n==Thread.setDaemon(true)== 即可将线程设置为后台线程\n\n> 注意：==Thread.setDaemon(true)==方法 必须在线程启动前设置为后台线程。因 后台线程的自动死亡是通过 前台线程死亡所收到的通知，并加以判断是否只剩后台线程，从而执行死亡的指令，在这一过程需要一定时间\n\n/** 后台线程\n *      说明1：将此线程标记为守护线程或用户线程。当唯一运行的线程都是守护线程时，Java 虚拟机退出。此方法必须在线程启动之前调用。\n *      说明2：当所有前台的线程都死亡后，后台线程会自动死亡\n */\npublic class DemonThread extends Thread{\n    \n    @Override\n    public void run() {\n        for (int i = 0 ; i < 1000 ; i++) {\n            System.out.println(getName()+" : "+i);\n        }\n    }\n    \n    /** 测试原理\n     *  满足条件其他线程都要比后台线程更早结束\n     *      主线程main：执行循环 10 次\n     *      后台线程dt：执行循环 1000 次\n     *\n     */\n    public static void main(String[] args) {\n        DemonThread dt = new DemonThread();\n        /**\n         * 设置为 后台线程\n         */\n        dt.setDaemon(true);\n        dt.start();\n        for (int i = 0 ; i < 10 ; i++) {\n            System.out.println(Thread.currentThread().getName()+" : "+i);\n        }\n        \n    }\n}\n\n\n> 不难看出 dt线程 后台线程 不能执行到 i = 999 的情况\n\n\n# 线程唤醒\n\n线程唤醒的操作，需要搭配 synchronized + wait + notify 共同完成的\n\n> 注意：\n> \n>  * 方法一般作用于 同步锁，在调用这些方法前提需要搭配 synchronized同步锁使用，以防多线程错乱\n>  * 如果 当前线程在同步锁 的作用下，且被 同步锁 调用了 wait()方法，同步锁将会释放，用于给别的线程获取执行唤醒操作\n>  * 唤醒线程使用的类是 ==java.lang.Object==\n\n方法说明\n\n * ==wait()== ：使当前线程等待 应用前线程必须有使用有 同步锁。 等待其他线程使用 同步锁 调用 notify()/notifyAll()方法 使其唤醒，然后线程等待直到它重新获取同步锁才恢复执行（被挂起 同步锁 会被释放）\n * ==notify()== ：唤醒正在等待的线程 唤醒正在此 同步锁 上等待的单个线程。如果有多个线程正在等待该对象，则选择其中一个被唤醒(选择是任意的)\n * ==notifyAll()== ：唤醒正在等待的所有线程 唤醒正在此 同步锁 上等待的所有线程\n\npublic class WakeThread {\n    \n    /**\n     *  线程唤醒\n     */\n    public static void main(String[] args) {\n    \n        /** 测试原理\n         *      创建多个线程，通过不同线程相互交互控制 同步锁的应用\n         *      1. 创建三个线程分别为A，B，C，三个线程打印他们自己的执行过程\n         *      2. 创建一个对象 充当 同步锁的使用\n         *      3. 最先获取 同步锁 A进行 wait() 挂起等待 notify()/notifyAll()唤醒\n         */\n    \n        // 同步锁\n        final Object synObj = new Object();\n        \n        Runnable t1 = ()->{\n            System.out.println("T1 启动");\n            synchronized (synObj) {\n                System.out.println("T1 获取 同步锁");\n                try {\n                    Thread.sleep(3000);\n                    System.out.println("T1 wait()时挂起");\n                    /**\n                     * T1 挂起wait() 等待唤醒\n                     */\n                    synObj.wait();\n                    System.out.println("T1 被其他线程唤醒后重新获取SynObj对象监视器执行");\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println("T1 结束");\n        };\n        Runnable t2 = ()->{\n            System.out.println("T2 启动");\n            synchronized (synObj) {\n                System.out.println("T2 获取 同步锁");\n                /**\n                 * T2 唤醒该 同步锁 中的一个单线程\n                 */\n                synObj.notify();\n                System.out.println("T2 执行 notify()方法 唤醒");\n                try {\n                    Thread.sleep(3000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println("T2 结束");\n        };\n        Runnable t3 = ()->{\n            System.out.println("T3 启动");\n            synchronized (synObj) {\n                System.out.println("T3 获取 同步锁");\n                /**\n                 * T3 唤醒该 同步锁 中的所有线程\n                 */\n                synObj.notifyAll();\n                System.out.println("T3 执行 notifyAll()方法 唤醒");\n                try {\n                    Thread.sleep(3000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n            System.out.println("T3 结束");\n        };\n        \n        new Thread(t1,"T1").start();\n        new Thread(t2,"T2").start();\n        new Thread(t3,"T3").start();\n        \n    }\n}\n/* 控制台结果\nT1 启动\nT3 启动\nT2 启动\nT1 获取 同步锁\nT1 wait()时挂起\nT2 获取 同步锁\nT2 执行 notify()方法 唤醒\nT2 结束\nT3 获取 同步锁\nT3 执行 notifyAll()方法 唤醒\nT3 结束\nT1 被其他线程唤醒后重新获取SynObj对象监视器执行\nT1 结束\n*/\n\n\n> T1 被唤醒后并非马上执行，因 T2与T3 争夺 同步锁，因此 1T 获取 同步锁 后才能继续执行\n\n\n# 线程礼让\n\n==yield()==静态方法 它可以让当前正在执行的线程暂停，但它不会堵塞线程该线程，它只是将线程转入就绪状态\n\n> 注意： A线程执行 yield()方法 礼让后 ，以下可能会出现优先级的问题\n> \n>  * A与B的 优先级 相同 ：A，B线程 依旧会有争夺CPU资源\n>  * A的优先级更高：A线程可能不但礼让后还抢占CPU资源的\n>  * B的优先级更高：A线程会老老实实的 礼让 B线程\n\n/** 礼让线程\n *      说明1：向调度程序提示当前线程愿意放弃其当前对处理器的使用。调度程序可以随意忽略此提示。\n *            Yield 是一种启发式尝试，旨在改善线程之间的相对进展，否则会过度使用 CPU。\n *            它的使用应与详细的分析和基准测试相结合，以确保它实际上具有预期的效果。\n *      说明2：将指定线程暂停，不会堵塞线程，重新分配到线程的就绪状态\n */\npublic class YieldTest extends Thread{\n    \n    public YieldTest(String name) {\n        super(name);\n    }\n    \n    @Override\n    public void run() {\n        for (int i = 0 ; i < 50 ; i++) {\n            System.out.println(getName()+" : "+i);\n            // 使当前线程 礼让\n            if (i==20) {\n                System.out.println(getName()+"礼让");\n                /**\n         \t\t* 设置 当前线程礼让\n         \t\t*/\n                Thread.yield();\n            }\n        }\n    }\n    \n    /** 测试原理\n     *    创建两个线程分别让他们执行到特定的时刻进行礼让\n     *      1. 创建线程A和线程B ，且A，B线程有循环 50次\n     *      2. A，B线程执行到 20 执行 yield() 使当前线程礼让\n     */\n    public static void main(String[] args) {\n        YieldTest yt1 = new YieldTest("A");\n        YieldTest yt2 = new YieldTest("B");\n        yt1.start();\n        yt2.start();\n    }\n}\n\n\n\n# 线程优先级\n\n每个线程都有自己的优先级，线程的优先级代表着该线程的重要性。多个处于就绪的线程就能体现优先级的作用！\n\nTHREAD常量        值\nMAX_PRIORITY    10\nMIN_PRIORITY    1\nNORM_PRIORITY   5 (默认值)\n\n==setPriority(int newPriority)==方法 对线程优先级的调整\n\n> **注意：**线程的优先级范围只能设置 0 - 10 整型范围\n\n点击代码示例* (线程优先级)\n\n\n# 线程生命周期\n\n线程具有生命周期，有7种分别为：出生状态、就绪状态、运行状态、休眠状态、阻塞状态、死亡状态\n\nWindows操作系统中，会为每个线程分配一小段CPU时间片，一旦CPU时间片结束会切换到下一线程\n\n周期的说明：\n\n * 出生/创建 状态(New)： 线程创建后到 线程的start()方法前\n * 就绪状态(Runnable)： 可执行状态，进入线程池等待获取CPU的使用权，获取使用权在进入进入运行状态\n * 运行状态(Running)： 已经获取CPU的使用权，执行run()方法，没有意外 线程则一直运行到结束\n * 阻塞状态(Blocked)： 线程可能处于某种原因放弃/CPU的使用权 (停止运行)，会直到结束进入线程池回到就绪状态，堵塞的情况分为：\n   * 等待堵塞： 线程 IO方法堵塞 ，JVM会把线程放入 等待池中\n   * 同步堵塞： 在线程获取 对象同步锁前，该 同步对象的同步锁 被别的线程占用 未释放锁 ，JVM会将线程放入 锁池中\n   * 其他堵塞： 线程执行 sleep()/join()方法，或用户 输入/输出，JVM会将线程至为堵塞状态\n * 死亡状态(Dead)： 线程方法跑完/线程异常/stop()方法停止=，则进入死亡状态\n\n再次进入运行状态：\n\n * 线程调用notify()方法(唤醒线程)\n * 线程调用notifyAll()方法(唤醒线程)\n * 线程调用interrupt()方法(中断线程)\n * 线程的休眠时间结束\n * 输入/输出 结束\n\n\n# 线程同步\n\n多线程执行程序，会出现线程抢资源的现象，该现象会导致数据脏读！为了防止多线程的冲突，JAVA提供了线程同步的机制来防止资源抢占的问题！\n\n\n# synchronized 关键字 隐式锁\n\nsynchronized 关键字采用定时只允许一个线程访问共享资源 (道理跟上排队上厕所一样\n\n * 同步对象 (又称同步监听器) 可以任意\n * 不可实例本身对象 (测试创建其他线程对象呢？)\n * 同步代码块中的线程跑完才会释放代码块\n\n# 同步块\n\n每个对象都有标志位，它具有0和1两个值。0代表同步块中在运行其他线程；1代表该线程能被同步块执行，执行中途并将Object对象的标志位设置为0，防止其他线程执行同步块中的代码。(一个线程运行到同步块时首先检查该对象的标志位)\n\n// Object 同步锁\nsynchronized(Object){\n    ···\n}\n//Object：任意对象，仅作为同步锁(相当于一把锁，多人使用的锁)\n\n\n点击代码示例* (synchronized安全线程)\n\n# 同步方法\n\n方法 前面修饰 synchronized关键字 形成同步方法 某对象调用同步方法时，该对象的其他同步方法必须等待该同步方法执行完毕后才能被执行。必须将每个能访问共享资源的方法修饰为synchronized，否则会报错！\n\n点击代码示例* (synchronized方法安全线程)\n\n\n# Lock 接口 显示锁\n\nReentrantLock 显示锁\n\nReentrantLock 相比 synchronized 更加直观\n\n构造方法 ReentrantLock() ReentrantLock(boolean fair)\n\n> fair： 公平锁\n\n方法\n\n返回        方法                                        说明\nint       getHoldCount()                            查询当前线程对锁的停止数量\nint       getQueueLength()                          获取锁的线程数 估数\nint       getWaitQueueLength(Condition condition)   获取与此锁相关条件等待的线程\nboolean   hasQueuedThread(Thread thread)            查询指定线程是否获取锁\nboolean   hasQueuedThreads()                        查询是否有线程等待锁\nboolean   hasWaiters(Condition condition)           查询是否有相关条件等待的锁\nboolean   isFair()                                  是否为锁的公平，启动则true\nboolean   isHeldByCurrentThread()                   查询锁是否是当前线程持有\nboolean   isLocked()                                查询锁是否有线程持有\nvoid      lock()                                    锁定锁(上锁)\nvoid      lockInterruptibly()                       锁定锁\nString    toString()                                返回标识锁的字符串内容\nboolean   tryLock()                                 判断锁是否存在\nboolean   tryLock(long timeout, TimeUnit unit)      判断锁是否存在，指定时间超时返回false\nvoid      unlock()                                  释放锁(解锁)\n\n点击代码示例* (ReentrantLock安全线程)\n\n\n# 同步锁总结\n\n 1. 同步锁解决方法：同步代码块、同步方法、Lock接口\n\n 2. 同步代码块 和 同步方法 ，是隐式 获取/释放 锁\n\n 3. Lock接口 获取/释放 锁是显示的，自行操作\n\n 4. Lock接口 较灵活，可不用在同一 代码块/方法 中 进行 获取/释放 锁\n\n 5. Lock接口 获取锁后 ，一定要释放锁\n\n 6. Lock 默认是非公平锁，释放锁后可以继续抢锁；如果是 公平锁会根据等待时间进行分配锁（等待时间越长获锁几率越高！\n\n\n# 线程池\n\n> ExecutorService接口\n> \n> 继承接口 Executor\n> \n> 实现类 AbstractExecutorService ， ForkJoinPool ， ScheduledThreadPoolExecutor ， ThreadPoolExecutor\n\n线程的集合称为线程池\n\n频繁多线程操作会影响效率。反复的 创建 、关闭 线程会需要大量时间！可减少时间 和 资源的浪费！\n\n线程池原理图\n\n\n# 缓存线程池 newCachedThreadPool\n\nnewCachedThreadPool 缓存线程池，缓存线程时长默认心跳存活60秒\n\n当一个线程添加到池中，如果该线程在 60秒内 未被使用，则移出该线程\n\n特点：\n\n * 无长度限制\n * 自动扩容空间\n\n点击代码示例* (缓存线程池)\n\n\n# 定长线程池 newFixedThreadPool\n\nnewFixedThreadPool 固定大小的线程池，可以指定线程池的大小\n\nThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue<Runnable>(),threadFactory);\n\n\n特点：\n\n * 自定 固定 长度\n * 无闲线程 空间未满 自动扩容\n * 无闲线程 空间已满 等待空闲\n\n点击代码示例* (定长线程池)\n\n\n# 单线程线程池 newSingleThreadExecutor\n\nnewSingleThreadExecutor 单个单线程线程池，只有一个线程的线程池\n\n特点：\n\n * 只有一个线程\n * 无闲线程 等待\n\n点击代码示例* (单线程线程池)\n\n\n# 定时线程池 newScheduledThreadPool\n\nnewScheduledThreadPool 周期性任务定长线程池，\n\n该线程池可用于周期性去执行任务，通常用于周期性的同步数据\n\n * 可指定长度\n * 无闲线程 空间未满 自动扩容\n * 无闲线程 空间已满 等待空闲\n * 定时执行、周期执行\n\n点击代码示例* (周期性任务定长线程池)\n\n\n# 代码索引\n\n# File操作\n\n(返回*)\n\npublic class Demo {\n    public static void main(String[] args) {\n        \n        //实例对象\n        Thread a = new MyThreadA();\n        Thread b = new MyThreadB();\n        \n        /**其他方法测试*/\n        System.out.println("==========");\n        System.out.println("a.getId()："+a.getId());\n        System.out.println("a.getName()："+a.getName());\n        System.out.println("a.getPriority()："+a.getPriority());\n        System.out.println("a.getState()："+a.getState());\n        System.out.println("a.isAlive()："+a.isAlive());\n        System.out.println("a.isInterrupted()："+a.isInterrupted());\n        System.out.println("a.toString()："+a.toString());\n        System.out.println("==========");\n        \n        //执行线程(双线程执行，同时执行)\n        /**线程A*/\n        a.start();\n        /**线程B*/\n        b.start();\n        \n        /**\n         \n        以下代码为运行a对象的run()方法再执行b对象run()方法\n        a.run();\n        b.run();\n        \n        */\n        \n    }\n}\n\nclass MyThreadA extends Thread{\n    @Override\n    public void run() {\n        for (int i = 0; i < 26; i++) {\n            System.out.print("A："+i);\n            /**休眠1秒(等待)*/\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    \n}\n\nclass MyThreadB extends Thread{\n    @Override\n    public void run() {\n        for (char i = \'a\'; i < \'z\'; i++) {\n            System.out.println("B："+i);\n            /**休眠1秒(等待)*/\n            try {\n                Thread.sleep(1000);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n    \n}\n\n\n\n/**运行结果\n\n==========\na.getId()：13\na.getName()：No.1\na.getPriority()：5\na.getState()：NEW\na.isAlive()：false\na.isInterrupted()：false\na.toString()：Thread[No.1,5,main]\n==========\n B：a\n A：0\n B：b\n A：1\n B：c\n A：2\n A：3\n B：d\n B：e\n A：4\n A：5\n B：f\n A：6\n B：g\n A：7\n B：h\n A：8\n B：i\n B：j\n A：9\n A：10\n B：k\n A：11\n B：l\n A：12\n B：m\n B：n\n A：13\n A：14\n B：o\n B：p\n A：15\n B：q\n A：16\n B：r\n A：17\n B：s\n A：18\n A：19\n B：t\n B：u\n A：20\n A：21\n B：v\n A：22\n B：w\n B：x\n A：23\n B：y\n A：24\n A：25\n \n */\n\n\n# Runnable操作\n\n(返回*)\n\npublic class MainStartRunnable {\n    public static void main(String[] args) {\n        Thread t = new Thread(new MyRunnable() , "A");\n        Thread t2 = new Thread(new MyRunnable() , "B");\n        Thread t3 = new Thread(new MyRunnable() , "C");\n        \n        t.start();\n        t2.start();\n        t3.start();\n        \n    }\n} \nclass MyRunnable implements Runnable {\n    @Override\n    public void run() {\n        for (int i = 0 ; i < 10 ; i++) {\n            System.out.println(Thread.currentThread().getName()+" : "+i);\n        }\n    }\n}\n\n/*\n\nB : 0\nA : 0\nA : 1\nA : 2\nA : 3\nA : 4\nA : 5\nA : 6\nA : 7\nA : 8\nA : 9\nB : 1\nB : 2\nB : 3\nB : 4\nB : 5\nB : 6\nB : 7\nB : 8\nB : 9\nC : 0\nC : 1\nC : 2\nC : 3\nC : 4\nC : 5\nC : 6\nC : 7\nC : 8\nC : 9\n\n\n*/\n\n\n# Callable操作\n\n(返回*)\n\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.FutureTask;\n\npublic class Demo {\n    public static void main(String[] args) throws ExecutionException, InterruptedException {\n        MyCallable callable = new MyCallable();\n        FutureTask<Integer> future = new FutureTask<>(callable);\n        new Thread(future).start();\n        System.out.println("线程返回 : "+future.get());\n        System.out.println("堵塞测试！！！");\n    }\n    \n    static class MyCallable implements Callable<Integer>{\n        int num = 0;\n        \n        //返回的方法\n        @Override\n        public Integer call() throws Exception {\n            for (int i = 1 ; i <= 100 ; i++) {\n                num += i;\n                System.out.println(Thread.currentThread().getName()+" : "+i);\n            }\n            return num;\n        }\n        \n    }\n}\n\n/*\n\nThread-0 : 1\nThread-0 : 2\nThread-0 : 3\n····\nThread-0 : 100\n线程返回 : 5050\n\n*/\n\n\n# synchronized安全线程\n\n(返回*)\n\npublic class Demo {\n    \n    public static void main(String[] args) {\n        Runnable t = new Ticket();\n        new Thread(t).start();\n        new Thread(t).start();\n        new Thread(t).start();\n    }\n    \n    static class Ticket implements Runnable{\n    \n        private int count = 10;\n        private final Object o = new Object();\n        \n        @Override\n        public void run() {\n            while (true){\n                synchronized (o){\n                    if (count > 0){\n                        \n                        //如果synchronized套在这里 ， 多线程会错读\n                        \n                        System.out.println(Thread.currentThread().getName()+" : "+ --count);\n                        try {\n                            Thread.sleep(1000);\n                        } catch (InterruptedException e) {\n                            e.printStackTrace();\n                        }\n                    }else {\n                        break;\n                    }\n                }\n            }\n        }\n        \n    }\n}\n\n/*\n\nThread-2 : 9\nThread-2 : 8\nThread-2 : 7\nThread-0 : 6\nThread-1 : 5\nThread-0 : 4\nThread-2 : 3\nThread-0 : 2\nThread-1 : 1\nThread-0 : 0\n堵塞测试！！！\n\n */\n\n\n\n# synchronized方法安全线程\n\n(返回*)\n\npublic class Demo2 {\n    public static void main(String[] args) {\n        Runnable t = new Ticket();\n        new Thread(t).start();\n        new Thread(t).start();\n        new Thread(t).start();\n        new Thread(t).start();\n    }\n    \n    static class Ticket implements Runnable{\n        int count = 10;\n        @Override\n        public void run() {\n            while (true){\n                if (sell()){\n                    break;\n                }\n            }\n        }\n    \n        private synchronized boolean sell() {\n            if (count > 0){\n                System.out.println(Thread.currentThread().getName()+" : "+ --count);\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                return false;\n            }\n            return true;\n        }\n    }\n    \n}\n\n/*\n\nThread-0 : 9\nThread-0 : 8\nThread-0 : 7\nThread-0 : 6\nThread-0 : 5\nThread-0 : 4\nThread-3 : 3\nThread-3 : 2\nThread-1 : 1\nThread-1 : 0\n\n* */\n\n\n# ReentrantLock安全线程\n\n(返回*)\n\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class Demo3 {\n    public static void main(String[] args) {\n        Runnable lockTest = new LockTest();\n        new Thread(lockTest).start();\n        new Thread(lockTest).start();\n        new Thread(lockTest).start();\n        new Thread(lockTest).start();\n    }\n    \n    static class LockTest implements Runnable{\n    \n        //显式锁\n         static ReentrantLock l = new ReentrantLock(true);\n        \n        int count = 10;\n        \n        @Override\n        public void run() {\n            while (true){\n                    l.lock();\n                    if (sell()){\n                        break;\n                    }\n                    if (count == 5){\n                        test();\n                    }\n                l.unlock();\n            }\n            l.unlock();\n            System.out.println("结束 ： "+l.tryLock());\n        }\n    \n        private void test() {\n            System.out.println(l.toString());\n            System.out.println(l.getHoldCount());\n            System.out.println(l.getQueueLength());\n        }\n    \n        private boolean sell() {\n            if (count > 0){\n                System.out.println(Thread.currentThread().getName()+" : "+ --count);\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n                return false;\n            }\n            return true;\n        }\n        \n    }\n}\n\n/*\n\nThread-0 : 9\nThread-3 : 8\nThread-2 : 7\nThread-1 : 6\nThread-0 : 5\njava.util.concurrent.locks.ReentrantLock@47ee0a89[Locked by thread Thread-0]\n1\n3\nThread-3 : 4\nThread-2 : 3\nThread-1 : 2\nThread-0 : 1\nThread-3 : 0\n结束 ： true\n结束 ： false\n\n*/\n\n\n# 线程优先级\n\n(返回*)\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class PriorityBookTest extends JFrame {\n\n    private Container c = getContentPane();\n    private JProgressBar\n            jp1 = new JProgressBar(),\n            jp2 = new JProgressBar(),\n            jp3 = new JProgressBar(),\n            jp4 = new JProgressBar();\n    private Thread\n            threadA = null,\n            threadB = null,\n            threadC = null,\n            threadD = null;\n\n    public PriorityBookTest(){\n        super("线程优先级");\n        setBounds(300 , 230 ,100,150);\n        setLayout(new FlowLayout());\n        setVisible(true);\n\n        threadA = new Thread(newThread(c , jp1));\n        threadB = new Thread(newThread(c , jp2));\n        threadC = new Thread(newThread(c , jp3));\n        threadD = new Thread(newThread(c , jp4));\n        setPriority("A" , 10 , threadA);\n        setPriority("B" , 7 , threadB);\n        setPriority("C" , 4 , threadC);\n        setPriority("D" , 1 , threadD);\n    }\n\n    private static Thread newThread(Container c , JProgressBar jp){\n        c.add(jp);\n        jp.setStringPainted(true);\n        Thread thread = new Thread(new Runnable() {\n            @Override\n            public void run() {\n                int count = 0 ;\n                while (count <= 100){\n                    jp.setValue(count++);\n                    try {\n                        Thread.sleep(1000);\n                    } catch (InterruptedException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        });\n        return thread;\n    }\n\n    public static void setPriority(String threadName , int priority , Thread t){\n        //设置进程优先级、名，启动\n        t.setPriority(priority);\n        t.setName(threadName);\n        t.start();\n    }\n\n    public static void main(String[] args) {\n        new PriorityBookTest();\n    }\n}\n\n/*\n\n执行结果 ： 窗体展示 进度条\n\n*/\n\n\n# 缓存线程池\n\n(返回*)\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\n//缓存线程池\n\npublic class Demo1 {\n    public static void main(String[] args) {\n        ExecutorService service = Executors.newCachedThreadPool();\n        \n        //执行任务\n        service.execute(new Runnable() {\n            @Override\n            public void run() {\n                 System.out.println(Thread.currentThread().getName()+" : 1");\n            }\n        });\n    \n        service.execute(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(Thread.currentThread().getName()+" : 2");\n                try {\n                    Thread.sleep(2000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n    \n        service.execute(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(Thread.currentThread().getName()+" : 3");\n                try {\n                    Thread.sleep(2000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n    \n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    \n        service.execute(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(Thread.currentThread().getName()+" : 4");\n            }\n        });\n        \n    }\n}\n\n/*\n\npool-1-thread-3 : 3\npool-1-thread-2 : 2\npool-1-thread-1 : 1\npool-1-thread-1 : 4\n\n*/\n\n\n# 定长线程池\n\n(返回*)\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\n//定长线程池\n\npublic class Demo2 {\n    \n    public static void main(String[] args) {\n        ExecutorService exception = Executors.newFixedThreadPool(2);\n        \n        exception.execute(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(Thread.currentThread().getName()+" : 1");\n                try {\n                    Thread.sleep(2000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n    \n        exception.execute(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(Thread.currentThread().getName()+" : 2");\n                try {\n                    Thread.sleep(2000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n    \n        exception.execute(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(Thread.currentThread().getName()+" : 3");\n                try {\n                    Thread.sleep(2000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n    \n        try {\n            Thread.sleep(1000);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    \n        exception.execute(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(Thread.currentThread().getName()+" : 4");\n                try {\n                    Thread.sleep(2000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n    \n    }\n}\n\n/*\n\npool-1-thread-1 : 1\npool-1-thread-2 : 2\npool-1-thread-2 : 3\npool-1-thread-1 : 4\n\n*/\n\n\n# 单线程线程池\n\n(返回*)\n\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\n\n//单线程线程池\n\npublic class Demo3 {\n    public static void main(String[] args) {\n        ExecutorService service = Executors.newSingleThreadExecutor();\n        \n        service.execute(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(Thread.currentThread().getName()+" : 1");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n    \n        service.execute(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(Thread.currentThread().getName()+" : 2");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n    \n        service.execute(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println(Thread.currentThread().getName()+" : 3");\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        });\n        \n    }\n}\n\n/*\n\npool-1-thread-1 : 1\npool-1-thread-1 : 2\npool-1-thread-1 : 3\n\n*/\n\n\n# 周期性任务定长线程池\n\n(返回*)\n\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\n//周期性任务定长线程池\n\npublic class Demo4 {\n    public static void main(String[] args) {\n        ScheduledExecutorService service = Executors.newScheduledThreadPool(2);\n    \n        /**定时执行\n         * 参数1. 线程\n         * 参数2. 延时时长值\n         * 参数3. 时长单位\n         */\n        service.schedule(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println("延时2s ， 执行的程序");\n            }\n        } , 2 , TimeUnit.SECONDS);\n    \n        /**周期执行\n         * 参数1. 线程\n         * 参数2. 延时时长值\n         * 参数3. 周期间隔时长值\n         * 参数4. 时长单位\n         */\n        service.scheduleAtFixedRate(new Runnable() {\n            @Override\n            public void run() {\n                System.out.println("延时3s 执行周期间隔2s 的循环程序");\n            }\n        } , 3 , 2 , TimeUnit.SECONDS);\n        \n        \n    }\n}\n\n/*\n\n延时2s ， 执行的程序\n延时3s 执行周期间隔2s 的循环程序\n延时3s 执行周期间隔2s 的循环程序\n延时3s 执行周期间隔2s 的循环程序\n·····\n\n*/\n',normalizedContent:'# java线程\n\n\n# 线程与进程\n\n线程 是进程中的执行过程，一个进程包含有多个线程，并发执行\n\n进程 是一个运行的应用程序，每个进程都有自己独立的内存空间\n\n> 一个程序运行后至少有一个进程，一个进程里可包含多个线程！\n\n进程特点：\n\n * 独立性： 进程是系统中独立存在的实体，他可以拥有自己的独立资源，每个进程都有自己的独立空间，未经进程本身的允许，用户线程不可以直接访问其他线程的地址空间\n * 动态性： 进程与程序的区别在于，程序只是一个静态的指令集合，而进程是一个正在系统中活动的指令集合，即线程加入了时间的概念。进程具有自己的声明周期和不同的状态，这些概念而程序都不具备有\n * 并发性： 多个进程可以在单个处理器上进行并发执行，而且多个线程之间是互不干扰的\n\n> 并发相关概念\n> \n>  * 并发： 同一时刻只能执行一条指令\n>  * 并行： 同一时刻执行多条不同指令\n>  * 同步： 执行完上条线程才能执行下条线程（类似接力）\n>  * 异步： 线程之间互不等待，线程启动即执行\n\n\n# 线程实现\n\n实现线程线程主要有\n\n * java.lang.thread类\n * runnable接口\n * callable接口\n\n\n# thread类\n\nthread类中实例化的对象代表线程，启动需要thread实例\n\n构造方法\n\n构造方法                                    说明\nthread()                                -\nthread(string name)                     指定线程名称\nthread(runnable target)                 \nthread(runnable target , string name)   \n\n常用方法\n\n修饰符            方法                             说明\nthread         currentthread()                返回对当前正在执行的线程对象的引用\nlong           getid()                        返回线程标识符\nstring         getname()                      返回线程名称\nint            getpriority()                  返回线程的优先级\nthread.state   getstate()                     返回线程的状态\nvoid           interrupt()                    中断线程\nboolean        isalive()                      线程是否运行\nboolean        isinterrupted()                线程是否被中断\nvoid           run()                          调用该runnable对象的run方法\nvoid           start()                        线程开始执行run方法\nvoid           sleep(long ms)                 线程以指定的毫秒数暂停(等待)\nvoid           join()                         在线程中加入另一个线程\nboolean        interrupted()                  中断线程\nvoid           setpriority(int newpriority)   设置线程的优先级newpriority的范围(1-10)\nvoid           setdaemon(boolean on)          是否设置守护线程。守护线程：主线程结束，子线程也跟着结束\nstring         tostring()                     返回线程的字符串表示、线程的名、优先级、线程组\n\n点击代码示例* (thread操作)\n\n\n# runnable接口\n\n线程一般通过thread类创建的。但 runnable接口 也可以实现进程\n\n优点\n\n * 适合多线程同时执行相同的任务\n * 可多个相同程序处理统一资源 （资源共享\n * 不受 类的单继承约束\n\n实现方式\n\n * ==thread(runnable target)==\n * ==thread(runnable target , string name)==\n\n点击代码示例* (runnable操作)\n\n\n# callable接口\n\nrunnable接口 比 callable接口 少了 线程结束无返回值 和 不能抛出异常 ，而 callable接口 正是弥补这一缺陷！\n\n特点：\n\n * 不能共享资源\n * 线程执行完毕有返回值\n * 线程可抛出异常\n\n应用步骤：\n\n 1. 设计一个类， 实现callable接口\n 2. 重写 call() 方法（类似于 thread中的run）\n 3. 创建实例 futuretask对象 进行封装 实现callable的类\n 4. 创建实例 thread对象 再次封装 futuretask对象\n 5. thread对象 start() 启用线程\n 6. 线程执行结束后 ，futuretask对象可通过 get() 获取 call() 方法的返回值\n\n> ps： futuretask类 和 callable接口 都需要泛型 否则应用可能报错 （泛型也意味着返回类型）\n\n//1. 编写 callable接口 ， 实现 call抽象方法\nclass mycallable implements callable<t>{\n    @ovrride\n    public <t> call() throws exception{\n        return t;\n    }\n}\n//2. 创建futuretask对象，并传入第一步编写的callable类对象\nfuturetask<t> future = new futuretask<>(callable);\n//3. 通过thread，启动线程\nnew thread(future).start();\n//4. 获取返回值，futuretask对象中的get()方法获取返回值(此方法有堵塞效果)\nfuture.get();\n\n\nfuturetask类 说明：用于异步获取执行结果或取消执行任务的作用(线程池的核心)\n\n点击代码示例* (runnable操作)\n\n\n# 线程应用总结\n\n      thread   runnable        callable\n类型    类        接口              接口\n实现    单继承实现    可多实现继承          可多实现继承\n返回    无        无               有\n回调    方法直接调用   调用thread的静态方法   调用thread的静态方法\n复杂度   简单       简单              复杂\n推荐用   n        y               y\n\n\n# 线程控制\n\n\n# 线程休眠\n\nsleep(long ms) 方法 停止多少秒。它可能会抛出interruptedexception异常，所以放在try-catch块中。暂停后醒来，不能保证它能立即运行！\n\n//休眠1s\nthread.sleep(1000); \n\n\n\n# 线程加入\n\n在多个线程并行的过程中，某个线程被join()方法执行，其他需要等待join线程完成才能结束\n\n修饰符    方法                                  说明\nvoid   ==join()==                          等待这个线程死亡\nvoid   ==join(long millis)==               等待这个线程死亡，最长时间为millisms\nvoid   ==join(long millis , int nanos)==   等待最多millisms 加上这个线程死亡的nanos纳秒\n\n> **注意：**线程在被启动后 join()方法 才有效！\n\n/** join线程\n * 但在某个过程其他线程在执行流中调用其他线程的join()方法时，调用线程被堵塞，直到join线程执行完为止\n * 等待这个线程死掉,才执行(此方法的调用与调用的行为方式完全相同)\n */\npublic class jointhread extends thread {\n    public jointhread(string name) {\n        super(name);\n    }\n    @override\n    public void run() {\n        for (int i = 0 ; i < 100 ; i++) {\n            if (i == 99) system.out.println(getname() + " : " + i);\n        }\n    }\n    \n    /** 测试原理\n     *  创建多个线程，让任意一线程 join加入\n     *      1. main线程 和 newthread线程 并行启动，分别循环100次\n     *      2. main线程循环到 10 jion线程 加入，并 jion() 执行\n     * 结论：\n     * 线程完毕顺序：newthread -> join -> main\n     */\n    public static void main(string[] args) throws interruptedexception {\n        new jointhread("newthread").start();\n        for (int i = 0 ; i < 100 ; i++) {\n            if (i == 10) {\n                jointhread jt = new jointhread("join线程");\n                jt.start();\n                /**\n                 * 优先执行\n                 */\n                jt.join();\n            }\n            if (i == 99) system.out.println(thread.currentthread().getname() + " : " + i);\n        }\n    }\n}\n/** 控制台结果\n *  newthread : 99\n *  join线程 : 99\n *  main : 99\n */\n\n\n> newthread线程 并非与 main线程 并行启动。join线程 是在 main线程 内设置的因此 main线程 需要等待 join线程 跑完\n\n\n# 线程后台\n\n后台线程是在所有前台的线程都死亡后，后台线程会自动死亡，后台线程的主要任务是为其他线程提供服务的（如：jvm垃圾回收线程(后台线程)\n\n==thread.setdaemon(true)== 即可将线程设置为后台线程\n\n> 注意：==thread.setdaemon(true)==方法 必须在线程启动前设置为后台线程。因 后台线程的自动死亡是通过 前台线程死亡所收到的通知，并加以判断是否只剩后台线程，从而执行死亡的指令，在这一过程需要一定时间\n\n/** 后台线程\n *      说明1：将此线程标记为守护线程或用户线程。当唯一运行的线程都是守护线程时，java 虚拟机退出。此方法必须在线程启动之前调用。\n *      说明2：当所有前台的线程都死亡后，后台线程会自动死亡\n */\npublic class demonthread extends thread{\n    \n    @override\n    public void run() {\n        for (int i = 0 ; i < 1000 ; i++) {\n            system.out.println(getname()+" : "+i);\n        }\n    }\n    \n    /** 测试原理\n     *  满足条件其他线程都要比后台线程更早结束\n     *      主线程main：执行循环 10 次\n     *      后台线程dt：执行循环 1000 次\n     *\n     */\n    public static void main(string[] args) {\n        demonthread dt = new demonthread();\n        /**\n         * 设置为 后台线程\n         */\n        dt.setdaemon(true);\n        dt.start();\n        for (int i = 0 ; i < 10 ; i++) {\n            system.out.println(thread.currentthread().getname()+" : "+i);\n        }\n        \n    }\n}\n\n\n> 不难看出 dt线程 后台线程 不能执行到 i = 999 的情况\n\n\n# 线程唤醒\n\n线程唤醒的操作，需要搭配 synchronized + wait + notify 共同完成的\n\n> 注意：\n> \n>  * 方法一般作用于 同步锁，在调用这些方法前提需要搭配 synchronized同步锁使用，以防多线程错乱\n>  * 如果 当前线程在同步锁 的作用下，且被 同步锁 调用了 wait()方法，同步锁将会释放，用于给别的线程获取执行唤醒操作\n>  * 唤醒线程使用的类是 ==java.lang.object==\n\n方法说明\n\n * ==wait()== ：使当前线程等待 应用前线程必须有使用有 同步锁。 等待其他线程使用 同步锁 调用 notify()/notifyall()方法 使其唤醒，然后线程等待直到它重新获取同步锁才恢复执行（被挂起 同步锁 会被释放）\n * ==notify()== ：唤醒正在等待的线程 唤醒正在此 同步锁 上等待的单个线程。如果有多个线程正在等待该对象，则选择其中一个被唤醒(选择是任意的)\n * ==notifyall()== ：唤醒正在等待的所有线程 唤醒正在此 同步锁 上等待的所有线程\n\npublic class wakethread {\n    \n    /**\n     *  线程唤醒\n     */\n    public static void main(string[] args) {\n    \n        /** 测试原理\n         *      创建多个线程，通过不同线程相互交互控制 同步锁的应用\n         *      1. 创建三个线程分别为a，b，c，三个线程打印他们自己的执行过程\n         *      2. 创建一个对象 充当 同步锁的使用\n         *      3. 最先获取 同步锁 a进行 wait() 挂起等待 notify()/notifyall()唤醒\n         */\n    \n        // 同步锁\n        final object synobj = new object();\n        \n        runnable t1 = ()->{\n            system.out.println("t1 启动");\n            synchronized (synobj) {\n                system.out.println("t1 获取 同步锁");\n                try {\n                    thread.sleep(3000);\n                    system.out.println("t1 wait()时挂起");\n                    /**\n                     * t1 挂起wait() 等待唤醒\n                     */\n                    synobj.wait();\n                    system.out.println("t1 被其他线程唤醒后重新获取synobj对象监视器执行");\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n            system.out.println("t1 结束");\n        };\n        runnable t2 = ()->{\n            system.out.println("t2 启动");\n            synchronized (synobj) {\n                system.out.println("t2 获取 同步锁");\n                /**\n                 * t2 唤醒该 同步锁 中的一个单线程\n                 */\n                synobj.notify();\n                system.out.println("t2 执行 notify()方法 唤醒");\n                try {\n                    thread.sleep(3000);\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n            system.out.println("t2 结束");\n        };\n        runnable t3 = ()->{\n            system.out.println("t3 启动");\n            synchronized (synobj) {\n                system.out.println("t3 获取 同步锁");\n                /**\n                 * t3 唤醒该 同步锁 中的所有线程\n                 */\n                synobj.notifyall();\n                system.out.println("t3 执行 notifyall()方法 唤醒");\n                try {\n                    thread.sleep(3000);\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n            system.out.println("t3 结束");\n        };\n        \n        new thread(t1,"t1").start();\n        new thread(t2,"t2").start();\n        new thread(t3,"t3").start();\n        \n    }\n}\n/* 控制台结果\nt1 启动\nt3 启动\nt2 启动\nt1 获取 同步锁\nt1 wait()时挂起\nt2 获取 同步锁\nt2 执行 notify()方法 唤醒\nt2 结束\nt3 获取 同步锁\nt3 执行 notifyall()方法 唤醒\nt3 结束\nt1 被其他线程唤醒后重新获取synobj对象监视器执行\nt1 结束\n*/\n\n\n> t1 被唤醒后并非马上执行，因 t2与t3 争夺 同步锁，因此 1t 获取 同步锁 后才能继续执行\n\n\n# 线程礼让\n\n==yield()==静态方法 它可以让当前正在执行的线程暂停，但它不会堵塞线程该线程，它只是将线程转入就绪状态\n\n> 注意： a线程执行 yield()方法 礼让后 ，以下可能会出现优先级的问题\n> \n>  * a与b的 优先级 相同 ：a，b线程 依旧会有争夺cpu资源\n>  * a的优先级更高：a线程可能不但礼让后还抢占cpu资源的\n>  * b的优先级更高：a线程会老老实实的 礼让 b线程\n\n/** 礼让线程\n *      说明1：向调度程序提示当前线程愿意放弃其当前对处理器的使用。调度程序可以随意忽略此提示。\n *            yield 是一种启发式尝试，旨在改善线程之间的相对进展，否则会过度使用 cpu。\n *            它的使用应与详细的分析和基准测试相结合，以确保它实际上具有预期的效果。\n *      说明2：将指定线程暂停，不会堵塞线程，重新分配到线程的就绪状态\n */\npublic class yieldtest extends thread{\n    \n    public yieldtest(string name) {\n        super(name);\n    }\n    \n    @override\n    public void run() {\n        for (int i = 0 ; i < 50 ; i++) {\n            system.out.println(getname()+" : "+i);\n            // 使当前线程 礼让\n            if (i==20) {\n                system.out.println(getname()+"礼让");\n                /**\n         \t\t* 设置 当前线程礼让\n         \t\t*/\n                thread.yield();\n            }\n        }\n    }\n    \n    /** 测试原理\n     *    创建两个线程分别让他们执行到特定的时刻进行礼让\n     *      1. 创建线程a和线程b ，且a，b线程有循环 50次\n     *      2. a，b线程执行到 20 执行 yield() 使当前线程礼让\n     */\n    public static void main(string[] args) {\n        yieldtest yt1 = new yieldtest("a");\n        yieldtest yt2 = new yieldtest("b");\n        yt1.start();\n        yt2.start();\n    }\n}\n\n\n\n# 线程优先级\n\n每个线程都有自己的优先级，线程的优先级代表着该线程的重要性。多个处于就绪的线程就能体现优先级的作用！\n\nthread常量        值\nmax_priority    10\nmin_priority    1\nnorm_priority   5 (默认值)\n\n==setpriority(int newpriority)==方法 对线程优先级的调整\n\n> **注意：**线程的优先级范围只能设置 0 - 10 整型范围\n\n点击代码示例* (线程优先级)\n\n\n# 线程生命周期\n\n线程具有生命周期，有7种分别为：出生状态、就绪状态、运行状态、休眠状态、阻塞状态、死亡状态\n\nwindows操作系统中，会为每个线程分配一小段cpu时间片，一旦cpu时间片结束会切换到下一线程\n\n周期的说明：\n\n * 出生/创建 状态(new)： 线程创建后到 线程的start()方法前\n * 就绪状态(runnable)： 可执行状态，进入线程池等待获取cpu的使用权，获取使用权在进入进入运行状态\n * 运行状态(running)： 已经获取cpu的使用权，执行run()方法，没有意外 线程则一直运行到结束\n * 阻塞状态(blocked)： 线程可能处于某种原因放弃/cpu的使用权 (停止运行)，会直到结束进入线程池回到就绪状态，堵塞的情况分为：\n   * 等待堵塞： 线程 io方法堵塞 ，jvm会把线程放入 等待池中\n   * 同步堵塞： 在线程获取 对象同步锁前，该 同步对象的同步锁 被别的线程占用 未释放锁 ，jvm会将线程放入 锁池中\n   * 其他堵塞： 线程执行 sleep()/join()方法，或用户 输入/输出，jvm会将线程至为堵塞状态\n * 死亡状态(dead)： 线程方法跑完/线程异常/stop()方法停止=，则进入死亡状态\n\n再次进入运行状态：\n\n * 线程调用notify()方法(唤醒线程)\n * 线程调用notifyall()方法(唤醒线程)\n * 线程调用interrupt()方法(中断线程)\n * 线程的休眠时间结束\n * 输入/输出 结束\n\n\n# 线程同步\n\n多线程执行程序，会出现线程抢资源的现象，该现象会导致数据脏读！为了防止多线程的冲突，java提供了线程同步的机制来防止资源抢占的问题！\n\n\n# synchronized 关键字 隐式锁\n\nsynchronized 关键字采用定时只允许一个线程访问共享资源 (道理跟上排队上厕所一样\n\n * 同步对象 (又称同步监听器) 可以任意\n * 不可实例本身对象 (测试创建其他线程对象呢？)\n * 同步代码块中的线程跑完才会释放代码块\n\n# 同步块\n\n每个对象都有标志位，它具有0和1两个值。0代表同步块中在运行其他线程；1代表该线程能被同步块执行，执行中途并将object对象的标志位设置为0，防止其他线程执行同步块中的代码。(一个线程运行到同步块时首先检查该对象的标志位)\n\n// object 同步锁\nsynchronized(object){\n    ···\n}\n//object：任意对象，仅作为同步锁(相当于一把锁，多人使用的锁)\n\n\n点击代码示例* (synchronized安全线程)\n\n# 同步方法\n\n方法 前面修饰 synchronized关键字 形成同步方法 某对象调用同步方法时，该对象的其他同步方法必须等待该同步方法执行完毕后才能被执行。必须将每个能访问共享资源的方法修饰为synchronized，否则会报错！\n\n点击代码示例* (synchronized方法安全线程)\n\n\n# lock 接口 显示锁\n\nreentrantlock 显示锁\n\nreentrantlock 相比 synchronized 更加直观\n\n构造方法 reentrantlock() reentrantlock(boolean fair)\n\n> fair： 公平锁\n\n方法\n\n返回        方法                                        说明\nint       getholdcount()                            查询当前线程对锁的停止数量\nint       getqueuelength()                          获取锁的线程数 估数\nint       getwaitqueuelength(condition condition)   获取与此锁相关条件等待的线程\nboolean   hasqueuedthread(thread thread)            查询指定线程是否获取锁\nboolean   hasqueuedthreads()                        查询是否有线程等待锁\nboolean   haswaiters(condition condition)           查询是否有相关条件等待的锁\nboolean   isfair()                                  是否为锁的公平，启动则true\nboolean   isheldbycurrentthread()                   查询锁是否是当前线程持有\nboolean   islocked()                                查询锁是否有线程持有\nvoid      lock()                                    锁定锁(上锁)\nvoid      lockinterruptibly()                       锁定锁\nstring    tostring()                                返回标识锁的字符串内容\nboolean   trylock()                                 判断锁是否存在\nboolean   trylock(long timeout, timeunit unit)      判断锁是否存在，指定时间超时返回false\nvoid      unlock()                                  释放锁(解锁)\n\n点击代码示例* (reentrantlock安全线程)\n\n\n# 同步锁总结\n\n 1. 同步锁解决方法：同步代码块、同步方法、lock接口\n\n 2. 同步代码块 和 同步方法 ，是隐式 获取/释放 锁\n\n 3. lock接口 获取/释放 锁是显示的，自行操作\n\n 4. lock接口 较灵活，可不用在同一 代码块/方法 中 进行 获取/释放 锁\n\n 5. lock接口 获取锁后 ，一定要释放锁\n\n 6. lock 默认是非公平锁，释放锁后可以继续抢锁；如果是 公平锁会根据等待时间进行分配锁（等待时间越长获锁几率越高！\n\n\n# 线程池\n\n> executorservice接口\n> \n> 继承接口 executor\n> \n> 实现类 abstractexecutorservice ， forkjoinpool ， scheduledthreadpoolexecutor ， threadpoolexecutor\n\n线程的集合称为线程池\n\n频繁多线程操作会影响效率。反复的 创建 、关闭 线程会需要大量时间！可减少时间 和 资源的浪费！\n\n线程池原理图\n\n\n# 缓存线程池 newcachedthreadpool\n\nnewcachedthreadpool 缓存线程池，缓存线程时长默认心跳存活60秒\n\n当一个线程添加到池中，如果该线程在 60秒内 未被使用，则移出该线程\n\n特点：\n\n * 无长度限制\n * 自动扩容空间\n\n点击代码示例* (缓存线程池)\n\n\n# 定长线程池 newfixedthreadpool\n\nnewfixedthreadpool 固定大小的线程池，可以指定线程池的大小\n\nthreadpoolexecutor(nthreads, nthreads,0l, timeunit.milliseconds,new linkedblockingqueue<runnable>(),threadfactory);\n\n\n特点：\n\n * 自定 固定 长度\n * 无闲线程 空间未满 自动扩容\n * 无闲线程 空间已满 等待空闲\n\n点击代码示例* (定长线程池)\n\n\n# 单线程线程池 newsinglethreadexecutor\n\nnewsinglethreadexecutor 单个单线程线程池，只有一个线程的线程池\n\n特点：\n\n * 只有一个线程\n * 无闲线程 等待\n\n点击代码示例* (单线程线程池)\n\n\n# 定时线程池 newscheduledthreadpool\n\nnewscheduledthreadpool 周期性任务定长线程池，\n\n该线程池可用于周期性去执行任务，通常用于周期性的同步数据\n\n * 可指定长度\n * 无闲线程 空间未满 自动扩容\n * 无闲线程 空间已满 等待空闲\n * 定时执行、周期执行\n\n点击代码示例* (周期性任务定长线程池)\n\n\n# 代码索引\n\n# file操作\n\n(返回*)\n\npublic class demo {\n    public static void main(string[] args) {\n        \n        //实例对象\n        thread a = new mythreada();\n        thread b = new mythreadb();\n        \n        /**其他方法测试*/\n        system.out.println("==========");\n        system.out.println("a.getid()："+a.getid());\n        system.out.println("a.getname()："+a.getname());\n        system.out.println("a.getpriority()："+a.getpriority());\n        system.out.println("a.getstate()："+a.getstate());\n        system.out.println("a.isalive()："+a.isalive());\n        system.out.println("a.isinterrupted()："+a.isinterrupted());\n        system.out.println("a.tostring()："+a.tostring());\n        system.out.println("==========");\n        \n        //执行线程(双线程执行，同时执行)\n        /**线程a*/\n        a.start();\n        /**线程b*/\n        b.start();\n        \n        /**\n         \n        以下代码为运行a对象的run()方法再执行b对象run()方法\n        a.run();\n        b.run();\n        \n        */\n        \n    }\n}\n\nclass mythreada extends thread{\n    @override\n    public void run() {\n        for (int i = 0; i < 26; i++) {\n            system.out.print("a："+i);\n            /**休眠1秒(等待)*/\n            try {\n                thread.sleep(1000);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        }\n    }\n    \n}\n\nclass mythreadb extends thread{\n    @override\n    public void run() {\n        for (char i = \'a\'; i < \'z\'; i++) {\n            system.out.println("b："+i);\n            /**休眠1秒(等待)*/\n            try {\n                thread.sleep(1000);\n            } catch (interruptedexception e) {\n                e.printstacktrace();\n            }\n        }\n    }\n    \n}\n\n\n\n/**运行结果\n\n==========\na.getid()：13\na.getname()：no.1\na.getpriority()：5\na.getstate()：new\na.isalive()：false\na.isinterrupted()：false\na.tostring()：thread[no.1,5,main]\n==========\n b：a\n a：0\n b：b\n a：1\n b：c\n a：2\n a：3\n b：d\n b：e\n a：4\n a：5\n b：f\n a：6\n b：g\n a：7\n b：h\n a：8\n b：i\n b：j\n a：9\n a：10\n b：k\n a：11\n b：l\n a：12\n b：m\n b：n\n a：13\n a：14\n b：o\n b：p\n a：15\n b：q\n a：16\n b：r\n a：17\n b：s\n a：18\n a：19\n b：t\n b：u\n a：20\n a：21\n b：v\n a：22\n b：w\n b：x\n a：23\n b：y\n a：24\n a：25\n \n */\n\n\n# runnable操作\n\n(返回*)\n\npublic class mainstartrunnable {\n    public static void main(string[] args) {\n        thread t = new thread(new myrunnable() , "a");\n        thread t2 = new thread(new myrunnable() , "b");\n        thread t3 = new thread(new myrunnable() , "c");\n        \n        t.start();\n        t2.start();\n        t3.start();\n        \n    }\n} \nclass myrunnable implements runnable {\n    @override\n    public void run() {\n        for (int i = 0 ; i < 10 ; i++) {\n            system.out.println(thread.currentthread().getname()+" : "+i);\n        }\n    }\n}\n\n/*\n\nb : 0\na : 0\na : 1\na : 2\na : 3\na : 4\na : 5\na : 6\na : 7\na : 8\na : 9\nb : 1\nb : 2\nb : 3\nb : 4\nb : 5\nb : 6\nb : 7\nb : 8\nb : 9\nc : 0\nc : 1\nc : 2\nc : 3\nc : 4\nc : 5\nc : 6\nc : 7\nc : 8\nc : 9\n\n\n*/\n\n\n# callable操作\n\n(返回*)\n\nimport java.util.concurrent.callable;\nimport java.util.concurrent.executionexception;\nimport java.util.concurrent.futuretask;\n\npublic class demo {\n    public static void main(string[] args) throws executionexception, interruptedexception {\n        mycallable callable = new mycallable();\n        futuretask<integer> future = new futuretask<>(callable);\n        new thread(future).start();\n        system.out.println("线程返回 : "+future.get());\n        system.out.println("堵塞测试！！！");\n    }\n    \n    static class mycallable implements callable<integer>{\n        int num = 0;\n        \n        //返回的方法\n        @override\n        public integer call() throws exception {\n            for (int i = 1 ; i <= 100 ; i++) {\n                num += i;\n                system.out.println(thread.currentthread().getname()+" : "+i);\n            }\n            return num;\n        }\n        \n    }\n}\n\n/*\n\nthread-0 : 1\nthread-0 : 2\nthread-0 : 3\n····\nthread-0 : 100\n线程返回 : 5050\n\n*/\n\n\n# synchronized安全线程\n\n(返回*)\n\npublic class demo {\n    \n    public static void main(string[] args) {\n        runnable t = new ticket();\n        new thread(t).start();\n        new thread(t).start();\n        new thread(t).start();\n    }\n    \n    static class ticket implements runnable{\n    \n        private int count = 10;\n        private final object o = new object();\n        \n        @override\n        public void run() {\n            while (true){\n                synchronized (o){\n                    if (count > 0){\n                        \n                        //如果synchronized套在这里 ， 多线程会错读\n                        \n                        system.out.println(thread.currentthread().getname()+" : "+ --count);\n                        try {\n                            thread.sleep(1000);\n                        } catch (interruptedexception e) {\n                            e.printstacktrace();\n                        }\n                    }else {\n                        break;\n                    }\n                }\n            }\n        }\n        \n    }\n}\n\n/*\n\nthread-2 : 9\nthread-2 : 8\nthread-2 : 7\nthread-0 : 6\nthread-1 : 5\nthread-0 : 4\nthread-2 : 3\nthread-0 : 2\nthread-1 : 1\nthread-0 : 0\n堵塞测试！！！\n\n */\n\n\n\n# synchronized方法安全线程\n\n(返回*)\n\npublic class demo2 {\n    public static void main(string[] args) {\n        runnable t = new ticket();\n        new thread(t).start();\n        new thread(t).start();\n        new thread(t).start();\n        new thread(t).start();\n    }\n    \n    static class ticket implements runnable{\n        int count = 10;\n        @override\n        public void run() {\n            while (true){\n                if (sell()){\n                    break;\n                }\n            }\n        }\n    \n        private synchronized boolean sell() {\n            if (count > 0){\n                system.out.println(thread.currentthread().getname()+" : "+ --count);\n                try {\n                    thread.sleep(1000);\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n                return false;\n            }\n            return true;\n        }\n    }\n    \n}\n\n/*\n\nthread-0 : 9\nthread-0 : 8\nthread-0 : 7\nthread-0 : 6\nthread-0 : 5\nthread-0 : 4\nthread-3 : 3\nthread-3 : 2\nthread-1 : 1\nthread-1 : 0\n\n* */\n\n\n# reentrantlock安全线程\n\n(返回*)\n\nimport java.util.concurrent.locks.reentrantlock;\n\npublic class demo3 {\n    public static void main(string[] args) {\n        runnable locktest = new locktest();\n        new thread(locktest).start();\n        new thread(locktest).start();\n        new thread(locktest).start();\n        new thread(locktest).start();\n    }\n    \n    static class locktest implements runnable{\n    \n        //显式锁\n         static reentrantlock l = new reentrantlock(true);\n        \n        int count = 10;\n        \n        @override\n        public void run() {\n            while (true){\n                    l.lock();\n                    if (sell()){\n                        break;\n                    }\n                    if (count == 5){\n                        test();\n                    }\n                l.unlock();\n            }\n            l.unlock();\n            system.out.println("结束 ： "+l.trylock());\n        }\n    \n        private void test() {\n            system.out.println(l.tostring());\n            system.out.println(l.getholdcount());\n            system.out.println(l.getqueuelength());\n        }\n    \n        private boolean sell() {\n            if (count > 0){\n                system.out.println(thread.currentthread().getname()+" : "+ --count);\n                try {\n                    thread.sleep(1000);\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n                return false;\n            }\n            return true;\n        }\n        \n    }\n}\n\n/*\n\nthread-0 : 9\nthread-3 : 8\nthread-2 : 7\nthread-1 : 6\nthread-0 : 5\njava.util.concurrent.locks.reentrantlock@47ee0a89[locked by thread thread-0]\n1\n3\nthread-3 : 4\nthread-2 : 3\nthread-1 : 2\nthread-0 : 1\nthread-3 : 0\n结束 ： true\n结束 ： false\n\n*/\n\n\n# 线程优先级\n\n(返回*)\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class prioritybooktest extends jframe {\n\n    private container c = getcontentpane();\n    private jprogressbar\n            jp1 = new jprogressbar(),\n            jp2 = new jprogressbar(),\n            jp3 = new jprogressbar(),\n            jp4 = new jprogressbar();\n    private thread\n            threada = null,\n            threadb = null,\n            threadc = null,\n            threadd = null;\n\n    public prioritybooktest(){\n        super("线程优先级");\n        setbounds(300 , 230 ,100,150);\n        setlayout(new flowlayout());\n        setvisible(true);\n\n        threada = new thread(newthread(c , jp1));\n        threadb = new thread(newthread(c , jp2));\n        threadc = new thread(newthread(c , jp3));\n        threadd = new thread(newthread(c , jp4));\n        setpriority("a" , 10 , threada);\n        setpriority("b" , 7 , threadb);\n        setpriority("c" , 4 , threadc);\n        setpriority("d" , 1 , threadd);\n    }\n\n    private static thread newthread(container c , jprogressbar jp){\n        c.add(jp);\n        jp.setstringpainted(true);\n        thread thread = new thread(new runnable() {\n            @override\n            public void run() {\n                int count = 0 ;\n                while (count <= 100){\n                    jp.setvalue(count++);\n                    try {\n                        thread.sleep(1000);\n                    } catch (interruptedexception e) {\n                        e.printstacktrace();\n                    }\n                }\n            }\n        });\n        return thread;\n    }\n\n    public static void setpriority(string threadname , int priority , thread t){\n        //设置进程优先级、名，启动\n        t.setpriority(priority);\n        t.setname(threadname);\n        t.start();\n    }\n\n    public static void main(string[] args) {\n        new prioritybooktest();\n    }\n}\n\n/*\n\n执行结果 ： 窗体展示 进度条\n\n*/\n\n\n# 缓存线程池\n\n(返回*)\n\nimport java.util.concurrent.executorservice;\nimport java.util.concurrent.executors;\n\n//缓存线程池\n\npublic class demo1 {\n    public static void main(string[] args) {\n        executorservice service = executors.newcachedthreadpool();\n        \n        //执行任务\n        service.execute(new runnable() {\n            @override\n            public void run() {\n                 system.out.println(thread.currentthread().getname()+" : 1");\n            }\n        });\n    \n        service.execute(new runnable() {\n            @override\n            public void run() {\n                system.out.println(thread.currentthread().getname()+" : 2");\n                try {\n                    thread.sleep(2000);\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n        });\n    \n        service.execute(new runnable() {\n            @override\n            public void run() {\n                system.out.println(thread.currentthread().getname()+" : 3");\n                try {\n                    thread.sleep(2000);\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n        });\n    \n        try {\n            thread.sleep(1000);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n    \n        service.execute(new runnable() {\n            @override\n            public void run() {\n                system.out.println(thread.currentthread().getname()+" : 4");\n            }\n        });\n        \n    }\n}\n\n/*\n\npool-1-thread-3 : 3\npool-1-thread-2 : 2\npool-1-thread-1 : 1\npool-1-thread-1 : 4\n\n*/\n\n\n# 定长线程池\n\n(返回*)\n\nimport java.util.concurrent.executorservice;\nimport java.util.concurrent.executors;\n\n//定长线程池\n\npublic class demo2 {\n    \n    public static void main(string[] args) {\n        executorservice exception = executors.newfixedthreadpool(2);\n        \n        exception.execute(new runnable() {\n            @override\n            public void run() {\n                system.out.println(thread.currentthread().getname()+" : 1");\n                try {\n                    thread.sleep(2000);\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n        });\n    \n        exception.execute(new runnable() {\n            @override\n            public void run() {\n                system.out.println(thread.currentthread().getname()+" : 2");\n                try {\n                    thread.sleep(2000);\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n        });\n    \n        exception.execute(new runnable() {\n            @override\n            public void run() {\n                system.out.println(thread.currentthread().getname()+" : 3");\n                try {\n                    thread.sleep(2000);\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n        });\n    \n        try {\n            thread.sleep(1000);\n        } catch (interruptedexception e) {\n            e.printstacktrace();\n        }\n    \n        exception.execute(new runnable() {\n            @override\n            public void run() {\n                system.out.println(thread.currentthread().getname()+" : 4");\n                try {\n                    thread.sleep(2000);\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n        });\n    \n    }\n}\n\n/*\n\npool-1-thread-1 : 1\npool-1-thread-2 : 2\npool-1-thread-2 : 3\npool-1-thread-1 : 4\n\n*/\n\n\n# 单线程线程池\n\n(返回*)\n\nimport java.util.concurrent.executorservice;\nimport java.util.concurrent.executors;\n\n//单线程线程池\n\npublic class demo3 {\n    public static void main(string[] args) {\n        executorservice service = executors.newsinglethreadexecutor();\n        \n        service.execute(new runnable() {\n            @override\n            public void run() {\n                system.out.println(thread.currentthread().getname()+" : 1");\n                try {\n                    thread.sleep(1000);\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n        });\n    \n        service.execute(new runnable() {\n            @override\n            public void run() {\n                system.out.println(thread.currentthread().getname()+" : 2");\n                try {\n                    thread.sleep(1000);\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n        });\n    \n        service.execute(new runnable() {\n            @override\n            public void run() {\n                system.out.println(thread.currentthread().getname()+" : 3");\n                try {\n                    thread.sleep(1000);\n                } catch (interruptedexception e) {\n                    e.printstacktrace();\n                }\n            }\n        });\n        \n    }\n}\n\n/*\n\npool-1-thread-1 : 1\npool-1-thread-1 : 2\npool-1-thread-1 : 3\n\n*/\n\n\n# 周期性任务定长线程池\n\n(返回*)\n\nimport java.util.concurrent.executors;\nimport java.util.concurrent.scheduledexecutorservice;\nimport java.util.concurrent.timeunit;\n\n//周期性任务定长线程池\n\npublic class demo4 {\n    public static void main(string[] args) {\n        scheduledexecutorservice service = executors.newscheduledthreadpool(2);\n    \n        /**定时执行\n         * 参数1. 线程\n         * 参数2. 延时时长值\n         * 参数3. 时长单位\n         */\n        service.schedule(new runnable() {\n            @override\n            public void run() {\n                system.out.println("延时2s ， 执行的程序");\n            }\n        } , 2 , timeunit.seconds);\n    \n        /**周期执行\n         * 参数1. 线程\n         * 参数2. 延时时长值\n         * 参数3. 周期间隔时长值\n         * 参数4. 时长单位\n         */\n        service.scheduleatfixedrate(new runnable() {\n            @override\n            public void run() {\n                system.out.println("延时3s 执行周期间隔2s 的循环程序");\n            }\n        } , 3 , 2 , timeunit.seconds);\n        \n        \n    }\n}\n\n/*\n\n延时2s ， 执行的程序\n延时3s 执行周期间隔2s 的循环程序\n延时3s 执行周期间隔2s 的循环程序\n延时3s 执行周期间隔2s 的循环程序\n·····\n\n*/\n',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Java事件",frontmatter:{title:"Java事件",date:"2020-02-18T00:00:00.000Z",permalink:"/backend/tfnnik",categories:["后端","Java基础"],tags:["Java"],author:"柏竹"},regularPath:"/01.%E5%90%8E%E7%AB%AF/01.Java%E5%9F%BA%E7%A1%80/15.%E7%9B%91%E5%90%AC%E4%BA%8B%E4%BB%B6.html",relativePath:"01.后端/01.Java基础/15.监听事件.md",key:"v-3ead9483",path:"/backend/tfnnik/",headers:[{level:2,title:"动作事件",slug:"动作事件",normalizedTitle:"动作事件",charIndex:13},{level:2,title:"焦点事件监听器",slug:"焦点事件监听器",normalizedTitle:"焦点事件监听器",charIndex:225},{level:2,title:"键盘事件",slug:"键盘事件",normalizedTitle:"键盘事件",charIndex:518},{level:2,title:"鼠标事件",slug:"鼠标事件",normalizedTitle:"鼠标事件",charIndex:2161},{level:2,title:"窗体事件",slug:"窗体事件",normalizedTitle:"窗体事件",charIndex:5052},{level:3,title:"窗体焦点事件",slug:"窗体焦点事件",normalizedTitle:"窗体焦点事件",charIndex:5061},{level:3,title:"窗体状态事件",slug:"窗体状态事件",normalizedTitle:"窗体状态事件",charIndex:5884},{level:3,title:"其他窗体事件",slug:"其他窗体事件",normalizedTitle:"其他窗体事件",charIndex:7440},{level:3,title:"选项事件",slug:"选项事件",normalizedTitle:"选项事件",charIndex:7789}],headersStr:"动作事件 焦点事件监听器 键盘事件 鼠标事件 窗体事件 窗体焦点事件 窗体状态事件 其他窗体事件 选项事件",content:'# Java事件\n\n\n# 动作事件\n\n> Class ActionEvent\n> \n> java.lang.Object java.util.EventObject java.awt.AWTEvent java.awt.event.ActionEvent\n\nActionEvent类 监听控件动作，ActionListener接口 也可实现处理事件监听\n\n抽象方法\n\nactionPerformed(ActionEvent e); 控件回车\n\n\n# 焦点事件监听器\n\n> Class FocusEvent\n> \n> java.lang.Object java.util.EventObject java.awt.AWTEvent java.awt.event.ComponentEvent java.awt.event.FocusEvent\n\nFocusEvent类 控件焦点监听，以光标视为焦点，失去或激活都会触发事件，FocusListener接口 也可实现处理事件监听\n\n抽象方法\n\n> focusGained(FocusEvent e); 获取焦点\n> \n> focusLost(FocusEvent e); 失去焦点\n\n\n# 键盘事件\n\n> Class KeyEvent\n> \n> java.lang.Object java.util.EventObject java.awt.AWTEvent java.awt.event.ComponentEvent java.awt.event.InputEvent java.awt.event.KeyEvent\n\nKeyEvent类 键盘监听，KeyListener接口 也可实现处理事件监听\n\n抽象方法\n\n> keyTyped(KeyEvent e); 点击\n> \n> KeyPressed(keyEvent e); 被按下（未松也触发）\n> \n> KeyReleased(keyEvent e); 松开释放\n\n方法自查API\n\n注意：KeyEvent类中以“VK_”为前缀的静态常量代表键盘的keyCode（键盘按键\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\n\npublic class KeyEventTest extends JFrame {\n\n    private JTextField jtf = new JTextField(3);\n    private JLabel jl = new JLabel("H");\n    private Container container = getContentPane();\n\n    public KeyEventTest(){\n        setBounds(400, 300, 90, 80);\n        setDefaultCloseOperation(3);\n        jtf.setFont(new Font("微软雅黑",Font.PLAIN,16));\n        jl.setFont(new Font("微软雅黑",Font.PLAIN,16));\n        //窗体流布局\n        container.setLayout(new FlowLayout());\n        //添加组件\n        container.add(jtf);\n        container.add(jl);\n\n        jtf.addKeyListener(new KeyListener() {\n            @Override\n            public void keyTyped(KeyEvent e) {\n                System.out.println("点击了键盘");\n            }\n\n            @Override\n            public void keyPressed(KeyEvent e) {\n                System.out.println(e.getKeyText(e.getKeyCode()));\n            }\n\n            @Override\n            public void keyReleased(KeyEvent e) {\n                jtf.setText("");\n                jl.setText(e.getKeyText(e.getKeyCode()));\n            }\n        });\n\n        setVisible(true);\n    }\n\n    public static void main(String[] args) {\n        new KeyEventTest();\n    }\n}\n\n\n\n# 鼠标事件\n\n> Class MouseEvent\n> \n> java.lang.Object java.util.EventObject java.awt.AWTEvent java.awt.event.ComponentEvent java.awt.event.InputEvent java.awt.event.MouseEvent\n\nMouseEvent类 键盘监听类，MouseListener接口也可实现处理事件监听\n\nMouseListener接口有5个抽象方法，分为不同的触发方式\n\n> mouseEntered(MouseEvent e);  鼠标移入组件触发\\\n> \n> mousePressed(MouseEvent e); 鼠标按下触发\n> \n> mouseReleased(MouseEvent e); 鼠标释放触发\n> \n> mouseClicked(MouseEvent e); 鼠标单击触发\n> \n> mouseExited(MouseEvent e); 鼠标移出组件触发\n\n方法自查API\n\nMouseEvent类静态常量\n\n静态常量      值   键\nBUTTON1   1   鼠标左键\nBUTTON2   2   鼠标滚轮\nBUTTON3   3   鼠标右键\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\n\npublic class MouseEventTest extends JFrame implements MouseListener {\n\n    private Container c = getContentPane();\n    private JButton jb = new JButton("清空测试");\n    private JLabel jl = new JLabel("H");\n    private JTextArea jta = new JTextArea(15,35);\n    private JScrollPane jsp = new JScrollPane(jta);\n    private String scr = "";\n    private static String tap = "(暂无)";\n\n    public MouseEventTest(){\n        setLayout(new FlowLayout());\n        setDefaultCloseOperation(3);\n        setBounds(400, 300, 400, 330);\n\n        //边框颜色\n        jsp.setBorder(BorderFactory.createLineBorder(Color.RED));\n\n        c.add(jb);\n        c.add(jl);\n        c.add(jsp);\n\n        //添加监听器\n        jb.addMouseListener(this);\n        jta.addMouseListener(this);\n        jb.addActionListener(new AbstractAction() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                jta.setText("");\n            }\n        });\n        setVisible(true);\n    }\n\n\n    //鼠标移入组件\n    @Override\n    public void mouseEntered(MouseEvent e) {\n        if (e.getSource() == jb){\n            scr = "按钮：";\n        }\n        if (e.getSource() == jta){\n            scr = "文本框：";\n        }\n        jl.setText(scr+"移入组件");\n    }\n    //鼠标移出组件\n    @Override\n    public void mouseExited(MouseEvent e){\n        jl.setText(scr+"移出组件");\n    }\n    //鼠标释放\n    @Override\n    public void mouseReleased(MouseEvent e){\n        annpanduan(e);\n        jl.setText(scr+"松开"+tap);\n        jta.append(scr+"松开"+tap+"\\n");\n    }\n\n    //鼠标按下\n    @Override\n    public void mousePressed(MouseEvent e){\n        annpanduan(e);\n        jl.setText(scr+"按下"+tap);\n        jta.append(scr+"按下"+tap+"\\n");\n\n    }\n\n    //鼠标单击\n    @Override\n    public void mouseClicked(MouseEvent e){\n        annpanduan(e);\n        jl.setText(scr+"单击"+tap);\n        jta.append(scr+"单击"+tap+"\\n");\n    }\n\n    public static void annpanduan(MouseEvent e){\n        int source = e.getButton();\n        switch(source){\n            case 1 : tap = "(左键)"; break;\n            case 2 : tap = "(中键)"; break;\n            case 3 : tap = "(右键)"; break;\n        }\n    }\n\n    public static void main(String[] args) {\n        new MouseEventTest();\n    }\n    \n}\n\n\n\n# 窗体事件\n\n\n# 窗体焦点事件\n\nWindowFocusListener接口，捕获当前窗体焦点变化 抽象方法\n\n> windowGainedFocus(WindowEvent e);  获取焦点触发\n> \n> windowLosetFocus(WindowEvent e);  失去焦点触发\n\nimport javax.swing.*;\nimport java.awt.event.WindowEvent;\nimport java.awt.event.WindowFocusListener;\n\npublic class WindowFocusTest extends JFrame implements WindowFocusListener {\n\n    public WindowFocusTest(){\n        setBounds(400,300,400,300);\n        setDefaultCloseOperation(3);\n        //为窗体添加焦点事件\n        addWindowFocusListener(this);\n        setVisible(true);\n    }\n\n    @Override\n    public void windowGainedFocus(WindowEvent e){//获取焦点\n        System.out.println("获取焦点");\n    }\n    @Override\n    public void windowLostFocus(WindowEvent e){//失去焦点\n        System.out.println("失去焦点");\n    }\n\n    public static void main(String[] args) {\n        new WindowFocusTest();\n    }\n}\n\n\n\n# 窗体状态事件\n\nWindowStateListener接口，捕获当前窗体正常、最大、最小化的变化 抽象方法\n\n> windowStateChanged(WindowEvent e);  窗体发生变化时触发\n\n窗体状态变化后，获取状态的方法\n\n（int）getNewState()  获取窗体 现在 的状态\n\n（int）getOldState()  获取窗体 以前 的状态\n\n窗体状态的静态常量\n\n静态常量             值   键\nNORMAL           0   正常化\nICONIFIED        1   最小化\nMAXIMIZED_BOTH   6   最大化\n\nimport javax.swing.*;\nimport java.awt.event.WindowEvent;\nimport java.awt.event.WindowFocusListener;\nimport java.awt.event.WindowStateListener;\n\npublic class WindowBasicTest extends JFrame implements WindowFocusListener, WindowStateListener {\n\n    public WindowBasicTest(){\n        setBounds(400,300,400,300);\n        setDefaultCloseOperation(3);\n        //为窗体添加焦点事件\n        addWindowFocusListener(this);\n        addWindowStateListener(this);\n        setVisible(true);\n    }\n\n    @Override\n    public void windowGainedFocus(WindowEvent e){//获取焦点\n        System.out.println("获取焦点");\n    }\n    @Override\n    public void windowLostFocus(WindowEvent e){//失去焦点\n        System.out.println("失去焦点");\n    }\n\n    @Override\n    public void windowStateChanged(WindowEvent e){//窗体发生变化\n        //原旧状态 --\x3e 新状态\n        System.out.println(VaryString(e.getOldState())+" --\x3e "+VaryString(e.getNewState()));\n    }\n    public String VaryString(int e){\n        String scr = null;\n        switch(e){\n            case 0: scr = "正常化";break;\n            case 1: scr = "最小化";break;\n            case 6: scr = "最大化";break;\n            default: scr = "最小化";break;\n        }\n        return scr;\n    }\n\n    public static void main(String[] args) {\n        new WindowBasicTest();\n    }\n}\n\n\n\n# 其他窗体事件\n\nWindowListener接口，捕获窗体的变化情况 抽象方法\n\n> windowActivated(WindowEvent e);  激活触发（类似焦点\n> \n> windowDeactivated(WindowEvent e); 非激活触发\n> \n> windowIconified(WindowEvent e); 最小化触发\n> \n> windowDeiconified(WindowEvent e); 非最小化触发\n> \n> windowOpened(WindowEvent e); 窗口打开触发\n> \n> windowClosing(WindowEvent e); 关闭窗口触发\n> \n> windowClosed(WindowEvent e); 已关闭窗口触发\n\n\n# 选项事件\n\n> Class ItemEvent\n> \n> java.lang.Object java.util.EventObject java.awt.AWTEvent java.awt.event.ItemEvent\n\nItemEvent类 选项监听类，ItemListener接口也可实现处理事件监听 抽象方法\n\n> itemStateChanged(ItemEvent e); 选定/取消 时触发\n\n处理选项方法\n\n（object）getItem()  获取选中对象 （int）getStateChange()  获取选中的状态\n\ngetStateChange()方法 返回的静态常量\n\n静态常量         值   键\nSELECTED     1   选中\nDESELECTED   2   取消\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ItemEvent;\nimport java.awt.event.ItemListener;\n\npublic class OptionEventTest extends JFrame implements ItemListener {\n\n   private String[] listdata = {"全部", "复选框", "单选按钮"};\n   private JComboBox jcblist = new JComboBox(listdata);\n   //选中内容\n   private JPanel jpl = new JPanel();\n   private JRadioButton jrb = new JRadioButton("单选按钮");\n   private JCheckBox jcb = new JCheckBox("复选框");\n   private Container c = getContentPane();\n\n   public OptionEventTest() {\n       setBounds(400, 300, 200, 140);\n       setDefaultCloseOperation(3);\n\n       jpl.add(jrb);\n       jpl.add(jcb);\n       jpl.setSize(200, 280);\n       jpl.setBorder(BorderFactory.createTitledBorder("显示区"));\n\n       c.add(jcblist, BorderLayout.NORTH);\n       c.add(jpl, BorderLayout.CENTER);\n\n       //监听\n       jrb.addItemListener(this);\n       jcb.addItemListener(this);\n       jcblist.addItemListener(new ItemListener() {\n           @Override\n           public void itemStateChanged(ItemEvent e) {\n               switch ((String) e.getItem()) {\n                   case "单选按钮":\n                       jrb.setVisible(true);\n                       jcb.setVisible(false);\n                       break;\n                   case "复选框":\n                       jrb.setVisible(false);\n                       jcb.setVisible(true);\n                       break;\n                   default:\n                       jrb.setVisible(true);\n                       jcb.setVisible(true);\n                       break;\n               }\n           }\n       });\n\n       setVisible(true);\n   }\n\n   @Override\n   public void itemStateChanged(ItemEvent e) {// 选中 ro 取消\n       //单选按钮和复选框的父类\n       JToggleButton tmp = (JToggleButton) e.getSource();\n       String type = tmp.getText();\n       switch (e.getStateChange()) {\n           case 1:\n               System.out.println("选中" + type);\n               break;\n           case 2:\n               System.out.println("取消" + type);\n               break;\n           default:\n               System.out.println("错误");\n               break;\n       }\n   }\n\n   public static void main(String[] args) {\n       new OptionEventTest();\n   }\n}\n',normalizedContent:'# java事件\n\n\n# 动作事件\n\n> class actionevent\n> \n> java.lang.object java.util.eventobject java.awt.awtevent java.awt.event.actionevent\n\nactionevent类 监听控件动作，actionlistener接口 也可实现处理事件监听\n\n抽象方法\n\nactionperformed(actionevent e); 控件回车\n\n\n# 焦点事件监听器\n\n> class focusevent\n> \n> java.lang.object java.util.eventobject java.awt.awtevent java.awt.event.componentevent java.awt.event.focusevent\n\nfocusevent类 控件焦点监听，以光标视为焦点，失去或激活都会触发事件，focuslistener接口 也可实现处理事件监听\n\n抽象方法\n\n> focusgained(focusevent e); 获取焦点\n> \n> focuslost(focusevent e); 失去焦点\n\n\n# 键盘事件\n\n> class keyevent\n> \n> java.lang.object java.util.eventobject java.awt.awtevent java.awt.event.componentevent java.awt.event.inputevent java.awt.event.keyevent\n\nkeyevent类 键盘监听，keylistener接口 也可实现处理事件监听\n\n抽象方法\n\n> keytyped(keyevent e); 点击\n> \n> keypressed(keyevent e); 被按下（未松也触发）\n> \n> keyreleased(keyevent e); 松开释放\n\n方法自查api\n\n注意：keyevent类中以“vk_”为前缀的静态常量代表键盘的keycode（键盘按键\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.keyevent;\nimport java.awt.event.keylistener;\n\npublic class keyeventtest extends jframe {\n\n    private jtextfield jtf = new jtextfield(3);\n    private jlabel jl = new jlabel("h");\n    private container container = getcontentpane();\n\n    public keyeventtest(){\n        setbounds(400, 300, 90, 80);\n        setdefaultcloseoperation(3);\n        jtf.setfont(new font("微软雅黑",font.plain,16));\n        jl.setfont(new font("微软雅黑",font.plain,16));\n        //窗体流布局\n        container.setlayout(new flowlayout());\n        //添加组件\n        container.add(jtf);\n        container.add(jl);\n\n        jtf.addkeylistener(new keylistener() {\n            @override\n            public void keytyped(keyevent e) {\n                system.out.println("点击了键盘");\n            }\n\n            @override\n            public void keypressed(keyevent e) {\n                system.out.println(e.getkeytext(e.getkeycode()));\n            }\n\n            @override\n            public void keyreleased(keyevent e) {\n                jtf.settext("");\n                jl.settext(e.getkeytext(e.getkeycode()));\n            }\n        });\n\n        setvisible(true);\n    }\n\n    public static void main(string[] args) {\n        new keyeventtest();\n    }\n}\n\n\n\n# 鼠标事件\n\n> class mouseevent\n> \n> java.lang.object java.util.eventobject java.awt.awtevent java.awt.event.componentevent java.awt.event.inputevent java.awt.event.mouseevent\n\nmouseevent类 键盘监听类，mouselistener接口也可实现处理事件监听\n\nmouselistener接口有5个抽象方法，分为不同的触发方式\n\n> mouseentered(mouseevent e);  鼠标移入组件触发\\\n> \n> mousepressed(mouseevent e); 鼠标按下触发\n> \n> mousereleased(mouseevent e); 鼠标释放触发\n> \n> mouseclicked(mouseevent e); 鼠标单击触发\n> \n> mouseexited(mouseevent e); 鼠标移出组件触发\n\n方法自查api\n\nmouseevent类静态常量\n\n静态常量      值   键\nbutton1   1   鼠标左键\nbutton2   2   鼠标滚轮\nbutton3   3   鼠标右键\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.actionevent;\nimport java.awt.event.mouseevent;\nimport java.awt.event.mouselistener;\n\npublic class mouseeventtest extends jframe implements mouselistener {\n\n    private container c = getcontentpane();\n    private jbutton jb = new jbutton("清空测试");\n    private jlabel jl = new jlabel("h");\n    private jtextarea jta = new jtextarea(15,35);\n    private jscrollpane jsp = new jscrollpane(jta);\n    private string scr = "";\n    private static string tap = "(暂无)";\n\n    public mouseeventtest(){\n        setlayout(new flowlayout());\n        setdefaultcloseoperation(3);\n        setbounds(400, 300, 400, 330);\n\n        //边框颜色\n        jsp.setborder(borderfactory.createlineborder(color.red));\n\n        c.add(jb);\n        c.add(jl);\n        c.add(jsp);\n\n        //添加监听器\n        jb.addmouselistener(this);\n        jta.addmouselistener(this);\n        jb.addactionlistener(new abstractaction() {\n            @override\n            public void actionperformed(actionevent e) {\n                jta.settext("");\n            }\n        });\n        setvisible(true);\n    }\n\n\n    //鼠标移入组件\n    @override\n    public void mouseentered(mouseevent e) {\n        if (e.getsource() == jb){\n            scr = "按钮：";\n        }\n        if (e.getsource() == jta){\n            scr = "文本框：";\n        }\n        jl.settext(scr+"移入组件");\n    }\n    //鼠标移出组件\n    @override\n    public void mouseexited(mouseevent e){\n        jl.settext(scr+"移出组件");\n    }\n    //鼠标释放\n    @override\n    public void mousereleased(mouseevent e){\n        annpanduan(e);\n        jl.settext(scr+"松开"+tap);\n        jta.append(scr+"松开"+tap+"\\n");\n    }\n\n    //鼠标按下\n    @override\n    public void mousepressed(mouseevent e){\n        annpanduan(e);\n        jl.settext(scr+"按下"+tap);\n        jta.append(scr+"按下"+tap+"\\n");\n\n    }\n\n    //鼠标单击\n    @override\n    public void mouseclicked(mouseevent e){\n        annpanduan(e);\n        jl.settext(scr+"单击"+tap);\n        jta.append(scr+"单击"+tap+"\\n");\n    }\n\n    public static void annpanduan(mouseevent e){\n        int source = e.getbutton();\n        switch(source){\n            case 1 : tap = "(左键)"; break;\n            case 2 : tap = "(中键)"; break;\n            case 3 : tap = "(右键)"; break;\n        }\n    }\n\n    public static void main(string[] args) {\n        new mouseeventtest();\n    }\n    \n}\n\n\n\n# 窗体事件\n\n\n# 窗体焦点事件\n\nwindowfocuslistener接口，捕获当前窗体焦点变化 抽象方法\n\n> windowgainedfocus(windowevent e);  获取焦点触发\n> \n> windowlosetfocus(windowevent e);  失去焦点触发\n\nimport javax.swing.*;\nimport java.awt.event.windowevent;\nimport java.awt.event.windowfocuslistener;\n\npublic class windowfocustest extends jframe implements windowfocuslistener {\n\n    public windowfocustest(){\n        setbounds(400,300,400,300);\n        setdefaultcloseoperation(3);\n        //为窗体添加焦点事件\n        addwindowfocuslistener(this);\n        setvisible(true);\n    }\n\n    @override\n    public void windowgainedfocus(windowevent e){//获取焦点\n        system.out.println("获取焦点");\n    }\n    @override\n    public void windowlostfocus(windowevent e){//失去焦点\n        system.out.println("失去焦点");\n    }\n\n    public static void main(string[] args) {\n        new windowfocustest();\n    }\n}\n\n\n\n# 窗体状态事件\n\nwindowstatelistener接口，捕获当前窗体正常、最大、最小化的变化 抽象方法\n\n> windowstatechanged(windowevent e);  窗体发生变化时触发\n\n窗体状态变化后，获取状态的方法\n\n（int）getnewstate()  获取窗体 现在 的状态\n\n（int）getoldstate()  获取窗体 以前 的状态\n\n窗体状态的静态常量\n\n静态常量             值   键\nnormal           0   正常化\niconified        1   最小化\nmaximized_both   6   最大化\n\nimport javax.swing.*;\nimport java.awt.event.windowevent;\nimport java.awt.event.windowfocuslistener;\nimport java.awt.event.windowstatelistener;\n\npublic class windowbasictest extends jframe implements windowfocuslistener, windowstatelistener {\n\n    public windowbasictest(){\n        setbounds(400,300,400,300);\n        setdefaultcloseoperation(3);\n        //为窗体添加焦点事件\n        addwindowfocuslistener(this);\n        addwindowstatelistener(this);\n        setvisible(true);\n    }\n\n    @override\n    public void windowgainedfocus(windowevent e){//获取焦点\n        system.out.println("获取焦点");\n    }\n    @override\n    public void windowlostfocus(windowevent e){//失去焦点\n        system.out.println("失去焦点");\n    }\n\n    @override\n    public void windowstatechanged(windowevent e){//窗体发生变化\n        //原旧状态 --\x3e 新状态\n        system.out.println(varystring(e.getoldstate())+" --\x3e "+varystring(e.getnewstate()));\n    }\n    public string varystring(int e){\n        string scr = null;\n        switch(e){\n            case 0: scr = "正常化";break;\n            case 1: scr = "最小化";break;\n            case 6: scr = "最大化";break;\n            default: scr = "最小化";break;\n        }\n        return scr;\n    }\n\n    public static void main(string[] args) {\n        new windowbasictest();\n    }\n}\n\n\n\n# 其他窗体事件\n\nwindowlistener接口，捕获窗体的变化情况 抽象方法\n\n> windowactivated(windowevent e);  激活触发（类似焦点\n> \n> windowdeactivated(windowevent e); 非激活触发\n> \n> windowiconified(windowevent e); 最小化触发\n> \n> windowdeiconified(windowevent e); 非最小化触发\n> \n> windowopened(windowevent e); 窗口打开触发\n> \n> windowclosing(windowevent e); 关闭窗口触发\n> \n> windowclosed(windowevent e); 已关闭窗口触发\n\n\n# 选项事件\n\n> class itemevent\n> \n> java.lang.object java.util.eventobject java.awt.awtevent java.awt.event.itemevent\n\nitemevent类 选项监听类，itemlistener接口也可实现处理事件监听 抽象方法\n\n> itemstatechanged(itemevent e); 选定/取消 时触发\n\n处理选项方法\n\n（object）getitem()  获取选中对象 （int）getstatechange()  获取选中的状态\n\ngetstatechange()方法 返回的静态常量\n\n静态常量         值   键\nselected     1   选中\ndeselected   2   取消\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.itemevent;\nimport java.awt.event.itemlistener;\n\npublic class optioneventtest extends jframe implements itemlistener {\n\n   private string[] listdata = {"全部", "复选框", "单选按钮"};\n   private jcombobox jcblist = new jcombobox(listdata);\n   //选中内容\n   private jpanel jpl = new jpanel();\n   private jradiobutton jrb = new jradiobutton("单选按钮");\n   private jcheckbox jcb = new jcheckbox("复选框");\n   private container c = getcontentpane();\n\n   public optioneventtest() {\n       setbounds(400, 300, 200, 140);\n       setdefaultcloseoperation(3);\n\n       jpl.add(jrb);\n       jpl.add(jcb);\n       jpl.setsize(200, 280);\n       jpl.setborder(borderfactory.createtitledborder("显示区"));\n\n       c.add(jcblist, borderlayout.north);\n       c.add(jpl, borderlayout.center);\n\n       //监听\n       jrb.additemlistener(this);\n       jcb.additemlistener(this);\n       jcblist.additemlistener(new itemlistener() {\n           @override\n           public void itemstatechanged(itemevent e) {\n               switch ((string) e.getitem()) {\n                   case "单选按钮":\n                       jrb.setvisible(true);\n                       jcb.setvisible(false);\n                       break;\n                   case "复选框":\n                       jrb.setvisible(false);\n                       jcb.setvisible(true);\n                       break;\n                   default:\n                       jrb.setvisible(true);\n                       jcb.setvisible(true);\n                       break;\n               }\n           }\n       });\n\n       setvisible(true);\n   }\n\n   @override\n   public void itemstatechanged(itemevent e) {// 选中 ro 取消\n       //单选按钮和复选框的父类\n       jtogglebutton tmp = (jtogglebutton) e.getsource();\n       string type = tmp.gettext();\n       switch (e.getstatechange()) {\n           case 1:\n               system.out.println("选中" + type);\n               break;\n           case 2:\n               system.out.println("取消" + type);\n               break;\n           default:\n               system.out.println("错误");\n               break;\n       }\n   }\n\n   public static void main(string[] args) {\n       new optioneventtest();\n   }\n}\n',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"JavaAWT绘图",frontmatter:{title:null,date:"2020-02-18T00:00:00.000Z",permalink:"/backend/34q8xb",categories:["后端","Java基础"],tags:["Java"],author:"柏竹"},regularPath:"/01.%E5%90%8E%E7%AB%AF/01.Java%E5%9F%BA%E7%A1%80/16.AWT%E7%BB%98%E5%9B%BE.html",relativePath:"01.后端/01.Java基础/16.AWT绘图.md",key:"v-fb49d4e2",path:"/backend/34q8xb/",headers:[{level:2,title:"绘制图形",slug:"绘制图形",normalizedTitle:"绘制图形",charIndex:16},{level:3,title:"Canvas画布类",slug:"canvas画布类",normalizedTitle:"canvas画布类",charIndex:25},{level:3,title:"Graphics绘图类",slug:"graphics绘图类",normalizedTitle:"graphics绘图类",charIndex:231},{level:3,title:"Graphics2D新绘图类",slug:"graphics2d新绘图类",normalizedTitle:"graphics2d新绘图类",charIndex:1493},{level:3,title:"代码绘制流程",slug:"代码绘制流程",normalizedTitle:"代码绘制流程",charIndex:1778},{level:2,title:"绘图属性",slug:"绘图属性",normalizedTitle:"绘图属性",charIndex:3827},{level:3,title:"颜色",slug:"颜色",normalizedTitle:"颜色",charIndex:3836},{level:3,title:"画笔",slug:"画笔",normalizedTitle:"画笔",charIndex:4049},{level:2,title:"绘制文本",slug:"绘制文本",normalizedTitle:"绘制文本",charIndex:6081},{level:3,title:"设置字体",slug:"设置字体",normalizedTitle:"设置字体",charIndex:6090},{level:3,title:"显示文字",slug:"显示文字",normalizedTitle:"显示文字",charIndex:6330},{level:2,title:"绘制图片",slug:"绘制图片",normalizedTitle:"绘制图片",charIndex:7566},{level:3,title:"图像处理",slug:"图像处理",normalizedTitle:"图像处理",charIndex:7743},{level:4,title:"缩放",slug:"缩放",normalizedTitle:"缩放",charIndex:7751},{level:3,title:"翻转",slug:"翻转",normalizedTitle:"翻转",charIndex:9177},{level:4,title:"旋转",slug:"旋转",normalizedTitle:"旋转",charIndex:11262},{level:4,title:"倾斜",slug:"倾斜",normalizedTitle:"倾斜",charIndex:12833},{level:3,title:"处理Main执行",slug:"处理main执行",normalizedTitle:"处理main执行",charIndex:15365}],headersStr:"绘制图形 Canvas画布类 Graphics绘图类 Graphics2D新绘图类 代码绘制流程 绘图属性 颜色 画笔 绘制文本 设置字体 显示文字 绘制图片 图像处理 缩放 翻转 旋转 倾斜 处理Main执行",content:'# JavaAWT绘图\n\n\n# 绘制图形\n\n\n# Canvas画布类\n\n> Class Canvas\n> \n> java.lang.Object java.awt.Component java.awt.Canvas\n\n用来 绘制图形 或 捕获用户输入的事件。绘制图形需要绘图方法实现绘制图形\n\n方法                    说明\npaint(Graphics g)     绘图\nrepaint(Graphics g)   重新绘图（刷新\n\n\n# Graphics绘图类\n\n> Class Graphics\n> \n> java.lang.Object java.awt.Graphics\n\nGraphics绘图类 是所有图形的抽象基类，它提供了绘图常用的方法\n\n图形       方法\n弧形       drawArc(int x , int y , int width , int height , int\n         startAngle , int arcAngle) \n直线       drawLine(int x1 , int y1 , int x2 , int y2) \n椭圆       drawOval(int x , int y , int width , int height) \n多边形      drawPolygon(int[] xPoints , int[] yPoints , int nPoints) \n多边线      drawPolyline(int[] xPoints , int[] yPoints , int nPoints) \n矩形       drawRect(int x , int y , int width , int height) \n圆角矩形     drawRoundRect(int x , int y , int width , int height , int\n         arcWidth, int arcHeight) \n实心弧形     fillArc(int x , int y , int width , int height , int height\n         , int startAngle , int arcAngle) \n实心椭圆     fillOval(int x , int y , int width , int height) \n实心多边形    fillPolygon(int[] xPoints , int[] yPoints , int nPoints) \n实心矩形     fillRect(int x , int y , int width , int height) \n实心圆角矩形   fillRoundRect(int x , int y , int width , int height , int\n         arcWidth, int arcHeight) \n\n参数           说明\nx            坐标X\ny            坐标Y\nwidth        宽度\nheight       高度\nstartAngle   起始角度\narcAngle     相对起始角度的弧的角度范围\nxPoints      X坐标的数组\nyPoints      Y坐标的数组\nnPoints      总数\narcWidth     四角圆弧的水平直径\narcHeight    四角圆弧的垂直直径\n\n\n# Graphics2D新绘图类\n\n> Class Graphics2D\n> \n> java.lang.Object java.awt.Graphics java.awt.Graphics2D\n\nGraphics类的扩展 Graphics2D新绘图类，它必须要 draw()和fill() 方法 绘图 方法的参数需要Shape图形接口实现绘图（接口在 java.awt.geom 包下\n\n抽象方法               说明\ndraw(Shape form)   绘制图形\nfill(Shape form)   填充图形\n\nform：Shape图形接口的对象\n\n\n# 代码绘制流程\n\n>  1. 创建窗体对象\n>  2. 创建 Canvas画布类 并添加入窗体容器里\n>  3. 调用 Canvas画布类中 paint(Graphics g)方法\n>  4. 调用 paint(Graphics g)方法 中的 Graphics对象 或 创建Graphics2D绘图对象\n>  5. 调用 绘图的抽象方法 实现绘图\n> \n> 方式二：（从步骤4开始，适合批量绘图）\n> \n>  5. 实例 java.awt.geom包 中的图形类，赋值至 Shape接口 对象\n>  6. 传参 调用 Graphics2D类 中的 draw() 或 fill() 方法 实现绘图\n\n大致例子：\n\n大致例子：\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.geom.Ellipse2D;\nimport java.awt.geom.Rectangle2D;\nimport java.awt.geom.RectangularShape;\n\npublic class DrawFrame extends JFrame {\n\n    private Container c = getContentPane();\n\n    public DrawFrame(){\n        setBounds(400 , 300 , 360 , 160);\n        setDefaultCloseOperation(3);\n\n        //Canvas匿名画布类 重写paint()绘图方法\n        c.add(new Canvas(){\n           @Override\n           public void paint(Graphics g){\n               Graphics2D g2 = (Graphics2D) g;\n//方法一\n               g2.drawRoundRect(10 , 5 , 100 , 100 , 10 , 10);\n               g2.fillOval(20 , 15 , 80 , 80);\n//方法二\n               //声明图形数组\n               Shape[] shapes = new Shape[4];\n               //以double精度创建\n               //绘制圆\n               shapes[0] = new Ellipse2D.Double(120, 5 , 100 ,100);\n               //绘制矩形\n               shapes[1] = new Rectangle2D.Double(230 ,5 ,100 ,100);\n                //绘制矩形\n               shapes[2] = new Rectangle2D.Double(130 ,15 ,80 ,80);\n               //绘制圆\n               shapes[3] = new Ellipse2D.Double(240 ,15 ,80 ,80);\n               for(Shape tmp : shapes){\n                   //Rectangle2D bounds = tmp.getBounds2D();    （Rectangle2D是RectangularShape的子类\n                   //RectangularShape类 用来查询和修改矩形框架的类\n                   RectangularShape bounds = tmp.getBounds2D();\n                   if(bounds.getWidth() == 80){\n                       //第二组图形创建\n                       g2.fill(tmp);\n                   }else{\n                       //第一组图形创建\n                       g2.draw(tmp);\n                   }\n               }\n           }\n        });\n\n    }\n\n    public static void main(String[] args) {\n        new DrawFrame().setVisible(true);\n    }\n}\n\n\n运行结果：\n\n\n# 绘图属性\n\n\n# 颜色\n\n> Class Color\n> \n> java.lang.Object java.awt.Color\n\nColor类 提供设置颜色的对象 构造方法\n\nColor(int R , int G , int B)  Color(int RGB) \n\n参数说明\n\n> R： 红色颜色值 G： 绿色颜色值 B： 蓝色颜色值 RGB： 组合RGB颜色值\n\nColor常量值 有已定义好的颜色对象，可直接调用（自行API查\n\n\n# 画笔\n\n> Class BasicStroke\n> \n> java.lang.Object java.awt.BasicStroke\n\nBasicStroke类 为图形轮廓定义基本渲染属性（定义边线属性 实现前提需要Stroke接口实现类！！！\n\n**构造方法 **\n\nBasicStroke() BasicStroke(float width) BasicStroke(float width , int cap , int join) BasicStroke(float width , int cap , int join , float miterlimit) BasicStroke(float width , int cap , int join , float miterlimit , float[] dash , float dash_phase)\n\n参数           说明\nwidth        画笔宽度\ncap          线端点的装饰\njoin         应用在路径线段交会处的装饰\nmiterlimit   斜接处的剪裁限制\ndash         虚线模式的数组\ndash_phase   开始虚线模式的偏移量\n\nCAP参数 3个常量及标识 JOIN参数 3常量及标识\n\n代码实现流程：\n\n>  1. 创建Stroke接口对象，实例BasicStroke对象\n>  2. 设置画笔 setStroke(Stroke)方法\n\n大致例子：\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class BrushTest extends JFrame {\n    public BrushTest(){\n        setBounds(400 ,300 ,300 ,230);\n        setDefaultCloseOperation(3);\n        add(new MyCanvas());\n    }\n\n    class MyCanvas extends Canvas{\n        @Override\n        public void paint(Graphics g) {\n            super.paint(g);\n            Graphics2D g2 = (Graphics2D)g;\n\n            Stroke[] s = {\n                    new BasicStroke(10 , BasicStroke.CAP_ROUND ,BasicStroke.JOIN_ROUND),\n                    new BasicStroke(10 , BasicStroke.CAP_BUTT , BasicStroke.JOIN_ROUND),\n                    new BasicStroke(10 , BasicStroke.CAP_SQUARE , BasicStroke.JOIN_ROUND),\n                    new BasicStroke(10 , BasicStroke.CAP_BUTT , BasicStroke.JOIN_BEVEL)\n            };\n\n        //    图形No.1\n            g2.setStroke(s[0]);\n            g2.drawLine(10,10 , 230,10);\n            g2.setStroke(s[1]);\n            g2.drawLine(10,30 , 230,30);\n            g2.setStroke(s[2]);\n            g2.drawLine(10,50 , 230,50);\n\n        //    图形No.2\n            //更改颜色\n            g2.setColor(Color.CYAN);\n            g2.setStroke(s[3]);\n            int[]   x = {20 ,200 ,20 ,200},\n                     y = {80 ,80 ,180 ,180};\n            g2.drawPolyline(x , y , 4);\n        }\n    }\n\n    public static void main(String[] args) {\n        new BrushTest().setVisible(true);\n    }\n}\n\n\n运行结果：\n\n\n# 绘制文本\n\n\n# 设置字体\n\n> Class Font\n> \n> java.lang.Object java.awt.Font\n\nFont类 封装字体的大小、样式等属性 构造方法\n\nFont(String naem , int style , int size)\n\n> name： 字体名称 style： 字体样式 size： 字体大小\n\n字体样式    常量\n普通      PLAIN\n粗体      BOLD\n斜体      ITALIC\n粗体&斜体   ITALIC | BOLD\n\n\n# 显示文字\n\nGraphics2D提供了 drawString()方法 ，可以抛开 JLable类 写入窗体的方法\n\n（Graphics2D | Graphics）drawString(String str , int x , int y)  （Graphics2D ）drawString(String str , float x , float y) \n\n> str： 文本 x： 坐标X y： 坐标Y\n\nimport javax.swing.*;\nimport java.awt.*;\n\n//4.绘制文本\npublic class DrawTextTest extends JFrame {\n\n    public DrawTextTest() {\n        setBounds(400, 300, 230, 150);\n        setDefaultCloseOperation(3);\n\n        add(new Canvas() {\n            @Override\n            public void paint(Graphics g) {\n                super.paint(g);\n                Graphics2D g2 = (Graphics2D) g;\n                Font[] f = {\n                        new Font("微软雅黑", Font.BOLD, 23),\n                        new Font("微软雅黑", Font.ITALIC, 23),\n                        new Font("微软雅黑", Font.ITALIC | Font.BOLD, 23)\n                };\n\n                g2.setFont(f[0]);\n                g2.drawString("Sanscan12" , 20 , 30);\n                g2.setFont(f[1]);\n                g2.drawString("Sanscan12" , 20 , 60);\n                g2.setFont(f[2]);\n                g2.drawString("Sanscan12" , 20 , 90);\n                \n            }\n        });\n    }\n\n    public static void main(String[] args) {\n        new DrawTextTest().setVisible(true);\n    }\n}\n\n\n运行结果：\n\n\n# 绘制图片\n\nGraphics提供了 drawImage()方法，可以进行绘制图片处理图片，抛开 JLable类 写入窗体的方法\n\ndrawImage(Image img  , int x  , int y , ImageObserver observer) \n\n> img： 图片对象 x： 坐标X y： 坐标Y observer： 窗体/容器\n\n\n# 图像处理\n\n# 缩放\n\n重写drawImage()方法，区别6个参数，要原有初始大小的图片\n\ndrawImage(Image img , int x , int y , int width , int height , ImageObserver observer) \n\n> width： 图片新宽度 height： 图片新高度\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\n//2.缩放\n// Main类调用 该实例\npublic class SizeTest extends Canvas {\n\n    int W , H ;\n    Image image;\n    static int count = 0;\n    static JButton[] jb = {\n            new JButton("放大"),\n            new JButton("缩小")\n    };\n\n    public SizeTest(){\n        this.image = new ImageIcon("Image1.png").getImage();\n        this.W = image.getWidth(this);\n        this.H = image.getHeight(this);\n\n        Canvas c = this;\n        //添加响应\n        // 放大\n        jb[0].addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                count+=1;\n                c.repaint();\n            }\n        });\n        //缩小\n        jb[1].addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                count-=1;\n                c.repaint();\n            }\n        });\n    }\n\n    @Override\n    public void paint(Graphics g) {\n        super.paint(g);\n        Graphics2D g2 = (Graphics2D)g;\n        g2.drawImage(image , 0 , 0 ,W+count , H+count , this);\n    }\n\n    public static JButton[] getJButtonAll(){\n        return jb;\n    }\n}\n\n\n运行结果：\n\n\n# 翻转\n\n重写drawImage()方法，区别10个参数，水平垂直翻转的作用\n\ndrawlmage(Image img , int dx1 , int dy1 , int dx2 , int dy2 , int sx1 , int sy1 , int sx2 , int sy2 , ImageObserver observer)\n\n> dx1/dy1： 目标矩形对应角XY坐标 dx2/dy2： 目标矩形对应角XY坐标 sx1/sy1： 源矩形左上角XY坐标 sx2/sy2： 源矩形右下角XY坐标\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\n//3.翻转\n//在Main类调用 该实例\npublic class TurnTest extends Canvas{\n\n    static JButton[] jb = {\n            new JButton("水平"),\n            new JButton("垂直")\n    };\n    Image image ;\n    int sx1,sy1,sx2,sy2;        //源矩形左上，右下\n    int dx1,dy1,dx2,dy2;     //目标矩形\n    int origin , width , hight;\n\n    public TurnTest(){\n        //初始化数据\n        image = new ImageIcon("Image1.png").getImage();\n        origin = 0;\n        width = image.getWidth(this);\n        hight = image.getHeight(this);\n        dx1 = sx1 = origin;\n        dy1 = sy1 = origin;\n        dx2 = sx2 = width;\n        dy2 = sy2 = hight;\n\n        Canvas c = this;\n        //水平\n        jb[0].addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                //dx1右上获取 宽（width-width）\n                dx1 = Math.abs(dx1 - width);\n                //dx2左下获取 宽  （0-width）\n                dx2 = Math.abs(dx2 - width);\n                c.repaint();\n            }\n        });\n        //垂直\n        jb[1].addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                //dy1 右上获取 高 （0-hight）\n                dy1 = Math.abs(dy1 - hight);\n                //dy2 左下获取 高 （higth - hight）\n                dy2 = Math.abs(dy2 - hight);\n                c.repaint();\n            }\n        });\n    }\n\n    @Override\n    public void paint(Graphics g) {\n        super.paint(g);\n        Graphics2D g2 = (Graphics2D)g;\n        g2.drawImage(image ,\n                dx1 , dy1 ,dx2 , dy2 ,  //目标矩形\n                sx1 , sy1 , sx2 , sy2 ,  //源矩形\n                this);\n    }\n\n    public static JButton[] getJButtonAll(){\n        return jb;\n    }\n}\n\n\n运行结果：\n\n# 旋转\n\n重写drawImage()方法，区别6个参数，旋转的前提需要调用Graphics2D类的rotate()方法，进行旋转\n\ndrawImage(Image img , int x , int y , int width , int height , ImageObserver observer)\n\n方法 rotate(double thete)  thete：旋转弧度\n\n> 参数的弧度值可以使用Math类的toRadians()方法将角度转换为弧度（近似值）\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\n\n//2.旋转\n// Main类调用 该实例\npublic class WhirlTest extends Canvas {\n\n    int W , H ;\n    Image image;\n    static int count = 0;\n    static JButton[] jb = {\n            new JButton("左转"),\n            new JButton("右转")\n    };\n\n    public WhirlTest(){\n        this.image = new ImageIcon("Image1.png").getImage();\n        this.W = image.getWidth(this);\n        this.H = image.getHeight(this);\n        Canvas c = this;\n\n        //添加响应\n        // 左\n        jb[0].addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                count++;\n                c.repaint();\n            }\n        });\n        //右\n        jb[1].addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                count--;\n                c.repaint();\n            }\n        });\n    }\n\n    @Override\n    public void paint(Graphics g) {\n        super.paint(g);\n        Graphics2D g2 = (Graphics2D)g;\n        //toRadians：以度为单位的角度转换为以弧度（近似值）\n        g2.rotate(Math.toRadians(count));\n        g2.drawImage(image , 0 , 0 ,W , H , this);\n    }\n\n    public static JButton[] getJButtonAll(){\n        return jb;\n    }\n}\n\n\n运行结果：\n\n# 倾斜\n\n重写drawImage()方法，区别6个参数，旋转的前提需要调用Graphics2D类的shear()方法，实现倾斜\n\ndrawImage(Image img , int x , int y , int width , int height , ImageObserver observer)\n\n方法 shear(double shx , double shy) shx： 水平倾斜量 ； shy： 垂直倾斜量\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\n\n//5.翻转\n//在Main类调用 该实例\npublic class TiltTest extends Canvas{\n\n    int W , H ;\n    double X , Y;\n    static boolean Narrow = false;\n    static JButton[] jb = {\n            new JButton("<--︿"),\n            new JButton("﹀--\x3e")\n    };\n    Image image ;\n\n    public TiltTest(){\n        //初始化数据\n        image = new ImageIcon("Image1.png").getImage();\n        W = image.getWidth(this);\n        H = image.getHeight(this);\n        X = Y = 0;\n\n        Canvas c = this;\n        //判断Alt键是否按下\n        System.out.println("通过点击Alt键，控制倾斜 X 或 Y 轴");\n        addKeyListener(new KeyListener() {\n            @Override\n            public void keyTyped(KeyEvent e) { }\n            @Override\n            public void keyPressed(KeyEvent e) {\n                if (e.getKeyText(e.getKeyCode()) == "Alt"){\n                    if (Narrow){\n                        Narrow = false;\n                        System.out.println("目前倾斜X轴");\n                    }else {\n                        Narrow = true;\n                        System.out.println("目前倾斜Y轴");\n                    }\n                }\n            }\n            @Override\n            public void keyReleased(KeyEvent e) { }\n        });\n        //<--\n        jb[0].addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                if (Narrow){\n                    Y -= 0.05;\n                }else {\n                    X -= 0.05;\n                }\n                c.repaint();\n            }\n        });\n        //--\x3e\n        jb[1].addActionListener(new ActionListener() {\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                if (Narrow){\n                    Y += 0.05;\n                }else {\n                    X += 0.05;\n                }\n                c.repaint();\n            }\n        });\n    }\n\n    @Override\n    public void paint(Graphics g) {\n        super.paint(g);\n        Graphics2D g2 = (Graphics2D)g;\n        //主要代码\n        g2.shear(X , Y);\n        g2.drawImage(image , 0 , 0 ,W , H , this);\n    }\n\n    public static JButton[] getJButtonAll(){\n        return jb;\n    }\n}\n\n\n运行结果：\n\n\n# 处理Main执行\n\n以上 图片处理 代码需要Main类执行\n\nimport javax.swing.*;\nimport java.awt.*;\n\n//1.图形显示\npublic class Main extends JFrame {\n\n    //public JButton\n    //        jb1 = new JButton("+"),\n    //        jb2 = new JButton("-");\n\n    //public Canvas canvas = null;\n\n    public Main(Canvas c , JButton jb1 ,JButton jb2){\n        setBounds(400 , 300 , 666 , 600);\n        setDefaultCloseOperation(3);\n        JPanel jp = new JPanel();\n        jp.add(jb1);\n        jp.add(jb2);\n        add(jp , BorderLayout.SOUTH);\n        add(c);\n    }\n\n\n    public static void main(String[] args) {\n        /*  自行实例\n         *   1.GraphTest    //显示图片\n         *   2.SizeTest     //放大与缩小\n         *   3.TurnTest    //翻转\n         *   4.WhirlTest    //旋转\n         *   5.TiltTest     //倾斜\n         * */\n         Canvas canvas = new TiltTest();//更改实例对象即可\n         JButton[]  jb = TiltTest.getJButtonAll();//更改类\n        new Main(canvas , jb[0] , jb[1]).setVisible(true);\n    }\n}\n\n\n图片流转换\n\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\n\n/**\n * 将二进制流转换成图片文件\n * @author 晚风工作室 www.soservers.com\n *\n */\n\npublic class ImgErToFileUtil {\n\n    /**\n     * 将接收的字符串转换成图片保存\n     * @param imgStr 二进制流转换的字符串\n     * @param imgPath 图片的保存路径\n     * @param imgName 图片的名称\n     * @return\n     * \t\t1：保存正常\n     * \t\t0：保存失败\n     */\n    public static int saveToImgByStr(String imgStr,String imgPath,String imgName){\n        try {\n            System.out.println("===imgStr.length()====>" + imgStr.length()\n                    + "=====imgStr=====>" + imgStr);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        int stateInt = 1;\n        if(imgStr != null && imgStr.length() > 0){\n            try {\n\n                // 将字符串转换成二进制，用于显示图片  \n                // 将上面生成的图片格式字符串 imgStr，还原成图片显示  \n                byte[] imgByte = hex2byte( imgStr );\n\n                InputStream in = new ByteArrayInputStream(imgByte);\n\n                File file=new File(imgPath,imgName);//可以是任何图片格式.jpg,.png等\n                FileOutputStream fos=new FileOutputStream(file);\n\n                byte[] b = new byte[1024];\n                int nRead = 0;\n                while ((nRead = in.read(b)) != -1) {\n                    fos.write(b, 0, nRead);\n                }\n                fos.flush();\n                fos.close();\n                in.close();\n\n            } catch (Exception e) {\n                stateInt = 0;\n                e.printStackTrace();\n            } finally {\n            }\n        }\n        return stateInt;\n    }\n\n    /**\n     * 将二进制转换成图片保存\n     * @param imgStr 二进制流转换的字符串\n     * @param imgPath 图片的保存路径\n     * @param imgName 图片的名称\n     * @return\n     * \t\t1：保存正常\n     * \t\t0：保存失败\n     */\n    public static int saveToImgByBytes(File imgFile,String imgPath,String imgName){\n\n        int stateInt = 1;\n        if(imgFile.length() > 0){\n            try {\n                File file=new File(imgPath,imgName);//可以是任何图片格式.jpg,.png等\n                FileOutputStream fos=new FileOutputStream(file);\n\n                FileInputStream fis = new FileInputStream(imgFile);\n\n                byte[] b = new byte[1024];\n                int nRead = 0;\n                while ((nRead = fis.read(b)) != -1) {\n                    fos.write(b, 0, nRead);\n                }\n                fos.flush();\n                fos.close();\n                fis.close();\n\n            } catch (Exception e) {\n                stateInt = 0;\n                e.printStackTrace();\n            } finally {\n            }\n        }\n        return stateInt;\n    }\n\n    /**\n     * 二进制转字符串\n     * @param b\n     * @return\n     */\n    public static String byte2hex(byte[] b) // 二进制转字符串\n    {\n        StringBuffer sb = new StringBuffer();\n        String stmp = "";\n        for (int n = 0; n < b.length; n++) {\n            stmp = Integer.toHexString(b[n] & 0XFF);\n            if (stmp.length() == 1) {\n                sb.append("0" + stmp);\n            } else {\n                sb.append(stmp);\n            }\n\n        }\n        return sb.toString();\n    }\n\n    /**\n     * 字符串转二进制\n     * @param str 要转换的字符串\n     * @return  转换后的二进制数组\n     */\n    public static byte[] hex2byte(String str) { // 字符串转二进制\n        if (str == null)\n            return null;\n        str = str.trim();\n        int len = str.length();\n        if (len == 0 || len % 2 == 1)\n            return null;\n        byte[] b = new byte[len / 2];\n        try {\n            for (int i = 0; i < str.length(); i += 2) {\n                b[i / 2] = (byte) Integer\n                        .decode("0X" + str.substring(i, i + 2)).intValue();\n            }\n            return b;\n        } catch (Exception e) {\n            return null;\n        }\n    }\n\n}\n',normalizedContent:'# javaawt绘图\n\n\n# 绘制图形\n\n\n# canvas画布类\n\n> class canvas\n> \n> java.lang.object java.awt.component java.awt.canvas\n\n用来 绘制图形 或 捕获用户输入的事件。绘制图形需要绘图方法实现绘制图形\n\n方法                    说明\npaint(graphics g)     绘图\nrepaint(graphics g)   重新绘图（刷新\n\n\n# graphics绘图类\n\n> class graphics\n> \n> java.lang.object java.awt.graphics\n\ngraphics绘图类 是所有图形的抽象基类，它提供了绘图常用的方法\n\n图形       方法\n弧形       drawarc(int x , int y , int width , int height , int\n         startangle , int arcangle) \n直线       drawline(int x1 , int y1 , int x2 , int y2) \n椭圆       drawoval(int x , int y , int width , int height) \n多边形      drawpolygon(int[] xpoints , int[] ypoints , int npoints) \n多边线      drawpolyline(int[] xpoints , int[] ypoints , int npoints) \n矩形       drawrect(int x , int y , int width , int height) \n圆角矩形     drawroundrect(int x , int y , int width , int height , int\n         arcwidth, int archeight) \n实心弧形     fillarc(int x , int y , int width , int height , int height\n         , int startangle , int arcangle) \n实心椭圆     filloval(int x , int y , int width , int height) \n实心多边形    fillpolygon(int[] xpoints , int[] ypoints , int npoints) \n实心矩形     fillrect(int x , int y , int width , int height) \n实心圆角矩形   fillroundrect(int x , int y , int width , int height , int\n         arcwidth, int archeight) \n\n参数           说明\nx            坐标x\ny            坐标y\nwidth        宽度\nheight       高度\nstartangle   起始角度\narcangle     相对起始角度的弧的角度范围\nxpoints      x坐标的数组\nypoints      y坐标的数组\nnpoints      总数\narcwidth     四角圆弧的水平直径\narcheight    四角圆弧的垂直直径\n\n\n# graphics2d新绘图类\n\n> class graphics2d\n> \n> java.lang.object java.awt.graphics java.awt.graphics2d\n\ngraphics类的扩展 graphics2d新绘图类，它必须要 draw()和fill() 方法 绘图 方法的参数需要shape图形接口实现绘图（接口在 java.awt.geom 包下\n\n抽象方法               说明\ndraw(shape form)   绘制图形\nfill(shape form)   填充图形\n\nform：shape图形接口的对象\n\n\n# 代码绘制流程\n\n>  1. 创建窗体对象\n>  2. 创建 canvas画布类 并添加入窗体容器里\n>  3. 调用 canvas画布类中 paint(graphics g)方法\n>  4. 调用 paint(graphics g)方法 中的 graphics对象 或 创建graphics2d绘图对象\n>  5. 调用 绘图的抽象方法 实现绘图\n> \n> 方式二：（从步骤4开始，适合批量绘图）\n> \n>  5. 实例 java.awt.geom包 中的图形类，赋值至 shape接口 对象\n>  6. 传参 调用 graphics2d类 中的 draw() 或 fill() 方法 实现绘图\n\n大致例子：\n\n大致例子：\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.geom.ellipse2d;\nimport java.awt.geom.rectangle2d;\nimport java.awt.geom.rectangularshape;\n\npublic class drawframe extends jframe {\n\n    private container c = getcontentpane();\n\n    public drawframe(){\n        setbounds(400 , 300 , 360 , 160);\n        setdefaultcloseoperation(3);\n\n        //canvas匿名画布类 重写paint()绘图方法\n        c.add(new canvas(){\n           @override\n           public void paint(graphics g){\n               graphics2d g2 = (graphics2d) g;\n//方法一\n               g2.drawroundrect(10 , 5 , 100 , 100 , 10 , 10);\n               g2.filloval(20 , 15 , 80 , 80);\n//方法二\n               //声明图形数组\n               shape[] shapes = new shape[4];\n               //以double精度创建\n               //绘制圆\n               shapes[0] = new ellipse2d.double(120, 5 , 100 ,100);\n               //绘制矩形\n               shapes[1] = new rectangle2d.double(230 ,5 ,100 ,100);\n                //绘制矩形\n               shapes[2] = new rectangle2d.double(130 ,15 ,80 ,80);\n               //绘制圆\n               shapes[3] = new ellipse2d.double(240 ,15 ,80 ,80);\n               for(shape tmp : shapes){\n                   //rectangle2d bounds = tmp.getbounds2d();    （rectangle2d是rectangularshape的子类\n                   //rectangularshape类 用来查询和修改矩形框架的类\n                   rectangularshape bounds = tmp.getbounds2d();\n                   if(bounds.getwidth() == 80){\n                       //第二组图形创建\n                       g2.fill(tmp);\n                   }else{\n                       //第一组图形创建\n                       g2.draw(tmp);\n                   }\n               }\n           }\n        });\n\n    }\n\n    public static void main(string[] args) {\n        new drawframe().setvisible(true);\n    }\n}\n\n\n运行结果：\n\n\n# 绘图属性\n\n\n# 颜色\n\n> class color\n> \n> java.lang.object java.awt.color\n\ncolor类 提供设置颜色的对象 构造方法\n\ncolor(int r , int g , int b)  color(int rgb) \n\n参数说明\n\n> r： 红色颜色值 g： 绿色颜色值 b： 蓝色颜色值 rgb： 组合rgb颜色值\n\ncolor常量值 有已定义好的颜色对象，可直接调用（自行api查\n\n\n# 画笔\n\n> class basicstroke\n> \n> java.lang.object java.awt.basicstroke\n\nbasicstroke类 为图形轮廓定义基本渲染属性（定义边线属性 实现前提需要stroke接口实现类！！！\n\n**构造方法 **\n\nbasicstroke() basicstroke(float width) basicstroke(float width , int cap , int join) basicstroke(float width , int cap , int join , float miterlimit) basicstroke(float width , int cap , int join , float miterlimit , float[] dash , float dash_phase)\n\n参数           说明\nwidth        画笔宽度\ncap          线端点的装饰\njoin         应用在路径线段交会处的装饰\nmiterlimit   斜接处的剪裁限制\ndash         虚线模式的数组\ndash_phase   开始虚线模式的偏移量\n\ncap参数 3个常量及标识 join参数 3常量及标识\n\n代码实现流程：\n\n>  1. 创建stroke接口对象，实例basicstroke对象\n>  2. 设置画笔 setstroke(stroke)方法\n\n大致例子：\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class brushtest extends jframe {\n    public brushtest(){\n        setbounds(400 ,300 ,300 ,230);\n        setdefaultcloseoperation(3);\n        add(new mycanvas());\n    }\n\n    class mycanvas extends canvas{\n        @override\n        public void paint(graphics g) {\n            super.paint(g);\n            graphics2d g2 = (graphics2d)g;\n\n            stroke[] s = {\n                    new basicstroke(10 , basicstroke.cap_round ,basicstroke.join_round),\n                    new basicstroke(10 , basicstroke.cap_butt , basicstroke.join_round),\n                    new basicstroke(10 , basicstroke.cap_square , basicstroke.join_round),\n                    new basicstroke(10 , basicstroke.cap_butt , basicstroke.join_bevel)\n            };\n\n        //    图形no.1\n            g2.setstroke(s[0]);\n            g2.drawline(10,10 , 230,10);\n            g2.setstroke(s[1]);\n            g2.drawline(10,30 , 230,30);\n            g2.setstroke(s[2]);\n            g2.drawline(10,50 , 230,50);\n\n        //    图形no.2\n            //更改颜色\n            g2.setcolor(color.cyan);\n            g2.setstroke(s[3]);\n            int[]   x = {20 ,200 ,20 ,200},\n                     y = {80 ,80 ,180 ,180};\n            g2.drawpolyline(x , y , 4);\n        }\n    }\n\n    public static void main(string[] args) {\n        new brushtest().setvisible(true);\n    }\n}\n\n\n运行结果：\n\n\n# 绘制文本\n\n\n# 设置字体\n\n> class font\n> \n> java.lang.object java.awt.font\n\nfont类 封装字体的大小、样式等属性 构造方法\n\nfont(string naem , int style , int size)\n\n> name： 字体名称 style： 字体样式 size： 字体大小\n\n字体样式    常量\n普通      plain\n粗体      bold\n斜体      italic\n粗体&斜体   italic | bold\n\n\n# 显示文字\n\ngraphics2d提供了 drawstring()方法 ，可以抛开 jlable类 写入窗体的方法\n\n（graphics2d | graphics）drawstring(string str , int x , int y)  （graphics2d ）drawstring(string str , float x , float y) \n\n> str： 文本 x： 坐标x y： 坐标y\n\nimport javax.swing.*;\nimport java.awt.*;\n\n//4.绘制文本\npublic class drawtexttest extends jframe {\n\n    public drawtexttest() {\n        setbounds(400, 300, 230, 150);\n        setdefaultcloseoperation(3);\n\n        add(new canvas() {\n            @override\n            public void paint(graphics g) {\n                super.paint(g);\n                graphics2d g2 = (graphics2d) g;\n                font[] f = {\n                        new font("微软雅黑", font.bold, 23),\n                        new font("微软雅黑", font.italic, 23),\n                        new font("微软雅黑", font.italic | font.bold, 23)\n                };\n\n                g2.setfont(f[0]);\n                g2.drawstring("sanscan12" , 20 , 30);\n                g2.setfont(f[1]);\n                g2.drawstring("sanscan12" , 20 , 60);\n                g2.setfont(f[2]);\n                g2.drawstring("sanscan12" , 20 , 90);\n                \n            }\n        });\n    }\n\n    public static void main(string[] args) {\n        new drawtexttest().setvisible(true);\n    }\n}\n\n\n运行结果：\n\n\n# 绘制图片\n\ngraphics提供了 drawimage()方法，可以进行绘制图片处理图片，抛开 jlable类 写入窗体的方法\n\ndrawimage(image img  , int x  , int y , imageobserver observer) \n\n> img： 图片对象 x： 坐标x y： 坐标y observer： 窗体/容器\n\n\n# 图像处理\n\n# 缩放\n\n重写drawimage()方法，区别6个参数，要原有初始大小的图片\n\ndrawimage(image img , int x , int y , int width , int height , imageobserver observer) \n\n> width： 图片新宽度 height： 图片新高度\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.actionevent;\nimport java.awt.event.actionlistener;\n\n//2.缩放\n// main类调用 该实例\npublic class sizetest extends canvas {\n\n    int w , h ;\n    image image;\n    static int count = 0;\n    static jbutton[] jb = {\n            new jbutton("放大"),\n            new jbutton("缩小")\n    };\n\n    public sizetest(){\n        this.image = new imageicon("image1.png").getimage();\n        this.w = image.getwidth(this);\n        this.h = image.getheight(this);\n\n        canvas c = this;\n        //添加响应\n        // 放大\n        jb[0].addactionlistener(new actionlistener() {\n            @override\n            public void actionperformed(actionevent e) {\n                count+=1;\n                c.repaint();\n            }\n        });\n        //缩小\n        jb[1].addactionlistener(new actionlistener() {\n            @override\n            public void actionperformed(actionevent e) {\n                count-=1;\n                c.repaint();\n            }\n        });\n    }\n\n    @override\n    public void paint(graphics g) {\n        super.paint(g);\n        graphics2d g2 = (graphics2d)g;\n        g2.drawimage(image , 0 , 0 ,w+count , h+count , this);\n    }\n\n    public static jbutton[] getjbuttonall(){\n        return jb;\n    }\n}\n\n\n运行结果：\n\n\n# 翻转\n\n重写drawimage()方法，区别10个参数，水平垂直翻转的作用\n\ndrawlmage(image img , int dx1 , int dy1 , int dx2 , int dy2 , int sx1 , int sy1 , int sx2 , int sy2 , imageobserver observer)\n\n> dx1/dy1： 目标矩形对应角xy坐标 dx2/dy2： 目标矩形对应角xy坐标 sx1/sy1： 源矩形左上角xy坐标 sx2/sy2： 源矩形右下角xy坐标\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.actionevent;\nimport java.awt.event.actionlistener;\n\n//3.翻转\n//在main类调用 该实例\npublic class turntest extends canvas{\n\n    static jbutton[] jb = {\n            new jbutton("水平"),\n            new jbutton("垂直")\n    };\n    image image ;\n    int sx1,sy1,sx2,sy2;        //源矩形左上，右下\n    int dx1,dy1,dx2,dy2;     //目标矩形\n    int origin , width , hight;\n\n    public turntest(){\n        //初始化数据\n        image = new imageicon("image1.png").getimage();\n        origin = 0;\n        width = image.getwidth(this);\n        hight = image.getheight(this);\n        dx1 = sx1 = origin;\n        dy1 = sy1 = origin;\n        dx2 = sx2 = width;\n        dy2 = sy2 = hight;\n\n        canvas c = this;\n        //水平\n        jb[0].addactionlistener(new actionlistener() {\n            @override\n            public void actionperformed(actionevent e) {\n                //dx1右上获取 宽（width-width）\n                dx1 = math.abs(dx1 - width);\n                //dx2左下获取 宽  （0-width）\n                dx2 = math.abs(dx2 - width);\n                c.repaint();\n            }\n        });\n        //垂直\n        jb[1].addactionlistener(new actionlistener() {\n            @override\n            public void actionperformed(actionevent e) {\n                //dy1 右上获取 高 （0-hight）\n                dy1 = math.abs(dy1 - hight);\n                //dy2 左下获取 高 （higth - hight）\n                dy2 = math.abs(dy2 - hight);\n                c.repaint();\n            }\n        });\n    }\n\n    @override\n    public void paint(graphics g) {\n        super.paint(g);\n        graphics2d g2 = (graphics2d)g;\n        g2.drawimage(image ,\n                dx1 , dy1 ,dx2 , dy2 ,  //目标矩形\n                sx1 , sy1 , sx2 , sy2 ,  //源矩形\n                this);\n    }\n\n    public static jbutton[] getjbuttonall(){\n        return jb;\n    }\n}\n\n\n运行结果：\n\n# 旋转\n\n重写drawimage()方法，区别6个参数，旋转的前提需要调用graphics2d类的rotate()方法，进行旋转\n\ndrawimage(image img , int x , int y , int width , int height , imageobserver observer)\n\n方法 rotate(double thete)  thete：旋转弧度\n\n> 参数的弧度值可以使用math类的toradians()方法将角度转换为弧度（近似值）\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.actionevent;\nimport java.awt.event.actionlistener;\n\n//2.旋转\n// main类调用 该实例\npublic class whirltest extends canvas {\n\n    int w , h ;\n    image image;\n    static int count = 0;\n    static jbutton[] jb = {\n            new jbutton("左转"),\n            new jbutton("右转")\n    };\n\n    public whirltest(){\n        this.image = new imageicon("image1.png").getimage();\n        this.w = image.getwidth(this);\n        this.h = image.getheight(this);\n        canvas c = this;\n\n        //添加响应\n        // 左\n        jb[0].addactionlistener(new actionlistener() {\n            @override\n            public void actionperformed(actionevent e) {\n                count++;\n                c.repaint();\n            }\n        });\n        //右\n        jb[1].addactionlistener(new actionlistener() {\n            @override\n            public void actionperformed(actionevent e) {\n                count--;\n                c.repaint();\n            }\n        });\n    }\n\n    @override\n    public void paint(graphics g) {\n        super.paint(g);\n        graphics2d g2 = (graphics2d)g;\n        //toradians：以度为单位的角度转换为以弧度（近似值）\n        g2.rotate(math.toradians(count));\n        g2.drawimage(image , 0 , 0 ,w , h , this);\n    }\n\n    public static jbutton[] getjbuttonall(){\n        return jb;\n    }\n}\n\n\n运行结果：\n\n# 倾斜\n\n重写drawimage()方法，区别6个参数，旋转的前提需要调用graphics2d类的shear()方法，实现倾斜\n\ndrawimage(image img , int x , int y , int width , int height , imageobserver observer)\n\n方法 shear(double shx , double shy) shx： 水平倾斜量 ； shy： 垂直倾斜量\n\nimport javax.swing.*;\nimport java.awt.*;\nimport java.awt.event.actionevent;\nimport java.awt.event.actionlistener;\nimport java.awt.event.keyevent;\nimport java.awt.event.keylistener;\n\n//5.翻转\n//在main类调用 该实例\npublic class tilttest extends canvas{\n\n    int w , h ;\n    double x , y;\n    static boolean narrow = false;\n    static jbutton[] jb = {\n            new jbutton("<--︿"),\n            new jbutton("﹀--\x3e")\n    };\n    image image ;\n\n    public tilttest(){\n        //初始化数据\n        image = new imageicon("image1.png").getimage();\n        w = image.getwidth(this);\n        h = image.getheight(this);\n        x = y = 0;\n\n        canvas c = this;\n        //判断alt键是否按下\n        system.out.println("通过点击alt键，控制倾斜 x 或 y 轴");\n        addkeylistener(new keylistener() {\n            @override\n            public void keytyped(keyevent e) { }\n            @override\n            public void keypressed(keyevent e) {\n                if (e.getkeytext(e.getkeycode()) == "alt"){\n                    if (narrow){\n                        narrow = false;\n                        system.out.println("目前倾斜x轴");\n                    }else {\n                        narrow = true;\n                        system.out.println("目前倾斜y轴");\n                    }\n                }\n            }\n            @override\n            public void keyreleased(keyevent e) { }\n        });\n        //<--\n        jb[0].addactionlistener(new actionlistener() {\n            @override\n            public void actionperformed(actionevent e) {\n                if (narrow){\n                    y -= 0.05;\n                }else {\n                    x -= 0.05;\n                }\n                c.repaint();\n            }\n        });\n        //--\x3e\n        jb[1].addactionlistener(new actionlistener() {\n            @override\n            public void actionperformed(actionevent e) {\n                if (narrow){\n                    y += 0.05;\n                }else {\n                    x += 0.05;\n                }\n                c.repaint();\n            }\n        });\n    }\n\n    @override\n    public void paint(graphics g) {\n        super.paint(g);\n        graphics2d g2 = (graphics2d)g;\n        //主要代码\n        g2.shear(x , y);\n        g2.drawimage(image , 0 , 0 ,w , h , this);\n    }\n\n    public static jbutton[] getjbuttonall(){\n        return jb;\n    }\n}\n\n\n运行结果：\n\n\n# 处理main执行\n\n以上 图片处理 代码需要main类执行\n\nimport javax.swing.*;\nimport java.awt.*;\n\n//1.图形显示\npublic class main extends jframe {\n\n    //public jbutton\n    //        jb1 = new jbutton("+"),\n    //        jb2 = new jbutton("-");\n\n    //public canvas canvas = null;\n\n    public main(canvas c , jbutton jb1 ,jbutton jb2){\n        setbounds(400 , 300 , 666 , 600);\n        setdefaultcloseoperation(3);\n        jpanel jp = new jpanel();\n        jp.add(jb1);\n        jp.add(jb2);\n        add(jp , borderlayout.south);\n        add(c);\n    }\n\n\n    public static void main(string[] args) {\n        /*  自行实例\n         *   1.graphtest    //显示图片\n         *   2.sizetest     //放大与缩小\n         *   3.turntest    //翻转\n         *   4.whirltest    //旋转\n         *   5.tilttest     //倾斜\n         * */\n         canvas canvas = new tilttest();//更改实例对象即可\n         jbutton[]  jb = tilttest.getjbuttonall();//更改类\n        new main(canvas , jb[0] , jb[1]).setvisible(true);\n    }\n}\n\n\n图片流转换\n\nimport java.io.bytearrayinputstream;\nimport java.io.file;\nimport java.io.fileinputstream;\nimport java.io.fileoutputstream;\nimport java.io.inputstream;\n\n/**\n * 将二进制流转换成图片文件\n * @author 晚风工作室 www.soservers.com\n *\n */\n\npublic class imgertofileutil {\n\n    /**\n     * 将接收的字符串转换成图片保存\n     * @param imgstr 二进制流转换的字符串\n     * @param imgpath 图片的保存路径\n     * @param imgname 图片的名称\n     * @return\n     * \t\t1：保存正常\n     * \t\t0：保存失败\n     */\n    public static int savetoimgbystr(string imgstr,string imgpath,string imgname){\n        try {\n            system.out.println("===imgstr.length()====>" + imgstr.length()\n                    + "=====imgstr=====>" + imgstr);\n        } catch (exception e) {\n            e.printstacktrace();\n        }\n        int stateint = 1;\n        if(imgstr != null && imgstr.length() > 0){\n            try {\n\n                // 将字符串转换成二进制，用于显示图片  \n                // 将上面生成的图片格式字符串 imgstr，还原成图片显示  \n                byte[] imgbyte = hex2byte( imgstr );\n\n                inputstream in = new bytearrayinputstream(imgbyte);\n\n                file file=new file(imgpath,imgname);//可以是任何图片格式.jpg,.png等\n                fileoutputstream fos=new fileoutputstream(file);\n\n                byte[] b = new byte[1024];\n                int nread = 0;\n                while ((nread = in.read(b)) != -1) {\n                    fos.write(b, 0, nread);\n                }\n                fos.flush();\n                fos.close();\n                in.close();\n\n            } catch (exception e) {\n                stateint = 0;\n                e.printstacktrace();\n            } finally {\n            }\n        }\n        return stateint;\n    }\n\n    /**\n     * 将二进制转换成图片保存\n     * @param imgstr 二进制流转换的字符串\n     * @param imgpath 图片的保存路径\n     * @param imgname 图片的名称\n     * @return\n     * \t\t1：保存正常\n     * \t\t0：保存失败\n     */\n    public static int savetoimgbybytes(file imgfile,string imgpath,string imgname){\n\n        int stateint = 1;\n        if(imgfile.length() > 0){\n            try {\n                file file=new file(imgpath,imgname);//可以是任何图片格式.jpg,.png等\n                fileoutputstream fos=new fileoutputstream(file);\n\n                fileinputstream fis = new fileinputstream(imgfile);\n\n                byte[] b = new byte[1024];\n                int nread = 0;\n                while ((nread = fis.read(b)) != -1) {\n                    fos.write(b, 0, nread);\n                }\n                fos.flush();\n                fos.close();\n                fis.close();\n\n            } catch (exception e) {\n                stateint = 0;\n                e.printstacktrace();\n            } finally {\n            }\n        }\n        return stateint;\n    }\n\n    /**\n     * 二进制转字符串\n     * @param b\n     * @return\n     */\n    public static string byte2hex(byte[] b) // 二进制转字符串\n    {\n        stringbuffer sb = new stringbuffer();\n        string stmp = "";\n        for (int n = 0; n < b.length; n++) {\n            stmp = integer.tohexstring(b[n] & 0xff);\n            if (stmp.length() == 1) {\n                sb.append("0" + stmp);\n            } else {\n                sb.append(stmp);\n            }\n\n        }\n        return sb.tostring();\n    }\n\n    /**\n     * 字符串转二进制\n     * @param str 要转换的字符串\n     * @return  转换后的二进制数组\n     */\n    public static byte[] hex2byte(string str) { // 字符串转二进制\n        if (str == null)\n            return null;\n        str = str.trim();\n        int len = str.length();\n        if (len == 0 || len % 2 == 1)\n            return null;\n        byte[] b = new byte[len / 2];\n        try {\n            for (int i = 0; i < str.length(); i += 2) {\n                b[i / 2] = (byte) integer\n                        .decode("0x" + str.substring(i, i + 2)).intvalue();\n            }\n            return b;\n        } catch (exception e) {\n            return null;\n        }\n    }\n\n}\n',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Java网页访问",frontmatter:{title:"Java网页访问",date:"2020-02-18T00:00:00.000Z",permalink:"/backend/1s9khm",categories:["后端","Java基础"],tags:["Java"],author:"柏竹"},regularPath:"/01.%E5%90%8E%E7%AB%AF/01.Java%E5%9F%BA%E7%A1%80/17.URL%E8%AF%B4%E6%98%8E.html",relativePath:"01.后端/01.Java基础/17.URL说明.md",key:"v-0e5d2811",path:"/backend/1s9khm/",headers:[{level:2,title:"URL",slug:"url",normalizedTitle:"url",charIndex:15},{level:2,title:"类",slug:"类",normalizedTitle:"类",charIndex:362},{level:3,title:"URL",slug:"url-2",normalizedTitle:"url",charIndex:15},{level:3,title:"URLConnection",slug:"urlconnection",normalizedTitle:"urlconnection",charIndex:757},{level:3,title:"HttpURLConnection",slug:"httpurlconnection",normalizedTitle:"httpurlconnection",charIndex:1602},{level:2,title:"编码",slug:"编码",normalizedTitle:"编码",charIndex:2089},{level:3,title:"URLEncoder类",slug:"urlencoder类",normalizedTitle:"urlencoder类",charIndex:2152},{level:3,title:"URLDecoder类",slug:"urldecoder类",normalizedTitle:"urldecoder类",charIndex:2484},{level:2,title:"代码示例",slug:"代码示例",normalizedTitle:"代码示例",charIndex:2707},{level:3,title:"下载器",slug:"下载器",normalizedTitle:"下载器",charIndex:2716},{level:3,title:"捕捉网页",slug:"捕捉网页",normalizedTitle:"捕捉网页",charIndex:4501}],headersStr:"URL 类 URL URLConnection HttpURLConnection 编码 URLEncoder类 URLDecoder类 代码示例 下载器 捕捉网页",content:'# Java网页访问\n\n\n# URL\n\nURL（Uniform Resource Locator），表示Internet上的资源地址。用户可通过URL进行访问网络资源。一般浏览器会对网络资源进行相应的解析 或 查找相应的文件 和 资源\n\n示例：\n\n> protocol://resourceName\n\nprotocol： 协议名，指定获取资源使用的传输协议（如：HTTP、FTP、FILE等） resourceName： 资源名，指定资源的完整地址，有 主机名、端口号、文件名、文件内部引用等。\n\n示例：\n\n> http://www.baidu.com/ （协议名://主机名）\n> \n> http://localhost:8080/Test/admin/login.jsp （协议名://机器名: 端口号/文件名\n\n\n# 类\n\n\n# URL\n\n> Class URL\n> \n> java.lang.Object java.net.URL\n\njava.net包 是专门处理 URL的类 ULR\n\n构造方法 （更多自行AIP）\n\nURL(String spec) URL(String protocol , String host , int port , String file) URL(String protocol , String host , String file)\n\n> spec： URL地址 protocol： 协议名称 host： 主机名称 port： 主机端口号 file： 主机上的文件\n\n方法 （更多自行AIP）\n\n返回              方法                 说明\nString          getFile()          获取 URL路径和文件名\nURLConnection   openConnection()   获取 通信连接对象\n\n\n# URLConnection\n\n> Class URLConnection\n> \n> java.lang.Object java.net.URLConnection\n\nURLConnection对象 是通过 URL对象 获取的通信连接\n\nURLConnection(URL url) 构造方法也可以实现通信连接\n\n方法 （更多自行AIP）\n\n返回             方法                                              说明\nvoid           setDoInput(boolean input)                       是否进行 URL连接输入\nvoid           setDoOutput(boolean output)                     是否进行 URL连接输出\nvoid           setRequestProperty(String key , String value)   设置键值对指定的常规请求属性（密钥已存在，则旧值被覆盖）\nInputStream    getInputStream()                                获取 URL输入流，读取资源\nOutputStream   getOutputStream()                               获取 URL输出流，输出资源\nint            getContentLength()                              获取 URL资源长度\nint            getResponseCode()                               获取 URL响应状态码（如：404）\n\n\n# HttpURLConnection\n\n> Class HttpURLConnection\n> \n> java.lang.Object java.net.URLConnection java.net.HttpURLConnection\n\nHttpURLConnection支持 HTTP\\HTTPS协议 ，可以将URLConnection强制转换HttpURLConnection\n\nHttpURLConnection (URL url) 构造方法也可以实现通信连接\n\n方法 （更多自行AIP）\n\n返回       方法                                说明\nvoid     setRequestMethod(String method)   设置 URL请求方法（GET、POST、...。默认GET(必须大写)）\nint      getResponseCode()                 从HTTP响应消息获取状态代码\nString   getRequestMethod()                获取请求方法\n\n\n# 编码\n\n在开发中，有时是需要中文转码，保证传输不会出现乱码的情况，常用的有URLEncode 与 URLDecode\n\n\n# URLEncoder类\n\n将普通字符串转换成 application/x-www-from-urlencoded 字符串\n\n1.字符a-z，A-Z，0-9，.，-，*，_ 都不会被编码\n\n2.将空格转换为加号 (+)\n\n3.将非文本内容转换成"%xy"的形式,xy是两位16进制的数值\n\n4.在每个 name=value 对之间放置 & 符号\n\n示例：\n\n//字符串中的非英文字符的内容，会被转化成%XX%XX XX 为十六进制的数字\nString urlString = URLEncoder.encode("你好" , "UTF-8");\nSystem.out.println(urlString);\n//输出：%E4%BD%A0%E5%A5%BD\n\n\n\n# URLDecoder类\n\n将 application/x-www-from-urlencoded 字符串转换成普通字符串。它与 URLEncoder类 是互为反向转换的过程（可以理解成 序列化与反序列化 的操作）\n\n示例：\n\nString keyWord = URLDecoder.decode("%E4%BD%A0%E5%A5%BD" , "UTF-8");\nSystem.out.println(keyWord);\n//输出：你好\n\n\n\n# 代码示例\n\n\n# 下载器\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.Scanner;\n\n/**\n * @Author: 柏竹\n * @Description: 一个简洁主义...\n * @Date_Created_in: 2021-03-01 23:40\n * @Modified_By:\n * @Project： 下载器\n */\npublic class Demo {\n    public static void main(String[] args) throws Exception {\n        //https://qd.myapp.com/myapp/qqteam/pcqq/PCQQ2020.exe\n        System.out.println("下载器");\n        System.out.print("输入地址： ");\n        String address = new Scanner(System.in).nextLine();\n        URL url  = new URL(address);\n        //获取 文件名称\n        String name = url.getFile();\n        /* name =  /myapp/qqteam/pcqq/PCQQ2020.exe */\n        System.out.println("1 : "+name);\n        //最后一次出现的索引 ‘/’下标 + 1 开始\n        name = name.substring(name.lastIndexOf("/")+1);\n        /* name = PCQQ2020.exe */\n        System.out.println("2 : "+name);\n        //进行url连接\n        URLConnection conn = url.openConnection();\n        //连接url对象的总长度（字节数\n        long length = conn.getContentLengthLong();\n        // 获取 输入流 的资源\n        InputStream is = conn.getInputStream();\n        //下载 目的 的位置\n        File file = new File("D:\\\\IDM\\\\"+name);\n        FileOutputStream fos = new FileOutputStream(file);\n        \n        //以下是执行下载\n        int len = -1;\n        // 每次对两字节\n        byte[] bytes = new byte[1024 * 1024];\n        int sum = 0;\n        while(true){\n            len = is.read(bytes);\n            if(len == -1){\n                break;\n            }\n            fos.write(bytes , 0 , len);\n            sum += len;\n            //通过文件 进度长 与 总长 的百分比进行算出下载进度\n            System.out.println("正在下载："+sum/(length/100)+"%");\n        }\n    \n        System.out.println("下载成功！！！");\n        is.close();\n        fos.close();\n    }\n}\n\n\n\n# 捕捉网页\n\nimport java.io.*;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Scanner;\n\n/**\n * @Author: 柏竹\n * @Description: 一个简洁主义...\n * @Date_Created_in: 2021-03-02 0:17\n * @Modified_By:\n * @Project：\n */\npublic class Demo {\n    public static void main(String[] args) throws Exception {\n    \n        System.out.println("网站捕捉");\n        System.out.print("输入地址： ");\n        String address = new Scanner(System.in).nextLine();\n        URL url = new URL(address);\n        URLConnection conn = url.openConnection();\n        InputStream is = conn.getInputStream();\n        File file = new File("D://IDM//"+"index.html");\n    \n        //字节流 -> 缓存字符流\n        BufferedReader br = new BufferedReader(new InputStreamReader(is , StandardCharsets.UTF_8));\n        //文件字节流 -> 缓存字符流\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(new FileOutputStream(file)));\n        String line = null;\n        \n        while (true){\n            line = br.readLine();\n            if (line == null){\n                break;\n            }\n            bw.write(line);\n            bw.newLine();\n            bw.flush();\n        }\n        System.out.println("网站捕捉完成！");\n        \n        br.close();\n        bw.close();\n    }\n}\n',normalizedContent:'# java网页访问\n\n\n# url\n\nurl（uniform resource locator），表示internet上的资源地址。用户可通过url进行访问网络资源。一般浏览器会对网络资源进行相应的解析 或 查找相应的文件 和 资源\n\n示例：\n\n> protocol://resourcename\n\nprotocol： 协议名，指定获取资源使用的传输协议（如：http、ftp、file等） resourcename： 资源名，指定资源的完整地址，有 主机名、端口号、文件名、文件内部引用等。\n\n示例：\n\n> http://www.baidu.com/ （协议名://主机名）\n> \n> http://localhost:8080/test/admin/login.jsp （协议名://机器名: 端口号/文件名\n\n\n# 类\n\n\n# url\n\n> class url\n> \n> java.lang.object java.net.url\n\njava.net包 是专门处理 url的类 ulr\n\n构造方法 （更多自行aip）\n\nurl(string spec) url(string protocol , string host , int port , string file) url(string protocol , string host , string file)\n\n> spec： url地址 protocol： 协议名称 host： 主机名称 port： 主机端口号 file： 主机上的文件\n\n方法 （更多自行aip）\n\n返回              方法                 说明\nstring          getfile()          获取 url路径和文件名\nurlconnection   openconnection()   获取 通信连接对象\n\n\n# urlconnection\n\n> class urlconnection\n> \n> java.lang.object java.net.urlconnection\n\nurlconnection对象 是通过 url对象 获取的通信连接\n\nurlconnection(url url) 构造方法也可以实现通信连接\n\n方法 （更多自行aip）\n\n返回             方法                                              说明\nvoid           setdoinput(boolean input)                       是否进行 url连接输入\nvoid           setdooutput(boolean output)                     是否进行 url连接输出\nvoid           setrequestproperty(string key , string value)   设置键值对指定的常规请求属性（密钥已存在，则旧值被覆盖）\ninputstream    getinputstream()                                获取 url输入流，读取资源\noutputstream   getoutputstream()                               获取 url输出流，输出资源\nint            getcontentlength()                              获取 url资源长度\nint            getresponsecode()                               获取 url响应状态码（如：404）\n\n\n# httpurlconnection\n\n> class httpurlconnection\n> \n> java.lang.object java.net.urlconnection java.net.httpurlconnection\n\nhttpurlconnection支持 http\\https协议 ，可以将urlconnection强制转换httpurlconnection\n\nhttpurlconnection (url url) 构造方法也可以实现通信连接\n\n方法 （更多自行aip）\n\n返回       方法                                说明\nvoid     setrequestmethod(string method)   设置 url请求方法（get、post、...。默认get(必须大写)）\nint      getresponsecode()                 从http响应消息获取状态代码\nstring   getrequestmethod()                获取请求方法\n\n\n# 编码\n\n在开发中，有时是需要中文转码，保证传输不会出现乱码的情况，常用的有urlencode 与 urldecode\n\n\n# urlencoder类\n\n将普通字符串转换成 application/x-www-from-urlencoded 字符串\n\n1.字符a-z，a-z，0-9，.，-，*，_ 都不会被编码\n\n2.将空格转换为加号 (+)\n\n3.将非文本内容转换成"%xy"的形式,xy是两位16进制的数值\n\n4.在每个 name=value 对之间放置 & 符号\n\n示例：\n\n//字符串中的非英文字符的内容，会被转化成%xx%xx xx 为十六进制的数字\nstring urlstring = urlencoder.encode("你好" , "utf-8");\nsystem.out.println(urlstring);\n//输出：%e4%bd%a0%e5%a5%bd\n\n\n\n# urldecoder类\n\n将 application/x-www-from-urlencoded 字符串转换成普通字符串。它与 urlencoder类 是互为反向转换的过程（可以理解成 序列化与反序列化 的操作）\n\n示例：\n\nstring keyword = urldecoder.decode("%e4%bd%a0%e5%a5%bd" , "utf-8");\nsystem.out.println(keyword);\n//输出：你好\n\n\n\n# 代码示例\n\n\n# 下载器\n\nimport java.io.file;\nimport java.io.fileoutputstream;\nimport java.io.inputstream;\nimport java.net.url;\nimport java.net.urlconnection;\nimport java.util.scanner;\n\n/**\n * @author: 柏竹\n * @description: 一个简洁主义...\n * @date_created_in: 2021-03-01 23:40\n * @modified_by:\n * @project： 下载器\n */\npublic class demo {\n    public static void main(string[] args) throws exception {\n        //https://qd.myapp.com/myapp/qqteam/pcqq/pcqq2020.exe\n        system.out.println("下载器");\n        system.out.print("输入地址： ");\n        string address = new scanner(system.in).nextline();\n        url url  = new url(address);\n        //获取 文件名称\n        string name = url.getfile();\n        /* name =  /myapp/qqteam/pcqq/pcqq2020.exe */\n        system.out.println("1 : "+name);\n        //最后一次出现的索引 ‘/’下标 + 1 开始\n        name = name.substring(name.lastindexof("/")+1);\n        /* name = pcqq2020.exe */\n        system.out.println("2 : "+name);\n        //进行url连接\n        urlconnection conn = url.openconnection();\n        //连接url对象的总长度（字节数\n        long length = conn.getcontentlengthlong();\n        // 获取 输入流 的资源\n        inputstream is = conn.getinputstream();\n        //下载 目的 的位置\n        file file = new file("d:\\\\idm\\\\"+name);\n        fileoutputstream fos = new fileoutputstream(file);\n        \n        //以下是执行下载\n        int len = -1;\n        // 每次对两字节\n        byte[] bytes = new byte[1024 * 1024];\n        int sum = 0;\n        while(true){\n            len = is.read(bytes);\n            if(len == -1){\n                break;\n            }\n            fos.write(bytes , 0 , len);\n            sum += len;\n            //通过文件 进度长 与 总长 的百分比进行算出下载进度\n            system.out.println("正在下载："+sum/(length/100)+"%");\n        }\n    \n        system.out.println("下载成功！！！");\n        is.close();\n        fos.close();\n    }\n}\n\n\n\n# 捕捉网页\n\nimport java.io.*;\nimport java.net.malformedurlexception;\nimport java.net.url;\nimport java.net.urlconnection;\nimport java.nio.charset.standardcharsets;\nimport java.util.scanner;\n\n/**\n * @author: 柏竹\n * @description: 一个简洁主义...\n * @date_created_in: 2021-03-02 0:17\n * @modified_by:\n * @project：\n */\npublic class demo {\n    public static void main(string[] args) throws exception {\n    \n        system.out.println("网站捕捉");\n        system.out.print("输入地址： ");\n        string address = new scanner(system.in).nextline();\n        url url = new url(address);\n        urlconnection conn = url.openconnection();\n        inputstream is = conn.getinputstream();\n        file file = new file("d://idm//"+"index.html");\n    \n        //字节流 -> 缓存字符流\n        bufferedreader br = new bufferedreader(new inputstreamreader(is , standardcharsets.utf_8));\n        //文件字节流 -> 缓存字符流\n        bufferedwriter bw = new bufferedwriter(new outputstreamwriter(new fileoutputstream(file)));\n        string line = null;\n        \n        while (true){\n            line = br.readline();\n            if (line == null){\n                break;\n            }\n            bw.write(line);\n            bw.newline();\n            bw.flush();\n        }\n        system.out.println("网站捕捉完成！");\n        \n        br.close();\n        bw.close();\n    }\n}\n',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Java注解",frontmatter:{title:"Java注解",date:"2020-02-18T00:00:00.000Z",permalink:"/backend/zyaf2n",categories:["后端","Java基础"],tags:["Java"],author:"柏竹"},regularPath:"/01.%E5%90%8E%E7%AB%AF/01.Java%E5%9F%BA%E7%A1%80/20.%E6%B3%A8%E8%A7%A3.html",relativePath:"01.后端/01.Java基础/20.注解.md",key:"v-10261aa3",path:"/backend/zyaf2n/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:13},{level:2,title:"内置注解",slug:"内置注解",normalizedTitle:"内置注解",charIndex:217},{level:3,title:"@Override",slug:"override",normalizedTitle:"@override",charIndex:226},{level:3,title:"@Deprecated",slug:"deprecated",normalizedTitle:"@deprecated",charIndex:279},{level:3,title:"@SafeVarargs",slug:"safevarargs",normalizedTitle:"@safevarargs",charIndex:353},{level:3,title:"@FunctionalInterface",slug:"functionalinterface",normalizedTitle:"@functionalinterface",charIndex:516},{level:3,title:"@Repeatable",slug:"repeatable",normalizedTitle:"@repeatable",charIndex:562},{level:3,title:"@SuppressWarnings",slug:"suppresswarnings",normalizedTitle:"@suppresswarnings",charIndex:597},{level:2,title:"元注解",slug:"元注解",normalizedTitle:"元注解",charIndex:2850},{level:3,title:"@Retention",slug:"retention",normalizedTitle:"@retention",charIndex:2870},{level:3,title:"@Documented",slug:"documented",normalizedTitle:"@documented",charIndex:3175},{level:3,title:"@Target",slug:"target",normalizedTitle:"@target",charIndex:3219},{level:3,title:"@Inherited",slug:"inherited",normalizedTitle:"@inherited",charIndex:3548},{level:2,title:"自定义注解",slug:"自定义注解",normalizedTitle:"自定义注解",charIndex:3582}],headersStr:"概述 内置注解 @Override @Deprecated @SafeVarargs @FunctionalInterface @Repeatable @SuppressWarnings 元注解 @Retention @Documented @Target @Inherited 自定义注解",content:'# Java注解\n\n\n# 概述\n\n> Class Annotation\n> \n> java.lang.Object java.text.Annotation\n\njava提供了Annotation功能，又称为Java标注， 用于对 类、构造方法、成员变量、方法、参数等声明，该功能不会影响程序的运行，会对编译器警告等辅助工具产生影响\n\n * 编译格式检查\n * 反射中解析\n * 生成帮助文档\n * 跟踪代码依赖\n * 。。。\n\n\n# 内置注解\n\n\n# @Override\n\n重写 编译器会验证 @Override 下的方法名是否 重写方法，必须的！\n\n\n# @Deprecated\n\n废弃 注解之后，表示此 方法/类 不再建议使用，调用时也会出现删除线，可以用但不建议，因 有更好的 方法/类 ！\n\n\n# @SafeVarargs\n\n泛型 写的 方法/构造方法 认为类型是安全的，那么你也就可以使用@SafeVarargs 来跳过安全警告\n\n用于：\n\n * 构造方法的参数个数不确定（数组形式） 如：public void Test(int... array)\n * static声明的 方法\n * final声明的 方法\n\n\n# @FunctionalInterface\n\n函数接口 仅仅只包含一个抽象方法的接口\n\n\n# @Repeatable\n\n多注解 可以在同一个声明上使用多次\n\n\n# @SuppressWarnings\n\n抑制警告 取消编译器对代码产生的警告\n\n@SuppressWarnings("unchecked") [^ 抑制单类型的警告] @SuppressWarnings("unchecked","rawtypes") [^ 抑制多类型的警告] @SuppressWarnings("all") [^ 抑制所有类型的警告]\n\n参数说明\n\n关键值                        作用\nall                        抑制所有警告\nboxing                     抑制装箱、拆箱操作时候的警告\ncast                       抑制映射相关的警告\ndep-ann                    抑制启用注释的警告\ndeprecation                抑制过期方法警告\nfallthrough                抑制确在switch中缺失breaks的警告\nfinally                    抑制finally模块没有返回的警告\nhiding                     抑制相对于隐藏变量的局部变量的警告\nincomplete-switch          忽略没有完整的switch语句\nnls                        忽略非nls格式的字符\nnull                       忽略对null的操作\nratypes                    使用generics时忽略没有指定相应的类型\nrestriction                抑制禁止使用劝阻或禁止引用的警告\nserial                     忽略在serializable类中没有声明serialVersionUID变量\nstatic-access              抑制不正确的静态访问方式警告\nsynthetic-access           抑制子类没有按最优方法访问内部类的警告\nunchecked                  抑制没有进行类型检查操作的警告\nunqualified-field-access   抑制没有权限访问的域的警告\nunused                     抑制没被使用过的代码的警告\n\n实例.1\n\npublic class Demo extends People implements IntfTest{\n    \n    /**\n     *  重写父类\n     */\n    @Override\n    public String getName(){\n        return new String("已重写");\n    }\n    \n    public static void main(String[] args) {\n        People p = new People();\n        p.setName("Test");\n    }\n    \n    @Override\n    public void show() {\n        System.out.println("测试输出");\n    }\n}\n\nclass People{\n    String name;\n    \n    public People() { }\n    \n    public String getName() {\n        return name;\n    }\n    \n    /** 废弃方法\n     * 此方法以废弃 。建议使用 setName2方法\n     * @param name 姓名\n     */\n    @Deprecated\n    public void setName(String name) {\n        this.name = name;\n    }\n    public void setName2(String name) {\n        if (name == null || name.equals(" ")){\n            return;\n        }\n        this.name = name;\n    }\n}\n\n@FunctionalInterface\ninterface IntfTest{\n    void show();\n}\n\n\n实例.2\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n@SuppressWarnings("all")\npublic class MySuppressWarnings {\n    public static void main(String[] args) {\n        @SuppressWarnings("unchecked")\n        List<Boolean> bool = new ArrayList();\n        // bool.add(true);\n    }\n}\n\n@SuppressWarnings("unchecked")\nclass Book{}\n\n\n\n# 元注解\n\n作用在其他注解的注解\n\n\n# @Retention\n\n策略属性 定义注解时，@Retention用于指定注解有效范围，默认值 CLASS。@Retention 的策略设置有 RetentionPolicy枚举类 中的常量\n\nRETENTIONPOLICY枚举常量   说明\nSOURCE                编译器处理完就没用了，有效范围最小\nCLASS                 注解将会存储于类对应的 .class文件 中，运行时不加载Annotation到JVM中\nRUNTIME               注解将会存储于类对应的 .class文件 中，在运行时加载Annotation到JVM中，范围最大\n\n\n# @Documented\n\n文档注释 标记注解是否包含在用户文档中javadoc\n\n\n# @Target\n\n设置类型 设置注解类型，指定使用地方 。若没有 @Target ，则任何地方都可用。@Target的设置有枚举类ElementType中的常量\n\nELEMENTTYPE枚举常量   说明\nANNOTATION_TYPE   用于Annotation类型\nTYPE              用于类、接口、枚举、Annotation类型\nCONSTRUCTOR       用于构造方法\nFIELD             用于成员变量、枚举常量\nMETHOD            用于方法\nPARAMETER         用于参数\nLOCAL_VARIABLE    用于局部变量\nPACKAGE           用于包\n\n\n# @Inherited\n\n继承注解 子类继承 父类使用的注解\n\n\n# 自定义注解\n\n定义用到 interface关键字 ，前面需加 @ ，定义Annotation类型关键字为： @interface\n\npublic @interface MyAnnotation{\n    String value() default "ABC";\n    Class type() default void.class;\n}\n\n\n注意：\n\n 1. 定义的注解，自动继承 java.lang,annotation.Annotation接口\n 2. 注解中的每一个方法，实际是声明的注解配置参数\n    * 方法的名称就是 配置参数的名称\n    * 方法的返回值类型，就是配置参数的类型。只能是：基本类型/Class/String/enum\n 3. 关键字 default 用于声明参数的默认值\n 4. 如果只有一个参数成员，一般参数名为value\n 5. 注解元素必须要有值\n\n实例.1\n\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\n\npublic class MyRepeatable {\n    \n    String info;\n    @Repeatable (RepeatableTests.class)\n    public @interface RepeatableTest{\n        String name();\n        String date();\n        String change() default "暂无优化";;\n    }\n    @Retention (RetentionPolicy.RUNTIME)\n    public @interface RepeatableTests{\n        RepeatableTest[] value();\n    }\n    \n    @RepeatableTest(name="Jon" , date = " 2021-02-03 07:02" , change= "if保险")\n    @RepeatableTest(name="K" , date = " 2021-03-13 12:01" , change= "修改变量")\n    @RepeatableTest(name="Jccn" , date = " 2021-03-04 12:04" , change= "设置变量")\n    @RepeatableTest(name="Cin" , date = " 2021-03-23 11:06")\n    public void setInfo(String info) {\n        if (info == null || info == " "){\n            info = null;\n            return;\n        }\n        this.info = this.info;\n    }\n    \n}\n\n\n实例.2\n\nimport java.lang.annotation.*;\n\npublic class Demo {\n    public static void main(String[] args) {\n        start();\n    }\n    \n    @MyAnnotation(Modified_By = "老刘" , info = "if判断")\n    private static void start() {\n        System.out.println("注释");\n    }\n}\n\n/** 设置用户\n * @author Sans\n */\n@Documented\n@Inherited\n@Retention(RetentionPolicy.CLASS)\n@Target({ElementType.CONSTRUCTOR,ElementType.TYPE,ElementType.METHOD})\n@interface MyAnnotation{\n    String Modified_By() default "root";\n    String info() default "null";\n}\n',normalizedContent:'# java注解\n\n\n# 概述\n\n> class annotation\n> \n> java.lang.object java.text.annotation\n\njava提供了annotation功能，又称为java标注， 用于对 类、构造方法、成员变量、方法、参数等声明，该功能不会影响程序的运行，会对编译器警告等辅助工具产生影响\n\n * 编译格式检查\n * 反射中解析\n * 生成帮助文档\n * 跟踪代码依赖\n * 。。。\n\n\n# 内置注解\n\n\n# @override\n\n重写 编译器会验证 @override 下的方法名是否 重写方法，必须的！\n\n\n# @deprecated\n\n废弃 注解之后，表示此 方法/类 不再建议使用，调用时也会出现删除线，可以用但不建议，因 有更好的 方法/类 ！\n\n\n# @safevarargs\n\n泛型 写的 方法/构造方法 认为类型是安全的，那么你也就可以使用@safevarargs 来跳过安全警告\n\n用于：\n\n * 构造方法的参数个数不确定（数组形式） 如：public void test(int... array)\n * static声明的 方法\n * final声明的 方法\n\n\n# @functionalinterface\n\n函数接口 仅仅只包含一个抽象方法的接口\n\n\n# @repeatable\n\n多注解 可以在同一个声明上使用多次\n\n\n# @suppresswarnings\n\n抑制警告 取消编译器对代码产生的警告\n\n@suppresswarnings("unchecked") [^ 抑制单类型的警告] @suppresswarnings("unchecked","rawtypes") [^ 抑制多类型的警告] @suppresswarnings("all") [^ 抑制所有类型的警告]\n\n参数说明\n\n关键值                        作用\nall                        抑制所有警告\nboxing                     抑制装箱、拆箱操作时候的警告\ncast                       抑制映射相关的警告\ndep-ann                    抑制启用注释的警告\ndeprecation                抑制过期方法警告\nfallthrough                抑制确在switch中缺失breaks的警告\nfinally                    抑制finally模块没有返回的警告\nhiding                     抑制相对于隐藏变量的局部变量的警告\nincomplete-switch          忽略没有完整的switch语句\nnls                        忽略非nls格式的字符\nnull                       忽略对null的操作\nratypes                    使用generics时忽略没有指定相应的类型\nrestriction                抑制禁止使用劝阻或禁止引用的警告\nserial                     忽略在serializable类中没有声明serialversionuid变量\nstatic-access              抑制不正确的静态访问方式警告\nsynthetic-access           抑制子类没有按最优方法访问内部类的警告\nunchecked                  抑制没有进行类型检查操作的警告\nunqualified-field-access   抑制没有权限访问的域的警告\nunused                     抑制没被使用过的代码的警告\n\n实例.1\n\npublic class demo extends people implements intftest{\n    \n    /**\n     *  重写父类\n     */\n    @override\n    public string getname(){\n        return new string("已重写");\n    }\n    \n    public static void main(string[] args) {\n        people p = new people();\n        p.setname("test");\n    }\n    \n    @override\n    public void show() {\n        system.out.println("测试输出");\n    }\n}\n\nclass people{\n    string name;\n    \n    public people() { }\n    \n    public string getname() {\n        return name;\n    }\n    \n    /** 废弃方法\n     * 此方法以废弃 。建议使用 setname2方法\n     * @param name 姓名\n     */\n    @deprecated\n    public void setname(string name) {\n        this.name = name;\n    }\n    public void setname2(string name) {\n        if (name == null || name.equals(" ")){\n            return;\n        }\n        this.name = name;\n    }\n}\n\n@functionalinterface\ninterface intftest{\n    void show();\n}\n\n\n实例.2\n\nimport java.util.arraylist;\nimport java.util.list;\n\n@suppresswarnings("all")\npublic class mysuppresswarnings {\n    public static void main(string[] args) {\n        @suppresswarnings("unchecked")\n        list<boolean> bool = new arraylist();\n        // bool.add(true);\n    }\n}\n\n@suppresswarnings("unchecked")\nclass book{}\n\n\n\n# 元注解\n\n作用在其他注解的注解\n\n\n# @retention\n\n策略属性 定义注解时，@retention用于指定注解有效范围，默认值 class。@retention 的策略设置有 retentionpolicy枚举类 中的常量\n\nretentionpolicy枚举常量   说明\nsource                编译器处理完就没用了，有效范围最小\nclass                 注解将会存储于类对应的 .class文件 中，运行时不加载annotation到jvm中\nruntime               注解将会存储于类对应的 .class文件 中，在运行时加载annotation到jvm中，范围最大\n\n\n# @documented\n\n文档注释 标记注解是否包含在用户文档中javadoc\n\n\n# @target\n\n设置类型 设置注解类型，指定使用地方 。若没有 @target ，则任何地方都可用。@target的设置有枚举类elementtype中的常量\n\nelementtype枚举常量   说明\nannotation_type   用于annotation类型\ntype              用于类、接口、枚举、annotation类型\nconstructor       用于构造方法\nfield             用于成员变量、枚举常量\nmethod            用于方法\nparameter         用于参数\nlocal_variable    用于局部变量\npackage           用于包\n\n\n# @inherited\n\n继承注解 子类继承 父类使用的注解\n\n\n# 自定义注解\n\n定义用到 interface关键字 ，前面需加 @ ，定义annotation类型关键字为： @interface\n\npublic @interface myannotation{\n    string value() default "abc";\n    class type() default void.class;\n}\n\n\n注意：\n\n 1. 定义的注解，自动继承 java.lang,annotation.annotation接口\n 2. 注解中的每一个方法，实际是声明的注解配置参数\n    * 方法的名称就是 配置参数的名称\n    * 方法的返回值类型，就是配置参数的类型。只能是：基本类型/class/string/enum\n 3. 关键字 default 用于声明参数的默认值\n 4. 如果只有一个参数成员，一般参数名为value\n 5. 注解元素必须要有值\n\n实例.1\n\nimport java.lang.annotation.repeatable;\nimport java.lang.annotation.retention;\nimport java.lang.annotation.retentionpolicy;\n\npublic class myrepeatable {\n    \n    string info;\n    @repeatable (repeatabletests.class)\n    public @interface repeatabletest{\n        string name();\n        string date();\n        string change() default "暂无优化";;\n    }\n    @retention (retentionpolicy.runtime)\n    public @interface repeatabletests{\n        repeatabletest[] value();\n    }\n    \n    @repeatabletest(name="jon" , date = " 2021-02-03 07:02" , change= "if保险")\n    @repeatabletest(name="k" , date = " 2021-03-13 12:01" , change= "修改变量")\n    @repeatabletest(name="jccn" , date = " 2021-03-04 12:04" , change= "设置变量")\n    @repeatabletest(name="cin" , date = " 2021-03-23 11:06")\n    public void setinfo(string info) {\n        if (info == null || info == " "){\n            info = null;\n            return;\n        }\n        this.info = this.info;\n    }\n    \n}\n\n\n实例.2\n\nimport java.lang.annotation.*;\n\npublic class demo {\n    public static void main(string[] args) {\n        start();\n    }\n    \n    @myannotation(modified_by = "老刘" , info = "if判断")\n    private static void start() {\n        system.out.println("注释");\n    }\n}\n\n/** 设置用户\n * @author sans\n */\n@documented\n@inherited\n@retention(retentionpolicy.class)\n@target({elementtype.constructor,elementtype.type,elementtype.method})\n@interface myannotation{\n    string modified_by() default "root";\n    string info() default "null";\n}\n',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"XML&JSON",frontmatter:{title:"XML&JSON",date:"2020-02-18T00:00:00.000Z",permalink:"/backend/lipl8p",categories:["后端","Java基础"],tags:["Java"],author:"柏竹"},regularPath:"/01.%E5%90%8E%E7%AB%AF/01.Java%E5%9F%BA%E7%A1%80/19.MXL&JSON.html",relativePath:"01.后端/01.Java基础/19.MXL&JSON.md",key:"v-6f9743c0",path:"/backend/lipl8p/",headers:[{level:2,title:"XML",slug:"xml",normalizedTitle:"xml",charIndex:2},{level:3,title:"XML文件",slug:"xml文件",normalizedTitle:"xml文件",charIndex:109},{level:3,title:"XML语法",slug:"xml语法",normalizedTitle:"xml语法",charIndex:167},{level:4,title:"文档声明",slug:"文档声明",normalizedTitle:"文档声明",charIndex:176},{level:4,title:"标记",slug:"标记",normalizedTitle:"标记",charIndex:66},{level:4,title:"嵌套标记",slug:"嵌套标记",normalizedTitle:"嵌套标记",charIndex:468},{level:4,title:"标记属性",slug:"标记属性",normalizedTitle:"标记属性",charIndex:590},{level:4,title:"注释",slug:"注释",normalizedTitle:"注释",charIndex:823},{level:4,title:"进阶CDATA",slug:"进阶cdata",normalizedTitle:"进阶cdata",charIndex:858},{level:3,title:"XML解析方式",slug:"xml解析方式",normalizedTitle:"xml解析方式",charIndex:1088},{level:4,title:"SAX解析",slug:"sax解析",normalizedTitle:"sax解析",charIndex:1099},{level:4,title:"DOM解析",slug:"dom解析",normalizedTitle:"dom解析",charIndex:1289},{level:4,title:"JDOM解析",slug:"jdom解析",normalizedTitle:"jdom解析",charIndex:1420},{level:4,title:"DOM4J解析",slug:"dom4j解析",normalizedTitle:"dom4j解析",charIndex:1521},{level:3,title:"XML对象类型",slug:"xml对象类型",normalizedTitle:"xml对象类型",charIndex:1994},{level:4,title:"文档对象",slug:"文档对象",normalizedTitle:"文档对象",charIndex:2005},{level:4,title:"元素对象",slug:"元素对象",normalizedTitle:"元素对象",charIndex:2628},{level:2,title:"JSON",slug:"json",normalizedTitle:"json",charIndex:6},{level:3,title:"对象格式",slug:"对象格式",normalizedTitle:"对象格式",charIndex:3517},{level:3,title:"JSON解析",slug:"json解析",normalizedTitle:"json解析",charIndex:3876},{level:4,title:"Gson",slug:"gson",normalizedTitle:"gson",charIndex:3919},{level:4,title:"FastJson",slug:"fastjson",normalizedTitle:"fastjson",charIndex:4238},{level:2,title:"代码索引",slug:"代码索引",normalizedTitle:"代码索引",charIndex:4550},{level:3,title:"XML解析",slug:"xml解析",normalizedTitle:"xml解析",charIndex:1088},{level:3,title:"XML网络解析",slug:"xml网络解析",normalizedTitle:"xml网络解析",charIndex:3449},{level:3,title:"DOM4J-XPATH网络解析",slug:"dom4j-xpath网络解析",normalizedTitle:"dom4j-xpath网络解析",charIndex:1564},{level:3,title:"XML生成",slug:"xml生成",normalizedTitle:"xml生成",charIndex:10958},{level:3,title:"XML类对象形式生成",slug:"xml类对象形式生成",normalizedTitle:"xml类对象形式生成",charIndex:13158},{level:3,title:"Gson序列化与反序列化",slug:"gson序列化与反序列化",normalizedTitle:"gson序列化与反序列化",charIndex:4221},{level:3,title:"FastJson序列化与反序列化",slug:"fastjson序列化与反序列化",normalizedTitle:"fastjson序列化与反序列化",charIndex:4528}],headersStr:"XML XML文件 XML语法 文档声明 标记 嵌套标记 标记属性 注释 进阶CDATA XML解析方式 SAX解析 DOM解析 JDOM解析 DOM4J解析 XML对象类型 文档对象 元素对象 JSON 对象格式 JSON解析 Gson FastJson 代码索引 XML解析 XML网络解析 DOM4J-XPATH网络解析 XML生成 XML类对象形式生成 Gson序列化与反序列化 FastJson序列化与反序列化",content:'# XML&JSON\n\n\n# XML\n\nXML 可拓展标志语言，Java实现需要导包jar，点击链接\n\n * 平台无关性，是门独立的标记语言\n * 自我描述\n * 网络数据传输\n * 数据存储\n * 配置文件\n\n\n# XML文件\n\n.XML文件 文件是保存 XML数据的方式。它可有其他形式。但XML语言不能理解成XML文件\n\n\n# XML语法\n\n# 文档声明\n\n<?xml version="1.0" encoding="UTF-8"?>\n\n\n版本，编码类型\n\n# 标记\n\n开始标记 : <标记名称>\n\n结束标记 : </标记名称>\n\n标记名称 : 自定义名称\n\n必须遵循以下命名规则：\n\n 1. 名称可以含字母、数字以及其他的字\n 2. 名称不能以数字或者标点符号开始\n 3. 名称不能以字符 “xml”（或者 XML、Xml）开始\n 4. 名称不能包含空格，不能包含冒号（:）\n 5. 名称区分大小写\n\n标记内容 : 开始标记与结束标记之间 ,是标记的内容\n\n<name>戴佳伟</name>\n<age>23</age>\n\n\n# 嵌套标记\n\n正例:\n<person>\n\t<name>戴佳伟</name>\n\t<age>23</age>\n</person>\n反例:\n<person>\n\t<name>戴佳伟<age></name>\n\t23</age>\n</person>\n\n\n# 标记属性\n\n标记中的属性, 在标记开始时 描述, 由属 性名 和 属性值 组成\n\n正例:\n<persons>\n\t<person id = "001" groupid = "1">\n\t\t<name>戴佳伟</name>\n\t\t<age>23</age>\n\t</person>\n\t<person  id = "002" groupid = "2">\n\t\t<name>陈二狗</name>\n\t\t<age>24</age>\n\t</person>\n</persons>\n\n\n# 注释\n\n注释不能写在文档文档声明前\n\n\x3c!--注释内容--\x3e\n\n\n# 进阶CDATA\n\n用于过滤内容。在解析文本数据时 < 和 & 字符在XML非法的，会产生错误，因解析器误认为 < 是新的元数开始 ；& 是字符实体的开始\n\n某些语言的文本，可能会存在大量 < 和 & 字符。因此可以将脚本代码定义为CATA\n\n\x3c!--\nCDATA 部分中的所有内容都会被解析器忽略。\nCDATA 部分由 "<![CDATA[" 开始，由 "]]>" 结束\n--\x3e\n<mane><![CDATA[你<a></a>好]]></mane>\n\n\n\n# XML解析方式\n\n# SAX解析\n\n说明：\n\n * 逐行解析 单向\n * 事件驱动机制。当每解析到 开始/结束/内容/属性 时，触发事件\n * 可进行发生时处理\n\n优点：\n\n * 可立即开始，无需等待数据处理\n * 逐行加载，省空间\n * 满足条件可立即停止解析\n\n缺点：\n\n * 单向解析，无法定位文档层次，读完一行释放一行！！\n * 只能得知自己的节点的 父/子 关系\n * 只读，无法修改\n\n# DOM解析\n\n说明：\n\n * 解析需要加载整个 文档 和 内存\n * 有文档树模型\n * 可操作文档树进行 获取、修改、删除等。。。\n\n优点：\n\n * 文档在内存中加载, 可对 数据 和 结构 做出更改\n * 双向访问\n\n缺点：\n\n * 耗费内存资源较大\n\n# JDOM解析\n\nJava特定文档模型，比DOM实现快\n\n优点：\n\n * 使用 具体类 而非接口，简化DOM的API\n * 复原Java集合类，使用方便\n\n缺点：\n\n * 灵活性差\n * 性能一般\n\n# DOM4J解析\n\nDOM4J是JDOM的一种智能分支。功能强大！\n\n点击代码示例* （DOM4J-XPATH网络解析）\n\n路径表示式\n\n> / ：从根节点开始查找 // ：从发起查找的节点位置，查找子节点 . ：找到当前节点 .. ：查找父节点 @ ：属性筛选 [@属性名 = \'value\'] [@属性名 > \'value\'] [@属性名 < \'value\'] [@属性名 != \'value\']\n\n<persons>\n\t<person id = "001" groupid = "1">\n\t\t<name>戴佳伟</name>\n\t\t<age>23</age>\n\t</person>\n\t<person  id = "002" groupid = "2">\n\t\t<name>陈二狗</name>\n\t\t<age>24</age>\n\t</person>\n</persons>\n\n\x3c!-- \n人名：\npersons : //person//name\n指定id\npersons : //person[@id = \'002\']//name\n--\x3e\n\n\n\n# XML对象类型\n\n# 文档对象\n\nDocument接口 用于文本容器。文档加载到内存的整个 XML文档\n\n常用方法 （更多自行API）\n\n返回           方法                              说明\nElement      addElement(String name)         添加 根节点 并返回\nElement      getRootElement()                获取 根节点\nElement      getDafultRootElement()          获取 树的根元素\nElement[]    getRootElements()               获取 定义的所有根元素\nint          getLength()                     获取 文档内容字符数\nString       getText(int off , int len)      获取 指定文本范围\nObject       getProperty(Object key)         获取 与文档关联的属性\nList<Node>   selectNodes(String name)        获取 指定路径的所有 name节点\nString       selectSingleNode(String name)   获取 指定路径的第一个 name节点\n\n# 元素对象\n\nElement接口 用于XML文档单个节点的捕捉。\n\n常用方法 （更多自行API）\n\n返回              方法                                         说明\nvoid            addAttribute(String name , String value)   添加属性\nElement         addElement(String sonName)                 添加 子节点并返回\nString          attributeValue(String name)                获取 节点的属性值\nString          getName()                                  获取 节点名称\nString          getText()                                  获取 节点内容\nElement         getParentElement()                         获取 父元素\nString          elementText(String sonName)                获取 子节点的内容\nElement         element(String name)                       获取 匹配名称的第一节点\nList<Element>   elements()                                 获取 所有的子节点对象\nString          setText()                                  更改 节点内容\n\n点击代码示例* （XML本地解析）\n\n点击代码示例* （XML网络解析）\n\n\n# JSON\n\nJSON（JavaScript Object Notation），是轻量级的数据交换格式\n\n\n# 对象格式\n\n * 一个对象，由大括号包括表示，括号中包含属性（通过键值描述对象）\n * 每对 键与值 要用 :冒号连接；每对 键值 要用 ,逗号分隔\n * 每对 键值的键 都要用 "引号引住（Java解析需要）\n * 每对 键值的值 使用的是Object类型（任何类型） 如果值中有数组形式需要 []方括号括住元素\n\n{\n    "name":"陈二狗",\n    "age":"23",\n    "friend":["王二","张三","李四",{\n       "name":"黑马老师",\n        "info":"带我们走向胜利！"\n    }],\n    "equipment":{\n        "name":"武士刀",\n        "length":"60cm"\n    }\n}\n\n\n\n# JSON解析\n\n导包链接进不了可以试试这个点击链接 （包含 谷歌 和 阿里 ）\n\n# Gson\n\nJava实现需要导包jar，点击链接\n\n//假如有个 `People类` ,有`name` , `age` 2个属性\nPeople people = new People("陈二狗" , "23");\n\n//序列化\nGson gson = new Gson();\nString json = gson.toJson(people); \t//可参数任意\n/* 序列化结果 的json\n{\n\t"name":"陈二狗",\n\t"age":"23"\n}\n*/\n\n//反序列化\nPeople people = gson.fromJson(json , People.class);\n\n\n点击代码示例* （Gson序列化与反序列化）\n\n# FastJson\n\nJava实现需要导包jar，点击链接\n\n//假如有个 `People类` ,有`name` , `age` 2个属性\nPeople people = new People("陈二狗" , "23");\n\n//序列化\nString json = JSON.toJSONString(people);\t//可参数任意\n/* 序列化结果 的json\n{\n\t"name":"陈二狗",\n\t"age":"23"\n}\n*/\n\n//反序列化\nPeople people = JSON.parseObject(json , People.class);\n\n\n点击代码示例* （FastJson序列化与反序列化）\n\n\n# 代码索引\n\n\n# XML解析\n\n（返回*）\n\nimport org.dom4j.Document;\nimport org.dom4j.DocumentException;\nimport org.dom4j.Element;\nimport org.dom4j.io.SAXReader;\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.util.List;\n\n/**\n * @Author: 柏竹\n * @Description: 一个简洁主义...\n * @Date_Created_in: 2021-02-27 21:50\n * @Modified_By:\n * @Project： 解析本地XML文件\n */\n\npublic class Demo {\n    public static void main(String[] args) throws IOException, DocumentException {\n        \n        //1.    获取流（项目跟路径）\n        FileInputStream fis = new FileInputStream("Demo.xml");\n        //2.    创建XML读取对象\n        SAXReader sr = new SAXReader();\n        //3.    读取并得到对象\n        Document doc = sr.read(fis);\n        //4.    通过文档获取根元素\n        Element root = doc.getRootElement();\n        //5.    解析根元素\n        \n        System.out.println(root.attributeValue("id"));\n        \n        List<Element> es = root.elements();\n        for (int i = 0 ; i < 2 ; i++) {\n            Element people = es.get(i);\n            System.out.println("====================");\n            System.out.println("name  : " + people.elementText("name"));\n            System.out.println("age  : " + people.elementText("age"));\n            System.out.println("====================");\n        }\n        \n        fis.close();\n    }\n}\n\n/*\n异灵术狗贼二人组\n====================\nname  : 戴佳伟\nage  : 23\n====================\n====================\nname  : 陈二狗\nage  : 24\n====================\n*/\n\n\nDemo.xml文件 （根项目路径）\n\n<?xml version="1.0" encoding="UTF-8"?>\n<peoples id="异灵术狗贼二人组">\n    <people>\n        <name>戴佳伟</name>\n        <age>23</age>\n    </people>\n    <people>\n        <name>陈二狗</name>\n        <age>24</age>\n    </people>\n</peoples>\n\n\n\n# XML网络解析\n\n（返回*）\n\nimport org.dom4j.Document;\nimport org.dom4j.DocumentException;\nimport org.dom4j.Element;\nimport org.dom4j.io.SAXReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.Scanner;\n\n/**\n * @Author: 柏竹\n * @Description: 一个简洁主义...\n * @Date_Created_in: 2021-02-28 8:56\n * @Modified_By:\n * @Project： 解析网络文件\n */\npublic class Demo2 {\n    public static void main(String[] args) throws IOException, DocumentException, InterruptedException {\n        System.out.println("手机信息查询");\n        System.out.print("输查询的手机号码 ： ");\n        String phone = new Scanner(System.in).nextLine();\n        URL url = new URL("http://apis.juhe.cn/mobile/get? phone="+phone+"&dtype=xml&key=9f3923e8f87f1ea50ed4ec8c39cc9253");\n        URLConnection conn = url.openConnection();\n        InputStream is = conn.getInputStream();\n        SAXReader sr = new SAXReader();\n        Document doc = sr.read(is);\n        Element root = doc.getRootElement();\n        Element code = root.element("resultcode");\n        Thread.sleep(1000);\n        if (code.getText().equals("200")){\n            Element result = root.element("result");\n            String province = result.element("province").getText();\n            String city = result.elementText("city");\n            String postCode = result.elementText("zip");\n            String supplier = result.elementText("company");\n            System.out.println("==============");\n            if (province.equals(city)){\n                System.out.println("归属地 ： " + province);\n            }else{\n                System.out.println("归属地 ： " + province +" "+city);\n            }\n            System.out.println("邮政编号 ： "+ postCode);\n            System.out.println("运营商 ： "+ supplier);\n            System.out.println("==============");\n        }else{\n            System.out.println("请从新输入号码 ！ ");\n        }\n        \n        is.close();\n    }\n}\n\n/*\n手机信息查询\n输查询的手机号码 ： 17155943925\n==============\n归属地 ： 福建 莆田\n邮政编号 ： 351100\n运营商 ： 国美极信\n==============\n*/\n\n\nxml网络文档\n\n<root nighteye="disabled">\n\t<resultcode>200</resultcode>\n\t<reason>Return Successd!</reason>\n\t<result>\n\t\t<province>福建</province>\n\t\t<city>莆田</city>\n\t\t<areacode>0594</areacode>\n\t\t<zip>351100</zip>\n\t\t<company>国美极信</company>\n\t\t<card/>\n\t</result>\n\t<error_code>0</error_code>\n</root>\n\n\n\n# DOM4J-XPATH网络解析\n\n（返回*）\n\nimport org.dom4j.Document;\nimport org.dom4j.DocumentException;\nimport org.dom4j.io.SAXReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.Scanner;\n\n/**\n * @Author: 柏竹\n * @Description: 一个简洁主义...\n * @Date_Created_in: 2021-02-28 8:56\n * @Modified_By:\n * @Project： 解析网络文件\n */\npublic class Demo3 {\n    public static void main(String[] args) throws IOException, DocumentException, InterruptedException {\n        System.out.println("手机信息查询");\n        System.out.print("输查询的手机号码 ： ");\n        String phone = new Scanner(System.in).nextLine();\n        URL url = new URL("http://apis.juhe.cn/mobile/get? phone="+phone+"&dtype=xml&key=9f3923e8f87f1ea50ed4ec8c39cc9253");\n        URLConnection conn = url.openConnection();\n        InputStream is = conn.getInputStream();\n        SAXReader sr = new SAXReader();\n        Document doc = sr.read(is);\n        String code = doc.selectSingleNode("//resultcode").getText();\n        if ("200".equals(code)){\n            String province = doc.selectSingleNode("//province").getText();\n            String city = doc.selectSingleNode("//city").getText();\n            String postCode = doc.selectSingleNode("//zip").getText();\n            String supplier = doc.selectSingleNode("//company").getText();\n            Thread.sleep(1000);\n            printInfo(province , city , postCode , supplier);\n        } else {\n            System.out.println("请从新输入号码 ！ ");\n        }\n        is.close();\n    }\n    \n    public static void printInfo(String province , String city , String postCode , String supplier) {\n        System.out.println("==============");\n        if (province.equals(city)){\n            System.out.println("归属地 ： " + province);\n        } else {\n            System.out.println("归属地 ： " + province + " " + city);\n        }\n        System.out.println("邮政编号 ： " + postCode);\n        System.out.println("运营商 ： " + supplier);\n        System.out.println("==============");\n    }\n}\n\n/*\n手机信息查询\n输查询的手机号码 ： 17155943925\n==============\n归属地 ： 福建 莆田\n邮政编号 ： 351100\n运营商 ： 国美极信\n==============\n*/\n\n\nxml网络文档\n\n<root nighteye="disabled">\n\t<resultcode>200</resultcode>\n\t<reason>Return Successd!</reason>\n\t<result>\n\t\t<province>福建</province>\n\t\t<city>莆田</city>\n\t\t<areacode>0594</areacode>\n\t\t<zip>351100</zip>\n\t\t<company>国美极信</company>\n\t\t<card/>\n\t</result>\n\t<error_code>0</error_code>\n</root>\n\n\n\n# XML生成\n\n生成于项目根路径\n\nimport org.dom4j.Document;\nimport org.dom4j.DocumentHelper;\nimport org.dom4j.Element;\nimport org.dom4j.io.XMLWriter;\n\nimport java.io.*;\n\n/**\n * @Author: 柏竹\n * @Description: 一个简洁主义...\n * @Date_Created_in: 2021-02-28 19:38\n * @Modified_By:\n * @Project： XML生成\n */\n\npublic class Demo {\n    public static void main(String[] args) throws IOException {\n        Document doc = DocumentHelper.createDocument();\n        Element root = doc.addElement("peoples");\n        \n        //后宫\n        String[] names ={\n          "黑猫" , "雪乃" , "黑子" , "柏竹" , "红豆" , "智乃" , "蕾姆" , "纱雾" , "琪露诺" , "麻衣"\n        };\n        String[] ages = {\n                "14" , "18" , "16" , "20" , "12" , "12" , "17" , "14" , "13" , "18"\n        };\n        \n        for (int i = 0 ; i < 10 ; i++) {\n            Element people = root.addElement("people");\n            people.addAttribute("id",1000+i+"");\n            Element name = people.addElement("name");\n            Element age = people.addElement("age");\n            name.setText(names[i]);\n            age.setText(ages[i]);\n        }\n    \n        FileOutputStream fos = new FileOutputStream("Demo.xml");\n        XMLWriter xw = new XMLWriter(fos);\n        xw.write(doc);\n        \n        xw.close();\n        fos.close();\n    }\n}\n\n/* 结果：代码格式化后的 xml文件 \n\n<?xml version="1.0" encoding="UTF-8"?>\n<peoples>\n    <people/>\n    <people id="1000">\n        <name>黑猫</name>\n        <age>14</age>\n    </people>\n    <people id="1001">\n        <name>雪乃</name>\n        <age>18</age>\n    </people>\n    <people id="1002">\n        <name>黑子</name>\n        <age>16</age>\n    </people>\n    <people id="1003">\n        <name>柏竹</name>\n        <age>20</age>\n    </people>\n    <people id="1004">\n        <name>红豆</name>\n        <age>12</age>\n    </people>\n    <people id="1005">\n        <name>智乃</name>\n        <age>12</age>\n    </people>\n    <people id="1006">\n        <name>蕾姆</name>\n        <age>17</age>\n    </people>\n    <people id="1007">\n        <name>纱雾</name>\n        <age>14</age>\n    </people>\n    <people id="1008">\n        <name>琪露诺</name>\n        <age>13</age>\n    </people>\n    <people id="1009">\n        <name>麻衣</name>\n        <age>18</age>\n    </people>\n</peoples>\n\n*/\n\n\n\n# XML类对象形式生成\n\n生成于项目根路径\n\npackage Demo2;\n\nimport com.thoughtworks.xstream.XStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.PrintWriter;\nimport java.io.Writer;\n\n/**\n * @Author: 柏竹\n * @Description: 一个简洁主义...\n * @Date_Created_in: 2021-02-28 20:41\n * @Modified_By:\n * @Project： XStream生成XML文件 （对象）\n */\npublic class Demo2 {\n    public static void main(String[] args) throws IOException {\n        XStream x = new XStream();\n        \n        x.alias("people" , People.class);\n        \n        People p1 = new People("智乃" , "12");\n        People p2 = new People("蕾姆" , "17");\n        People p3 = new People("黑子" , "16");\n        \n        //前期学习不太会太多，用了较粗暴的方式生成\n        FileOutputStream fos = new FileOutputStream("Demo2.xml");\n        Writer w = new PrintWriter(fos);\n        w.write("<?xml version=\\"1.0\\" encoding=\\"UTF-8\\"?>");\n        w.write("<peoples>");\n        w.write(x.toXML(p1));\n        w.write(x.toXML(p2));\n        w.write(x.toXML(p3));\n        w.write("</peoples>");\n    \n        w.close();\n        fos.close();\n    }\n}\n\n/*结果：代码格式化后的 xml文件 \n\n<?xml version="1.0" encoding="UTF-8"?>\n<peoples>\n    <people>\n        <name>智乃</name>\n        <age>12</age>\n    </people>\n    <people>\n        <name>蕾姆</name>\n        <age>17</age>\n    </people>\n    <people>\n        <name>黑子</name>\n        <age>16</age>\n    </people>\n</peoples>\n\n*/\n\n\n文章会持续更新！！！\n\n\n# Gson序列化与反序列化\n\n（返回*）\n\npackage Gson;\nimport UtilClass.Book;\nimport UtilClass.People;\nimport com.google.gson.Gson;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\n/**\n * @Author: 柏竹\n * @Description: 一个简洁主义...\n * @Date_Created_in: 2021-03-01 10:37\n * @Modified_By:\n * @Project：Gson实现JSON\n */\npublic class Demo {\n    public static void main(String[] args) {\n        //序列化\n        People people = new People("陈二狗" , "23");\n        Gson gson = new Gson();\n        String json = gson.toJson(people);\n        System.out.println(json);\n        //json = {"name":"陈二狗","age":"23"}\n        \n        //反序列化\n        People people2 = gson.fromJson(json , People.class);\n        System.out.println(people2.getName());\n        System.out.println(people2.getAge());\n        \n        \n        \n        System.out.println("================");\n        // 难度提升\n        //序列化\n        //页数 对应 内容\n        HashMap<Integer , List<String>> data = new HashMap<>();\n        List<String> array = new ArrayList<>();\n        array.add("发");\n        array.add("法");\n        array.add("罚");\n        array.add("伐");\n        array.add("阀");\n        //。。。\n        data.put(189 , array);\n        \n        Book book = new Book("汉语字典","文字API" , data);\n        json = gson.toJson(book);\n        System.out.println(json);\n        /*\n        {\n            "name":"汉语字典",\n            "info":"文字API",\n            "data":{\n                "189":["发","法","罚","伐","阀"]\n            }\n        }\n        */\n        \n        //反序列化\n        Book book2 = gson.fromJson(json , Book.class);\n        System.out.println(book2.getData());\n    }\n}\n\n\n/*\n\n{"name":"陈二狗","age":"23"}\n陈二狗\n23\n================\n{"name":"汉语字典","info":"文字API","data":{"189":["发","法","罚","伐","阀"]}}\n{189=[发, 法, 罚, 伐, 阀]}\n\n*/\n\n\n\n# FastJson序列化与反序列化\n\n（返回*）\n\npackage FastJson;\n\nimport UtilClass.Book;\nimport UtilClass.People;\nimport com.alibaba.fastjson.JSON;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\n\n/**\n * @Author: 柏竹\n * @Description: 一个简洁主义...\n * @Date_Created_in: 2021-03-01 11:13\n * @Modified_By:\n * @Project： FastJson实现JSON\n */\npublic class Demo {\n    public static void main(String[] args) {\n        //序列化\n        People people = new People("陈二狗" , "23");\n        String json = JSON.toJSONString(people);\n        System.out.println(people);\n        //json = UtilClass.People{name=\'陈二狗\', age=\'23\'}     包.类{类属性}\n        \n        //反序列化\n        People people2 = JSON.parseObject(json , People.class);\n        System.out.println(people2.getName());\n        System.out.println(people2.getAge());\n    \n        System.out.println("================");\n        // 难度提升\n        //序列化\n        //页数 对应 内容\n        HashMap<Integer , List<String>> data = new HashMap<>();\n        List<String> array = new ArrayList<>();\n        array.add("发");\n        array.add("法");\n        array.add("罚");\n        array.add("伐");\n        array.add("阀");\n        //。。。\n        data.put(189 , array);\n    \n        Book book = new Book("汉语字典","文字API" , data);\n        json = JSON.toJSONString(book);\n        System.out.println(json);\n        /*\n        {\n            "data":{\n                189:["发","法","罚","伐","阀"]\n            },\n            "info":"文字API",\n            "name":"汉语字典"\n        }\n         */\n    \n        //反序列化\n        Book book2 = JSON.parseObject(json , Book.class);\n        System.out.println(book2.getData());\n    }\n}\n\n/*\nUtilClass.People{name=\'陈二狗\', age=\'23\'}\n陈二狗\n23\n================\n{"data":{189:["发","法","罚","伐","阀"]},"info":"文字API","name":"汉语字典"}\n{189=[发, 法, 罚, 伐, 阀]}\n */\n\n\n\nPeople工具类\n\npackage UtilClass;\n\nimport java.util.Objects;\n\n/**\n * @Author: 柏竹\n * @Description: 一个简洁主义...\n * @Date_Created_in: 2021-03-01 10:36\n * @Modified_By:\n * @Project：\n */\npublic class People {\n    String name;\n    String age;\n    \n    public People() {\n    }\n    \n    public People(String name , String age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    @Override\n    public String toString() {\n        return "UtilClass.People{" +\n                "name=\'" + name + \'\\\'\' +\n                ", age=\'" + age + \'\\\'\' +\n                \'}\';\n    }\n    \n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        People people = (People) o;\n        return Objects.equals(name , people.name) &&\n                Objects.equals(age , people.age);\n    }\n    \n    @Override\n    public int hashCode() {\n        return Objects.hash(name , age);\n    }\n    \n    public String getName() {\n        return name;\n    }\n    \n    public void setName(String name) {\n        this.name = name;\n    }\n    \n    public String getAge() {\n        return age;\n    }\n    \n    public void setAge(String age) {\n        this.age = age;\n    }\n}\n\n\nBook工具类\n\npackage UtilClass;\n\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Objects;\n\n/**\n * @Author: 柏竹\n * @Description: 一个简洁主义...\n * @Date_Created_in: 2021-03-01 10:48\n * @Modified_By:\n * @Project：\n */\npublic class Book {\n    String name;\n    String info;\n    HashMap<Integer , List<String>> data;\n    \n    public Book() {\n    }\n    \n    public Book(String name , String info , HashMap<Integer, List<String>> data) {\n        this.name = name;\n        this.info = info;\n        this.data = data;\n    }\n    \n    @Override\n    public String toString() {\n        return "Book{" +\n                "name=\'" + name + \'\\\'\' +\n                ", info=\'" + info + \'\\\'\' +\n                ", data=" + data +\n                \'}\';\n    }\n    \n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n        Book book = (Book) o;\n        return Objects.equals(name , book.name) &&\n                Objects.equals(info , book.info) &&\n                Objects.equals(data , book.data);\n    }\n    \n    @Override\n    public int hashCode() {\n        return Objects.hash(name , info , data);\n    }\n    \n    public String getName() {\n        return name;\n    }\n    \n    public void setName(String name) {\n        this.name = name;\n    }\n    \n    public String getInfo() {\n        return info;\n    }\n    \n    public void setInfo(String info) {\n        this.info = info;\n    }\n    \n    public HashMap<Integer, List<String>> getData() {\n        return data;\n    }\n    \n    public void setData(HashMap<Integer, List<String>> data) {\n        this.data = data;\n    }\n}\n',normalizedContent:'# xml&json\n\n\n# xml\n\nxml 可拓展标志语言，java实现需要导包jar，点击链接\n\n * 平台无关性，是门独立的标记语言\n * 自我描述\n * 网络数据传输\n * 数据存储\n * 配置文件\n\n\n# xml文件\n\n.xml文件 文件是保存 xml数据的方式。它可有其他形式。但xml语言不能理解成xml文件\n\n\n# xml语法\n\n# 文档声明\n\n<?xml version="1.0" encoding="utf-8"?>\n\n\n版本，编码类型\n\n# 标记\n\n开始标记 : <标记名称>\n\n结束标记 : </标记名称>\n\n标记名称 : 自定义名称\n\n必须遵循以下命名规则：\n\n 1. 名称可以含字母、数字以及其他的字\n 2. 名称不能以数字或者标点符号开始\n 3. 名称不能以字符 “xml”（或者 xml、xml）开始\n 4. 名称不能包含空格，不能包含冒号（:）\n 5. 名称区分大小写\n\n标记内容 : 开始标记与结束标记之间 ,是标记的内容\n\n<name>戴佳伟</name>\n<age>23</age>\n\n\n# 嵌套标记\n\n正例:\n<person>\n\t<name>戴佳伟</name>\n\t<age>23</age>\n</person>\n反例:\n<person>\n\t<name>戴佳伟<age></name>\n\t23</age>\n</person>\n\n\n# 标记属性\n\n标记中的属性, 在标记开始时 描述, 由属 性名 和 属性值 组成\n\n正例:\n<persons>\n\t<person id = "001" groupid = "1">\n\t\t<name>戴佳伟</name>\n\t\t<age>23</age>\n\t</person>\n\t<person  id = "002" groupid = "2">\n\t\t<name>陈二狗</name>\n\t\t<age>24</age>\n\t</person>\n</persons>\n\n\n# 注释\n\n注释不能写在文档文档声明前\n\n\x3c!--注释内容--\x3e\n\n\n# 进阶cdata\n\n用于过滤内容。在解析文本数据时 < 和 & 字符在xml非法的，会产生错误，因解析器误认为 < 是新的元数开始 ；& 是字符实体的开始\n\n某些语言的文本，可能会存在大量 < 和 & 字符。因此可以将脚本代码定义为cata\n\n\x3c!--\ncdata 部分中的所有内容都会被解析器忽略。\ncdata 部分由 "<![cdata[" 开始，由 "]]>" 结束\n--\x3e\n<mane><![cdata[你<a></a>好]]></mane>\n\n\n\n# xml解析方式\n\n# sax解析\n\n说明：\n\n * 逐行解析 单向\n * 事件驱动机制。当每解析到 开始/结束/内容/属性 时，触发事件\n * 可进行发生时处理\n\n优点：\n\n * 可立即开始，无需等待数据处理\n * 逐行加载，省空间\n * 满足条件可立即停止解析\n\n缺点：\n\n * 单向解析，无法定位文档层次，读完一行释放一行！！\n * 只能得知自己的节点的 父/子 关系\n * 只读，无法修改\n\n# dom解析\n\n说明：\n\n * 解析需要加载整个 文档 和 内存\n * 有文档树模型\n * 可操作文档树进行 获取、修改、删除等。。。\n\n优点：\n\n * 文档在内存中加载, 可对 数据 和 结构 做出更改\n * 双向访问\n\n缺点：\n\n * 耗费内存资源较大\n\n# jdom解析\n\njava特定文档模型，比dom实现快\n\n优点：\n\n * 使用 具体类 而非接口，简化dom的api\n * 复原java集合类，使用方便\n\n缺点：\n\n * 灵活性差\n * 性能一般\n\n# dom4j解析\n\ndom4j是jdom的一种智能分支。功能强大！\n\n点击代码示例* （dom4j-xpath网络解析）\n\n路径表示式\n\n> / ：从根节点开始查找 // ：从发起查找的节点位置，查找子节点 . ：找到当前节点 .. ：查找父节点 @ ：属性筛选 [@属性名 = \'value\'] [@属性名 > \'value\'] [@属性名 < \'value\'] [@属性名 != \'value\']\n\n<persons>\n\t<person id = "001" groupid = "1">\n\t\t<name>戴佳伟</name>\n\t\t<age>23</age>\n\t</person>\n\t<person  id = "002" groupid = "2">\n\t\t<name>陈二狗</name>\n\t\t<age>24</age>\n\t</person>\n</persons>\n\n\x3c!-- \n人名：\npersons : //person//name\n指定id\npersons : //person[@id = \'002\']//name\n--\x3e\n\n\n\n# xml对象类型\n\n# 文档对象\n\ndocument接口 用于文本容器。文档加载到内存的整个 xml文档\n\n常用方法 （更多自行api）\n\n返回           方法                              说明\nelement      addelement(string name)         添加 根节点 并返回\nelement      getrootelement()                获取 根节点\nelement      getdafultrootelement()          获取 树的根元素\nelement[]    getrootelements()               获取 定义的所有根元素\nint          getlength()                     获取 文档内容字符数\nstring       gettext(int off , int len)      获取 指定文本范围\nobject       getproperty(object key)         获取 与文档关联的属性\nlist<node>   selectnodes(string name)        获取 指定路径的所有 name节点\nstring       selectsinglenode(string name)   获取 指定路径的第一个 name节点\n\n# 元素对象\n\nelement接口 用于xml文档单个节点的捕捉。\n\n常用方法 （更多自行api）\n\n返回              方法                                         说明\nvoid            addattribute(string name , string value)   添加属性\nelement         addelement(string sonname)                 添加 子节点并返回\nstring          attributevalue(string name)                获取 节点的属性值\nstring          getname()                                  获取 节点名称\nstring          gettext()                                  获取 节点内容\nelement         getparentelement()                         获取 父元素\nstring          elementtext(string sonname)                获取 子节点的内容\nelement         element(string name)                       获取 匹配名称的第一节点\nlist<element>   elements()                                 获取 所有的子节点对象\nstring          settext()                                  更改 节点内容\n\n点击代码示例* （xml本地解析）\n\n点击代码示例* （xml网络解析）\n\n\n# json\n\njson（javascript object notation），是轻量级的数据交换格式\n\n\n# 对象格式\n\n * 一个对象，由大括号包括表示，括号中包含属性（通过键值描述对象）\n * 每对 键与值 要用 :冒号连接；每对 键值 要用 ,逗号分隔\n * 每对 键值的键 都要用 "引号引住（java解析需要）\n * 每对 键值的值 使用的是object类型（任何类型） 如果值中有数组形式需要 []方括号括住元素\n\n{\n    "name":"陈二狗",\n    "age":"23",\n    "friend":["王二","张三","李四",{\n       "name":"黑马老师",\n        "info":"带我们走向胜利！"\n    }],\n    "equipment":{\n        "name":"武士刀",\n        "length":"60cm"\n    }\n}\n\n\n\n# json解析\n\n导包链接进不了可以试试这个点击链接 （包含 谷歌 和 阿里 ）\n\n# gson\n\njava实现需要导包jar，点击链接\n\n//假如有个 `people类` ,有`name` , `age` 2个属性\npeople people = new people("陈二狗" , "23");\n\n//序列化\ngson gson = new gson();\nstring json = gson.tojson(people); \t//可参数任意\n/* 序列化结果 的json\n{\n\t"name":"陈二狗",\n\t"age":"23"\n}\n*/\n\n//反序列化\npeople people = gson.fromjson(json , people.class);\n\n\n点击代码示例* （gson序列化与反序列化）\n\n# fastjson\n\njava实现需要导包jar，点击链接\n\n//假如有个 `people类` ,有`name` , `age` 2个属性\npeople people = new people("陈二狗" , "23");\n\n//序列化\nstring json = json.tojsonstring(people);\t//可参数任意\n/* 序列化结果 的json\n{\n\t"name":"陈二狗",\n\t"age":"23"\n}\n*/\n\n//反序列化\npeople people = json.parseobject(json , people.class);\n\n\n点击代码示例* （fastjson序列化与反序列化）\n\n\n# 代码索引\n\n\n# xml解析\n\n（返回*）\n\nimport org.dom4j.document;\nimport org.dom4j.documentexception;\nimport org.dom4j.element;\nimport org.dom4j.io.saxreader;\nimport java.io.fileinputstream;\nimport java.io.ioexception;\nimport java.util.list;\n\n/**\n * @author: 柏竹\n * @description: 一个简洁主义...\n * @date_created_in: 2021-02-27 21:50\n * @modified_by:\n * @project： 解析本地xml文件\n */\n\npublic class demo {\n    public static void main(string[] args) throws ioexception, documentexception {\n        \n        //1.    获取流（项目跟路径）\n        fileinputstream fis = new fileinputstream("demo.xml");\n        //2.    创建xml读取对象\n        saxreader sr = new saxreader();\n        //3.    读取并得到对象\n        document doc = sr.read(fis);\n        //4.    通过文档获取根元素\n        element root = doc.getrootelement();\n        //5.    解析根元素\n        \n        system.out.println(root.attributevalue("id"));\n        \n        list<element> es = root.elements();\n        for (int i = 0 ; i < 2 ; i++) {\n            element people = es.get(i);\n            system.out.println("====================");\n            system.out.println("name  : " + people.elementtext("name"));\n            system.out.println("age  : " + people.elementtext("age"));\n            system.out.println("====================");\n        }\n        \n        fis.close();\n    }\n}\n\n/*\n异灵术狗贼二人组\n====================\nname  : 戴佳伟\nage  : 23\n====================\n====================\nname  : 陈二狗\nage  : 24\n====================\n*/\n\n\ndemo.xml文件 （根项目路径）\n\n<?xml version="1.0" encoding="utf-8"?>\n<peoples id="异灵术狗贼二人组">\n    <people>\n        <name>戴佳伟</name>\n        <age>23</age>\n    </people>\n    <people>\n        <name>陈二狗</name>\n        <age>24</age>\n    </people>\n</peoples>\n\n\n\n# xml网络解析\n\n（返回*）\n\nimport org.dom4j.document;\nimport org.dom4j.documentexception;\nimport org.dom4j.element;\nimport org.dom4j.io.saxreader;\nimport java.io.ioexception;\nimport java.io.inputstream;\nimport java.net.url;\nimport java.net.urlconnection;\nimport java.util.scanner;\n\n/**\n * @author: 柏竹\n * @description: 一个简洁主义...\n * @date_created_in: 2021-02-28 8:56\n * @modified_by:\n * @project： 解析网络文件\n */\npublic class demo2 {\n    public static void main(string[] args) throws ioexception, documentexception, interruptedexception {\n        system.out.println("手机信息查询");\n        system.out.print("输查询的手机号码 ： ");\n        string phone = new scanner(system.in).nextline();\n        url url = new url("http://apis.juhe.cn/mobile/get? phone="+phone+"&dtype=xml&key=9f3923e8f87f1ea50ed4ec8c39cc9253");\n        urlconnection conn = url.openconnection();\n        inputstream is = conn.getinputstream();\n        saxreader sr = new saxreader();\n        document doc = sr.read(is);\n        element root = doc.getrootelement();\n        element code = root.element("resultcode");\n        thread.sleep(1000);\n        if (code.gettext().equals("200")){\n            element result = root.element("result");\n            string province = result.element("province").gettext();\n            string city = result.elementtext("city");\n            string postcode = result.elementtext("zip");\n            string supplier = result.elementtext("company");\n            system.out.println("==============");\n            if (province.equals(city)){\n                system.out.println("归属地 ： " + province);\n            }else{\n                system.out.println("归属地 ： " + province +" "+city);\n            }\n            system.out.println("邮政编号 ： "+ postcode);\n            system.out.println("运营商 ： "+ supplier);\n            system.out.println("==============");\n        }else{\n            system.out.println("请从新输入号码 ！ ");\n        }\n        \n        is.close();\n    }\n}\n\n/*\n手机信息查询\n输查询的手机号码 ： 17155943925\n==============\n归属地 ： 福建 莆田\n邮政编号 ： 351100\n运营商 ： 国美极信\n==============\n*/\n\n\nxml网络文档\n\n<root nighteye="disabled">\n\t<resultcode>200</resultcode>\n\t<reason>return successd!</reason>\n\t<result>\n\t\t<province>福建</province>\n\t\t<city>莆田</city>\n\t\t<areacode>0594</areacode>\n\t\t<zip>351100</zip>\n\t\t<company>国美极信</company>\n\t\t<card/>\n\t</result>\n\t<error_code>0</error_code>\n</root>\n\n\n\n# dom4j-xpath网络解析\n\n（返回*）\n\nimport org.dom4j.document;\nimport org.dom4j.documentexception;\nimport org.dom4j.io.saxreader;\nimport java.io.ioexception;\nimport java.io.inputstream;\nimport java.net.url;\nimport java.net.urlconnection;\nimport java.util.scanner;\n\n/**\n * @author: 柏竹\n * @description: 一个简洁主义...\n * @date_created_in: 2021-02-28 8:56\n * @modified_by:\n * @project： 解析网络文件\n */\npublic class demo3 {\n    public static void main(string[] args) throws ioexception, documentexception, interruptedexception {\n        system.out.println("手机信息查询");\n        system.out.print("输查询的手机号码 ： ");\n        string phone = new scanner(system.in).nextline();\n        url url = new url("http://apis.juhe.cn/mobile/get? phone="+phone+"&dtype=xml&key=9f3923e8f87f1ea50ed4ec8c39cc9253");\n        urlconnection conn = url.openconnection();\n        inputstream is = conn.getinputstream();\n        saxreader sr = new saxreader();\n        document doc = sr.read(is);\n        string code = doc.selectsinglenode("//resultcode").gettext();\n        if ("200".equals(code)){\n            string province = doc.selectsinglenode("//province").gettext();\n            string city = doc.selectsinglenode("//city").gettext();\n            string postcode = doc.selectsinglenode("//zip").gettext();\n            string supplier = doc.selectsinglenode("//company").gettext();\n            thread.sleep(1000);\n            printinfo(province , city , postcode , supplier);\n        } else {\n            system.out.println("请从新输入号码 ！ ");\n        }\n        is.close();\n    }\n    \n    public static void printinfo(string province , string city , string postcode , string supplier) {\n        system.out.println("==============");\n        if (province.equals(city)){\n            system.out.println("归属地 ： " + province);\n        } else {\n            system.out.println("归属地 ： " + province + " " + city);\n        }\n        system.out.println("邮政编号 ： " + postcode);\n        system.out.println("运营商 ： " + supplier);\n        system.out.println("==============");\n    }\n}\n\n/*\n手机信息查询\n输查询的手机号码 ： 17155943925\n==============\n归属地 ： 福建 莆田\n邮政编号 ： 351100\n运营商 ： 国美极信\n==============\n*/\n\n\nxml网络文档\n\n<root nighteye="disabled">\n\t<resultcode>200</resultcode>\n\t<reason>return successd!</reason>\n\t<result>\n\t\t<province>福建</province>\n\t\t<city>莆田</city>\n\t\t<areacode>0594</areacode>\n\t\t<zip>351100</zip>\n\t\t<company>国美极信</company>\n\t\t<card/>\n\t</result>\n\t<error_code>0</error_code>\n</root>\n\n\n\n# xml生成\n\n生成于项目根路径\n\nimport org.dom4j.document;\nimport org.dom4j.documenthelper;\nimport org.dom4j.element;\nimport org.dom4j.io.xmlwriter;\n\nimport java.io.*;\n\n/**\n * @author: 柏竹\n * @description: 一个简洁主义...\n * @date_created_in: 2021-02-28 19:38\n * @modified_by:\n * @project： xml生成\n */\n\npublic class demo {\n    public static void main(string[] args) throws ioexception {\n        document doc = documenthelper.createdocument();\n        element root = doc.addelement("peoples");\n        \n        //后宫\n        string[] names ={\n          "黑猫" , "雪乃" , "黑子" , "柏竹" , "红豆" , "智乃" , "蕾姆" , "纱雾" , "琪露诺" , "麻衣"\n        };\n        string[] ages = {\n                "14" , "18" , "16" , "20" , "12" , "12" , "17" , "14" , "13" , "18"\n        };\n        \n        for (int i = 0 ; i < 10 ; i++) {\n            element people = root.addelement("people");\n            people.addattribute("id",1000+i+"");\n            element name = people.addelement("name");\n            element age = people.addelement("age");\n            name.settext(names[i]);\n            age.settext(ages[i]);\n        }\n    \n        fileoutputstream fos = new fileoutputstream("demo.xml");\n        xmlwriter xw = new xmlwriter(fos);\n        xw.write(doc);\n        \n        xw.close();\n        fos.close();\n    }\n}\n\n/* 结果：代码格式化后的 xml文件 \n\n<?xml version="1.0" encoding="utf-8"?>\n<peoples>\n    <people/>\n    <people id="1000">\n        <name>黑猫</name>\n        <age>14</age>\n    </people>\n    <people id="1001">\n        <name>雪乃</name>\n        <age>18</age>\n    </people>\n    <people id="1002">\n        <name>黑子</name>\n        <age>16</age>\n    </people>\n    <people id="1003">\n        <name>柏竹</name>\n        <age>20</age>\n    </people>\n    <people id="1004">\n        <name>红豆</name>\n        <age>12</age>\n    </people>\n    <people id="1005">\n        <name>智乃</name>\n        <age>12</age>\n    </people>\n    <people id="1006">\n        <name>蕾姆</name>\n        <age>17</age>\n    </people>\n    <people id="1007">\n        <name>纱雾</name>\n        <age>14</age>\n    </people>\n    <people id="1008">\n        <name>琪露诺</name>\n        <age>13</age>\n    </people>\n    <people id="1009">\n        <name>麻衣</name>\n        <age>18</age>\n    </people>\n</peoples>\n\n*/\n\n\n\n# xml类对象形式生成\n\n生成于项目根路径\n\npackage demo2;\n\nimport com.thoughtworks.xstream.xstream;\nimport java.io.fileoutputstream;\nimport java.io.ioexception;\nimport java.io.printwriter;\nimport java.io.writer;\n\n/**\n * @author: 柏竹\n * @description: 一个简洁主义...\n * @date_created_in: 2021-02-28 20:41\n * @modified_by:\n * @project： xstream生成xml文件 （对象）\n */\npublic class demo2 {\n    public static void main(string[] args) throws ioexception {\n        xstream x = new xstream();\n        \n        x.alias("people" , people.class);\n        \n        people p1 = new people("智乃" , "12");\n        people p2 = new people("蕾姆" , "17");\n        people p3 = new people("黑子" , "16");\n        \n        //前期学习不太会太多，用了较粗暴的方式生成\n        fileoutputstream fos = new fileoutputstream("demo2.xml");\n        writer w = new printwriter(fos);\n        w.write("<?xml version=\\"1.0\\" encoding=\\"utf-8\\"?>");\n        w.write("<peoples>");\n        w.write(x.toxml(p1));\n        w.write(x.toxml(p2));\n        w.write(x.toxml(p3));\n        w.write("</peoples>");\n    \n        w.close();\n        fos.close();\n    }\n}\n\n/*结果：代码格式化后的 xml文件 \n\n<?xml version="1.0" encoding="utf-8"?>\n<peoples>\n    <people>\n        <name>智乃</name>\n        <age>12</age>\n    </people>\n    <people>\n        <name>蕾姆</name>\n        <age>17</age>\n    </people>\n    <people>\n        <name>黑子</name>\n        <age>16</age>\n    </people>\n</peoples>\n\n*/\n\n\n文章会持续更新！！！\n\n\n# gson序列化与反序列化\n\n（返回*）\n\npackage gson;\nimport utilclass.book;\nimport utilclass.people;\nimport com.google.gson.gson;\nimport java.util.arraylist;\nimport java.util.hashmap;\nimport java.util.list;\n\n/**\n * @author: 柏竹\n * @description: 一个简洁主义...\n * @date_created_in: 2021-03-01 10:37\n * @modified_by:\n * @project：gson实现json\n */\npublic class demo {\n    public static void main(string[] args) {\n        //序列化\n        people people = new people("陈二狗" , "23");\n        gson gson = new gson();\n        string json = gson.tojson(people);\n        system.out.println(json);\n        //json = {"name":"陈二狗","age":"23"}\n        \n        //反序列化\n        people people2 = gson.fromjson(json , people.class);\n        system.out.println(people2.getname());\n        system.out.println(people2.getage());\n        \n        \n        \n        system.out.println("================");\n        // 难度提升\n        //序列化\n        //页数 对应 内容\n        hashmap<integer , list<string>> data = new hashmap<>();\n        list<string> array = new arraylist<>();\n        array.add("发");\n        array.add("法");\n        array.add("罚");\n        array.add("伐");\n        array.add("阀");\n        //。。。\n        data.put(189 , array);\n        \n        book book = new book("汉语字典","文字api" , data);\n        json = gson.tojson(book);\n        system.out.println(json);\n        /*\n        {\n            "name":"汉语字典",\n            "info":"文字api",\n            "data":{\n                "189":["发","法","罚","伐","阀"]\n            }\n        }\n        */\n        \n        //反序列化\n        book book2 = gson.fromjson(json , book.class);\n        system.out.println(book2.getdata());\n    }\n}\n\n\n/*\n\n{"name":"陈二狗","age":"23"}\n陈二狗\n23\n================\n{"name":"汉语字典","info":"文字api","data":{"189":["发","法","罚","伐","阀"]}}\n{189=[发, 法, 罚, 伐, 阀]}\n\n*/\n\n\n\n# fastjson序列化与反序列化\n\n（返回*）\n\npackage fastjson;\n\nimport utilclass.book;\nimport utilclass.people;\nimport com.alibaba.fastjson.json;\nimport java.util.arraylist;\nimport java.util.hashmap;\nimport java.util.list;\n\n/**\n * @author: 柏竹\n * @description: 一个简洁主义...\n * @date_created_in: 2021-03-01 11:13\n * @modified_by:\n * @project： fastjson实现json\n */\npublic class demo {\n    public static void main(string[] args) {\n        //序列化\n        people people = new people("陈二狗" , "23");\n        string json = json.tojsonstring(people);\n        system.out.println(people);\n        //json = utilclass.people{name=\'陈二狗\', age=\'23\'}     包.类{类属性}\n        \n        //反序列化\n        people people2 = json.parseobject(json , people.class);\n        system.out.println(people2.getname());\n        system.out.println(people2.getage());\n    \n        system.out.println("================");\n        // 难度提升\n        //序列化\n        //页数 对应 内容\n        hashmap<integer , list<string>> data = new hashmap<>();\n        list<string> array = new arraylist<>();\n        array.add("发");\n        array.add("法");\n        array.add("罚");\n        array.add("伐");\n        array.add("阀");\n        //。。。\n        data.put(189 , array);\n    \n        book book = new book("汉语字典","文字api" , data);\n        json = json.tojsonstring(book);\n        system.out.println(json);\n        /*\n        {\n            "data":{\n                189:["发","法","罚","伐","阀"]\n            },\n            "info":"文字api",\n            "name":"汉语字典"\n        }\n         */\n    \n        //反序列化\n        book book2 = json.parseobject(json , book.class);\n        system.out.println(book2.getdata());\n    }\n}\n\n/*\nutilclass.people{name=\'陈二狗\', age=\'23\'}\n陈二狗\n23\n================\n{"data":{189:["发","法","罚","伐","阀"]},"info":"文字api","name":"汉语字典"}\n{189=[发, 法, 罚, 伐, 阀]}\n */\n\n\n\npeople工具类\n\npackage utilclass;\n\nimport java.util.objects;\n\n/**\n * @author: 柏竹\n * @description: 一个简洁主义...\n * @date_created_in: 2021-03-01 10:36\n * @modified_by:\n * @project：\n */\npublic class people {\n    string name;\n    string age;\n    \n    public people() {\n    }\n    \n    public people(string name , string age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    @override\n    public string tostring() {\n        return "utilclass.people{" +\n                "name=\'" + name + \'\\\'\' +\n                ", age=\'" + age + \'\\\'\' +\n                \'}\';\n    }\n    \n    @override\n    public boolean equals(object o) {\n        if (this == o) return true;\n        if (o == null || getclass() != o.getclass()) return false;\n        people people = (people) o;\n        return objects.equals(name , people.name) &&\n                objects.equals(age , people.age);\n    }\n    \n    @override\n    public int hashcode() {\n        return objects.hash(name , age);\n    }\n    \n    public string getname() {\n        return name;\n    }\n    \n    public void setname(string name) {\n        this.name = name;\n    }\n    \n    public string getage() {\n        return age;\n    }\n    \n    public void setage(string age) {\n        this.age = age;\n    }\n}\n\n\nbook工具类\n\npackage utilclass;\n\n\nimport java.util.hashmap;\nimport java.util.list;\nimport java.util.objects;\n\n/**\n * @author: 柏竹\n * @description: 一个简洁主义...\n * @date_created_in: 2021-03-01 10:48\n * @modified_by:\n * @project：\n */\npublic class book {\n    string name;\n    string info;\n    hashmap<integer , list<string>> data;\n    \n    public book() {\n    }\n    \n    public book(string name , string info , hashmap<integer, list<string>> data) {\n        this.name = name;\n        this.info = info;\n        this.data = data;\n    }\n    \n    @override\n    public string tostring() {\n        return "book{" +\n                "name=\'" + name + \'\\\'\' +\n                ", info=\'" + info + \'\\\'\' +\n                ", data=" + data +\n                \'}\';\n    }\n    \n    @override\n    public boolean equals(object o) {\n        if (this == o) {\n            return true;\n        }\n        if (o == null || getclass() != o.getclass()) {\n            return false;\n        }\n        book book = (book) o;\n        return objects.equals(name , book.name) &&\n                objects.equals(info , book.info) &&\n                objects.equals(data , book.data);\n    }\n    \n    @override\n    public int hashcode() {\n        return objects.hash(name , info , data);\n    }\n    \n    public string getname() {\n        return name;\n    }\n    \n    public void setname(string name) {\n        this.name = name;\n    }\n    \n    public string getinfo() {\n        return info;\n    }\n    \n    public void setinfo(string info) {\n        this.info = info;\n    }\n    \n    public hashmap<integer, list<string>> getdata() {\n        return data;\n    }\n    \n    public void setdata(hashmap<integer, list<string>> data) {\n        this.data = data;\n    }\n}\n',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Tomcat",frontmatter:{title:"Tomcat",author:"柏竹",permalink:"/backend/0y9sdx",date:"2020-02-18T00:00:00.000Z",categories:["后端","JavaWeb"],tags:["Tomcat"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/02.JavaWeb/01.Tomcat%E5%BA%94%E7%94%A8.html",relativePath:"01.后端/02.JavaWeb/01.Tomcat应用.md",key:"v-5169e0e4",path:"/backend/0y9sdx/",headers:[{level:2,title:"Tomcat下载",slug:"tomcat下载",normalizedTitle:"tomcat下载",charIndex:55},{level:2,title:"Tomcat目录",slug:"tomcat目录",normalizedTitle:"tomcat目录",charIndex:814},{level:2,title:"Tomcat配置",slug:"tomcat配置",normalizedTitle:"tomcat配置",charIndex:1201},{level:3,title:"IDEA整合",slug:"idea整合",normalizedTitle:"idea整合",charIndex:1214},{level:3,title:"JavaWeb项目创建",slug:"javaweb项目创建",normalizedTitle:"javaweb项目创建",charIndex:1268},{level:3,title:"配置端口号",slug:"配置端口号",normalizedTitle:"配置端口号",charIndex:1418},{level:2,title:"Tomcat项目管理",slug:"tomcat项目管理",normalizedTitle:"tomcat项目管理",charIndex:1584}],headersStr:"Tomcat下载 Tomcat目录 Tomcat配置 IDEA整合 JavaWeb项目创建 配置端口号 Tomcat项目管理",content:'# Tomcat\n\nTomcat 服务器是一个免费的开放源代码的Web 应用服务器，轻量级应用服务器\n\n\n# Tomcat下载\n\n点击网站\n\n 1. 下载后解压路径要纯英文\n 2. 打开 根路径下的 bin/startup.bat 文件\n 3. 打开 浏览器 进入地址：http://localhost:8080/ 浏览器进入的地址不是空，表示成功 优化使用，需要cmd方便应用\n 4. 环境配置 新建 系统变量（JDK配置） 变量名：CATALINA_HOME 变量值：C:\\Program Files\\Java\\apache-tomcat-9.0.13 (自己解压的路径)\n 5. 环境配置 更变 系统变量 （指令应用） 变量名：Path 新增值：%CATALINA_HOME%\\bin\n 6. 添加服务 cmd执行指令：service install / service install Tomcat9 (注意版本)\n 7. 服务配置 “Apache Tomcat ...”（设为 自动启动/手动 作为Tomcat服务的入口）\n\n可能要解决的问题:\n\n * 启动tomcat服务\n * Window功能 服务启动：打开 控制面板 -> 程序安装与卸载 -> window功能启动\n   * 启动 ==Internet Information Services== 下的所有子功能\n * Tomcat 中文乱码：修改以下配置文件中的 编码集\n * * `server.xml` 在配置端口的标签中 添加属性：==URIEncoding="UTF-8"==\n   * `logging.properties` 在属性 `java.util.logging.ConsoleHandler.encoding` 中设置值为 ==GBK==\n * startup.sh启动闪退：配置Java环境变量和Tomcat环境变量\n\n\n\n\n# Tomcat目录\n\n * bin： 存二进制可执行文件，指令操作控制\n * conf： 配置文件应用，有四个\n   * server.xml： 配置整个服务器信息\n     * tomcat-users.xml： 存储用户文件，账号密码等\n   * web.xml： 部署描述 的文件 ，如 MIME => text/html\n   * context.xml： 所有应用的统一配置（勿改）\n * lib： 类库，存储jar文件，用于添加依赖\n * logs： 日志文件\n * temp： 临时存放文件夹（缓存），停止Tomcat删除！！\n * webapps： 存放web项目的目录，每个文件夹都是项目（也有tomcat自带的）\n * work： 运行时生成的文件，每次运行都会重新生成（重复覆盖）\n * LICENSE： 许可证\n * NOTICE： 说明文件\n\n\n# Tomcat配置\n\n\n# IDEA整合\n\n添加tomcat\n\n\n\n\n\n引入路径\n\n\n\n添加 war exploded应用\n\n\n\n\n# JavaWeb项目创建\n\n创建项目，如果没有JavaWeb\n\n\n\n可在项目设置里添加框架\n\n\n\n\n\n在 WEB-INF 目录下 新建 classes 和 lib 文件夹 用于配置 jar包 和 classes包\n\n\n\n配置路径 classes包\n\n\n\n\n\n配置依赖 jar包\n\n\n\n\n\n\n\n\n\n\n# 配置端口号\n\n在根路径 找 ../conf/server.xml 文件（69行左右）\n\n\x3c!-- 修改 port属性 的值即可 --\x3e\n<Connector port="8888" protocol="HTTP/1.1" connectionTimeout="20000"\n redirectPort="8443" />\n\n\n\n# Tomcat项目管理\n\n添加管理员信息\n\n修改 ../conf/tomcat-users.xml 文件 将一下代码添加至 <tomcat-users> 标签\n\n<role rolename="manager-gui"/>\n<user username="tomcat" password="tomcat" roles="manager-gui"/>\n\n\nrolename/roles： 权限 username： 用户名 password： 密码',normalizedContent:'# tomcat\n\ntomcat 服务器是一个免费的开放源代码的web 应用服务器，轻量级应用服务器\n\n\n# tomcat下载\n\n点击网站\n\n 1. 下载后解压路径要纯英文\n 2. 打开 根路径下的 bin/startup.bat 文件\n 3. 打开 浏览器 进入地址：http://localhost:8080/ 浏览器进入的地址不是空，表示成功 优化使用，需要cmd方便应用\n 4. 环境配置 新建 系统变量（jdk配置） 变量名：catalina_home 变量值：c:\\program files\\java\\apache-tomcat-9.0.13 (自己解压的路径)\n 5. 环境配置 更变 系统变量 （指令应用） 变量名：path 新增值：%catalina_home%\\bin\n 6. 添加服务 cmd执行指令：service install / service install tomcat9 (注意版本)\n 7. 服务配置 “apache tomcat ...”（设为 自动启动/手动 作为tomcat服务的入口）\n\n可能要解决的问题:\n\n * 启动tomcat服务\n * window功能 服务启动：打开 控制面板 -> 程序安装与卸载 -> window功能启动\n   * 启动 ==internet information services== 下的所有子功能\n * tomcat 中文乱码：修改以下配置文件中的 编码集\n * * `server.xml` 在配置端口的标签中 添加属性：==uriencoding="utf-8"==\n   * `logging.properties` 在属性 `java.util.logging.consolehandler.encoding` 中设置值为 ==gbk==\n * startup.sh启动闪退：配置java环境变量和tomcat环境变量\n\n\n\n\n# tomcat目录\n\n * bin： 存二进制可执行文件，指令操作控制\n * conf： 配置文件应用，有四个\n   * server.xml： 配置整个服务器信息\n     * tomcat-users.xml： 存储用户文件，账号密码等\n   * web.xml： 部署描述 的文件 ，如 mime => text/html\n   * context.xml： 所有应用的统一配置（勿改）\n * lib： 类库，存储jar文件，用于添加依赖\n * logs： 日志文件\n * temp： 临时存放文件夹（缓存），停止tomcat删除！！\n * webapps： 存放web项目的目录，每个文件夹都是项目（也有tomcat自带的）\n * work： 运行时生成的文件，每次运行都会重新生成（重复覆盖）\n * license： 许可证\n * notice： 说明文件\n\n\n# tomcat配置\n\n\n# idea整合\n\n添加tomcat\n\n\n\n\n\n引入路径\n\n\n\n添加 war exploded应用\n\n\n\n\n# javaweb项目创建\n\n创建项目，如果没有javaweb\n\n\n\n可在项目设置里添加框架\n\n\n\n\n\n在 web-inf 目录下 新建 classes 和 lib 文件夹 用于配置 jar包 和 classes包\n\n\n\n配置路径 classes包\n\n\n\n\n\n配置依赖 jar包\n\n\n\n\n\n\n\n\n\n\n# 配置端口号\n\n在根路径 找 ../conf/server.xml 文件（69行左右）\n\n\x3c!-- 修改 port属性 的值即可 --\x3e\n<connector port="8888" protocol="http/1.1" connectiontimeout="20000"\n redirectport="8443" />\n\n\n\n# tomcat项目管理\n\n添加管理员信息\n\n修改 ../conf/tomcat-users.xml 文件 将一下代码添加至 <tomcat-users> 标签\n\n<role rolename="manager-gui"/>\n<user username="tomcat" password="tomcat" roles="manager-gui"/>\n\n\nrolename/roles： 权限 username： 用户名 password： 密码',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"JSP",frontmatter:{title:"JSP",author:"柏竹",permalink:"/backend/nkcjdp",date:"2020-02-18T00:00:00.000Z",categories:["后端","JavaWeb"],tags:["JSP"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/02.JavaWeb/03.JSP.html",relativePath:"01.后端/02.JavaWeb/03.JSP.md",key:"v-cd1cf0e8",path:"/backend/nkcjdp/",headers:[{level:2,title:"JSP 引入",slug:"jsp-引入",normalizedTitle:"jsp 引入",charIndex:123},{level:2,title:"JSP 原理",slug:"jsp-原理",normalizedTitle:"jsp 原理",charIndex:188},{level:2,title:"JSP 内置对象",slug:"jsp-内置对象",normalizedTitle:"jsp 内置对象",charIndex:301},{level:3,title:"request对象",slug:"request对象",normalizedTitle:"request对象",charIndex:314},{level:3,title:"response对象",slug:"response对象",normalizedTitle:"response对象",charIndex:452},{level:3,title:"session对象",slug:"session对象",normalizedTitle:"session对象",charIndex:599},{level:3,title:"application对象",slug:"application对象",normalizedTitle:"application对象",charIndex:706},{level:3,title:"out对象",slug:"out对象",normalizedTitle:"out对象",charIndex:799},{level:3,title:"pageContext对象",slug:"pagecontext对象",normalizedTitle:"pagecontext对象",charIndex:883},{level:3,title:"config对象",slug:"config对象",normalizedTitle:"config对象",charIndex:950},{level:3,title:"page对象",slug:"page对象",normalizedTitle:"page对象",charIndex:1063},{level:3,title:"exception对象",slug:"exception对象",normalizedTitle:"exception对象",charIndex:1108},{level:2,title:"JSP 指令",slug:"jsp-指令",normalizedTitle:"jsp 指令",charIndex:1284},{level:2,title:"状态码",slug:"状态码",normalizedTitle:"状态码",charIndex:2127},{level:2,title:"EL表达式",slug:"el表达式",normalizedTitle:"el表达式",charIndex:3103},{level:2,title:"JSTL",slug:"jstl",normalizedTitle:"jstl",charIndex:4403},{level:3,title:"JSTL引入",slug:"jstl引入",normalizedTitle:"jstl引入",charIndex:4474},{level:3,title:"核心标签",slug:"核心标签",normalizedTitle:"核心标签",charIndex:4928},{level:3,title:"应用实例",slug:"应用实例",normalizedTitle:"应用实例",charIndex:5773}],headersStr:"JSP 引入 JSP 原理 JSP 内置对象 request对象 response对象 session对象 application对象 out对象 pageContext对象 config对象 page对象 exception对象 JSP 指令 状态码 EL表达式 JSTL JSTL引入 核心标签 应用实例",content:'# JSP\n\nJSP是 Servlet设计的简化版，可在HTML页面添加 Java语言的脚本。JSP开发的Web应用可跨平台，也能在其他系统运行\n\n> *.html 静态页面\n> \n> *.jsp 动态页面（嵌套Java和html代码）\n\n\n# JSP 引入\n\n声明标签 <%! 变量/方法 的声明%>\n\n表达式 <%= 表达式%>\n\n执行标签 <%java代码%>\n\n\n# JSP 原理\n\n\n\n当浏览器访问服务器时。地址后缀为 .jsp ，会先找 index.jsp ，找到随后进行翻译成 index_jsp.java 并对其进行编译，产生一个 index_jsp.class 进行加载运行\n\n\n# JSP 内置对象\n\n\n# request对象\n\nrequest 对象是 javax.servlet.HttpServletRequest 类型的对象 该对象代表了客户端的请求信息，主要⽤于接受HTTP协议传送到服务器的数据 作用域：一次请求\n\n点击详细说明HttpServletRequest\n\n\n# response对象\n\nresponse 对象是 javax.servlet.HttpServletResponse 类型的对象 response 代表的是对客户端的响应，主要是将JSP容器处理过的对象传回到客户端 作用域：本页面\n\n点击详细说明HttpServletResponse\n\n\n# session对象\n\nsession 对象是由服务器自动创建的与用户请求相关的对象，每个会话都有对应的会话ID，用于保存信息，以及跟踪用户的操作状态 作用域：本次会话\n\n点击详细说明HttpSession\n\n\n# application对象\n\napplication对象 可将信息保存在服务器，直至服务器关闭（类似于全局变量） 作用域：服务器运行\n\n点击详细说明ServletContext\n\n\n# out对象\n\nout对象 可在Web浏览器内输出信息，管理应用服务器上的输出缓冲区（输出完及时不关闭流）\n\n点击详细说明ServletOutputStream\n\n\n# pageContext对象\n\npageContext对象 用于获取任何范围的参数\n\n更多方法说明ServletContext\n\n\n# config对象\n\nconfig对象 用于获取服务器的配置信息 使用前提需要 pageConext对象 的 getServletConfig() 方法 获取 config对象\n\n更多方法说明ServletConfig\n\n\n# page对象\n\npage对象 代表JSP本身（类似于Java语言 的 this）\n\n\n# exception对象\n\nexception对象 用于显示异常信息 在JSP页面 page指令 添加 isErrorPage = "true" 属性 和 errorPage="XXX.jsp"页面才生效 如果页面异常则会生成 exception对象 并把 page指令 设定在错误页面中进行处理\n\n更多方法说明ServletException\n\n\n# JSP 指令\n\nJSP指令 控制JSP编译器如何去生成servlet\n\npage指令 定义网页依赖（脚本、异常、缓冲、...） <%@ page language="java" import="java.util.*" pageEncoding="UTF-8"%>\n\n属性             值            说明\nlanguage       java、...     解释JSP文件使用的语言\nextends        任何类的全名       编译时继承哪个类\nimport         任何类的全名       引入类、包等...\nsession        true、false   设置JSP文件是否内置Session对象 (默认true)\nautoFlush      true、false   是否运行缓存 (默认true)\nbuffer         none、 指定KB   指定缓存大小 (默认none)\ncontentType    文档类型         规定了生成内容的类型。当生成非HTML内容或者当前字符集并非默认字符集时使用\nerrorPage      相对路径         指定 页面异常时转送的页面\nisErrorPage    true、false   指定页面是否显示错误提示页面 (默认false)\nisThreadSafe   true、false   最终生成的servlet是否具有线程安全性 (默认false)\npageEncoding   utf-8、...    指定 编码类型\n\n**Include指令** JSP可以通过include指令来包含其他文件 并且同时编译运行<%@ include file="相对url地址" %>`\n\nTaglib指令 JSP允许自定义标签库，引入库、标签等... <%@ taglib uri="标签库路径" prefix="指定标签库前缀" %>\n\n\n# 状态码\n\n状态码   消息                           说明\n100   Continue                     部分请求接收，但未被拒绝，客户端延长请求\n101   Switching Protocols          服务器交换机协议\n200   OK                           请求被确认\n201   Created                      请求时完整的，新的资源被创建\n202   Accepted                     请求被接收，但未处理完\n300   Multiple Choices             一个超链接表，用户可以选择超链接访问，支持5个超链接\n301   Moved Permanently            被请求的页面已经移动到了新的URL下\n302   Found                        被请求的页面暂时性地移动到了新的URL下\n303   See Other                    被请求的页面可以在一个不同的URL下找到\n400   Bad Request                  服务器无法识别请求\n403   Forbidden                    禁止访问所请求的页面\n404   Not Found                    服务器无法找到所请求的页面\n405   Method Not Allowed           请求中所指定的方法不被允许\n500   Internal Server Error        请求不完整，服务器遇见出乎意料的状况\n501   Not Implemented              请求不完整，服务器不提供所需要的功能\n502   Bad Gateway                  请求不完整，服务器中上游服务器接收了一个无效的响应\n503   Service Unavailable          请求不完整，服务器暂时重启 / 关闭\n505   HTTP Version Not Supported   服务器不支持指定的HTTP版本\n\n\n# EL表达式\n\nEL表达式可 讲话对象和变量 快速呈现出来\n\n展示方式\n\n默认展示：${需要展示的信息} 指定展示：${对象.key}\n\n**默认获取顺序 ** 根据以下对象查找key值是否存在，存在则优先获取\n\n 1. pageContext对象 (当前页面)\n 2. request对象 (请求范围)\n 3. session对象 (会话范围)\n 4. application对象 (程序范围)\n\nEL基本操作符\n\n术语      定义\n算术      +、-、*、/、%\n逻辑      and、ro、not、&&、||、!\n关系      ==、eq、!=、ne、gt、<=、le、>=、ge\nEmpty   判断前缀是否为null （应用==empty <域对象>== 返回 布尔值）\n类型      三目运算符\n\n示例：\n\n<%\n    pageContext.setAttribute("number",1);\n    pageContext.setAttribute("name","");\n    request.setAttribute("number",2);\n    session.setAttribute("number",3);\n    application.setAttribute("number",4);\n%>\n<h2>作用域数据获取:</h2>\n<p>直接获取name：${number}</p>\n<p>pageScope域获取name：${pageScope.number}</p>\n<p>requestScope域获取name：${requestScope.number}</p>\n<p>sessionScope域获取name：${sessionScope.number}</p>\n<p>applicationScope域获取name：${applicationScope.number}</p>\n<h2>表达式应用</h2>\n<p>pageContext > session : ${number > sessionScope.number}</p>\n<p>name 是否为空 : ${empty name}</p>\n<p>session、application 获取最大值:${sessionScope.number > applicationScope.number?sessionScope.number:applicationScope.number}</p>\n<%--  浏览器结果\n作用域数据获取:\n    直接获取name：1\n    pageScope域获取name：1\n    requestScope域获取name：2\n    sessionScope域获取name：3\n    applicationScope域获取name：4\n表达式应用\n    pageContext > session : false\n    name 是否为空 : true\n    session、application 获取最大值:4\n--%>\n\n\n\n# JSTL\n\nJSTL是⼀个JSP标签集合，它封装了JSP应用的通用核心功能（条件判断、循环迭代、...）\n\n点击JSTL标签更多说明\n\n\n# JSTL引入\n\n>  1. 引入jar依赖：standard.jar 、 jstl.jar\n>  2. 在JSP文件的页面 引入相应功能范围的标签 <%@ taglib prefix="前缀" uri="功能范围路径" %>\n\n功能范围        URI                                      前缀\ncore        http://java.sun.com/jsp/jstl/core        c\ni18n        http://java.sun.com/jsp/jstl/fmt         fmt\nsql         http://java.sun.com/jsp/jstl/sql         sql\nxml         http://java.sun.com/jsp/jstl/xml         x\nfunctions   http://java.sun.com/jsp/jstl/functions   fn\n\n\n# 核心标签\n\n引入：==<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>==\n\n分类\n\n>  * 表达式操作 out、set、remove、catch\n>  * 流程控制 if、choose、when、otherwise\n>  * 迭代操作 forEach、forTokens\n>  * URL操作 import、param、url、redirect\n\n＜c:set>标签 保存数据\n\n属性         值说明\nvalue      存储的值\nvar        存入的变量名\nscope      指定变量范围\ntarget     对象类型\nproperty   指定target对象的属性值\n\n＜c:out>标签 输出数据\n\n属性          值说明\nvalue       输出的数据\ndefault     无输出则默认代替\nescapeXml   是否忽略XML特殊字符\n\n＜c:remove>标签 删除保存的数据\n\n属性      值说明\nvar     移除的变量名\nScope   var变量的范围\n\n＜c:if>标签 if判断\n\n属性      值说明\ntest    表达式的结果(true/false)\nvar     存储表达式结果的变量名\nscope   var变量的范围\n\n＜c:choose>,＜c:when>,＜c:otherwise>标签 if-else 判断\n\n属性     值说明\ntest   表达式的结果(true/false)\n\n＜c:forEach>标签 循环循环\n\n属性          值说明\nvar         迭代对象\nitems       迭代的集合对象\nvarStatus   迭代对象的相关成员信息\nbegin       开始迭代的位置\nend         结束迭代的位置\nstep        每次迭代的间隔数\n\n\n# 应用实例\n\n<%@ page import="java.util.ArrayList" %>\n<%@ page import="java.util.List" %>\n<%@ page import="java.util.Date" %>\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<%@ taglib prefix="c" uri ="http://java.sun.com/jsp/jstl/core"%>\n<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %>\n<html>\n  <head>\n    <title>$Title$</title>\n  </head>\n  <body>\n  <h1>JSTL 测试</h1>\n\n  <h2>表达式操作 标签</h2>\n  <h3>set存数据</h3>\n  <c:set var="name" value="Sanscan12" scope="session"/>\n  <c:set var="name" value="Sanscan12" scope="application"/>\n  <h3>out显示数据</h3>\n  sessionScope-name = <c:out value="${sessionScope.name}"/> <br>\n  <%--sessionScope-name = Sanscan12--%>\n  name = <c:out value="null" default="Error"/> <br>\n  <%--name = null--%>\n  <h3>remove移除数据</h3>\n  移除 application-name数据！<c:remove var="name" scope="application"/> <br>\n  <%--移除 application-name数据！--%>\n  applicationScope-name = <c:out value="${applicationScope.name}" default="Error"/> <br>\n  <%--applicationScope-name = Error--%>\n  sessionScope-name = <c:out value="${sessionScope.name}" default="Error"/> <br>\n  <%--sessionScope-name = Sanscan12--%>\n\n  <h2>流程控制 标签</h2>\n  <h3>if判断</h3>\n  Sans 是本人？<c:if test="${name==\'Sans\'}" var="result" />\n  <c:out value="${result}"/><br>\n  <%--Sans 是本人？ false--%>\n  Sanscan12 是本人？<c:if test="${name==\'Sanscan12\'}" >true</c:if> <br>\n  <%--Sanscan12 是本人？true--%>\n  <h3>if-else判断</h3>\n  Sanscan12 是本人？\n  <c:choose>\n    <c:when test="${name==\'Sanscan12\'}">\n      Yes\n    </c:when>\n    <c:otherwise>\n      No\n    </c:otherwise>\n  </c:choose>\n<%-- Sanscan12 是本人？ Yes --%>\n  <h3>forEach循环</h3>\n  <%\n    List list = new ArrayList();\n    list.add("123");\n    list.add("456");\n    list.add("789");\n    pageContext.setAttribute("ulist",list);\n  %>\n  <c:forEach var="name" items="${ulist}" varStatus="sta">\n<%--  个数-索引-值   --%>\n    ${sta.count} --\x3e ${sta.index} --\x3e ${name} <br>\n  </c:forEach>\n<%--\n1 --\x3e 0 --\x3e 123\n2 --\x3e 1 --\x3e 456\n3 --\x3e 2 --\x3e 789\n--%>\n    <c:forEach var="i" begin="1" end="10" step="1">\n    \t${i}\n\t</c:forEach>\n  \n  <h2>格式化 标签</h2>\n  <h3>日期格式化 --\x3e 字符串</h3>\n  <%pageContext.setAttribute("nowDate",new Date());%>\n  nowDate：<fmt:formatDate value="${nowDate}"/> <br>\n  <%--2021年4月17日--%>\n  YYYYMMdd-nowDate：<fmt:formatDate value="${nowDate}" pattern="YYYY-MM-dd"/> <br>\n  <%--2021-04-17--%>\n  date-nowDate：<fmt:formatDate value="${nowDate}" type="date"/> <br>\n  <%--2021年4月17日--%>\n  time-nowTime：<fmt:formatDate value="${nowDate}" type="time"/> <br>\n  <%--上午10:38:38--%>\n  both-now：<fmt:formatDate value="${nowDate}" type="both"/> <br>\n  <%--2021年4月17日 上午10:38:38--%>\n  <%--<h3>字符串格式化 --\x3e 日期</h3>--%>\n  <%--Format：<fmt:parseDate value="${nowDate}" var="test"/> <br>--%>\n  <%--YYYY：<fmt:parseDate value="${nowDate}" var="forDate2" pattern="YYYY"/> <br>--%>\n  <h3>数字格式化</h3>\n  type-currency-value(3.14): <fmt:formatNumber value="3.14" type="currency"/> <br>\n  <%--￥3.14--%>\n  type-percent-value(3.14): <fmt:formatNumber value="3.14" type="percent"/> <br>\n  <%--314%--%>\n  maxIntegerDigits(4)-value(314159.26): <fmt:formatNumber value="314159.26" maxIntegerDigits="4"/> <br>\n  <%--4,159.26--%>\n  maxFractionDigits(2)-value(3.14159): <fmt:formatNumber value="3.14159" maxFractionDigits="2"/> <br>\n  <%--3.14--%>\n  maxFractionDigits(2)-value(3.14559): <fmt:formatNumber value="3.14559" maxFractionDigits="2"/> <br>\n  <%--3.15--%>\n  pattern(0.###E0)-value(0.31415926535897): <fmt:formatNumber value="0.31415926535897" pattern="0.###E0"/> <br>\n  <%--3.142E-1--%>\n  pattern(00.###E0)-value(0.31415926535897): <fmt:formatNumber value="0.31415926535897" pattern="00.###E0"/> <br>\n  <%--31.416E-2--%>\n  pattern(0.###E0)-value(31415926535897): <fmt:formatNumber value="31415926535897" pattern="0.###E0"/> <br>\n  <%--3.142E13--%>\n  </body>\n</html>\n',normalizedContent:'# jsp\n\njsp是 servlet设计的简化版，可在html页面添加 java语言的脚本。jsp开发的web应用可跨平台，也能在其他系统运行\n\n> *.html 静态页面\n> \n> *.jsp 动态页面（嵌套java和html代码）\n\n\n# jsp 引入\n\n声明标签 <%! 变量/方法 的声明%>\n\n表达式 <%= 表达式%>\n\n执行标签 <%java代码%>\n\n\n# jsp 原理\n\n\n\n当浏览器访问服务器时。地址后缀为 .jsp ，会先找 index.jsp ，找到随后进行翻译成 index_jsp.java 并对其进行编译，产生一个 index_jsp.class 进行加载运行\n\n\n# jsp 内置对象\n\n\n# request对象\n\nrequest 对象是 javax.servlet.httpservletrequest 类型的对象 该对象代表了客户端的请求信息，主要⽤于接受http协议传送到服务器的数据 作用域：一次请求\n\n点击详细说明httpservletrequest\n\n\n# response对象\n\nresponse 对象是 javax.servlet.httpservletresponse 类型的对象 response 代表的是对客户端的响应，主要是将jsp容器处理过的对象传回到客户端 作用域：本页面\n\n点击详细说明httpservletresponse\n\n\n# session对象\n\nsession 对象是由服务器自动创建的与用户请求相关的对象，每个会话都有对应的会话id，用于保存信息，以及跟踪用户的操作状态 作用域：本次会话\n\n点击详细说明httpsession\n\n\n# application对象\n\napplication对象 可将信息保存在服务器，直至服务器关闭（类似于全局变量） 作用域：服务器运行\n\n点击详细说明servletcontext\n\n\n# out对象\n\nout对象 可在web浏览器内输出信息，管理应用服务器上的输出缓冲区（输出完及时不关闭流）\n\n点击详细说明servletoutputstream\n\n\n# pagecontext对象\n\npagecontext对象 用于获取任何范围的参数\n\n更多方法说明servletcontext\n\n\n# config对象\n\nconfig对象 用于获取服务器的配置信息 使用前提需要 pageconext对象 的 getservletconfig() 方法 获取 config对象\n\n更多方法说明servletconfig\n\n\n# page对象\n\npage对象 代表jsp本身（类似于java语言 的 this）\n\n\n# exception对象\n\nexception对象 用于显示异常信息 在jsp页面 page指令 添加 iserrorpage = "true" 属性 和 errorpage="xxx.jsp"页面才生效 如果页面异常则会生成 exception对象 并把 page指令 设定在错误页面中进行处理\n\n更多方法说明servletexception\n\n\n# jsp 指令\n\njsp指令 控制jsp编译器如何去生成servlet\n\npage指令 定义网页依赖（脚本、异常、缓冲、...） <%@ page language="java" import="java.util.*" pageencoding="utf-8"%>\n\n属性             值            说明\nlanguage       java、...     解释jsp文件使用的语言\nextends        任何类的全名       编译时继承哪个类\nimport         任何类的全名       引入类、包等...\nsession        true、false   设置jsp文件是否内置session对象 (默认true)\nautoflush      true、false   是否运行缓存 (默认true)\nbuffer         none、 指定kb   指定缓存大小 (默认none)\ncontenttype    文档类型         规定了生成内容的类型。当生成非html内容或者当前字符集并非默认字符集时使用\nerrorpage      相对路径         指定 页面异常时转送的页面\niserrorpage    true、false   指定页面是否显示错误提示页面 (默认false)\nisthreadsafe   true、false   最终生成的servlet是否具有线程安全性 (默认false)\npageencoding   utf-8、...    指定 编码类型\n\n**include指令** jsp可以通过include指令来包含其他文件 并且同时编译运行<%@ include file="相对url地址" %>`\n\ntaglib指令 jsp允许自定义标签库，引入库、标签等... <%@ taglib uri="标签库路径" prefix="指定标签库前缀" %>\n\n\n# 状态码\n\n状态码   消息                           说明\n100   continue                     部分请求接收，但未被拒绝，客户端延长请求\n101   switching protocols          服务器交换机协议\n200   ok                           请求被确认\n201   created                      请求时完整的，新的资源被创建\n202   accepted                     请求被接收，但未处理完\n300   multiple choices             一个超链接表，用户可以选择超链接访问，支持5个超链接\n301   moved permanently            被请求的页面已经移动到了新的url下\n302   found                        被请求的页面暂时性地移动到了新的url下\n303   see other                    被请求的页面可以在一个不同的url下找到\n400   bad request                  服务器无法识别请求\n403   forbidden                    禁止访问所请求的页面\n404   not found                    服务器无法找到所请求的页面\n405   method not allowed           请求中所指定的方法不被允许\n500   internal server error        请求不完整，服务器遇见出乎意料的状况\n501   not implemented              请求不完整，服务器不提供所需要的功能\n502   bad gateway                  请求不完整，服务器中上游服务器接收了一个无效的响应\n503   service unavailable          请求不完整，服务器暂时重启 / 关闭\n505   http version not supported   服务器不支持指定的http版本\n\n\n# el表达式\n\nel表达式可 讲话对象和变量 快速呈现出来\n\n展示方式\n\n默认展示：${需要展示的信息} 指定展示：${对象.key}\n\n**默认获取顺序 ** 根据以下对象查找key值是否存在，存在则优先获取\n\n 1. pagecontext对象 (当前页面)\n 2. request对象 (请求范围)\n 3. session对象 (会话范围)\n 4. application对象 (程序范围)\n\nel基本操作符\n\n术语      定义\n算术      +、-、*、/、%\n逻辑      and、ro、not、&&、||、!\n关系      ==、eq、!=、ne、gt、<=、le、>=、ge\nempty   判断前缀是否为null （应用==empty <域对象>== 返回 布尔值）\n类型      三目运算符\n\n示例：\n\n<%\n    pagecontext.setattribute("number",1);\n    pagecontext.setattribute("name","");\n    request.setattribute("number",2);\n    session.setattribute("number",3);\n    application.setattribute("number",4);\n%>\n<h2>作用域数据获取:</h2>\n<p>直接获取name：${number}</p>\n<p>pagescope域获取name：${pagescope.number}</p>\n<p>requestscope域获取name：${requestscope.number}</p>\n<p>sessionscope域获取name：${sessionscope.number}</p>\n<p>applicationscope域获取name：${applicationscope.number}</p>\n<h2>表达式应用</h2>\n<p>pagecontext > session : ${number > sessionscope.number}</p>\n<p>name 是否为空 : ${empty name}</p>\n<p>session、application 获取最大值:${sessionscope.number > applicationscope.number?sessionscope.number:applicationscope.number}</p>\n<%--  浏览器结果\n作用域数据获取:\n    直接获取name：1\n    pagescope域获取name：1\n    requestscope域获取name：2\n    sessionscope域获取name：3\n    applicationscope域获取name：4\n表达式应用\n    pagecontext > session : false\n    name 是否为空 : true\n    session、application 获取最大值:4\n--%>\n\n\n\n# jstl\n\njstl是⼀个jsp标签集合，它封装了jsp应用的通用核心功能（条件判断、循环迭代、...）\n\n点击jstl标签更多说明\n\n\n# jstl引入\n\n>  1. 引入jar依赖：standard.jar 、 jstl.jar\n>  2. 在jsp文件的页面 引入相应功能范围的标签 <%@ taglib prefix="前缀" uri="功能范围路径" %>\n\n功能范围        uri                                      前缀\ncore        http://java.sun.com/jsp/jstl/core        c\ni18n        http://java.sun.com/jsp/jstl/fmt         fmt\nsql         http://java.sun.com/jsp/jstl/sql         sql\nxml         http://java.sun.com/jsp/jstl/xml         x\nfunctions   http://java.sun.com/jsp/jstl/functions   fn\n\n\n# 核心标签\n\n引入：==<%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %>==\n\n分类\n\n>  * 表达式操作 out、set、remove、catch\n>  * 流程控制 if、choose、when、otherwise\n>  * 迭代操作 foreach、fortokens\n>  * url操作 import、param、url、redirect\n\n＜c:set>标签 保存数据\n\n属性         值说明\nvalue      存储的值\nvar        存入的变量名\nscope      指定变量范围\ntarget     对象类型\nproperty   指定target对象的属性值\n\n＜c:out>标签 输出数据\n\n属性          值说明\nvalue       输出的数据\ndefault     无输出则默认代替\nescapexml   是否忽略xml特殊字符\n\n＜c:remove>标签 删除保存的数据\n\n属性      值说明\nvar     移除的变量名\nscope   var变量的范围\n\n＜c:if>标签 if判断\n\n属性      值说明\ntest    表达式的结果(true/false)\nvar     存储表达式结果的变量名\nscope   var变量的范围\n\n＜c:choose>,＜c:when>,＜c:otherwise>标签 if-else 判断\n\n属性     值说明\ntest   表达式的结果(true/false)\n\n＜c:foreach>标签 循环循环\n\n属性          值说明\nvar         迭代对象\nitems       迭代的集合对象\nvarstatus   迭代对象的相关成员信息\nbegin       开始迭代的位置\nend         结束迭代的位置\nstep        每次迭代的间隔数\n\n\n# 应用实例\n\n<%@ page import="java.util.arraylist" %>\n<%@ page import="java.util.list" %>\n<%@ page import="java.util.date" %>\n<%@ page contenttype="text/html;charset=utf-8" language="java" %>\n<%@ taglib prefix="c" uri ="http://java.sun.com/jsp/jstl/core"%>\n<%@ taglib prefix="fmt" uri="http://java.sun.com/jsp/jstl/fmt" %>\n<html>\n  <head>\n    <title>$title$</title>\n  </head>\n  <body>\n  <h1>jstl 测试</h1>\n\n  <h2>表达式操作 标签</h2>\n  <h3>set存数据</h3>\n  <c:set var="name" value="sanscan12" scope="session"/>\n  <c:set var="name" value="sanscan12" scope="application"/>\n  <h3>out显示数据</h3>\n  sessionscope-name = <c:out value="${sessionscope.name}"/> <br>\n  <%--sessionscope-name = sanscan12--%>\n  name = <c:out value="null" default="error"/> <br>\n  <%--name = null--%>\n  <h3>remove移除数据</h3>\n  移除 application-name数据！<c:remove var="name" scope="application"/> <br>\n  <%--移除 application-name数据！--%>\n  applicationscope-name = <c:out value="${applicationscope.name}" default="error"/> <br>\n  <%--applicationscope-name = error--%>\n  sessionscope-name = <c:out value="${sessionscope.name}" default="error"/> <br>\n  <%--sessionscope-name = sanscan12--%>\n\n  <h2>流程控制 标签</h2>\n  <h3>if判断</h3>\n  sans 是本人？<c:if test="${name==\'sans\'}" var="result" />\n  <c:out value="${result}"/><br>\n  <%--sans 是本人？ false--%>\n  sanscan12 是本人？<c:if test="${name==\'sanscan12\'}" >true</c:if> <br>\n  <%--sanscan12 是本人？true--%>\n  <h3>if-else判断</h3>\n  sanscan12 是本人？\n  <c:choose>\n    <c:when test="${name==\'sanscan12\'}">\n      yes\n    </c:when>\n    <c:otherwise>\n      no\n    </c:otherwise>\n  </c:choose>\n<%-- sanscan12 是本人？ yes --%>\n  <h3>foreach循环</h3>\n  <%\n    list list = new arraylist();\n    list.add("123");\n    list.add("456");\n    list.add("789");\n    pagecontext.setattribute("ulist",list);\n  %>\n  <c:foreach var="name" items="${ulist}" varstatus="sta">\n<%--  个数-索引-值   --%>\n    ${sta.count} --\x3e ${sta.index} --\x3e ${name} <br>\n  </c:foreach>\n<%--\n1 --\x3e 0 --\x3e 123\n2 --\x3e 1 --\x3e 456\n3 --\x3e 2 --\x3e 789\n--%>\n    <c:foreach var="i" begin="1" end="10" step="1">\n    \t${i}\n\t</c:foreach>\n  \n  <h2>格式化 标签</h2>\n  <h3>日期格式化 --\x3e 字符串</h3>\n  <%pagecontext.setattribute("nowdate",new date());%>\n  nowdate：<fmt:formatdate value="${nowdate}"/> <br>\n  <%--2021年4月17日--%>\n  yyyymmdd-nowdate：<fmt:formatdate value="${nowdate}" pattern="yyyy-mm-dd"/> <br>\n  <%--2021-04-17--%>\n  date-nowdate：<fmt:formatdate value="${nowdate}" type="date"/> <br>\n  <%--2021年4月17日--%>\n  time-nowtime：<fmt:formatdate value="${nowdate}" type="time"/> <br>\n  <%--上午10:38:38--%>\n  both-now：<fmt:formatdate value="${nowdate}" type="both"/> <br>\n  <%--2021年4月17日 上午10:38:38--%>\n  <%--<h3>字符串格式化 --\x3e 日期</h3>--%>\n  <%--format：<fmt:parsedate value="${nowdate}" var="test"/> <br>--%>\n  <%--yyyy：<fmt:parsedate value="${nowdate}" var="fordate2" pattern="yyyy"/> <br>--%>\n  <h3>数字格式化</h3>\n  type-currency-value(3.14): <fmt:formatnumber value="3.14" type="currency"/> <br>\n  <%--￥3.14--%>\n  type-percent-value(3.14): <fmt:formatnumber value="3.14" type="percent"/> <br>\n  <%--314%--%>\n  maxintegerdigits(4)-value(314159.26): <fmt:formatnumber value="314159.26" maxintegerdigits="4"/> <br>\n  <%--4,159.26--%>\n  maxfractiondigits(2)-value(3.14159): <fmt:formatnumber value="3.14159" maxfractiondigits="2"/> <br>\n  <%--3.14--%>\n  maxfractiondigits(2)-value(3.14559): <fmt:formatnumber value="3.14559" maxfractiondigits="2"/> <br>\n  <%--3.15--%>\n  pattern(0.###e0)-value(0.31415926535897): <fmt:formatnumber value="0.31415926535897" pattern="0.###e0"/> <br>\n  <%--3.142e-1--%>\n  pattern(00.###e0)-value(0.31415926535897): <fmt:formatnumber value="0.31415926535897" pattern="00.###e0"/> <br>\n  <%--31.416e-2--%>\n  pattern(0.###e0)-value(31415926535897): <fmt:formatnumber value="31415926535897" pattern="0.###e0"/> <br>\n  <%--3.142e13--%>\n  </body>\n</html>\n',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"JavaWeb Servlet",frontmatter:{title:"JavaWeb Servlet",author:"柏竹",permalink:"/backend/qls54u",date:"2020-02-18T00:00:00.000Z",categories:["后端","JavaWeb"],tags:["Jsp","servlet"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/02.JavaWeb/02.servlet%E5%BA%94%E7%94%A8.html",relativePath:"01.后端/02.JavaWeb/02.servlet应用.md",key:"v-b93f4c84",path:"/backend/qls54u/",headers:[{level:2,title:"Servlet API",slug:"servlet-api",normalizedTitle:"servlet api",charIndex:193},{level:3,title:"Servlet",slug:"servlet-2",normalizedTitle:"servlet",charIndex:2},{level:3,title:"GenericServlet",slug:"genericservlet",normalizedTitle:"genericservlet",charIndex:591},{level:3,title:"HttpServlet",slug:"httpservlet",normalizedTitle:"httpservlet",charIndex:930},{level:3,title:"ServletContext",slug:"servletcontext",normalizedTitle:"servletcontext",charIndex:871},{level:2,title:"Servlet 应用",slug:"servlet-应用",normalizedTitle:"servlet 应用",charIndex:1648},{level:2,title:"Servlet 工作原理",slug:"servlet-工作原理",normalizedTitle:"servlet 工作原理",charIndex:3704},{level:2,title:"Servlet 生命周期",slug:"servlet-生命周期",normalizedTitle:"servlet 生命周期",charIndex:3928},{level:2,title:"Request 请求",slug:"request-请求",normalizedTitle:"request 请求",charIndex:4340},{level:2,title:"Response 响应",slug:"response-响应",normalizedTitle:"response 响应",charIndex:8393},{level:3,title:"响应图片",slug:"响应图片",normalizedTitle:"响应图片",charIndex:8947},{level:2,title:"Session 会话",slug:"session-会话",normalizedTitle:"session 会话",charIndex:10558},{level:2,title:"Servlet 初始化参数",slug:"servlet-初始化参数",normalizedTitle:"servlet 初始化参数",charIndex:11739},{level:2,title:"Servlet 注解",slug:"servlet-注解",normalizedTitle:"servlet 注解",charIndex:13003},{level:2,title:"Servlet 下载",slug:"servlet-下载",normalizedTitle:"servlet 下载",charIndex:14060}],headersStr:"Servlet API Servlet GenericServlet HttpServlet ServletContext Servlet 应用 Servlet 工作原理 Servlet 生命周期 Request 请求 Response 响应 响应图片 Session 会话 Servlet 初始化参数 Servlet 注解 Servlet 下载",content:'# Servlet\n\nServlet是在Web服务器运行的Java程序，主要负责与客户端数据交互，生成动态的Web内容。通常 通过HTTP 进行 接收 和 响应 来自客户端的请求！\n\n工作步骤：\n\n 1. 服务器 启动Servlet\n 2. 客户端 发送请求 至 服务器\n 3. 服务器 调用Servlet，根据 客户端 请求内容 传给服务器\n 4. 服务器 响应返回 客户端\n\n\n# Servlet API\n\n点击查看文档\n\n\n# Servlet\n\n> implements Servlet javax.servlet\n\n用于 接收请求 与 响应请求 ，服务器必须实现的方法\n\n返回              抽象方法                     说明\nvoid            ==init()==               构造服务器\nvoid            ==service()==            服务器 响应请求\nvoid            ==destroy()==            移出 服务器 视为垃圾\nServletConfig   ==getServletConfig()==   获取 服务器对象\nString          ==getServletInfo()==     获取 有关服务器的信息\n\n\n# GenericServlet\n\n> class abstract GenericServlet javax.servlet\n\nGenericServlet类 实现 Servlet接口 用于Web的 HTTP Servlet 服务项\n\n返回               方法                            说明\nEnumeration      ==getInitParameterNames()==   获取 指定参数名的对象\nEnumeration      ==getServletName()==          获取 服务名\nServletContext   ==getServletContext()==       获取 全局对象\n\n\n# HttpServlet\n\n> class abstract HttpServlet javax.servlet.http\n\nHttpServlet 继承 GenericServlet类 处理 http请求数据\n\n返回     方法             说明\nvoid   ==doGet()==    处理GET请求\nvoid   ==doPost()==   处理POST请求\nvoid   ==doPut()==    处理PUT请求\n···    ...            ...（更多自查文档）\n\n\n# ServletContext\n\n> implements ServletContext\n> \n> javax.servlet Interface ServletContext\n\n点击对象方法\n\n用于与其他 servlet容器 通信的方法\n\n获取方式在请求的方法体里\n\n * ==this.getServletContext()==\n * ==HttpServletRequest.getServletContext()==\n\n存取值常用方法\n\n返回       方法                                      说明\nvoid     setAttribute(String key,Object value)   向上下域 存键值\nObject   getAttribute(String key)                从上下域 取指定键的值\nvoid     removeAttribute(String key)             删除上下文 指定键的值\n\n\n# Servlet 应用\n\n 1. 在 web 创建 index.html ，模拟客户端请求发送\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>!!!</title>\n</head>\n<body>\n    <h1>No.1 Servlet应用</h1>\n    <a href="test">get请求测试</a>\n    <form action="test" method="post">\n        <input type="submit" value="post-test">\n    </form>\n</body>\n</html>\n\n\n 2. 创建实现Servlet类，继承 HttpServlet类\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class LoginServlet extends HttpServlet {\n    \n    /*\n    * HttpServletRequest：请求对象\n    * HttpServletResponse：响应对象\n    * */\n    \n    //处理 get 请求\n    @Override\n    protected void doGet(HttpServletRequest req , HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println("get-------");\n        System.out.println("req : " + req);\n        System.out.println("resp : " + resp);\n    }\n    \n    //处理 post 请求\n    @Override\n    protected void doPost(HttpServletRequest req , HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println("post-------");\n        System.out.println("req : " + req);\n        System.out.println("resp : " + resp);\n    }\n    \n}\n\n\n 3. 在 ../web/WEB-INF/web.xml 文档配置映射关系 在 <web-app> 添加映射关系\n\n<servlet>\n    \x3c!-- ⾃定义名称 --\x3e\n    <servlet-name>No1</servlet-name>\n    \x3c!-- \n\t处理请求的类的完整路径\n\tLoginServlet类在src根路径里\n\t --\x3e\n    <servlet-class>LoginServlet</servlet-class>\n</servlet>\n\x3c!-- mapping 表示映射 --\x3e\n<servlet-mapping>\n    \x3c!-- ⾃定义名称 --\x3e\n    <servlet-name>No1</servlet-name>\n    \x3c!-- 请求名 --\x3e\n    <url-pattern>/test</url-pattern>\n</servlet-mapping>\n\n\n> 标签执行顺序：\n> \n>  1. 客户端 请求\n>  2. 进入 web.xml 匹配数据\n>  3. <servlet-mapping> 里的 <url-pattern> 标签 内容 与 请求名 进行匹配\n>  4. 匹配成功后 进行以下匹配 （映射标签） <servlet-mapping> 里的 <servlet-name> 标签 内容 与 <servlet> 里的 <servlet-name> 标签 内容\n>  5. 匹配成功后 进行以下匹配 （处理类路径） <servlet> 里的 <servlet-class> 标签 内容 与 src内的路径匹配\n\n 4. 启动，打开 地址： （以下两个测试） http://localhost:8080/工程名/访问服务器的路径 http://localhost:8080\n\n\n# Servlet 工作原理\n\n 1. Servlet容器 将Servlet类载入内存 ， 实例调用它具体方法。一个Web应用一个Servlet\n 2. 调用Servlet的Service()方法 ServletRequest对象 (请求对象) 和 ServletResponse对象 (响应对象) 都是由 Servlet容器 封装好的，直接调用即可\n 3. 每个Servlet都有一个封装Servlet配置的 ServletConfig对象\n\n\n# Servlet 生命周期\n\n\n\n 1. 实例化（使用构造方法创建对象）\n 2. 初始化 init()方法\n 3. 服务 service()方法\n 4. 销毁 destroy()方法\n\ninit方法 将会主要完成以下工作：\n\n 1. 创建用于解析 xml 配置文件的 contextDigester 对象\n 2. 读取默认 context.xml 配置文件，如果存在解析它\n 3. 读取默认 Host 配置文件，如果存在解析它\n 4. 读取默认 Context 自身的配置文件，如果存在解析它\n 5. 设置 Context 的 DocBase\n\n注意：\n\n 1. 当客户端发送请求，如果 存在servlet对象无需创建，否则新建servlet对象\n 2. 第二次请求时，会判断对象是否存在，但不会执执行init()方法，而直接执行service()方法\n 3. 相应的请求方式，会对应 service方法里的处理方式\n\n\n# Request 请求\n\nHttpServletRequest表示Http环境中的Servlet请求。（扩展了ServletRequest接口）\n\n点击更多Servlet请求方法\n\n返回                  常用方法                                          说明\nString              ==getParameter(String name)==                 获取 表单指定名称 组件的值\nString[]            ==getParameterValues(String name)==           获取 表单指定名称 组件的多个值\nvoid                ==setCharacterEncoding(String env)==          设置 请求的编码类型（针对Post请求）\nRequestDispatcher   ==getRequestDispatcher(String url)==          跳转 指定页面路径\nvoid                ==setAttribute(String key , String value)==   存储请求属性\nObject              ==getAttribute(String key)==                  获取 指定属性的返回值\nString              ==getRequestURI()==                           获取 url\n\n请求方式：\n\n>  * 通过表单 get/post 提交\n> \n>  * 通过 a标签 发送数据\n>    \n>    <a href="提交名?key1=value&key2=vlaue..">提交</a>\n>    <a href="/test?name=sans&age=12">提交</a>\n>    \n> \n>  * 通过地址栏直接拼接-get请求\n> \n>  * js提交数据-get请求\n\n乱码处理：\n\n>  * post请求转编码 setCharacterEncoding("UTF-8");\n> \n>  * get请求 转编码 （方法1）\n>    \n>    //针对于get提交时中⽂乱码\n>    String s=new String(变量名.getBytes("ISO-8859-1"),"UTF-8");\n>    String s=new String(request.getParameter("key").getBytes("ISO-8859-1"),"GBK");\n>    \n> \n>  * get请求 转编码 （方法2） 在Tomcat目录 /conf/server.xml 设置字符集\n>    \n>    <Connector port="8080" protocol="HTTP/1.1" \n>     connectionTimeout="20000"\n>     redirectPort="8443" URIEncoding="UTF-8" />\n>    \n\nget和post区别：\n\n> get请求： 该请求会附加在URL之后，从 ? 开始以 & 分割变量和属性。url采用的是ASCLL编码。\n> \n> post请求： 该请求数据置放在HTTP请求包的包体中进行传输数据。\n> \n> 数据传输大小 get会受到url的长度限制，而post不会\n> \n> 安全性 提交/进入 时，get会在url后面显示，而post不会\n\n实例：\n\nhtml页面\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>!!!</title>\n</head>\n<body>\n    <a href="requestTest?click=true&summary=用户点击了超链接">超链接测试</a>\n    <form action="requestTest" method="post">\n        uname:<input type="text" name="username"><br>\n        upassword:<input type="password" name="userpassword"><br>\n        sex:\n        <input type="radio" name="sex" value="man">男\n        <input type="radio" name="sex" value="woman">女\n        <br>\n        hobby:\n        <input type="checkbox" name="hobby" value="basketball">篮球\n        <input type="checkbox" name="hobby" value="football">足球\n        <input type="checkbox" name="hobby" value="tennis">网球\n        <br>\n        <input type="submit">\n    </form>\n</body>\n</html>\n\n\nJava获取\n\nimport javax.servlet.ServletException;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\npublic class MyRequestTest extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req , HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println("Get=========");\n        System.out.println("超链接点击了？"+req.getParameter("click"));\n        System.out.println("摘要："+req.getParameter("summary"));\n    }\n    \n    @Override\n    protected void doPost(HttpServletRequest req , HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println("Post=========");\n        //解决乱码\n        req.setCharacterEncoding("utf-8");\n        \n        String name = req.getParameter("username");\n        String password = req.getParameter("userpassword");\n        String sex = req.getParameter("sex");\n        String[] hobbys = req.getParameterValues("hobby");\n\n        System.out.println("UserName："+name);\n        System.out.println("UserPassword："+ password);\n        System.out.println("sex："+ sex);\n        if (hobbys != null || hobbys.length != 0){\n            System.out.println("hobby：");\n            for (String tmp : hobbys) {\n                System.out.println(tmp);\n            }\n        }\n        \n        //存值\n        req.setAttribute("username",name);\n        req.setAttribute("userpassword",password);\n        \n        //取值\n        System.out.println("取值测试：");\n        System.out.println(req.getAttribute("username"));\n        \n        //跳转页面 (提交跳转的页面 在web文件夹下subTest.html)\n        req.getRequestDispatcher("/subTest.html").forward(req,resp);\n    }\n}\n\n\n\n# Response 响应\n\nHttpServletResponse 表示 Servlet响应，继承了ServletResponse接口，专门用来封装HTTP响应消息。\n\n点击更多Servlet响应方法\n\n返回            常用方法                                说明\nvoid          ==addCookie(Cookie cookie)==        指定 cookie添加到响应中\nvoid          ==sendRedirect(String location)==   指定 重定向URL位置（页面跳转）\nPrintWriter   ==getWriter()==                     获取 可以给前端输出的字符流对象\nvoid          ==setContentType(String type)==     设置 响应的内容类型\n\n重定向与转发的区别\n\n>  * 重定向 会改变地址，requset存储的数据会丢失 转发 时地址会显示请求页面的地址，保存了页面的数据\n>  * 重定向 两次请求 两次响应；转发 一次请求 一次响应\n>  * js 跳转页面，也会丢失 requset存储的数据\n\n\n\n\n# 响应图片\n\n以流的形式响应图片\n\n实现方案：\n\n 1. 使用FileChannel的方法\n 2. 使用普通的io，fileinputstream->byte[]->response.outputstream\n 3. 使用ImageIO的read和write方法实现\n\n// 方式1\n@Override\nprotected void doGet(HttpServletRequest req , HttpServletResponse resp) throws ServletException, IOException {\n    File file = new File("C:\\\\Users\\\\admin\\\\Desktop\\\\ceshi.jpg");\n    try (FileInputStream fis = new FileInputStream(file)) {\n        response.setContentType("image/png");\n        fis.getChannel().\n            transferTo(0,fis.available(),Channels.newChannel(response.getOutputStream()));\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}\n\n// 方式2\n@Override\nprotected void doGet(HttpServletRequest req , HttpServletResponse resp) throws ServletException, IOException {\n    File file = new File("C:\\\\Users\\\\admin\\\\Desktop\\\\ceshi.jpg");\n    try(FileInputStream fis = new FileInputStream(file)) {\n        response.setContentType("image/png");\n        byte[] bytes = new byte[fis.available()];\n        fis.read(bytes);\n        response.getOutputStream().write(bytes);\n    }catch (Exception e){\n        e.printStackTrace();\n    }\n}\n\n// 方式3\n@Override\nprotected void doGet(HttpServletRequest req , HttpServletResponse resp) throws ServletException, IOException {\n    File file = new File("C:\\\\Users\\\\admin\\\\Desktop\\\\ceshi.jpg");\n    try {\n        BufferedImage image = ImageIO.read(file);\n        response.setContentType("image/png");\n        OutputStream os = response.getOutputStream();\n        ImageIO.write(image, "png", os);\n        os.flush();\n        os.close();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n\n\n\n# Session 会话\n\nsession是服务器端使用的一种记录客户端状态的机制。（是ServletRequest的扩展） sessinon可有多个页面、多个request(请求)，重定向也不会丢失数据。 当浏览器访问Web服务器时，Servlet容器就会创建一个Session对象和ID属性，当客户端后续访问服务器时，只要将ID标识号传递给服务器，服务器就能判断该请求是哪个客户端发送的，从而选择与之对应的Session对象为其服务。\n\n更多ServletRequest方法 更多HttpServletRequest方法 更多HttpSession方法\n\n返回            常用方法                                          说明\nHttpSession   ==getSession()==                              获取 请求的Session对象\nvoid          ==setAttribute(String key , Object value)==   以key/value存储属性值\nObject        ==getAttribute(String key)==                  获取 指定key的属性值，没有则null\nvoid          ==invalidate()==                              设置 session 无效，取消任何会话的对象\nString        ==getid()==                                   获取 当前 会话ID标识号\nvoid          ==setMaxInactiveInterval(int interval)==      设置 会话有效时长 ，超出时长则无效会话(单位：秒)\nvoid          ==removeAttribute(String key)==               从此会话 删除 指定key的值(置为null)\n\n会话有效时长：\n\n>  1. setMaxInactiveInterval(int second) //指定秒数有效\n> \n>  2. 编辑 web.xml\n>     \n>     <session-config>\n>      \t<session-timeout>10</session-timeout>//单位:分钟\n>      </session-config> \n>     \n\nsession失效方式：\n\n>  1. invalidate()\n>  2. removeAttribute("key");\n>  3. 直接关闭浏览器\n\n\n# Servlet 初始化参数\n\n在 web.xml 中配置 Servlet 时，可以配置初始化参数 Servlet可通过 ServletConfig接口 提供的方法来获取这些参数\n\nservlet局部参数配置\n\n在 web.xml 中对应的 servlet 添加 init-param属性（获取参数仅限于配置的servlet）\n\n<init-param>\n       <param-name>key</param-name>\n       <param-value>value</param-value>\n</init-param>\n\n\nservlet全局部参数配置\n\n在 web.xml 中添加 context-param属性 （全部servlet都可获取）\n\n<context-param>\n        <param-name>key</param-name>\n        <param-value>value</param-value>\n </context-param>\n\n\n获取数据\n\n 1. 请求 -> init() -> ... servlet中 重写init()方法，通过以下代码获取 （全局和局部获取方式不一样）\n    \n    @Override\n    public void init(ServletConfig config) throws ServletException {\n        //匹配指定name 获取 对应的值\n        //局部\n        String vlaue = config.getInitParameter("key") );\n        //全局\n        String vlaue2 = config.getServletContext().getInitParameter("allKey") );\n    }\n    \n\n 2. 请求 -> init() -> servlet() -> doGet()/doPost() -> ...\n    \n    //超链接响应获取\n    @Override\n    protected void doGet(HttpServletRequest req , HttpServletResponse resp) throws ServletException, IOException {\n        //局部\n        String vlaue = this.getInitParameter("key");\n        //全局\n        String vlaue2 = this.getInitParameter("allKey");\n        String vlaue3 = this.getServletContext().getInitParameter("allKey");\n    }\n    \n\n注意： 不同的获取方式不能共存！！！\n\n\n# Servlet 注解\n\n注解 提供的信息，让开发更便捷易懂\n\n属性                  类型               必须   说明\nasyncSupported      boolean          F    Servlet是否支持异步操作\ndisplayName         String           F    Servlet显示名称\ninitParams          webInitParam[]   F    配置初始化参数\nloadOnStartup       int              F    Servlet 的优先级 加载(越小越早)\nname                String           F    指定Servlet名称\nurlPatterns/value   String[]         T    两个属性作用相同，指定处理的url\n\nurlPatterns匹配说明\n\n> 完全匹配 /test/userList.action 匹配绝对路径的请求\n> \n> 路径匹配 /test/* 匹配test路径下的所有请求\n> \n> 扩展名匹配 *.action 匹配后缀为action 结尾的请求\n\n注意：\n\n>  * 如果当前Servlet注解了就无需再配置 web.xml\n>  * name若不指定值，则默认以类名为name\n>  * urlPatterns路径分割不需有斜杠 /\n>  * urlPatterns可映射多个路径\n\n@WebServlet(\n        name = "No.6",\n        //完全路径；全局路径匹配；扩展名匹配\n        //   /test/no1/index.css\n        //   /test/*    ;   /test/no1/*\n        //   *.css\n        \n        urlPatterns = "/test/no1/*",\n        initParams = {\n                @WebInitParam(name = "name",value = "zhangsan")\n        },\n        loadOnStartup = 1\n)\npublic class AnnotationTest extends HttpServlet {\n    ···\n}\n\n\n\n# Servlet 下载\n\n如果用户需要通过 链接进行下载，可通过得到的请求进行响应输出，从而达到下载的效果\n\n大致步骤：\n\n 1. 通过 在请求中的属性 获取指定下载的文件名\n 2. 获取 项目的下载虚拟路径 ==ServletContext.getRealPath(<web根目录开始找下载文件夹路径>)==\n 3. 获取文件输入流 （拼接获取指定的文件流 （filename步骤1获取的属性值） ==new FileInputStream(path + filename);==\n 4. 设置文件名解决汉字不能 。一定要用 iso8859-1 编码集（用于响应头拼接 ==new String(filename.getBytes(),"iso8859-1");==\n 5. 设置响应头 ==resp.setHeader("content-disposition","attachment;filename="+filename);==\n 6. 获取 响应输出流\n 7. 读写输出至浏览器\n 8. 关闭 输入、输出 流\n\n示例：\n\n> 下载的文件夹在根目录中的 files 文件夹 里\n\nhtml\n\n<body>\n    <h3>超链接下载方式</h3>\n    <div>\n        <a href="files/file.txt">文本文件</a>\n        <a href="files/file.jpg">图片文件</a>\n        <a href="files/file.zip">压缩文件</a>\n    </div>\n    \n    <h3>手动编码下载方式</h3>\n    <div>\n        <a href="/download?fileName=file.txt">文本文件</a>\n        <a href="/download?fileName=file.jpg">图片文件</a>\n        <a href="/download?fileName=file.zip">压缩文件</a>\n    </div>\n</body>\n\n\njava\n\n@WebSevlet("/download/*")\n\n@Override\nprotected void doPost(HttpServletRequest req , HttpServletResponse resp) throws ServletException, IOException {\n    \n    String filename = req.getParameter("fileName");\n    String path = req.getServletContext().getRealPath("/files/");\n    \n    InputStream in = new FileInputStream(path + filename);\n    // 对汉字进行编码（因 浏览器会 识别 iso8859-1\n    filename = new String(filename.getBytes(),"iso8859-1");\n    // 设置响应头\n    resp.setHeader("content-disposition","attachment;filename="+filename);\n    OutputStream out = resp.getOutputStream();\n    byte[] bs = new byte[1024 * 8];\n    int len = 0;\n    while ((len = in.read(bs)) != -1) {\n        out.write(bs,0,len);\n    }\n    in.close();\n    out.close();\n}\n',normalizedContent:'# servlet\n\nservlet是在web服务器运行的java程序，主要负责与客户端数据交互，生成动态的web内容。通常 通过http 进行 接收 和 响应 来自客户端的请求！\n\n工作步骤：\n\n 1. 服务器 启动servlet\n 2. 客户端 发送请求 至 服务器\n 3. 服务器 调用servlet，根据 客户端 请求内容 传给服务器\n 4. 服务器 响应返回 客户端\n\n\n# servlet api\n\n点击查看文档\n\n\n# servlet\n\n> implements servlet javax.servlet\n\n用于 接收请求 与 响应请求 ，服务器必须实现的方法\n\n返回              抽象方法                     说明\nvoid            ==init()==               构造服务器\nvoid            ==service()==            服务器 响应请求\nvoid            ==destroy()==            移出 服务器 视为垃圾\nservletconfig   ==getservletconfig()==   获取 服务器对象\nstring          ==getservletinfo()==     获取 有关服务器的信息\n\n\n# genericservlet\n\n> class abstract genericservlet javax.servlet\n\ngenericservlet类 实现 servlet接口 用于web的 http servlet 服务项\n\n返回               方法                            说明\nenumeration      ==getinitparameternames()==   获取 指定参数名的对象\nenumeration      ==getservletname()==          获取 服务名\nservletcontext   ==getservletcontext()==       获取 全局对象\n\n\n# httpservlet\n\n> class abstract httpservlet javax.servlet.http\n\nhttpservlet 继承 genericservlet类 处理 http请求数据\n\n返回     方法             说明\nvoid   ==doget()==    处理get请求\nvoid   ==dopost()==   处理post请求\nvoid   ==doput()==    处理put请求\n···    ...            ...（更多自查文档）\n\n\n# servletcontext\n\n> implements servletcontext\n> \n> javax.servlet interface servletcontext\n\n点击对象方法\n\n用于与其他 servlet容器 通信的方法\n\n获取方式在请求的方法体里\n\n * ==this.getservletcontext()==\n * ==httpservletrequest.getservletcontext()==\n\n存取值常用方法\n\n返回       方法                                      说明\nvoid     setattribute(string key,object value)   向上下域 存键值\nobject   getattribute(string key)                从上下域 取指定键的值\nvoid     removeattribute(string key)             删除上下文 指定键的值\n\n\n# servlet 应用\n\n 1. 在 web 创建 index.html ，模拟客户端请求发送\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>!!!</title>\n</head>\n<body>\n    <h1>no.1 servlet应用</h1>\n    <a href="test">get请求测试</a>\n    <form action="test" method="post">\n        <input type="submit" value="post-test">\n    </form>\n</body>\n</html>\n\n\n 2. 创建实现servlet类，继承 httpservlet类\n\nimport javax.servlet.servletexception;\nimport javax.servlet.http.httpservlet;\nimport javax.servlet.http.httpservletrequest;\nimport javax.servlet.http.httpservletresponse;\nimport java.io.ioexception;\n\npublic class loginservlet extends httpservlet {\n    \n    /*\n    * httpservletrequest：请求对象\n    * httpservletresponse：响应对象\n    * */\n    \n    //处理 get 请求\n    @override\n    protected void doget(httpservletrequest req , httpservletresponse resp) throws servletexception, ioexception {\n        system.out.println("get-------");\n        system.out.println("req : " + req);\n        system.out.println("resp : " + resp);\n    }\n    \n    //处理 post 请求\n    @override\n    protected void dopost(httpservletrequest req , httpservletresponse resp) throws servletexception, ioexception {\n        system.out.println("post-------");\n        system.out.println("req : " + req);\n        system.out.println("resp : " + resp);\n    }\n    \n}\n\n\n 3. 在 ../web/web-inf/web.xml 文档配置映射关系 在 <web-app> 添加映射关系\n\n<servlet>\n    \x3c!-- ⾃定义名称 --\x3e\n    <servlet-name>no1</servlet-name>\n    \x3c!-- \n\t处理请求的类的完整路径\n\tloginservlet类在src根路径里\n\t --\x3e\n    <servlet-class>loginservlet</servlet-class>\n</servlet>\n\x3c!-- mapping 表示映射 --\x3e\n<servlet-mapping>\n    \x3c!-- ⾃定义名称 --\x3e\n    <servlet-name>no1</servlet-name>\n    \x3c!-- 请求名 --\x3e\n    <url-pattern>/test</url-pattern>\n</servlet-mapping>\n\n\n> 标签执行顺序：\n> \n>  1. 客户端 请求\n>  2. 进入 web.xml 匹配数据\n>  3. <servlet-mapping> 里的 <url-pattern> 标签 内容 与 请求名 进行匹配\n>  4. 匹配成功后 进行以下匹配 （映射标签） <servlet-mapping> 里的 <servlet-name> 标签 内容 与 <servlet> 里的 <servlet-name> 标签 内容\n>  5. 匹配成功后 进行以下匹配 （处理类路径） <servlet> 里的 <servlet-class> 标签 内容 与 src内的路径匹配\n\n 4. 启动，打开 地址： （以下两个测试） http://localhost:8080/工程名/访问服务器的路径 http://localhost:8080\n\n\n# servlet 工作原理\n\n 1. servlet容器 将servlet类载入内存 ， 实例调用它具体方法。一个web应用一个servlet\n 2. 调用servlet的service()方法 servletrequest对象 (请求对象) 和 servletresponse对象 (响应对象) 都是由 servlet容器 封装好的，直接调用即可\n 3. 每个servlet都有一个封装servlet配置的 servletconfig对象\n\n\n# servlet 生命周期\n\n\n\n 1. 实例化（使用构造方法创建对象）\n 2. 初始化 init()方法\n 3. 服务 service()方法\n 4. 销毁 destroy()方法\n\ninit方法 将会主要完成以下工作：\n\n 1. 创建用于解析 xml 配置文件的 contextdigester 对象\n 2. 读取默认 context.xml 配置文件，如果存在解析它\n 3. 读取默认 host 配置文件，如果存在解析它\n 4. 读取默认 context 自身的配置文件，如果存在解析它\n 5. 设置 context 的 docbase\n\n注意：\n\n 1. 当客户端发送请求，如果 存在servlet对象无需创建，否则新建servlet对象\n 2. 第二次请求时，会判断对象是否存在，但不会执执行init()方法，而直接执行service()方法\n 3. 相应的请求方式，会对应 service方法里的处理方式\n\n\n# request 请求\n\nhttpservletrequest表示http环境中的servlet请求。（扩展了servletrequest接口）\n\n点击更多servlet请求方法\n\n返回                  常用方法                                          说明\nstring              ==getparameter(string name)==                 获取 表单指定名称 组件的值\nstring[]            ==getparametervalues(string name)==           获取 表单指定名称 组件的多个值\nvoid                ==setcharacterencoding(string env)==          设置 请求的编码类型（针对post请求）\nrequestdispatcher   ==getrequestdispatcher(string url)==          跳转 指定页面路径\nvoid                ==setattribute(string key , string value)==   存储请求属性\nobject              ==getattribute(string key)==                  获取 指定属性的返回值\nstring              ==getrequesturi()==                           获取 url\n\n请求方式：\n\n>  * 通过表单 get/post 提交\n> \n>  * 通过 a标签 发送数据\n>    \n>    <a href="提交名?key1=value&key2=vlaue..">提交</a>\n>    <a href="/test?name=sans&age=12">提交</a>\n>    \n> \n>  * 通过地址栏直接拼接-get请求\n> \n>  * js提交数据-get请求\n\n乱码处理：\n\n>  * post请求转编码 setcharacterencoding("utf-8");\n> \n>  * get请求 转编码 （方法1）\n>    \n>    //针对于get提交时中⽂乱码\n>    string s=new string(变量名.getbytes("iso-8859-1"),"utf-8");\n>    string s=new string(request.getparameter("key").getbytes("iso-8859-1"),"gbk");\n>    \n> \n>  * get请求 转编码 （方法2） 在tomcat目录 /conf/server.xml 设置字符集\n>    \n>    <connector port="8080" protocol="http/1.1" \n>     connectiontimeout="20000"\n>     redirectport="8443" uriencoding="utf-8" />\n>    \n\nget和post区别：\n\n> get请求： 该请求会附加在url之后，从 ? 开始以 & 分割变量和属性。url采用的是ascll编码。\n> \n> post请求： 该请求数据置放在http请求包的包体中进行传输数据。\n> \n> 数据传输大小 get会受到url的长度限制，而post不会\n> \n> 安全性 提交/进入 时，get会在url后面显示，而post不会\n\n实例：\n\nhtml页面\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>!!!</title>\n</head>\n<body>\n    <a href="requesttest?click=true&summary=用户点击了超链接">超链接测试</a>\n    <form action="requesttest" method="post">\n        uname:<input type="text" name="username"><br>\n        upassword:<input type="password" name="userpassword"><br>\n        sex:\n        <input type="radio" name="sex" value="man">男\n        <input type="radio" name="sex" value="woman">女\n        <br>\n        hobby:\n        <input type="checkbox" name="hobby" value="basketball">篮球\n        <input type="checkbox" name="hobby" value="football">足球\n        <input type="checkbox" name="hobby" value="tennis">网球\n        <br>\n        <input type="submit">\n    </form>\n</body>\n</html>\n\n\njava获取\n\nimport javax.servlet.servletexception;\nimport javax.servlet.http.httpservlet;\nimport javax.servlet.http.httpservletrequest;\nimport javax.servlet.http.httpservletresponse;\nimport java.io.ioexception;\n\npublic class myrequesttest extends httpservlet {\n    @override\n    protected void doget(httpservletrequest req , httpservletresponse resp) throws servletexception, ioexception {\n        system.out.println("get=========");\n        system.out.println("超链接点击了？"+req.getparameter("click"));\n        system.out.println("摘要："+req.getparameter("summary"));\n    }\n    \n    @override\n    protected void dopost(httpservletrequest req , httpservletresponse resp) throws servletexception, ioexception {\n        system.out.println("post=========");\n        //解决乱码\n        req.setcharacterencoding("utf-8");\n        \n        string name = req.getparameter("username");\n        string password = req.getparameter("userpassword");\n        string sex = req.getparameter("sex");\n        string[] hobbys = req.getparametervalues("hobby");\n\n        system.out.println("username："+name);\n        system.out.println("userpassword："+ password);\n        system.out.println("sex："+ sex);\n        if (hobbys != null || hobbys.length != 0){\n            system.out.println("hobby：");\n            for (string tmp : hobbys) {\n                system.out.println(tmp);\n            }\n        }\n        \n        //存值\n        req.setattribute("username",name);\n        req.setattribute("userpassword",password);\n        \n        //取值\n        system.out.println("取值测试：");\n        system.out.println(req.getattribute("username"));\n        \n        //跳转页面 (提交跳转的页面 在web文件夹下subtest.html)\n        req.getrequestdispatcher("/subtest.html").forward(req,resp);\n    }\n}\n\n\n\n# response 响应\n\nhttpservletresponse 表示 servlet响应，继承了servletresponse接口，专门用来封装http响应消息。\n\n点击更多servlet响应方法\n\n返回            常用方法                                说明\nvoid          ==addcookie(cookie cookie)==        指定 cookie添加到响应中\nvoid          ==sendredirect(string location)==   指定 重定向url位置（页面跳转）\nprintwriter   ==getwriter()==                     获取 可以给前端输出的字符流对象\nvoid          ==setcontenttype(string type)==     设置 响应的内容类型\n\n重定向与转发的区别\n\n>  * 重定向 会改变地址，requset存储的数据会丢失 转发 时地址会显示请求页面的地址，保存了页面的数据\n>  * 重定向 两次请求 两次响应；转发 一次请求 一次响应\n>  * js 跳转页面，也会丢失 requset存储的数据\n\n\n\n\n# 响应图片\n\n以流的形式响应图片\n\n实现方案：\n\n 1. 使用filechannel的方法\n 2. 使用普通的io，fileinputstream->byte[]->response.outputstream\n 3. 使用imageio的read和write方法实现\n\n// 方式1\n@override\nprotected void doget(httpservletrequest req , httpservletresponse resp) throws servletexception, ioexception {\n    file file = new file("c:\\\\users\\\\admin\\\\desktop\\\\ceshi.jpg");\n    try (fileinputstream fis = new fileinputstream(file)) {\n        response.setcontenttype("image/png");\n        fis.getchannel().\n            transferto(0,fis.available(),channels.newchannel(response.getoutputstream()));\n    } catch (exception e) {\n        e.printstacktrace();\n    }\n}\n\n// 方式2\n@override\nprotected void doget(httpservletrequest req , httpservletresponse resp) throws servletexception, ioexception {\n    file file = new file("c:\\\\users\\\\admin\\\\desktop\\\\ceshi.jpg");\n    try(fileinputstream fis = new fileinputstream(file)) {\n        response.setcontenttype("image/png");\n        byte[] bytes = new byte[fis.available()];\n        fis.read(bytes);\n        response.getoutputstream().write(bytes);\n    }catch (exception e){\n        e.printstacktrace();\n    }\n}\n\n// 方式3\n@override\nprotected void doget(httpservletrequest req , httpservletresponse resp) throws servletexception, ioexception {\n    file file = new file("c:\\\\users\\\\admin\\\\desktop\\\\ceshi.jpg");\n    try {\n        bufferedimage image = imageio.read(file);\n        response.setcontenttype("image/png");\n        outputstream os = response.getoutputstream();\n        imageio.write(image, "png", os);\n        os.flush();\n        os.close();\n    } catch (ioexception e) {\n        e.printstacktrace();\n    }\n}\n\n\n\n# session 会话\n\nsession是服务器端使用的一种记录客户端状态的机制。（是servletrequest的扩展） sessinon可有多个页面、多个request(请求)，重定向也不会丢失数据。 当浏览器访问web服务器时，servlet容器就会创建一个session对象和id属性，当客户端后续访问服务器时，只要将id标识号传递给服务器，服务器就能判断该请求是哪个客户端发送的，从而选择与之对应的session对象为其服务。\n\n更多servletrequest方法 更多httpservletrequest方法 更多httpsession方法\n\n返回            常用方法                                          说明\nhttpsession   ==getsession()==                              获取 请求的session对象\nvoid          ==setattribute(string key , object value)==   以key/value存储属性值\nobject        ==getattribute(string key)==                  获取 指定key的属性值，没有则null\nvoid          ==invalidate()==                              设置 session 无效，取消任何会话的对象\nstring        ==getid()==                                   获取 当前 会话id标识号\nvoid          ==setmaxinactiveinterval(int interval)==      设置 会话有效时长 ，超出时长则无效会话(单位：秒)\nvoid          ==removeattribute(string key)==               从此会话 删除 指定key的值(置为null)\n\n会话有效时长：\n\n>  1. setmaxinactiveinterval(int second) //指定秒数有效\n> \n>  2. 编辑 web.xml\n>     \n>     <session-config>\n>      \t<session-timeout>10</session-timeout>//单位:分钟\n>      </session-config> \n>     \n\nsession失效方式：\n\n>  1. invalidate()\n>  2. removeattribute("key");\n>  3. 直接关闭浏览器\n\n\n# servlet 初始化参数\n\n在 web.xml 中配置 servlet 时，可以配置初始化参数 servlet可通过 servletconfig接口 提供的方法来获取这些参数\n\nservlet局部参数配置\n\n在 web.xml 中对应的 servlet 添加 init-param属性（获取参数仅限于配置的servlet）\n\n<init-param>\n       <param-name>key</param-name>\n       <param-value>value</param-value>\n</init-param>\n\n\nservlet全局部参数配置\n\n在 web.xml 中添加 context-param属性 （全部servlet都可获取）\n\n<context-param>\n        <param-name>key</param-name>\n        <param-value>value</param-value>\n </context-param>\n\n\n获取数据\n\n 1. 请求 -> init() -> ... servlet中 重写init()方法，通过以下代码获取 （全局和局部获取方式不一样）\n    \n    @override\n    public void init(servletconfig config) throws servletexception {\n        //匹配指定name 获取 对应的值\n        //局部\n        string vlaue = config.getinitparameter("key") );\n        //全局\n        string vlaue2 = config.getservletcontext().getinitparameter("allkey") );\n    }\n    \n\n 2. 请求 -> init() -> servlet() -> doget()/dopost() -> ...\n    \n    //超链接响应获取\n    @override\n    protected void doget(httpservletrequest req , httpservletresponse resp) throws servletexception, ioexception {\n        //局部\n        string vlaue = this.getinitparameter("key");\n        //全局\n        string vlaue2 = this.getinitparameter("allkey");\n        string vlaue3 = this.getservletcontext().getinitparameter("allkey");\n    }\n    \n\n注意： 不同的获取方式不能共存！！！\n\n\n# servlet 注解\n\n注解 提供的信息，让开发更便捷易懂\n\n属性                  类型               必须   说明\nasyncsupported      boolean          f    servlet是否支持异步操作\ndisplayname         string           f    servlet显示名称\ninitparams          webinitparam[]   f    配置初始化参数\nloadonstartup       int              f    servlet 的优先级 加载(越小越早)\nname                string           f    指定servlet名称\nurlpatterns/value   string[]         t    两个属性作用相同，指定处理的url\n\nurlpatterns匹配说明\n\n> 完全匹配 /test/userlist.action 匹配绝对路径的请求\n> \n> 路径匹配 /test/* 匹配test路径下的所有请求\n> \n> 扩展名匹配 *.action 匹配后缀为action 结尾的请求\n\n注意：\n\n>  * 如果当前servlet注解了就无需再配置 web.xml\n>  * name若不指定值，则默认以类名为name\n>  * urlpatterns路径分割不需有斜杠 /\n>  * urlpatterns可映射多个路径\n\n@webservlet(\n        name = "no.6",\n        //完全路径；全局路径匹配；扩展名匹配\n        //   /test/no1/index.css\n        //   /test/*    ;   /test/no1/*\n        //   *.css\n        \n        urlpatterns = "/test/no1/*",\n        initparams = {\n                @webinitparam(name = "name",value = "zhangsan")\n        },\n        loadonstartup = 1\n)\npublic class annotationtest extends httpservlet {\n    ···\n}\n\n\n\n# servlet 下载\n\n如果用户需要通过 链接进行下载，可通过得到的请求进行响应输出，从而达到下载的效果\n\n大致步骤：\n\n 1. 通过 在请求中的属性 获取指定下载的文件名\n 2. 获取 项目的下载虚拟路径 ==servletcontext.getrealpath(<web根目录开始找下载文件夹路径>)==\n 3. 获取文件输入流 （拼接获取指定的文件流 （filename步骤1获取的属性值） ==new fileinputstream(path + filename);==\n 4. 设置文件名解决汉字不能 。一定要用 iso8859-1 编码集（用于响应头拼接 ==new string(filename.getbytes(),"iso8859-1");==\n 5. 设置响应头 ==resp.setheader("content-disposition","attachment;filename="+filename);==\n 6. 获取 响应输出流\n 7. 读写输出至浏览器\n 8. 关闭 输入、输出 流\n\n示例：\n\n> 下载的文件夹在根目录中的 files 文件夹 里\n\nhtml\n\n<body>\n    <h3>超链接下载方式</h3>\n    <div>\n        <a href="files/file.txt">文本文件</a>\n        <a href="files/file.jpg">图片文件</a>\n        <a href="files/file.zip">压缩文件</a>\n    </div>\n    \n    <h3>手动编码下载方式</h3>\n    <div>\n        <a href="/download?filename=file.txt">文本文件</a>\n        <a href="/download?filename=file.jpg">图片文件</a>\n        <a href="/download?filename=file.zip">压缩文件</a>\n    </div>\n</body>\n\n\njava\n\n@websevlet("/download/*")\n\n@override\nprotected void dopost(httpservletrequest req , httpservletresponse resp) throws servletexception, ioexception {\n    \n    string filename = req.getparameter("filename");\n    string path = req.getservletcontext().getrealpath("/files/");\n    \n    inputstream in = new fileinputstream(path + filename);\n    // 对汉字进行编码（因 浏览器会 识别 iso8859-1\n    filename = new string(filename.getbytes(),"iso8859-1");\n    // 设置响应头\n    resp.setheader("content-disposition","attachment;filename="+filename);\n    outputstream out = resp.getoutputstream();\n    byte[] bs = new byte[1024 * 8];\n    int len = 0;\n    while ((len = in.read(bs)) != -1) {\n        out.write(bs,0,len);\n    }\n    in.close();\n    out.close();\n}\n',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"过滤监听器",frontmatter:{title:"过滤监听器",author:"柏竹",permalink:"/backend/0nybdh",date:"2020-02-18T00:00:00.000Z",categories:["后端","JavaWeb"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/02.JavaWeb/04.Filter%E8%BF%87%E6%BB%A4%E7%9B%91%E5%90%AC%E5%99%A8.html",relativePath:"01.后端/02.JavaWeb/04.Filter过滤监听器.md",key:"v-e6903300",path:"/backend/0nybdh/",headers:[{level:2,title:"过滤器",slug:"过滤器",normalizedTitle:"过滤器",charIndex:2},{level:3,title:"应用步骤",slug:"应用步骤",normalizedTitle:"应用步骤",charIndex:109},{level:3,title:"过滤器注解说明",slug:"过滤器注解说明",normalizedTitle:"过滤器注解说明",charIndex:724},{level:3,title:"过滤器执行过程",slug:"过滤器执行过程",normalizedTitle:"过滤器执行过程",charIndex:1320},{level:3,title:"过滤器声明周期",slug:"过滤器声明周期",normalizedTitle:"过滤器声明周期",charIndex:1575},{level:3,title:"应用场景",slug:"应用场景",normalizedTitle:"应用场景",charIndex:1789},{level:2,title:"监听器",slug:"监听器",normalizedTitle:"监听器",charIndex:6},{level:2,title:"应用测试",slug:"应用测试",normalizedTitle:"应用测试",charIndex:2713}],headersStr:"过滤器 应用步骤 过滤器注解说明 过滤器执行过程 过滤器声明周期 应用场景 监听器 应用测试",content:'# 过滤器&监听器\n\n\n# 过滤器\n\n过滤器是对web资源进行拦截，做⼀些处理后再交给下⼀个过滤器或servlet处理，通常都是用来拦截request进行处理的，也可以对返回的response进行拦截处理\n\n\n\n\n# 应用步骤\n\n 1. 添加 servlet jar依赖包\n\n 2. 创建对象类 应用 javax.servlet.Filter接口 ，并重写里面所有方法\n\n 3. 配置 url 的访问入口，有两种方式 web.xml / @WebFilter\n    \n    web.xml 文件配置\n    \n    <filter>\n        <filter-name>过滤器映射名</filter-name>\n        <filter-class>类路径</filter-class>\n    </filter>\n    <filter-mapping>\n        <filter-name>过滤器映射名</filter-name>\n        <url-pattern>请求url</url-pattern>\n    </filter-mapping>\n    \n    \n    @WebFilter 注解配置\n    \n    @WebFiler("...")\n    public class MyFilter implements Filter {...}\n    \n\n 4. 自定义过滤 约束 配置\n\n 5. 回调servlet/转接过滤器 ，在 doFileter() 添加以下代码\n    \n    filterChain.doFilter(Request , Response);\n    \n\n\n# 过滤器注解说明\n\n@WebFilter 注解配置\n\n属性                值 [默认值]                      说明\ndescription       String [""]                  描述\ndisplayName       String [""]                  显示名称\ninitParams        WebInitParam[] [{}]          初始化参数\nfilterName        String [""]                  过滤器名称\nvalue             String[] [{}]                过滤地址url\nurlPatterns       String[] [{}]                网址模式\ndispatcherTypes   DispatcherType[] [REQUEST]   拦截形式\nasyncSupported    Boolean [false]              异步支持\n\n拦截形式      说明\nFORWARD   转发访问资源\nINCLUDE   包含访问资源\nREQUEST   请求资源\nASYNC     异步访问资源\nERROR     错误跳转资源\n\n\n# 过滤器执行过程\n\n 1. 客户端发出Web请求，如果 过滤器与此地址匹配，则会优先进入过滤器\n 2. 请求会进入到 doFilter()方法，进行代码逻辑处理\n 3. 调用 chain.doFilter()方法 放行请求，否则会拦截请求\n 4. 请求通过后，响应回来依旧需要经过 过滤器\n\n注意:\n\n * 过滤器执行是同步的，因此 chain.doFilter()方法 之前是 请求处理的范围 ，则之后为 响应处理的范围\n * 如果过滤器有多个，会依次执行所有匹配url的过滤器才能获取Web资源\n\n\n\n\n# 过滤器声明周期\n\n 1. init() ：在服务器启动后，会创建 Filter对象 ，然后 调用 init()方法 ，只会执行一次\n 2. doFilter() ：每次请求地址匹配都会拦截请求\n 3. destroy() ：在服务器关闭后，Filter对象被销毁 ，然后执行 destroy()方法 （前提需要在正常关闭情况下\n\n注意: init() / destroy() 方法 一般用于 初次加载/释放资源 的情况\n\n\n# 应用场景\n\n * 防止用户未登陆访问资源\n * 设置统一编码类型\n * 加密、解密\n * 过滤非法文字\n * 下载资源的限制\n * ...\n\n\n# 监听器\n\n监听器是监听某个域对象的的状态变化的组件\n\n> 事件源对象：request、 session、servletContext 监听状态： 创建、变化、销毁 配置监听： 绑定与事件源的监听 监听响应： 监听状态发生变化进行响应\n\n监听器类型\n\n接口           SERVLETCONTEXT                    HTTPSESSION                    SERVLETREQUEST\n监听对象 创建/销毁   ServletContextListener            HttpSessionListener            ServlerRequestListener\n监听对象属性变化     ServletContextAttributeListener   HttpSessionAttributeListener   ServletRequestAttributeListener\n\n对象周期和用意\n\n>  * ServletContext： 服务器启动 -> 服务器关闭 初始化对象、初始化数据（配置加载等信息）\n>  * Session： request.getSession创建 -> 服务器关闭、超时销毁、手动销毁 数据存取重要信息、网站记录数器 等。。。\n>  * Request： 请求开始 -> 请求结束 信息交互的存取\n\n应用步骤：\n\n>  1. 添加 servlet jar依赖包\n> \n>  2. \n> \n>  3. 创建对象类 应用 监听的接口 并重写事件处理的方法\n> \n>  4. 配置 web.xml 文件/添加注释 @WebListener（以下配置用于监听器使用）\n>     \n>     <listener>\n>             <listener-class>类路径</listener-class>\n>     </listener>\n>     \n\n点击了解监听器\n\n\n# 应用测试\n\n点击个人项目应用测试',normalizedContent:'# 过滤器&监听器\n\n\n# 过滤器\n\n过滤器是对web资源进行拦截，做⼀些处理后再交给下⼀个过滤器或servlet处理，通常都是用来拦截request进行处理的，也可以对返回的response进行拦截处理\n\n\n\n\n# 应用步骤\n\n 1. 添加 servlet jar依赖包\n\n 2. 创建对象类 应用 javax.servlet.filter接口 ，并重写里面所有方法\n\n 3. 配置 url 的访问入口，有两种方式 web.xml / @webfilter\n    \n    web.xml 文件配置\n    \n    <filter>\n        <filter-name>过滤器映射名</filter-name>\n        <filter-class>类路径</filter-class>\n    </filter>\n    <filter-mapping>\n        <filter-name>过滤器映射名</filter-name>\n        <url-pattern>请求url</url-pattern>\n    </filter-mapping>\n    \n    \n    @webfilter 注解配置\n    \n    @webfiler("...")\n    public class myfilter implements filter {...}\n    \n\n 4. 自定义过滤 约束 配置\n\n 5. 回调servlet/转接过滤器 ，在 dofileter() 添加以下代码\n    \n    filterchain.dofilter(request , response);\n    \n\n\n# 过滤器注解说明\n\n@webfilter 注解配置\n\n属性                值 [默认值]                      说明\ndescription       string [""]                  描述\ndisplayname       string [""]                  显示名称\ninitparams        webinitparam[] [{}]          初始化参数\nfiltername        string [""]                  过滤器名称\nvalue             string[] [{}]                过滤地址url\nurlpatterns       string[] [{}]                网址模式\ndispatchertypes   dispatchertype[] [request]   拦截形式\nasyncsupported    boolean [false]              异步支持\n\n拦截形式      说明\nforward   转发访问资源\ninclude   包含访问资源\nrequest   请求资源\nasync     异步访问资源\nerror     错误跳转资源\n\n\n# 过滤器执行过程\n\n 1. 客户端发出web请求，如果 过滤器与此地址匹配，则会优先进入过滤器\n 2. 请求会进入到 dofilter()方法，进行代码逻辑处理\n 3. 调用 chain.dofilter()方法 放行请求，否则会拦截请求\n 4. 请求通过后，响应回来依旧需要经过 过滤器\n\n注意:\n\n * 过滤器执行是同步的，因此 chain.dofilter()方法 之前是 请求处理的范围 ，则之后为 响应处理的范围\n * 如果过滤器有多个，会依次执行所有匹配url的过滤器才能获取web资源\n\n\n\n\n# 过滤器声明周期\n\n 1. init() ：在服务器启动后，会创建 filter对象 ，然后 调用 init()方法 ，只会执行一次\n 2. dofilter() ：每次请求地址匹配都会拦截请求\n 3. destroy() ：在服务器关闭后，filter对象被销毁 ，然后执行 destroy()方法 （前提需要在正常关闭情况下\n\n注意: init() / destroy() 方法 一般用于 初次加载/释放资源 的情况\n\n\n# 应用场景\n\n * 防止用户未登陆访问资源\n * 设置统一编码类型\n * 加密、解密\n * 过滤非法文字\n * 下载资源的限制\n * ...\n\n\n# 监听器\n\n监听器是监听某个域对象的的状态变化的组件\n\n> 事件源对象：request、 session、servletcontext 监听状态： 创建、变化、销毁 配置监听： 绑定与事件源的监听 监听响应： 监听状态发生变化进行响应\n\n监听器类型\n\n接口           servletcontext                    httpsession                    servletrequest\n监听对象 创建/销毁   servletcontextlistener            httpsessionlistener            servlerrequestlistener\n监听对象属性变化     servletcontextattributelistener   httpsessionattributelistener   servletrequestattributelistener\n\n对象周期和用意\n\n>  * servletcontext： 服务器启动 -> 服务器关闭 初始化对象、初始化数据（配置加载等信息）\n>  * session： request.getsession创建 -> 服务器关闭、超时销毁、手动销毁 数据存取重要信息、网站记录数器 等。。。\n>  * request： 请求开始 -> 请求结束 信息交互的存取\n\n应用步骤：\n\n>  1. 添加 servlet jar依赖包\n> \n>  2. \n> \n>  3. 创建对象类 应用 监听的接口 并重写事件处理的方法\n> \n>  4. 配置 web.xml 文件/添加注释 @weblistener（以下配置用于监听器使用）\n>     \n>     <listener>\n>             <listener-class>类路径</listener-class>\n>     </listener>\n>     \n\n点击了解监听器\n\n\n# 应用测试\n\n点击个人项目应用测试',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"会话跟踪",frontmatter:{title:"会话跟踪",author:"柏竹",permalink:"/backend/tlfhkk",date:"2020-02-18T00:00:00.000Z",categories:["后端","JavaWeb"],tags:["Cookie","Session"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/02.JavaWeb/05.Session&Cookie%E4%BC%9A%E8%AF%9D%E8%B7%9F%E8%B8%AA.html",relativePath:"01.后端/02.JavaWeb/05.Session&Cookie会话跟踪.md",key:"v-3fdb40e9",path:"/backend/tlfhkk/",headers:[{level:2,title:"Cookie",slug:"cookie",normalizedTitle:"cookie",charIndex:62},{level:3,title:"Cookie应用",slug:"cookie应用",normalizedTitle:"cookie应用",charIndex:250},{level:2,title:"Session",slug:"session",normalizedTitle:"session",charIndex:69},{level:3,title:"Session应用",slug:"session应用",normalizedTitle:"session应用",charIndex:1811},{level:3,title:"Session生命周期",slug:"session生命周期",normalizedTitle:"session生命周期",charIndex:2073},{level:2,title:"Session和Cookie的区别",slug:"session和cookie的区别",normalizedTitle:"session和cookie的区别",charIndex:2493}],headersStr:"Cookie Cookie应用 Session Session应用 Session生命周期 Session和Cookie的区别",content:'# 会话跟踪\n\n会话跟踪是Web程序中常用的技术，用来跟踪用户的整个会话。保持对用户会话期间的数据管理。常用的会话跟踪技术是Cookie与Session。\n\n> Cookie 通过在 客户端记录 信息确定用户身份 Session 通过在 服务器端记录 信息确定用户身份\n\n\n# Cookie\n\nCookie是客户端请求服务器后，服务器发给客户端的⼀个辨认标识，保存在客户端，当客户端再次向服务器发送请求时，会携带着这个辨认标识，服务器就可以通过这个标识来识别 客户端的身份 或 状态等...\n\n\n# Cookie应用\n\n应用步骤：\n\n 1. 存数据 实例 Cookie对象（String key, String value）\n 2. 响应返回 HttpServletResponse.addCookie(Cookie cookie)方法 对指定的 cookie对象 进行添加至响应中(可多次添加数据)\n 3. 客户端识别读取 ， HttpServletRequest.getCookies() 获取 得到 Cookies对象数组\n 4. 对其数组进行遍历 cookie对象 ，Cookie.getName()方法 判断对应 保存的key 进行获取 value值\n 5. 符合条件的 key 对其值进行 范围保存value值\n\nCookie保存\n\n@Override\nprotected void doPost(HttpServletRequest req , HttpServletResponse resp) throws ServletException, IOException {\n        System.out.println("Post请求============");\n        String user = req.getParameter("user");\n        //创建保存 cookie对象\n        Cookie cookie = new Cookie("uname",user);\n        //添加对象\n        resp.addCookie(cookie);\n}\n\n\nCookie读取\n\n// 方式No.1\n<%\n    Cookie[] cookies = request.getCookies();\n    if (cookies != null) {\n      for (Cookie c : cookies) {\n        if (c.getName().equals("uname")) {\n          pageContext.setAttribute("uname",c.getValue());\n          break;\n        }\n      }\n    }\n%>\n\n// 方式No.2\n${cookie.<键名>.vlaue}\n\n\nCookie定时销毁\n\nCookie cookie = new Cookie("username", "aaa");\n//设置Cookie的有效时间为30s\ncookie.setMaxAge(30);\nresponse.addCookie(cookie); \n\n\nCookie中文编码\n\n// 存数据前 将String 转换 编码\nString name = URLEncoder.encode("张三", "utf-8");\nCookie cookie = new Cookie("name", name);\n    \n// 取数据前 将String 反转 编码\nString name = URLDecoder.decode( cookie.getName() ,"utf-8");\n\n\n点击Cookie更多方法 点击了解HttpServletResponse\n\n注意：\n\n>  * 未对Cookie有效时长设置 ，则Cookie在浏览器关闭自动销毁\n>  * Cookie数据 会保存在当前的客户端\n>  * Cookie不适保存隐私信息\n\n\n# Session\n\nSession是客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上的数据 Session对象 对应的类为 javax.servlet.http.HttpSession类\n\n\n# Session应用\n\n应用步骤：\n\n>  1. 获取HttpSession对象，通过 HttpServletRequest.getSession()方法 获取对象\n>  2. 保存对象属性，通过 HttpSession.setAttribute(String key , String value)方法 存储数据\n>  3. 读取数据，通过HttpSession.getAttribute(String key)方法 获取数据\n\n点击更多HttpSession方法 点击更多HttpServletRequest方法\n\n\n# Session生命周期\n\nSession保存在服务器端 Session在用户第⼀次访问服务器的时候自动创建。需要注意只有访问JSP、Servlet等程序时才会创建 Session对象，只访问HTML、IMAGE等静态资源并不会创建Session\n\n点击了解Session生命周期\n\nSession销毁操作有哪些？\n\n * 关闭服务器\n * session对象调用 invalidate()\n * session对象设置了自动销毁时间 session.setMaxInactiveInterval(60) （60s销毁）\n * session默认30min自动销毁（从你上一次访问服务器开始计时开始\n\n注意:\n\n * Session对象 重定向/转发时，session数据不会丢失 (重定向请求数据会丢失)\n * Session 用于存储有意义的数据（减少服务器压力）\n * Session 有生命周期时长的限制（默认30min失效\n\n\n# Session和Cookie的区别\n\n * Cookie数据保存在客户端\n * Cookies不会占服务器资源\n * Session数据保存在服务器端\n * Session的客户端SessionID标识符，用存服务端的Session存储空间',normalizedContent:'# 会话跟踪\n\n会话跟踪是web程序中常用的技术，用来跟踪用户的整个会话。保持对用户会话期间的数据管理。常用的会话跟踪技术是cookie与session。\n\n> cookie 通过在 客户端记录 信息确定用户身份 session 通过在 服务器端记录 信息确定用户身份\n\n\n# cookie\n\ncookie是客户端请求服务器后，服务器发给客户端的⼀个辨认标识，保存在客户端，当客户端再次向服务器发送请求时，会携带着这个辨认标识，服务器就可以通过这个标识来识别 客户端的身份 或 状态等...\n\n\n# cookie应用\n\n应用步骤：\n\n 1. 存数据 实例 cookie对象（string key, string value）\n 2. 响应返回 httpservletresponse.addcookie(cookie cookie)方法 对指定的 cookie对象 进行添加至响应中(可多次添加数据)\n 3. 客户端识别读取 ， httpservletrequest.getcookies() 获取 得到 cookies对象数组\n 4. 对其数组进行遍历 cookie对象 ，cookie.getname()方法 判断对应 保存的key 进行获取 value值\n 5. 符合条件的 key 对其值进行 范围保存value值\n\ncookie保存\n\n@override\nprotected void dopost(httpservletrequest req , httpservletresponse resp) throws servletexception, ioexception {\n        system.out.println("post请求============");\n        string user = req.getparameter("user");\n        //创建保存 cookie对象\n        cookie cookie = new cookie("uname",user);\n        //添加对象\n        resp.addcookie(cookie);\n}\n\n\ncookie读取\n\n// 方式no.1\n<%\n    cookie[] cookies = request.getcookies();\n    if (cookies != null) {\n      for (cookie c : cookies) {\n        if (c.getname().equals("uname")) {\n          pagecontext.setattribute("uname",c.getvalue());\n          break;\n        }\n      }\n    }\n%>\n\n// 方式no.2\n${cookie.<键名>.vlaue}\n\n\ncookie定时销毁\n\ncookie cookie = new cookie("username", "aaa");\n//设置cookie的有效时间为30s\ncookie.setmaxage(30);\nresponse.addcookie(cookie); \n\n\ncookie中文编码\n\n// 存数据前 将string 转换 编码\nstring name = urlencoder.encode("张三", "utf-8");\ncookie cookie = new cookie("name", name);\n    \n// 取数据前 将string 反转 编码\nstring name = urldecoder.decode( cookie.getname() ,"utf-8");\n\n\n点击cookie更多方法 点击了解httpservletresponse\n\n注意：\n\n>  * 未对cookie有效时长设置 ，则cookie在浏览器关闭自动销毁\n>  * cookie数据 会保存在当前的客户端\n>  * cookie不适保存隐私信息\n\n\n# session\n\nsession是客户端浏览器访问服务器的时候，服务器把客户端信息以某种形式记录在服务器上的数据 session对象 对应的类为 javax.servlet.http.httpsession类\n\n\n# session应用\n\n应用步骤：\n\n>  1. 获取httpsession对象，通过 httpservletrequest.getsession()方法 获取对象\n>  2. 保存对象属性，通过 httpsession.setattribute(string key , string value)方法 存储数据\n>  3. 读取数据，通过httpsession.getattribute(string key)方法 获取数据\n\n点击更多httpsession方法 点击更多httpservletrequest方法\n\n\n# session生命周期\n\nsession保存在服务器端 session在用户第⼀次访问服务器的时候自动创建。需要注意只有访问jsp、servlet等程序时才会创建 session对象，只访问html、image等静态资源并不会创建session\n\n点击了解session生命周期\n\nsession销毁操作有哪些？\n\n * 关闭服务器\n * session对象调用 invalidate()\n * session对象设置了自动销毁时间 session.setmaxinactiveinterval(60) （60s销毁）\n * session默认30min自动销毁（从你上一次访问服务器开始计时开始\n\n注意:\n\n * session对象 重定向/转发时，session数据不会丢失 (重定向请求数据会丢失)\n * session 用于存储有意义的数据（减少服务器压力）\n * session 有生命周期时长的限制（默认30min失效\n\n\n# session和cookie的区别\n\n * cookie数据保存在客户端\n * cookies不会占服务器资源\n * session数据保存在服务器端\n * session的客户端sessionid标识符，用存服务端的session存储空间',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"MVC设计模式",frontmatter:{title:"MVC设计模式",author:"柏竹",permalink:"/backend/aud35w",date:"2020-02-18T00:00:00.000Z",categories:["后端","JavaWeb"],tags:["MVC"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/02.JavaWeb/06.MVC.html",relativePath:"01.后端/02.JavaWeb/06.MVC.md",key:"v-f872bd68",path:"/backend/aud35w/",headers:[{level:2,title:"三层构架",slug:"三层构架",normalizedTitle:"三层构架",charIndex:214}],headersStr:"三层构架",content:"# MVC设计模式\n\nMVC设计是用于应用程序的分层开发的模式 模型层(Model)、显示层(View)、控制层(Controller)\n\n> M： 应用程序的核心功能，管理模块中的数据和值（bean, dao）\n> \n> V： 视图提供模型的展示，会根据用户控制情况进行更变（jsp/html）\n> \n> C： 对用户的输入做出反应，管理用户和视图的交互，是连接模型和视图的枢纽（servlet/service）\n\n\n\n\n# 三层构架\n\n三层架构是将整个业务应用划分为： 表现层（UI）、业务逻辑层（BLL）、数 据访问层（DAL）\n\n> UI： 用户交互的页面。用于用户 输入、显示、处理需求等。。（jsp/html）\n> \n> BLL： 业务逻辑的操作，对数据业务逻辑处理（servlet/service）\n> \n> DAL： 数据库编辑，增删查操作等（dao）\n\n\n\nMVC和三层架构的联系\n\n>  * MVC中的V、C分化为三层中的UI层进行处理，而三层中的BBL、DAL是MVC中的M整合\n>  * MVC可与三层构架共存（MVC可代做为表示层展示）\n\n\n\nMVC和三层架构的区别\n\n> MVC： 无上下关系，相互协助关系（可接 接口）\n> \n> 三层构架： 上下层关系，上层依赖下层（缺一不可）",normalizedContent:"# mvc设计模式\n\nmvc设计是用于应用程序的分层开发的模式 模型层(model)、显示层(view)、控制层(controller)\n\n> m： 应用程序的核心功能，管理模块中的数据和值（bean, dao）\n> \n> v： 视图提供模型的展示，会根据用户控制情况进行更变（jsp/html）\n> \n> c： 对用户的输入做出反应，管理用户和视图的交互，是连接模型和视图的枢纽（servlet/service）\n\n\n\n\n# 三层构架\n\n三层架构是将整个业务应用划分为： 表现层（ui）、业务逻辑层（bll）、数 据访问层（dal）\n\n> ui： 用户交互的页面。用于用户 输入、显示、处理需求等。。（jsp/html）\n> \n> bll： 业务逻辑的操作，对数据业务逻辑处理（servlet/service）\n> \n> dal： 数据库编辑，增删查操作等（dao）\n\n\n\nmvc和三层架构的联系\n\n>  * mvc中的v、c分化为三层中的ui层进行处理，而三层中的bbl、dal是mvc中的m整合\n>  * mvc可与三层构架共存（mvc可代做为表示层展示）\n\n\n\nmvc和三层架构的区别\n\n> mvc： 无上下关系，相互协助关系（可接 接口）\n> \n> 三层构架： 上下层关系，上层依赖下层（缺一不可）",charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"JSON",frontmatter:{title:"JSON",author:"柏竹",permalink:"/backend/d4tcq2",date:"2020-02-18T00:00:00.000Z",categories:["后端","JavaWeb"],tags:["JSON"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/02.JavaWeb/08.JSON%E6%93%8D%E4%BD%9C.html",relativePath:"01.后端/02.JavaWeb/08.JSON操作.md",key:"v-3f258632",path:"/backend/d4tcq2/",headers:[{level:2,title:"JSON 访问",slug:"json-访问",normalizedTitle:"json 访问",charIndex:335},{level:2,title:"JSON与Java对象的转换",slug:"json与java对象的转换",normalizedTitle:"json与java对象的转换",charIndex:1225},{level:3,title:"java--\x3ejson",slug:"java-json",normalizedTitle:"java--&gt;json",charIndex:null},{level:3,title:"json--\x3ejava",slug:"json-java",normalizedTitle:"json--&gt;java",charIndex:null},{level:3,title:"java集合--\x3ejson数组",slug:"java集合-json数组",normalizedTitle:"java集合--&gt;json数组",charIndex:null},{level:3,title:"json数组--\x3ejava集合",slug:"json数组-java集合",normalizedTitle:"json数组--&gt;java集合",charIndex:null}],headersStr:"JSON 访问 JSON与Java对象的转换 java--\x3ejson json--\x3ejava java集合--\x3ejson数组 json数组--\x3ejava集合",content:'# JSON\n\nJSON 语法是 JavaScript 对象表示语法的子集\n\n * 数据在名称/值对中\n * 数据由逗号分隔\n * 花括号保存对象\n * 方括号保存数组\n\nvar 变量名 = {\n\t"key" : value , // Number类型\n\t"key2" : "value" , // 字符串类型\n\t"key3" : [] , // 数组类型\n\t"key4" : {}, // json 对象类型\n\t"key5" : [{},{}] // json 数组\n};\n\n\nJSON 值\n\n * 数字（整数或浮点数）\n * 字符串（在双引号中）\n * 布尔值（true 或 false）\n * 数组（在方括号中）\n * 对象（在花括号中）\n * null\n\n\n# JSON 访问\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n</head>\n\n    <script type="text/javascript">\n\n        //json访问\n        var json1 = {name:"张三",age:12};\n        document.write("name: "+json1.name+"<br/>");\n        document.write("age: "+json1.age+"<br/><br/>");\n\n        //json数组访问\n        var json2 = {names:["张三","李四","王五"]};\n        document.write("name(0): "+json2.names[0]+"<br/>");\n        document.write("name(1): "+json2.names[1]+"<br/>");\n        document.write("name(2): "+json2.names[2]+"<br/><br/>");\n\n        //json嵌套访问\n        var json3 = {names:[{"name":"张三","age":18},{"name":"李四","age":19},{"name":"王五","age":"20"}]};\n        document.write(json3.names[0].name+"<br/>");\n        document.write(json3.names[2].name+"  ");\n        document.write(json3.names[2].age+"<br/>");\n\n    <\/script>\n\n<body>\n    \n</body>\n</html>\n\n\n\n# JSON与Java对象的转换\n\njson与java对象转换的前提需要\n\njar依赖包 点击下载\n\n实体类：\n\n> MyUser 属性： name、age 方法： get、set、构造(全参、无参)、toString\n\n\n# java--\x3ejson\n\nMyUser user = new MyUser("张三" , 18);\nJSONObject jsonObject = JSONObject.fromObject(user);\nSystem.out.println("json: " + jsonObject);\n\n/*\njson: {"age":18,"name":"张三"}\n*/\n\n\n\n# json--\x3ejava\n\nString str = "{\'age\':19,\'name\':\'李四\'}";\nJSONObject json = JSONObject.fromObject(str);\nMyUser user2 = (MyUser) JSONObject.toBean(json, MyUser.class);\nSystem.out.println("user2 : " + user2);\n\n/*\nuser2 : user{name=\'李四\', age=19}\n*/\n\n\n\n# java集合--\x3ejson数组\n\nList list = new ArrayList();\nlist.add(new MyUser("张三" , 18));\nlist.add(new MyUser("李四" , 19));\nlist.add(new MyUser("王五" , 20));\nJSONArray jsonArray = JSONArray.fromObject(list);\nSystem.out.println("jsonArray : " + jsonArray);\n\n/*\njsonArray : [{"age":18,"name":"张三"},{"age":19,"name":"李四"},{"age":20,"name":"王五"}]\n*/\n\n\n\n# json数组--\x3ejava集合\n\n方法1\n\nString str2 = "[{\'age\':11,\'name\':\'张三\'},{\'age\':22,\'name\':\'李四\'},{\'age\':33,\'name\':\'王五\'}]";\nJSONArray jsonArray2 = JSONArray.fromObject(str2);\nObject[] objects = (Object[]) JSONArray.toArray(jsonArray2,MyUser.class);\nSystem.out.println("遍历java集合=========1");\nfor (Object object : objects) {\n    System.out.println(object);\n}\n\n/*\n遍历java集合=========1\nuser{name=\'张三\', age=11}\nuser{name=\'李四\', age=22}\nuser{name=\'王五\', age=33}\n*/\n\n\n方法2\n\nString str3 = "[{\'age\':111,\'name\':\'张三\'},{\'age\':222,\'name\':\'李四\'},{\'age\':333,\'name\':\'王五\'}]";\nJSONArray jsonArray3 = JSONArray.fromObject(str3);\nList<MyUser> list2 = (List<MyUser>) JSONArray.toCollection(jsonArray3,MyUser.class);\nSystem.out.println("遍历java集合=========2");\nfor (MyUser tmp : list2) {\n    System.out.println(tmp);\n}\n\n/*\n遍历java集合=========2\nuser{name=\'张三\', age=111}\nuser{name=\'李四\', age=222}\nuser{name=\'王五\', age=333}\n*/\n',normalizedContent:'# json\n\njson 语法是 javascript 对象表示语法的子集\n\n * 数据在名称/值对中\n * 数据由逗号分隔\n * 花括号保存对象\n * 方括号保存数组\n\nvar 变量名 = {\n\t"key" : value , // number类型\n\t"key2" : "value" , // 字符串类型\n\t"key3" : [] , // 数组类型\n\t"key4" : {}, // json 对象类型\n\t"key5" : [{},{}] // json 数组\n};\n\n\njson 值\n\n * 数字（整数或浮点数）\n * 字符串（在双引号中）\n * 布尔值（true 或 false）\n * 数组（在方括号中）\n * 对象（在花括号中）\n * null\n\n\n# json 访问\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>title</title>\n</head>\n\n    <script type="text/javascript">\n\n        //json访问\n        var json1 = {name:"张三",age:12};\n        document.write("name: "+json1.name+"<br/>");\n        document.write("age: "+json1.age+"<br/><br/>");\n\n        //json数组访问\n        var json2 = {names:["张三","李四","王五"]};\n        document.write("name(0): "+json2.names[0]+"<br/>");\n        document.write("name(1): "+json2.names[1]+"<br/>");\n        document.write("name(2): "+json2.names[2]+"<br/><br/>");\n\n        //json嵌套访问\n        var json3 = {names:[{"name":"张三","age":18},{"name":"李四","age":19},{"name":"王五","age":"20"}]};\n        document.write(json3.names[0].name+"<br/>");\n        document.write(json3.names[2].name+"  ");\n        document.write(json3.names[2].age+"<br/>");\n\n    <\/script>\n\n<body>\n    \n</body>\n</html>\n\n\n\n# json与java对象的转换\n\njson与java对象转换的前提需要\n\njar依赖包 点击下载\n\n实体类：\n\n> myuser 属性： name、age 方法： get、set、构造(全参、无参)、tostring\n\n\n# java--\x3ejson\n\nmyuser user = new myuser("张三" , 18);\njsonobject jsonobject = jsonobject.fromobject(user);\nsystem.out.println("json: " + jsonobject);\n\n/*\njson: {"age":18,"name":"张三"}\n*/\n\n\n\n# json--\x3ejava\n\nstring str = "{\'age\':19,\'name\':\'李四\'}";\njsonobject json = jsonobject.fromobject(str);\nmyuser user2 = (myuser) jsonobject.tobean(json, myuser.class);\nsystem.out.println("user2 : " + user2);\n\n/*\nuser2 : user{name=\'李四\', age=19}\n*/\n\n\n\n# java集合--\x3ejson数组\n\nlist list = new arraylist();\nlist.add(new myuser("张三" , 18));\nlist.add(new myuser("李四" , 19));\nlist.add(new myuser("王五" , 20));\njsonarray jsonarray = jsonarray.fromobject(list);\nsystem.out.println("jsonarray : " + jsonarray);\n\n/*\njsonarray : [{"age":18,"name":"张三"},{"age":19,"name":"李四"},{"age":20,"name":"王五"}]\n*/\n\n\n\n# json数组--\x3ejava集合\n\n方法1\n\nstring str2 = "[{\'age\':11,\'name\':\'张三\'},{\'age\':22,\'name\':\'李四\'},{\'age\':33,\'name\':\'王五\'}]";\njsonarray jsonarray2 = jsonarray.fromobject(str2);\nobject[] objects = (object[]) jsonarray.toarray(jsonarray2,myuser.class);\nsystem.out.println("遍历java集合=========1");\nfor (object object : objects) {\n    system.out.println(object);\n}\n\n/*\n遍历java集合=========1\nuser{name=\'张三\', age=11}\nuser{name=\'李四\', age=22}\nuser{name=\'王五\', age=33}\n*/\n\n\n方法2\n\nstring str3 = "[{\'age\':111,\'name\':\'张三\'},{\'age\':222,\'name\':\'李四\'},{\'age\':333,\'name\':\'王五\'}]";\njsonarray jsonarray3 = jsonarray.fromobject(str3);\nlist<myuser> list2 = (list<myuser>) jsonarray.tocollection(jsonarray3,myuser.class);\nsystem.out.println("遍历java集合=========2");\nfor (myuser tmp : list2) {\n    system.out.println(tmp);\n}\n\n/*\n遍历java集合=========2\nuser{name=\'张三\', age=111}\nuser{name=\'李四\', age=222}\nuser{name=\'王五\', age=333}\n*/\n',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Ajax",frontmatter:{title:"Ajax",author:"柏竹",permalink:"/backend/s9wrzy",date:"2020-02-18T00:00:00.000Z",categories:["后端","JavaWeb"],tags:["Ajax"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/02.JavaWeb/07.AJAX%E5%BA%94%E7%94%A8.html",relativePath:"01.后端/02.JavaWeb/07.AJAX应用.md",key:"v-302a0722",path:"/backend/s9wrzy/",headers:[{level:2,title:"Ajax工作原理",slug:"ajax工作原理",normalizedTitle:"ajax工作原理",charIndex:230},{level:2,title:"Ajax对象",slug:"ajax对象",normalizedTitle:"ajax对象",charIndex:378},{level:3,title:"核心对象",slug:"核心对象",normalizedTitle:"核心对象",charIndex:389},{level:3,title:"属性",slug:"属性",normalizedTitle:"属性",charIndex:619},{level:3,title:"方法",slug:"方法",normalizedTitle:"方法",charIndex:82},{level:2,title:"Ajax应用",slug:"ajax应用",normalizedTitle:"ajax应用",charIndex:1806},{level:3,title:"对象创建",slug:"对象创建",normalizedTitle:"对象创建",charIndex:1880},{level:3,title:"请求方式",slug:"请求方式",normalizedTitle:"请求方式",charIndex:1851},{level:4,title:"GET 请求",slug:"get-请求",normalizedTitle:"get 请求",charIndex:2323},{level:4,title:"POST 请求",slug:"post-请求",normalizedTitle:"post 请求",charIndex:2496},{level:3,title:"响应回调",slug:"响应回调",normalizedTitle:"响应回调",charIndex:3082},{level:3,title:"发送请求",slug:"发送请求",normalizedTitle:"发送请求",charIndex:1871},{level:2,title:"JQ实现Ajax请求",slug:"jq实现ajax请求",normalizedTitle:"jq实现ajax请求",charIndex:3978},{level:3,title:"ajax()",slug:"ajax-2",normalizedTitle:"ajax()",charIndex:3993},{level:3,title:"get()",slug:"get",normalizedTitle:"get()",charIndex:4658},{level:3,title:"post()",slug:"post",normalizedTitle:"post()",charIndex:4815}],headersStr:"Ajax工作原理 Ajax对象 核心对象 属性 方法 Ajax应用 对象创建 请求方式 GET 请求 POST 请求 响应回调 发送请求 JQ实现Ajax请求 ajax() get() post()",content:'# Ajax\n\nAJAX 是一种用于创建快速动态网页的技术 是 HTML/XHTML 、 CSS 、 JavaScript/DOM 知识的结合应用，结合出的新技术新方法 通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。可在不重新加载整个网页的情况下，对网页的某部分进行更新\n\nJQUery中文API1：https://www.jquery123.com/\n\nJQUery中文API2：https://jqueryapi.net/\n\n\n# Ajax工作原理\n\nAjax的工作原理相当于在用户和服务器之间加了—个中间层(AJAX引擎)，客户端操作与服务器响应异步化。并不是所有的用户请求都提交给服务器，只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。\n\n点击异步了解\n\n以下图片服务器处理为单线程！！！\n\n\n\n\n# Ajax对象\n\n\n# 核心对象\n\n不同的浏览器 加载使用的对象是不一样的，可分为两种：\n\n * XMLHttpRequest ：AJAX核心对象 （用于常规的浏览器 ==let xmlHttp = new XMLHttpRequest()==\n * ActiveXObject ：IE 浏览器 ==let xmlHttp = new ActiveXObject("Microsoft.XMLHTTP");==\n\n判断浏览器类型的 ==window.XMLHttpRequest== 属性 返回的布尔值进行判断 （false 为 IE浏览器\n\n\n# 属性\n\n常用属性                 说明\nonreadystatechange   处理服务器响应的函数\nreadyState           服务器响应的状态信息\nresponseText         取回由服务器返回的数据\nstatus               服务器的HTTP状态码\n更多属性                 说明\nresponseXML          服务器的响应(返回DOM的XML文档对象)\nresponseBody         服务器返回的主题(非文本)\nresponseStream       服务器返回的数据流\nstatusText           服务器返回的状态文本信息(对应HTTP状态码文本信息)\n\nreadyState属性状态说明\n\nREADYSTATE值   说明\n0             请求未初始化(调用open()之前)\n1             请求已提出(调用send()之前)\n2             请求已发送(从响应得到内容头部)\n3             请求处理中(响应中，数据可用，但服务器未完成)\n4             请求已完成(可以访问响应的结果并使用)\n\n点击了解status属性状态码\n\n\n# 方法\n\n常用方法                                                 说明\n==open(String method, String url, boolean async)==   设置请求的类型、URL 以及是否异步处理请求\n==send(String string)==                              将请求发送到服务器\n                                                     POST请求需要传递参数\n更多方法                                                 说明\n==abort()==                                          停止当前请求\n==getAllResponseHeaders()==                          把HTTP请求的所有响应首部 键/值 返回\n==getResponseHeader()==                              返回指定首部的串值\n==setRequestHeader(String header, String value)==    向请求添加 HTTP 头\n\n\n# Ajax应用\n\n应用步骤：\n\n 1. 创建 XMLHttpRequest对象\n 2. 设置请求方式\n 3. 调用回调函数\n 4. 发送请求\n\n\n# 对象创建\n\n对象创建说明：\n\n> XMLHttpRequest对象\n> \n> variable=new XMLHttpRequest();\n> \n> \n> 老版本浏览器ActiveXObject对象\n> \n> variable=new ActiveXObject("Microsoft.XMLHTTP");\n> \n> \n> 所有浏览器对象创建\n> \n> var xmlHttp;\n> if (window.XMLHttpRequest) {\n>  xmlHttp = new XMLHttpRequest();\n> } else {  //照顾 IE使用者\n>  if (window.ActiveXObject) {\n>      xmlHttp = new ActiveXObject("Microsoft.XMLHTTP");\n>  }\n> }\n\n\n# 请求方式\n\n请求类型分为 ： Get 、Post两种 请求发送到服务器，需要用到 open() 和 send() 方法\n\n# GET 请求\n\n例子：向服务器发送 testGet 的请求\n\n//无信息\nxmlHttp.open("get","testGet",true);\nxmlHttp.send();\n//为url添加信息\nxmlHttp.open("get","testGet?name=\'张三\'&age=23",true);\nxmlHttp.send();\n\n\n# POST 请求\n\n例子：向服务器发送 testPost 的请求 使用post请求需要配置：xmlHttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");\n\n//无信息\nxmlHttp.open("post","testPost",true);\nxmlHttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");\nxmlHttp.send();\n//有信息\nxmlHttp.open("post","testPost",true);\nxmlHttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");\nvar name = "张三";\nxmlHttp.send("name="+name+"&age=23");\n\n\n注意：\n\n>  * get请求 单次数据上传有限\n>  * 非 隐私/重要 数据交互用 get请求\n>  * 大量数据交互用 post请求\n>  * open() 最后参数是控制是否异步，一般默认true\n>  * post请求 需要 setRequestHeader() 的配置\n\n\n# 响应回调\n\n回调函数，就是请求在后台处理完，再返回到前台所实现的功能（服务器响应后执行的任务） 回调需要显示在页面中因此需要 xmlHttp.onreadystatechange 属性返回匿名的函数进行页面交互\n\nxmlhttp.onreadystatechange=function(){\n     var mydiv = document.getElementById("myDiv");\n     if (xmlhttp.readyState==4 && xmlhttp.status==200){\n     \tmydiv.innerHTML=xmlHttp.responseText;\n     }else{\n     \tmydiv.innerHTML="异常："+xmlhttp.status;\n     }\n}\n\n\n服务器响应\n\nresponseText属性 接收 字符串形式 的响应数据 Response响应 需要 PrintWriter流 进行输出 字符串形式的响应数据\n\nPrintWriter writer = response.getWriter();\nwriter.println("输出内容");\n\n//页面获取方式\nvar text = xmlHttp.responseText;\n\n\nresponseXML属性 接收 XML形式 响应的数据 ...（后面更新）\n\n\n# 发送请求\n\n请求发送可 通过 send() 方法直接发送\n\n//get请求\nxmlHttp.send();\n//post请求\nxmlHttp.open("post","testPost",true);\n// 增加time随机参数，防⽌读取缓存\n// 向请求添加 HTTP 头，POST如果有数据一定加！！！！\nxmlHttp.setRequestHeader("Content-type","application/x-www-form-urlencoded");\nvar urlInfo = "name=\'张三\'&age=23" ;\nxmlHttp.send(urlInfo);\n\n\n\n# JQ实现Ajax请求\n\n\n# ajax()\n\n$.ajax( [settings]); settings参数列表，用于配置 Ajax 请求的键值对集合\n\nSETTINGS属性   类型 [默认值]         说明\nurl          String           请求地址\nasync        Boolean [true]   是否启动异步请求\ndata         JSON/String      发送到服务器的数据\ntype         <请求类型>           GET/PSOT\ndataType     String           预期的返回数据的类型 xml/html/script/json...\nsuccess      function()       请求成功后的回调函数\nerror        function()       请求失败时调用此函数\n\n$.ajax({\n    url: "/textChange",\n    type: "post",\n    data: {"name": "张三", "password": "123123"},\n    dataType: "text",\n    //指定 标签p 进行响应测试\n    success: function (rs) {\n        $("p").html(rs);\n    },\n    error: function (rs) {\n        $("p").html(rs);\n    }\n});\n\n\n\n# get()\n\n==$.get(url , data , function(result) {});==\n\n $.get("textChange", "name=张三&password=123123", function (result) {\n     $("p").html(result);\n });\n\n\n\n# post()\n\n==$.post(url , data , function(result){});==\n\n $.post("textChange", "name=张三&password=123123", function (result) {\n     $("p").html(result);\n });\n',normalizedContent:'# ajax\n\najax 是一种用于创建快速动态网页的技术 是 html/xhtml 、 css 、 javascript/dom 知识的结合应用，结合出的新技术新方法 通过在后台与服务器进行少量数据交换，ajax 可以使网页实现异步更新。可在不重新加载整个网页的情况下，对网页的某部分进行更新\n\njquery中文api1：https://www.jquery123.com/\n\njquery中文api2：https://jqueryapi.net/\n\n\n# ajax工作原理\n\najax的工作原理相当于在用户和服务器之间加了—个中间层(ajax引擎)，客户端操作与服务器响应异步化。并不是所有的用户请求都提交给服务器，只有确定需要从服务器读取新数据时再由ajax引擎代为向服务器提交请求。\n\n点击异步了解\n\n以下图片服务器处理为单线程！！！\n\n\n\n\n# ajax对象\n\n\n# 核心对象\n\n不同的浏览器 加载使用的对象是不一样的，可分为两种：\n\n * xmlhttprequest ：ajax核心对象 （用于常规的浏览器 ==let xmlhttp = new xmlhttprequest()==\n * activexobject ：ie 浏览器 ==let xmlhttp = new activexobject("microsoft.xmlhttp");==\n\n判断浏览器类型的 ==window.xmlhttprequest== 属性 返回的布尔值进行判断 （false 为 ie浏览器\n\n\n# 属性\n\n常用属性                 说明\nonreadystatechange   处理服务器响应的函数\nreadystate           服务器响应的状态信息\nresponsetext         取回由服务器返回的数据\nstatus               服务器的http状态码\n更多属性                 说明\nresponsexml          服务器的响应(返回dom的xml文档对象)\nresponsebody         服务器返回的主题(非文本)\nresponsestream       服务器返回的数据流\nstatustext           服务器返回的状态文本信息(对应http状态码文本信息)\n\nreadystate属性状态说明\n\nreadystate值   说明\n0             请求未初始化(调用open()之前)\n1             请求已提出(调用send()之前)\n2             请求已发送(从响应得到内容头部)\n3             请求处理中(响应中，数据可用，但服务器未完成)\n4             请求已完成(可以访问响应的结果并使用)\n\n点击了解status属性状态码\n\n\n# 方法\n\n常用方法                                                 说明\n==open(string method, string url, boolean async)==   设置请求的类型、url 以及是否异步处理请求\n==send(string string)==                              将请求发送到服务器\n                                                     post请求需要传递参数\n更多方法                                                 说明\n==abort()==                                          停止当前请求\n==getallresponseheaders()==                          把http请求的所有响应首部 键/值 返回\n==getresponseheader()==                              返回指定首部的串值\n==setrequestheader(string header, string value)==    向请求添加 http 头\n\n\n# ajax应用\n\n应用步骤：\n\n 1. 创建 xmlhttprequest对象\n 2. 设置请求方式\n 3. 调用回调函数\n 4. 发送请求\n\n\n# 对象创建\n\n对象创建说明：\n\n> xmlhttprequest对象\n> \n> variable=new xmlhttprequest();\n> \n> \n> 老版本浏览器activexobject对象\n> \n> variable=new activexobject("microsoft.xmlhttp");\n> \n> \n> 所有浏览器对象创建\n> \n> var xmlhttp;\n> if (window.xmlhttprequest) {\n>  xmlhttp = new xmlhttprequest();\n> } else {  //照顾 ie使用者\n>  if (window.activexobject) {\n>      xmlhttp = new activexobject("microsoft.xmlhttp");\n>  }\n> }\n\n\n# 请求方式\n\n请求类型分为 ： get 、post两种 请求发送到服务器，需要用到 open() 和 send() 方法\n\n# get 请求\n\n例子：向服务器发送 testget 的请求\n\n//无信息\nxmlhttp.open("get","testget",true);\nxmlhttp.send();\n//为url添加信息\nxmlhttp.open("get","testget?name=\'张三\'&age=23",true);\nxmlhttp.send();\n\n\n# post 请求\n\n例子：向服务器发送 testpost 的请求 使用post请求需要配置：xmlhttp.setrequestheader("content-type","application/x-www-form-urlencoded");\n\n//无信息\nxmlhttp.open("post","testpost",true);\nxmlhttp.setrequestheader("content-type","application/x-www-form-urlencoded");\nxmlhttp.send();\n//有信息\nxmlhttp.open("post","testpost",true);\nxmlhttp.setrequestheader("content-type","application/x-www-form-urlencoded");\nvar name = "张三";\nxmlhttp.send("name="+name+"&age=23");\n\n\n注意：\n\n>  * get请求 单次数据上传有限\n>  * 非 隐私/重要 数据交互用 get请求\n>  * 大量数据交互用 post请求\n>  * open() 最后参数是控制是否异步，一般默认true\n>  * post请求 需要 setrequestheader() 的配置\n\n\n# 响应回调\n\n回调函数，就是请求在后台处理完，再返回到前台所实现的功能（服务器响应后执行的任务） 回调需要显示在页面中因此需要 xmlhttp.onreadystatechange 属性返回匿名的函数进行页面交互\n\nxmlhttp.onreadystatechange=function(){\n     var mydiv = document.getelementbyid("mydiv");\n     if (xmlhttp.readystate==4 && xmlhttp.status==200){\n     \tmydiv.innerhtml=xmlhttp.responsetext;\n     }else{\n     \tmydiv.innerhtml="异常："+xmlhttp.status;\n     }\n}\n\n\n服务器响应\n\nresponsetext属性 接收 字符串形式 的响应数据 response响应 需要 printwriter流 进行输出 字符串形式的响应数据\n\nprintwriter writer = response.getwriter();\nwriter.println("输出内容");\n\n//页面获取方式\nvar text = xmlhttp.responsetext;\n\n\nresponsexml属性 接收 xml形式 响应的数据 ...（后面更新）\n\n\n# 发送请求\n\n请求发送可 通过 send() 方法直接发送\n\n//get请求\nxmlhttp.send();\n//post请求\nxmlhttp.open("post","testpost",true);\n// 增加time随机参数，防⽌读取缓存\n// 向请求添加 http 头，post如果有数据一定加！！！！\nxmlhttp.setrequestheader("content-type","application/x-www-form-urlencoded");\nvar urlinfo = "name=\'张三\'&age=23" ;\nxmlhttp.send(urlinfo);\n\n\n\n# jq实现ajax请求\n\n\n# ajax()\n\n$.ajax( [settings]); settings参数列表，用于配置 ajax 请求的键值对集合\n\nsettings属性   类型 [默认值]         说明\nurl          string           请求地址\nasync        boolean [true]   是否启动异步请求\ndata         json/string      发送到服务器的数据\ntype         <请求类型>           get/psot\ndatatype     string           预期的返回数据的类型 xml/html/script/json...\nsuccess      function()       请求成功后的回调函数\nerror        function()       请求失败时调用此函数\n\n$.ajax({\n    url: "/textchange",\n    type: "post",\n    data: {"name": "张三", "password": "123123"},\n    datatype: "text",\n    //指定 标签p 进行响应测试\n    success: function (rs) {\n        $("p").html(rs);\n    },\n    error: function (rs) {\n        $("p").html(rs);\n    }\n});\n\n\n\n# get()\n\n==$.get(url , data , function(result) {});==\n\n $.get("textchange", "name=张三&password=123123", function (result) {\n     $("p").html(result);\n });\n\n\n\n# post()\n\n==$.post(url , data , function(result){});==\n\n $.post("textchange", "name=张三&password=123123", function (result) {\n     $("p").html(result);\n });\n',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"JspSmartUpload应用",frontmatter:{title:"JspSmartUpload应用",author:"柏竹",permalink:"/backend/r5xd4s",date:"2020-02-18T00:00:00.000Z",categories:["后端","JavaWeb"],tags:["Jsp"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/02.JavaWeb/09.%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD.html",relativePath:"01.后端/02.JavaWeb/09.文件上传下载.md",key:"v-3f4e8dea",path:"/backend/r5xd4s/",headers:[{level:4,title:"File",slug:"file",normalizedTitle:"file",charIndex:76},{level:4,title:"Files",slug:"files",normalizedTitle:"files",charIndex:591},{level:4,title:"Request",slug:"request",normalizedTitle:"request",charIndex:827},{level:4,title:"SmartUpload",slug:"smartupload",normalizedTitle:"smartupload",charIndex:5},{level:2,title:"文件上传",slug:"文件上传",normalizedTitle:"文件上传",charIndex:846},{level:2,title:"文件下载",slug:"文件下载",normalizedTitle:"文件下载",charIndex:3587},{level:2,title:"代码实例",slug:"代码实例",normalizedTitle:"代码实例",charIndex:4648}],headersStr:"File Files Request SmartUpload 文件上传 文件下载 代码实例",content:'# JspSmartUpload应用\n\njspSmartUp是一种早期流行的使用框架，适合于上传小型的文件，具有灵活性简单高效。 使用方法很简单\n\n# File\n\nFile类 包装上传文件的所有信息。通过 File类 可 获取/设置 文件的相关信息\n\n常用方法\n\n返回        方法                             说明\nboolean   isMissing()                    判断文件是否对应表单的\nvoid      saveAs(String url, int type)   将文件进行保存\nString    getFieldName()                 获取 文件的表单name属性值\nString    getFileName()                  获取 上传文件名称\nString    getFilePathName()              获取 文件全名\nlong      getSize()                      获取 文件长度(字节)\nString    getFileExt()                   获取 文件扩展名\nvoid      setCharset(String charset)     设置 编码字符集\n\n# Files\n\nFiles类表示所有上传文件的集合\n\n常用方法\n\n返回     方法                      说明\nvoid   addFile(File newFile)   添加 新文件进集合\nint    getCount()              获取 上传文件的个数\nlong   getSize()               获取 上传文件大小(字节)\nFile   getFile(int index)      获取 指定文件\n\n# Request\n\nRequest类表示文件上传表单，request对象 无法获得表单中的name属性值，必须通过依赖包里的 com.jspsmart.upload.Request对象 来获取name属性值\n\n常用方法\n\n返回         方法                                说明\nString     getParameter(String name)         获取 指定表单name属性值的value值\nString[]   getParameterValues(String name)   获取 指定表单name属性值的多个value值\n\n# SmartUpload\n\n常用方法\n\n返回        方法                                                 说明\nvoid      initialize()                                       上传和下载的初始化配置\nvoid      upload()                                           上传操作，在初始化配置后执行\nint       save(String pathName)                              上传保存后，返回保存文件数\nvoid      setContentDisposition(string contentdisposition)   提示文件是否添加额外信息contentdisposition参数：\n                                                             Content-Disposition、attachment == null (效果一样)\nvoid      downloadFile(String url)                           指定下载路径的文件\nFiles     getFiles()                                         获取 上传的所有文件\nRequest   getRequest()                                       获取 上传表单请求数据\nvoid      setMaxFileSize(long filesize)                      设置 单个文件大小 (字节)\nvoid      setTotalMaxFileSize(long allfilesize)              设置 总文件大小 (字节)\nvoid      setAllowedFilesList(String form)                   设置 限制文件类型(多个类型分号分割)\n\n\n# 文件上传\n\n实现步骤：\n\n>  1. 导入依赖包\n> \n>  2. 实例 SmartUpload对象 (用于创建上传对象)\n> \n>  3. 初始化配置上传文件 方式/限制 ，SmartUpload.initialize()方法 进行初始化配置\n> \n>  4. 进行上传文件 ，SmartUpload.upload()方法 上传文件\n> \n>  5. 通过 com.jspsmart.upload.File对象 得到文件，通过以下方式获取名称\n>     \n>     //·····\n>     Files files = smartUpload.getFiles();\n>     File file = files.getFile(0);\n>     String fileName = file.getFileName();\n>     \n> \n>  6. 对文件进行保存，File.saveAs()方法 上传保存的位置 保存类型、目录位置是否存在！\n\n注意：\n\n>  * form表单 提交类型为post\n> \n>  * form表单 必须添加属性：==enctype="multipart/form-data"== (以二进制形式处理表单元素)\n> \n>  * input组件 添加 自定义name属性值\n> \n>  * input组件 添加 ==multiple="multiple"== 属性值 可选择多个文件\n> \n>  * 服务端 提取表单数据方式：（因设置了二进制形式获取值的方式也不一样 ==SmartUpload.getRequest().getParameter("name属性值");==\n>    \n>    SmartUpload sup = new SmartUpload();\n>    //初始化配置。。。。\n>    String uname = sup.getRequest().getParameter("username");\n>    \n\n快速初始化配置\n\nSmartUpload sup = new SmartUpload();\nPageContext pageContext = JspFactory.getDefaultFactory()\n        .getPageContext(this,req,resp,null,false,1024,true);\nsup.initialize(pageContext);\n\n\nJspFactory.getPageContext()方法说明\n\npublic abstract PageContext getPageContext(Servlet servlet, ServletRequest req, ServletResponse resp, String errorPageURL, boolean needsSession, int buffer boolean autoflush)\n\n\n参数             说明\nservlet        请求的servlet，在servlet中传this即可\nreq            servlet上挂起的当前请求\nresp           servlet上挂起的当前响应\nerrorPageURL   请求JSP的错误页面的URL，或null\nneedsSession   是否需要session\nbuffer         以字节为单位的缓冲区大小\nautoflush      缓冲区溢出时是否 自动刷新到输出流\n\n\n# 文件下载\n\n实现步骤：\n\n> 方式1\n> \n>  1. 导入依赖包\n> \n>  2. 实例 SmartUpload对象 (用于创建上传对象)\n> \n>  3. 初始化配置文件 方式/限制 ，SmartUpload.initialize()方法 进行初始化配置\n> \n>  4. 设置 禁止浏览器自动打开，SmartUpload.setContentDisposition(null)\n> \n>  5. 获取指定文件路径，和请求中的文件名\n>     \n>     //假设：web/test/image.png 、name = image.png\n>     String name = req.getParameter("file");\n>     String url = "test/"+name;\n>     \n> \n>  6. 下载指定路径文件 SmartUpload.downloadFile(url)\n> \n> 方式2\n> \n>  1. 导入依赖包\n> \n>  2. 获取下载的文件，在请求参数中获取 文件名\n> \n>  3. 设置 响应内容，调用 HttpServletResponse.setContentType()方法 ，将响应内容设置为通用的二进制流\n>     \n>     resp.setContentType("application/octet-stream");\n>     \n> \n>  4. 添加响应头，调用 HttpServletResponse.addHeader()方法 设置响应头\n>     \n>     //......\n>     //配置名称设置编码集\n>     name = URLEncoder.encode(name, StandardCharsets.UTF_8);\n>     resp.addHeader("Content-Disposition","attachment;filename="+name);\n>     \n> \n>  5. 响应转送下载\n>     \n>     //假设路径：web/test/image.png 、name = image.png\n>     String url = "test/image.png"+name;\n>     req.getRequestDispatcher(url).forward(req,resp);\n>     \n> \n>  6. 清空缓存 resp.flushBuffer()\n\n\n# 代码实例\n\nindex.jsp\n\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>$Title$</title>\n</head>\n<body>\n<h1>上传</h1>\n<form action="upload" method="post" enctype="multipart/form-data">\n    name: <input type="text" name="userName"> <br>\n    age: <input type="text" name="userAge"> <br>\n    image: <input type="file" name="image"> <br>\n    <input type="submit" value="上传信息">\n</form>\n</body>\n</html>\n\n\nsuccess.jsp\n\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n    <h1>接收Test</h1>\n    <p>userName: ${userName}</p>\n    <p>userAge: ${userAge}</p>\n    <p>image: <a href="download?file=${fileName}">${fileName}</a>(点击下载)</p>\n    <img src="test/${fileName}">\n</body>\n</html>\n\n\nUpload类（上传服务端）\n\npackage servlet;\n\nimport com.jspsmart.upload.*;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\n\n/**\n * @Author: 柏竹\n * @Description: 一个简洁主义...\n * @Date_Created_in: 2021-04-29 16:49\n * @Modified_By: Sans\n * @Project: 上传服务端\n */\n@WebServlet(urlPatterns = "/upload")\npublic class Upload extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req , HttpServletResponse resp) throws ServletException, IOException {\n        doPost(req , resp);\n    }\n    \n    @Override\n    protected void doPost(HttpServletRequest req , HttpServletResponse resp) throws ServletException, IOException {\n        \n        try {\n            //实例SmartUpload\n            SmartUpload upload = new SmartUpload();\n            //初始化配置SmartUpload\n            upload.initialize(this.getServletConfig(), req, resp);\n            upload.setCharset("utf-8");\n            upload.setAllowedFilesList("jpg,png");\n            upload.setMaxFileSize(2 * 1024 * 1024);\n            upload.setAllowedFilesList("jpg,png");\n            //上传\n            upload.upload();\n            //获取文件信息\n            Files files = upload.getFiles();\n            File file = files.getFile(0);\n            String fileName = file.getFileName();\n            String url = "test/"+fileName;\n            //保存上传指定目录\n            file.saveAs(url,1);\n            //获取表单数据并存储\n            Request request = upload.getRequest();\n            req.setAttribute("userName",request.getParameter("userName"));\n            req.setAttribute("userAge",request.getParameter("userAge"));\n            req.setAttribute("fileName",fileName);\n            req.getRequestDispatcher("success.jsp").forward(req,resp);\n        } catch (SmartUploadException e) {\n            e.printStackTrace();\n        }\n    \n    }\n}\n\n\nDownload类（下载服务端）\n\npackage servlet;\n\nimport com.jspsmart.upload.SmartUpload;\nimport com.jspsmart.upload.SmartUploadException;\n\nimport javax.servlet.ServletException;\nimport javax.servlet.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport java.io.IOException;\nimport java.net.URLEncoder;\nimport java.nio.charset.StandardCharsets;\n\n/**\n * @Author: 柏竹\n * @Description: 一个简洁主义...\n * @Date_Created_in: 2021-04-29 17:13\n * @Modified_By: Sans\n * @Project: 下载服务端\n */\n@WebServlet(urlPatterns = "/download")\npublic class Download extends HttpServlet {\n    @Override\n    protected void doGet(HttpServletRequest req , HttpServletResponse resp) throws ServletException, IOException {\n        doPost(req , resp);\n    }\n    \n    @Override\n    protected void doPost(HttpServletRequest req , HttpServletResponse resp) throws ServletException, IOException {\n        String name = req.getParameter("file");\n        String url = "test/"+name;\n        System.out.println(url);\n    \n        //方式1\n        SmartUpload sup = new SmartUpload();\n        sup.initialize(this.getServletConfig(), req, resp);\n        // 设定contentDisposition为null以禁止浏览器自动打开文件\n        // 保证单击链接后下载文件\n        sup.setContentDisposition(null);\n        //指定下载的文件\n        try {\n            sup.downloadFile(url);\n        } catch (SmartUploadException e) {\n            e.printStackTrace();\n        }\n    \n        //方式2\n        /*\n        //将响应内容设置为通用的二进制流\n        resp.setContentType("application/octet-stream");\n        //attachment 告诉浏览器附件的方式为 下载文件（弹出下载框）\n        name = URLEncoder.encode(name, StandardCharsets.UTF_8);\n        resp.addHeader("Content-Disposition","attachment;filename="+name);\n    \n        req.getRequestDispatcher(url).forward(req,resp);\n        //清空缓存： 将服务端缓冲区的文件内容，立即权并不传递给客户端\n        resp.flushBuffer();\n        */\n    }\n}\n',normalizedContent:'# jspsmartupload应用\n\njspsmartup是一种早期流行的使用框架，适合于上传小型的文件，具有灵活性简单高效。 使用方法很简单\n\n# file\n\nfile类 包装上传文件的所有信息。通过 file类 可 获取/设置 文件的相关信息\n\n常用方法\n\n返回        方法                             说明\nboolean   ismissing()                    判断文件是否对应表单的\nvoid      saveas(string url, int type)   将文件进行保存\nstring    getfieldname()                 获取 文件的表单name属性值\nstring    getfilename()                  获取 上传文件名称\nstring    getfilepathname()              获取 文件全名\nlong      getsize()                      获取 文件长度(字节)\nstring    getfileext()                   获取 文件扩展名\nvoid      setcharset(string charset)     设置 编码字符集\n\n# files\n\nfiles类表示所有上传文件的集合\n\n常用方法\n\n返回     方法                      说明\nvoid   addfile(file newfile)   添加 新文件进集合\nint    getcount()              获取 上传文件的个数\nlong   getsize()               获取 上传文件大小(字节)\nfile   getfile(int index)      获取 指定文件\n\n# request\n\nrequest类表示文件上传表单，request对象 无法获得表单中的name属性值，必须通过依赖包里的 com.jspsmart.upload.request对象 来获取name属性值\n\n常用方法\n\n返回         方法                                说明\nstring     getparameter(string name)         获取 指定表单name属性值的value值\nstring[]   getparametervalues(string name)   获取 指定表单name属性值的多个value值\n\n# smartupload\n\n常用方法\n\n返回        方法                                                 说明\nvoid      initialize()                                       上传和下载的初始化配置\nvoid      upload()                                           上传操作，在初始化配置后执行\nint       save(string pathname)                              上传保存后，返回保存文件数\nvoid      setcontentdisposition(string contentdisposition)   提示文件是否添加额外信息contentdisposition参数：\n                                                             content-disposition、attachment == null (效果一样)\nvoid      downloadfile(string url)                           指定下载路径的文件\nfiles     getfiles()                                         获取 上传的所有文件\nrequest   getrequest()                                       获取 上传表单请求数据\nvoid      setmaxfilesize(long filesize)                      设置 单个文件大小 (字节)\nvoid      settotalmaxfilesize(long allfilesize)              设置 总文件大小 (字节)\nvoid      setallowedfileslist(string form)                   设置 限制文件类型(多个类型分号分割)\n\n\n# 文件上传\n\n实现步骤：\n\n>  1. 导入依赖包\n> \n>  2. 实例 smartupload对象 (用于创建上传对象)\n> \n>  3. 初始化配置上传文件 方式/限制 ，smartupload.initialize()方法 进行初始化配置\n> \n>  4. 进行上传文件 ，smartupload.upload()方法 上传文件\n> \n>  5. 通过 com.jspsmart.upload.file对象 得到文件，通过以下方式获取名称\n>     \n>     //·····\n>     files files = smartupload.getfiles();\n>     file file = files.getfile(0);\n>     string filename = file.getfilename();\n>     \n> \n>  6. 对文件进行保存，file.saveas()方法 上传保存的位置 保存类型、目录位置是否存在！\n\n注意：\n\n>  * form表单 提交类型为post\n> \n>  * form表单 必须添加属性：==enctype="multipart/form-data"== (以二进制形式处理表单元素)\n> \n>  * input组件 添加 自定义name属性值\n> \n>  * input组件 添加 ==multiple="multiple"== 属性值 可选择多个文件\n> \n>  * 服务端 提取表单数据方式：（因设置了二进制形式获取值的方式也不一样 ==smartupload.getrequest().getparameter("name属性值");==\n>    \n>    smartupload sup = new smartupload();\n>    //初始化配置。。。。\n>    string uname = sup.getrequest().getparameter("username");\n>    \n\n快速初始化配置\n\nsmartupload sup = new smartupload();\npagecontext pagecontext = jspfactory.getdefaultfactory()\n        .getpagecontext(this,req,resp,null,false,1024,true);\nsup.initialize(pagecontext);\n\n\njspfactory.getpagecontext()方法说明\n\npublic abstract pagecontext getpagecontext(servlet servlet, servletrequest req, servletresponse resp, string errorpageurl, boolean needssession, int buffer boolean autoflush)\n\n\n参数             说明\nservlet        请求的servlet，在servlet中传this即可\nreq            servlet上挂起的当前请求\nresp           servlet上挂起的当前响应\nerrorpageurl   请求jsp的错误页面的url，或null\nneedssession   是否需要session\nbuffer         以字节为单位的缓冲区大小\nautoflush      缓冲区溢出时是否 自动刷新到输出流\n\n\n# 文件下载\n\n实现步骤：\n\n> 方式1\n> \n>  1. 导入依赖包\n> \n>  2. 实例 smartupload对象 (用于创建上传对象)\n> \n>  3. 初始化配置文件 方式/限制 ，smartupload.initialize()方法 进行初始化配置\n> \n>  4. 设置 禁止浏览器自动打开，smartupload.setcontentdisposition(null)\n> \n>  5. 获取指定文件路径，和请求中的文件名\n>     \n>     //假设：web/test/image.png 、name = image.png\n>     string name = req.getparameter("file");\n>     string url = "test/"+name;\n>     \n> \n>  6. 下载指定路径文件 smartupload.downloadfile(url)\n> \n> 方式2\n> \n>  1. 导入依赖包\n> \n>  2. 获取下载的文件，在请求参数中获取 文件名\n> \n>  3. 设置 响应内容，调用 httpservletresponse.setcontenttype()方法 ，将响应内容设置为通用的二进制流\n>     \n>     resp.setcontenttype("application/octet-stream");\n>     \n> \n>  4. 添加响应头，调用 httpservletresponse.addheader()方法 设置响应头\n>     \n>     //......\n>     //配置名称设置编码集\n>     name = urlencoder.encode(name, standardcharsets.utf_8);\n>     resp.addheader("content-disposition","attachment;filename="+name);\n>     \n> \n>  5. 响应转送下载\n>     \n>     //假设路径：web/test/image.png 、name = image.png\n>     string url = "test/image.png"+name;\n>     req.getrequestdispatcher(url).forward(req,resp);\n>     \n> \n>  6. 清空缓存 resp.flushbuffer()\n\n\n# 代码实例\n\nindex.jsp\n\n<%@ page contenttype="text/html;charset=utf-8" language="java" %>\n<html>\n<head>\n    <title>$title$</title>\n</head>\n<body>\n<h1>上传</h1>\n<form action="upload" method="post" enctype="multipart/form-data">\n    name: <input type="text" name="username"> <br>\n    age: <input type="text" name="userage"> <br>\n    image: <input type="file" name="image"> <br>\n    <input type="submit" value="上传信息">\n</form>\n</body>\n</html>\n\n\nsuccess.jsp\n\n<%@ page contenttype="text/html;charset=utf-8" language="java" %>\n<html>\n<head>\n    <title>title</title>\n</head>\n<body>\n    <h1>接收test</h1>\n    <p>username: ${username}</p>\n    <p>userage: ${userage}</p>\n    <p>image: <a href="download?file=${filename}">${filename}</a>(点击下载)</p>\n    <img src="test/${filename}">\n</body>\n</html>\n\n\nupload类（上传服务端）\n\npackage servlet;\n\nimport com.jspsmart.upload.*;\n\nimport javax.servlet.servletexception;\nimport javax.servlet.annotation.webservlet;\nimport javax.servlet.http.httpservlet;\nimport javax.servlet.http.httpservletrequest;\nimport javax.servlet.http.httpservletresponse;\nimport java.io.ioexception;\n\n/**\n * @author: 柏竹\n * @description: 一个简洁主义...\n * @date_created_in: 2021-04-29 16:49\n * @modified_by: sans\n * @project: 上传服务端\n */\n@webservlet(urlpatterns = "/upload")\npublic class upload extends httpservlet {\n    @override\n    protected void doget(httpservletrequest req , httpservletresponse resp) throws servletexception, ioexception {\n        dopost(req , resp);\n    }\n    \n    @override\n    protected void dopost(httpservletrequest req , httpservletresponse resp) throws servletexception, ioexception {\n        \n        try {\n            //实例smartupload\n            smartupload upload = new smartupload();\n            //初始化配置smartupload\n            upload.initialize(this.getservletconfig(), req, resp);\n            upload.setcharset("utf-8");\n            upload.setallowedfileslist("jpg,png");\n            upload.setmaxfilesize(2 * 1024 * 1024);\n            upload.setallowedfileslist("jpg,png");\n            //上传\n            upload.upload();\n            //获取文件信息\n            files files = upload.getfiles();\n            file file = files.getfile(0);\n            string filename = file.getfilename();\n            string url = "test/"+filename;\n            //保存上传指定目录\n            file.saveas(url,1);\n            //获取表单数据并存储\n            request request = upload.getrequest();\n            req.setattribute("username",request.getparameter("username"));\n            req.setattribute("userage",request.getparameter("userage"));\n            req.setattribute("filename",filename);\n            req.getrequestdispatcher("success.jsp").forward(req,resp);\n        } catch (smartuploadexception e) {\n            e.printstacktrace();\n        }\n    \n    }\n}\n\n\ndownload类（下载服务端）\n\npackage servlet;\n\nimport com.jspsmart.upload.smartupload;\nimport com.jspsmart.upload.smartuploadexception;\n\nimport javax.servlet.servletexception;\nimport javax.servlet.annotation.webservlet;\nimport javax.servlet.http.httpservlet;\nimport javax.servlet.http.httpservletrequest;\nimport javax.servlet.http.httpservletresponse;\nimport java.io.ioexception;\nimport java.net.urlencoder;\nimport java.nio.charset.standardcharsets;\n\n/**\n * @author: 柏竹\n * @description: 一个简洁主义...\n * @date_created_in: 2021-04-29 17:13\n * @modified_by: sans\n * @project: 下载服务端\n */\n@webservlet(urlpatterns = "/download")\npublic class download extends httpservlet {\n    @override\n    protected void doget(httpservletrequest req , httpservletresponse resp) throws servletexception, ioexception {\n        dopost(req , resp);\n    }\n    \n    @override\n    protected void dopost(httpservletrequest req , httpservletresponse resp) throws servletexception, ioexception {\n        string name = req.getparameter("file");\n        string url = "test/"+name;\n        system.out.println(url);\n    \n        //方式1\n        smartupload sup = new smartupload();\n        sup.initialize(this.getservletconfig(), req, resp);\n        // 设定contentdisposition为null以禁止浏览器自动打开文件\n        // 保证单击链接后下载文件\n        sup.setcontentdisposition(null);\n        //指定下载的文件\n        try {\n            sup.downloadfile(url);\n        } catch (smartuploadexception e) {\n            e.printstacktrace();\n        }\n    \n        //方式2\n        /*\n        //将响应内容设置为通用的二进制流\n        resp.setcontenttype("application/octet-stream");\n        //attachment 告诉浏览器附件的方式为 下载文件（弹出下载框）\n        name = urlencoder.encode(name, standardcharsets.utf_8);\n        resp.addheader("content-disposition","attachment;filename="+name);\n    \n        req.getrequestdispatcher(url).forward(req,resp);\n        //清空缓存： 将服务端缓冲区的文件内容，立即权并不传递给客户端\n        resp.flushbuffer();\n        */\n    }\n}\n',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Stream流",frontmatter:{title:"Stream流",date:"2020-02-18T00:00:00.000Z",permalink:"/backend/c69655",categories:["后端","Java"],tags:["Java技巧"],author:"柏竹"},regularPath:"/01.%E5%90%8E%E7%AB%AF/03.Java%E6%8B%93%E5%B1%95/03.Stream%E6%B5%81%E6%93%8D%E4%BD%9C.html",relativePath:"01.后端/03.Java拓展/03.Stream流操作.md",key:"v-62776f4a",path:"/backend/c69655/",headers:[{level:2,title:"创建 Stream流",slug:"创建-stream流",normalizedTitle:"创建 stream流",charIndex:94},{level:2,title:"处理 Stream流",slug:"处理-stream流",normalizedTitle:"处理 stream流",charIndex:792},{level:2,title:"导出 Stream流",slug:"导出-stream流",normalizedTitle:"导出 stream流",charIndex:1953},{level:2,title:"实战场景",slug:"实战场景",normalizedTitle:"实战场景",charIndex:3354},{level:3,title:"类型转换",slug:"类型转换",normalizedTitle:"类型转换",charIndex:3363}],headersStr:"创建 Stream流 处理 Stream流 导出 Stream流 实战场景 类型转换",content:'# Stream\n\nStream流 是针对集合迭代器的增强\n\n能够自由使用表达式进行控制集合数据\n\n**应用步骤 : **\n\n 1. 创建 流对象\n 2. 处理 流对象\n 3. \n\n\n# 创建 Stream流\n\n有三种不同创建方式 :\n\n    元素组分类         方法                           说明\n1   集合            Steam stream()               Collection自带方法\n2   数组            Arrays.stream(T[] array)     数组工具类静态方法实现\n3   Stream 静态方法   Stream.stream(T... values)   零散数据 特定接口实现\n\n集合\n\nArrays.asList(1,2,3,4).stream();\n\n\n> 其他集合如此\n\n数组\n\n数组 通过 ==Arrays.stream()== 静态方法实现 流转化\n\nArrays.stream(new int[]{1,2,3,4})\n\n\n其他\n\n零散数据 通过 ==Stream.of()== 静态方法实现 流转化\n\nStream.of(1, 2, 3);\n\n\n哈希\n\nMap不能直接进行 Stream流转化 , 需要将数据进行降维 , 类单列集合 才可使用\n\nMap<String,String> map = new HashMap<>();\nmap.put("aaa","111");\nmap.put("bbb","222");\nmap.put("ccc","333");\n// 降维转化\n// 方式1 将key降维\nmap.keySet().stream();\n// 方式2 以 Entry单列 降维\nmap.entrySet().stream();\n\n\n\n# 处理 Stream流\n\n进行对流 数据进行加工(又称中间操作) . 在Stream流中进行操作的数据不会对原集合数据造成影响\n\n**特性 : **\n\n * 不会存储数据\n * 不会改变数据\n * 不能重复使用 (建议链式调用)\n\n特性测试\n\n@Test\npublic void test() {\n    /* 不会改变数据 */\n    List<Integer> list = Arrays.asList(1, 2, 2, 3, 4, 4, 5);\n    List<Integer> collect = list.stream().distinct().collect(Collectors.toList());\n    // list = [1, 2, 2, 3, 4, 4, 5]\n    System.out.println("list = " + list);\n    // collect = [1, 2, 3, 4, 5]\n    System.out.println("collect = " + collect);\n}\n@Test\npublic void test2() {\n    /* 流不能复用*/\n    Stream<Integer> stream = Stream.of(1, 2, 3, 4, 5);\n    stream.filter(val -> val > 2);\n    // 下面会报错\n    Stream<Integer> skip = stream.skip(2);\n    //stream1.forEach(System.out::println);\n    skip.forEach(System.out::println);\n}\n\n\n方法 :\n\n返回              方法                                说明\nStream          ==filter(Predicate predicate)==   过滤\nStream          ==limit(long maxSize)==           获取前N个元素\nStream          ==skip(long n)==                  跳过前N个元素获取\nStream          ==distinct()==                    元素去重\nstatic Stream   ==concat(Stream a, Stream b)==    合并a和b两个流\nStream          ==map(Function<T, R> mapper)==    转换流类型\n\n> 详细就不测试了\n\n\n# 导出 Stream流\n\n进行对流 进行 遍历/统计/集合/数组 的导出 , 专门针对加工后的 Stream进行导出 (最终操作)\n\n导出方式 :\n\n 1. 直接遍历\n 2. 总数统计\n 3. 集合/数组 导出\n 4. get导出 (用于Optional中存在一个值的时候)\n\n**方法 : **\n\n返回     方法                                        说明\nvoid   ==forEach(Consumer action)==              遍历\nlong   ==count()==                               统计\n-      ==toArray(IntFunction<A[]> generator)==   数组导出\n-      ==collect(Collector collector)==          集合导出\n\nList<Integer> list = Arrays.asList(1, 2, 2, 3, 4, 4, 5);\n        // 懂得都懂\n        //list.forEach(System.out::print);\n        // 计算总数\n        System.out.println("count = " + list.stream().count()); // count = 7\n        // 数组 导出\n        Integer[] ints = list.stream().distinct().toArray(Integer[]::new);\n        System.out.println("ints = " + Arrays.toString(ints)); // ints = [1, 2, 3, 4, 5]\n        // 集合 导出\n        List<Integer> collect = list.stream().distinct().collect(Collectors.toList());\n        System.out.println("collect = " + collect); // [1, 2, 3, 4, 5]\n\n\n> 集合/数据 导出方式 携带的参数是指定导出不同类型的 数组/集合 !\n\nMap导出\n\n流需要以Map导出 , 需要自行定义 K/V 的指向 . ==Collectors.toMap(K , V)==\n\nList<String> list = Arrays.asList("aaa-111", "bbb-222", "ccc-333");\nMap<String, String> map = list.stream().collect(Collectors.toMap(\n        str -> str.split("-")[0],\n        str -> str.split("-")[1]\n));\nmap.forEach((k,v) ->{\n    System.out.println(k+" : "+v);\n});\n/* map存储是无序的\naaa : 111\nccc : 333\nbbb : 222\n*/\n\n\n\n# 实战场景\n\n\n# 类型转换\n\n集合 数据类型的转换\n\nList<User> list = new ArrayList();\n\n// list 存数据img...\n\nList<UserVO> listVO = list.stream().map(user -> {\n    UserVO userVO = new UserVO;\n    BeanUtils.copyProperties(user, userVO);\n    return userVO;\n}).collect(Collectors.toList());\n',normalizedContent:'# stream\n\nstream流 是针对集合迭代器的增强\n\n能够自由使用表达式进行控制集合数据\n\n**应用步骤 : **\n\n 1. 创建 流对象\n 2. 处理 流对象\n 3. \n\n\n# 创建 stream流\n\n有三种不同创建方式 :\n\n    元素组分类         方法                           说明\n1   集合            steam stream()               collection自带方法\n2   数组            arrays.stream(t[] array)     数组工具类静态方法实现\n3   stream 静态方法   stream.stream(t... values)   零散数据 特定接口实现\n\n集合\n\narrays.aslist(1,2,3,4).stream();\n\n\n> 其他集合如此\n\n数组\n\n数组 通过 ==arrays.stream()== 静态方法实现 流转化\n\narrays.stream(new int[]{1,2,3,4})\n\n\n其他\n\n零散数据 通过 ==stream.of()== 静态方法实现 流转化\n\nstream.of(1, 2, 3);\n\n\n哈希\n\nmap不能直接进行 stream流转化 , 需要将数据进行降维 , 类单列集合 才可使用\n\nmap<string,string> map = new hashmap<>();\nmap.put("aaa","111");\nmap.put("bbb","222");\nmap.put("ccc","333");\n// 降维转化\n// 方式1 将key降维\nmap.keyset().stream();\n// 方式2 以 entry单列 降维\nmap.entryset().stream();\n\n\n\n# 处理 stream流\n\n进行对流 数据进行加工(又称中间操作) . 在stream流中进行操作的数据不会对原集合数据造成影响\n\n**特性 : **\n\n * 不会存储数据\n * 不会改变数据\n * 不能重复使用 (建议链式调用)\n\n特性测试\n\n@test\npublic void test() {\n    /* 不会改变数据 */\n    list<integer> list = arrays.aslist(1, 2, 2, 3, 4, 4, 5);\n    list<integer> collect = list.stream().distinct().collect(collectors.tolist());\n    // list = [1, 2, 2, 3, 4, 4, 5]\n    system.out.println("list = " + list);\n    // collect = [1, 2, 3, 4, 5]\n    system.out.println("collect = " + collect);\n}\n@test\npublic void test2() {\n    /* 流不能复用*/\n    stream<integer> stream = stream.of(1, 2, 3, 4, 5);\n    stream.filter(val -> val > 2);\n    // 下面会报错\n    stream<integer> skip = stream.skip(2);\n    //stream1.foreach(system.out::println);\n    skip.foreach(system.out::println);\n}\n\n\n方法 :\n\n返回              方法                                说明\nstream          ==filter(predicate predicate)==   过滤\nstream          ==limit(long maxsize)==           获取前n个元素\nstream          ==skip(long n)==                  跳过前n个元素获取\nstream          ==distinct()==                    元素去重\nstatic stream   ==concat(stream a, stream b)==    合并a和b两个流\nstream          ==map(function<t, r> mapper)==    转换流类型\n\n> 详细就不测试了\n\n\n# 导出 stream流\n\n进行对流 进行 遍历/统计/集合/数组 的导出 , 专门针对加工后的 stream进行导出 (最终操作)\n\n导出方式 :\n\n 1. 直接遍历\n 2. 总数统计\n 3. 集合/数组 导出\n 4. get导出 (用于optional中存在一个值的时候)\n\n**方法 : **\n\n返回     方法                                        说明\nvoid   ==foreach(consumer action)==              遍历\nlong   ==count()==                               统计\n-      ==toarray(intfunction<a[]> generator)==   数组导出\n-      ==collect(collector collector)==          集合导出\n\nlist<integer> list = arrays.aslist(1, 2, 2, 3, 4, 4, 5);\n        // 懂得都懂\n        //list.foreach(system.out::print);\n        // 计算总数\n        system.out.println("count = " + list.stream().count()); // count = 7\n        // 数组 导出\n        integer[] ints = list.stream().distinct().toarray(integer[]::new);\n        system.out.println("ints = " + arrays.tostring(ints)); // ints = [1, 2, 3, 4, 5]\n        // 集合 导出\n        list<integer> collect = list.stream().distinct().collect(collectors.tolist());\n        system.out.println("collect = " + collect); // [1, 2, 3, 4, 5]\n\n\n> 集合/数据 导出方式 携带的参数是指定导出不同类型的 数组/集合 !\n\nmap导出\n\n流需要以map导出 , 需要自行定义 k/v 的指向 . ==collectors.tomap(k , v)==\n\nlist<string> list = arrays.aslist("aaa-111", "bbb-222", "ccc-333");\nmap<string, string> map = list.stream().collect(collectors.tomap(\n        str -> str.split("-")[0],\n        str -> str.split("-")[1]\n));\nmap.foreach((k,v) ->{\n    system.out.println(k+" : "+v);\n});\n/* map存储是无序的\naaa : 111\nccc : 333\nbbb : 222\n*/\n\n\n\n# 实战场景\n\n\n# 类型转换\n\n集合 数据类型的转换\n\nlist<user> list = new arraylist();\n\n// list 存数据img...\n\nlist<uservo> listvo = list.stream().map(user -> {\n    uservo uservo = new uservo;\n    beanutils.copyproperties(user, uservo);\n    return uservo;\n}).collect(collectors.tolist());\n',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Java序列化",frontmatter:{title:"Java序列化",date:"2020-02-18T00:00:00.000Z",permalink:"/backend/d69655",categories:["后端","Java"],tags:["Java技巧"],author:"柏竹"},regularPath:"/01.%E5%90%8E%E7%AB%AF/03.Java%E6%8B%93%E5%B1%95/02.%20Properties%20%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.html",relativePath:"01.后端/03.Java拓展/02. Properties 序列化与反序列化.md",key:"v-6e838041",path:"/backend/d69655/",headers:[{level:2,title:"Properties类",slug:"properties类",normalizedTitle:"properties类",charIndex:14},{level:2,title:"序列化 与 反序列化",slug:"序列化-与-反序列化",normalizedTitle:"序列化 与 反序列化",charIndex:1455},{level:3,title:"序列化",slug:"序列化",normalizedTitle:"序列化",charIndex:6},{level:3,title:"反序列化",slug:"反序列化",normalizedTitle:"反序列化",charIndex:1461},{level:3,title:"序列化限制",slug:"序列化限制",normalizedTitle:"序列化限制",charIndex:2232},{level:2,title:"Externalizable接口 序列化",slug:"externalizable接口-序列化",normalizedTitle:"externalizable接口 序列化",charIndex:8101}],headersStr:"Properties类 序列化 与 反序列化 序列化 反序列化 序列化限制 Externalizable接口 序列化",content:'# Java序列化\n\n\n# Properties类\n\n> Class Properties\n> \n> java.lang.Object java.util.Dictionary<K,V> java.util.Hashtable<Object,Object> java.util.Properties\n> \n> 实现接口\n> \n> Serializable ， Cloneable ， Map < Object ， Object >\n\n// ".properties文件" 与 Properties 类\n\n实现本地文件存储数据 Properties，每一个 Key（键）和 Value（值）都有对应的字符串储存在文件中\n\n方法\n\n返回            方法                                                             说明\nString        getProperty(String key)                                        获取指定的键\nvoid          list(PrintStream out)                                          打印到字节输出流\nvoid          list(PrintWriter out)                                          打印到字符输出流\nvoid          load(InputStream inStream)                                     从输入字节流读取键、值\nvoid          load(Reader reader)                                            从输入字符流读取键、值\nvoid          loadFromXML(InputStream in)                                    字节输入流中的XML文档表示的所有属性加载到此属性表中\nvoid          store(OutputStream out, String comments)                       将 键、值 写入 Properties表中，写入格式是字节输出流\nvoid          store(Writer writer, String comments)                          将 键、值 写入 Properties表中，写入格式是字输出符流\nvoid          storeToXML(OutputStream os, String comment)                    发出Properties表中所有键、值的XML文档\nvoid          storeToXML(OutputStream os, String comment, String encoding)   指定编码发 出Properties表中所有键、值的XML文档\nSet<String>   stringPropertyNames()                                          返回列表中的一组键\n\n\n# 序列化 与 反序列化\n\n\n# 序列化\n\n> Class ObjectOutputStream\n> \n> java.lang.Object java.io.OutputStream java.io.ObjectOutputStream\n> \n> 实现接口\n> \n> Closeable ， DataOutput ， Flushable ， ObjectOutput ， ObjectStreamConstants ， AutoCloseable\n\n可以通过使用流的文件来实现对象的持久存储 如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象（发个文件到另一台电脑实现对象）\n\n注意：\n\n * 实现重构的对象必须实现 Java.io.Serializable 接口\n * 重构对象的属性也必须实现 Java.io.Serializable 接口\n\n以上说明是实现重构对象的前提\n\n构造方法\n\nObjectOutputStream() ObjectOutputStream(OutputStream out)\n\n方法 （方法自行API）\n\n\n# 反序列化\n\n> Class ObjectInputStream\n> \n> java.lang.Object java.io.InputStream java.io.ObjectInputStream\n> \n> 实现接口\n> \n> Closeable ， DataInput ， ObjectInput ， ObjectStreamConstants ， AutoCloseable\n\nObjectInputStream用于恢复先前序列化的对象 构造方法\n\nObjectInputStream() ObjectInputStream(InputStream in)\n\n方法 （方法自行API）\n\n\n# 序列化限制\n\n指定对象部分属性序列化\n\n实现方式：\n\n 1. 对象属性用 transient 修饰符 限制属性序列化\n 2. 对象属性用 static 修饰符 限制属性序列化\n 3. 对象实现 writeObject()方法 和 readObject()方法 进行对指定属性进行实例化\n\n注意： 方法3 ，writeObject()方法 和 readObject()方法 必须是 私有 无返回，否则无效\n\n//模板\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n//写\nprivate void writeObject(ObjectOutputStream out) throws IOException\n//读\nprivate void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException\n\n\n代码实例\n\nMain类 （写入操作）\n\nimport java.io.OutputStream;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Main {\n    public static void main(String[] args) {\n        MySerializableUtil su = new MySerializableUtil();\n        \n        //数据处理 ，储存\n        \n        People p = new People("柏竹" , 20 , null);\n        \n        List<String> childrenName = new ArrayList<>();\n        childrenName.add("黑猫");\n        childrenName.add("大鲸");\n        childrenName.add("白兔");\n        HaveAll haveAll = new HaveAll(7654321 , "网球" , 3);\n        haveAll.setChildrenName(childrenName);\n        p.setHaveAll(haveAll);\n    \n        System.out.println("原始数据 ： "+ p);\n        \n        //数据 序列化\n        \n        String fileName = "Date.txt";\n        try {\n            MySerializableUtil.mySerializableUtil(p , fileName);\n            System.out.println("Serialization OK！");\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    \n        //读取\n        System.out.println("读数据 ： ");\n        Object o = su.myDeserialize(fileName);\n        System.out.println(o);\n    }\n}\n\n/*\n\n原始数据 ： People{name=\'柏竹\', age=20, haveAll=HaveAll{money=7654321, house=\'网球\', childrenNum=3}}\n 调用 writeObject() 限制!!!\nSerialization OK！\n读数据 ： \n 调用 readObject() !!!\nPeople{name=\'柏竹\', age=20, haveAll=HaveAll{money=0, house=\'网球\', childrenNum=3}}\n\n*/\n\n\nInput类 （读文件数据）（用于在别的地方读取对象）\n\npublic class Input {\n    public static void main(String[] args) {\n        MySerializableUtil su = new MySerializableUtil();\n        Object o = su.myDeserialize("Date.txt");\n        System.out.println(o);\n    }\n}\n\n\nMySerializableUtil类 （操作工具）\n\nimport java.io.*;\n\n/**\n * 序列化 与 序列化 工具类\n */\npublic class MySerializableUtil {\n    /**\n     * 序列化\n     * @param data  数据\n     * @param fileName  字节输出流\n     */\n    public static void mySerializableUtil(Object data , String fileName){\n        try(ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(fileName))) {\n            oos.writeObject(data);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    /**\n     *  反序列化\n     * @param fileName 字节输入流\n     * @return 返回获取的对象\n     */\n    public static Object myDeserialize(String fileName){\n        try (ObjectInputStream ois = new ObjectInputStream(new FileInputStream(fileName))) {\n            return ois.readObject();\n        }catch (Exception e){\n            e.printStackTrace();\n        }\n        return null;\n    }\n}\n\n\nPeople类 （存储对象）\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.io.Serializable;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n/**\n * 实现Serializable接口\n */\npublic class People implements Serializable {\n    String name;\n    //年龄不能序列化\n    static int age;\n    /**人的明细*/\n    HaveAll haveAll;\n    \n    //指定对象序列化\n    private void writeObject(ObjectOutputStream out) throws IOException {\n        System.out.println(" 调用 writeObject() 限制!!!");\n        out.writeObject(name);\n        out.writeObject(haveAll);\n    }\n    \n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException{\n        System.out.println(" 调用 readObject() !!!");\n        name =(String) in.readObject();\n        haveAll = (HaveAll) in.readObject();\n    }\n    \n    public People() {\n    }\n    public People(String name , int age , HaveAll haveAll) {\n        this.name = name;\n        this.age = age;\n        this.haveAll = haveAll;\n    }\n    \n    public void setHaveAll(HaveAll haveAll) {\n        this.haveAll = haveAll;\n    }\n    \n    public void setName(String name) {\n        this.name = name;\n    }\n    \n    public void setAge(int age) {\n        this.age = age;\n    }\n    \n    public String getName() {\n        return name;\n    }\n    \n    public int getAge() {\n        return age;\n    }\n    \n    public HaveAll getHaveAll() {\n        return haveAll;\n    }\n    \n    @Override\n    public String toString() {\n        return "People{" +\n                "name=\'" + name + \'\\\'\' +\n                ", age=" + age +\n                ", haveAll=" + haveAll +\n                \'}\';\n    }\n}\n\n\nHaveAll类 （存储PeoPle对象中的对象）\n\nimport java.io.Serializable;\nimport java.util.List;\n\npublic class HaveAll implements Serializable {\n    // 余额 & 爱好 & 已有的孩子 & 孩子名字集合\n    // 余额不能序列化对象\n    private transient long money;\n    String house;\n    int childrenNum;\n    List<String> childrenName;\n    //不多写了\n    \n    public HaveAll() { }\n    public HaveAll(long money , String house ,int childrenNum) {\n        this.money = money;\n        this.house = house;\n        this.childrenNum = childrenNum;\n    }\n    \n    public List<String> getChildrenName() {\n        return childrenName;\n    }\n    \n    public void setChildrenName(List<String> childrenName) {\n        this.childrenName = childrenName;\n    }\n    \n    public void setMoney(long money) {\n        this.money = money;\n    }\n    \n    public void setHouse(String house) {\n        this.house = house;\n    }\n    \n    public void setChildrenNum(int childrenNum) {\n        this.childrenNum = childrenNum;\n    }\n    \n    public long getMoney() {\n        return money;\n    }\n    \n    public String getHouse() {\n        return house;\n    }\n    \n    public int getChildrenNum() {\n        return childrenNum;\n    }\n    \n    @Override\n    public String toString() {\n        return "HaveAll{" +\n                "money=" + money +\n                ", house=\'" + house + \'\\\'\' +\n                ", childrenNum=" + childrenNum +\n                \'}\';\n    }\n}\n\n\n\n# Externalizable接口 序列化\n\n> 继承接口 Serializable\n> \n> 实现类 ActivationDataFlavor ， DataFlavor ， MimeType ， MLet ， PrivateMLet\n\nExternalizable接口 也能实现 序列化 和 反序列化 ，因继承 Serializable接口。 使用该接口需要定义 writeExteranl()、 readExternal() 抽象方法才可以实现序列化与反序列化\n\n//模板\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n//写\npublic void writeExternal(ObjectOutputStream out) throws IOException\n//读\npublic void readExternal(ObjectInputStream in) throws IOException, ClassNotFoundException\n\n\n实现方式： 在以上代码中的 People类 更改\n\nimport java.io.IOException;\nimport java.io.Serializable;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\n/**\n * 实现Serializable接口\n */\npublic class People implements Externalizable {\n    String name;\n    //年龄不能序列化\n    static int age;\n    /**人的明细*/\n    HaveAll haveAll;\n    \n    //指定对象序列化\n public void writeExternal(ObjectOutputStream out) throws IOException {\n        System.out.println(" 调用 writeObject() 限制!!!");\n        out.writeObject(name);\n        out.writeObject(haveAll);\n    }\n    \npublic void readExternal(ObjectInputStream in) throws IOException, ClassNotFoundException{\n        System.out.println(" 调用 readObject() !!!");\n        name =(String) in.readObject();\n        haveAll = (HaveAll) in.readObject();\n    }\n    \n   //·····省略\n}\n',normalizedContent:'# java序列化\n\n\n# properties类\n\n> class properties\n> \n> java.lang.object java.util.dictionary<k,v> java.util.hashtable<object,object> java.util.properties\n> \n> 实现接口\n> \n> serializable ， cloneable ， map < object ， object >\n\n// ".properties文件" 与 properties 类\n\n实现本地文件存储数据 properties，每一个 key（键）和 value（值）都有对应的字符串储存在文件中\n\n方法\n\n返回            方法                                                             说明\nstring        getproperty(string key)                                        获取指定的键\nvoid          list(printstream out)                                          打印到字节输出流\nvoid          list(printwriter out)                                          打印到字符输出流\nvoid          load(inputstream instream)                                     从输入字节流读取键、值\nvoid          load(reader reader)                                            从输入字符流读取键、值\nvoid          loadfromxml(inputstream in)                                    字节输入流中的xml文档表示的所有属性加载到此属性表中\nvoid          store(outputstream out, string comments)                       将 键、值 写入 properties表中，写入格式是字节输出流\nvoid          store(writer writer, string comments)                          将 键、值 写入 properties表中，写入格式是字输出符流\nvoid          storetoxml(outputstream os, string comment)                    发出properties表中所有键、值的xml文档\nvoid          storetoxml(outputstream os, string comment, string encoding)   指定编码发 出properties表中所有键、值的xml文档\nset<string>   stringpropertynames()                                          返回列表中的一组键\n\n\n# 序列化 与 反序列化\n\n\n# 序列化\n\n> class objectoutputstream\n> \n> java.lang.object java.io.outputstream java.io.objectoutputstream\n> \n> 实现接口\n> \n> closeable ， dataoutput ， flushable ， objectoutput ， objectstreamconstants ， autocloseable\n\n可以通过使用流的文件来实现对象的持久存储 如果流是网络套接字流，则可以在另一个主机上或另一个进程中重构对象（发个文件到另一台电脑实现对象）\n\n注意：\n\n * 实现重构的对象必须实现 java.io.serializable 接口\n * 重构对象的属性也必须实现 java.io.serializable 接口\n\n以上说明是实现重构对象的前提\n\n构造方法\n\nobjectoutputstream() objectoutputstream(outputstream out)\n\n方法 （方法自行api）\n\n\n# 反序列化\n\n> class objectinputstream\n> \n> java.lang.object java.io.inputstream java.io.objectinputstream\n> \n> 实现接口\n> \n> closeable ， datainput ， objectinput ， objectstreamconstants ， autocloseable\n\nobjectinputstream用于恢复先前序列化的对象 构造方法\n\nobjectinputstream() objectinputstream(inputstream in)\n\n方法 （方法自行api）\n\n\n# 序列化限制\n\n指定对象部分属性序列化\n\n实现方式：\n\n 1. 对象属性用 transient 修饰符 限制属性序列化\n 2. 对象属性用 static 修饰符 限制属性序列化\n 3. 对象实现 writeobject()方法 和 readobject()方法 进行对指定属性进行实例化\n\n注意： 方法3 ，writeobject()方法 和 readobject()方法 必须是 私有 无返回，否则无效\n\n//模板\nimport java.io.objectinputstream;\nimport java.io.objectoutputstream;\n//写\nprivate void writeobject(objectoutputstream out) throws ioexception\n//读\nprivate void readobject(objectinputstream in) throws ioexception, classnotfoundexception\n\n\n代码实例\n\nmain类 （写入操作）\n\nimport java.io.outputstream;\nimport java.util.arraylist;\nimport java.util.list;\n\npublic class main {\n    public static void main(string[] args) {\n        myserializableutil su = new myserializableutil();\n        \n        //数据处理 ，储存\n        \n        people p = new people("柏竹" , 20 , null);\n        \n        list<string> childrenname = new arraylist<>();\n        childrenname.add("黑猫");\n        childrenname.add("大鲸");\n        childrenname.add("白兔");\n        haveall haveall = new haveall(7654321 , "网球" , 3);\n        haveall.setchildrenname(childrenname);\n        p.sethaveall(haveall);\n    \n        system.out.println("原始数据 ： "+ p);\n        \n        //数据 序列化\n        \n        string filename = "date.txt";\n        try {\n            myserializableutil.myserializableutil(p , filename);\n            system.out.println("serialization ok！");\n        } catch (exception e) {\n            e.printstacktrace();\n        }\n    \n        //读取\n        system.out.println("读数据 ： ");\n        object o = su.mydeserialize(filename);\n        system.out.println(o);\n    }\n}\n\n/*\n\n原始数据 ： people{name=\'柏竹\', age=20, haveall=haveall{money=7654321, house=\'网球\', childrennum=3}}\n 调用 writeobject() 限制!!!\nserialization ok！\n读数据 ： \n 调用 readobject() !!!\npeople{name=\'柏竹\', age=20, haveall=haveall{money=0, house=\'网球\', childrennum=3}}\n\n*/\n\n\ninput类 （读文件数据）（用于在别的地方读取对象）\n\npublic class input {\n    public static void main(string[] args) {\n        myserializableutil su = new myserializableutil();\n        object o = su.mydeserialize("date.txt");\n        system.out.println(o);\n    }\n}\n\n\nmyserializableutil类 （操作工具）\n\nimport java.io.*;\n\n/**\n * 序列化 与 序列化 工具类\n */\npublic class myserializableutil {\n    /**\n     * 序列化\n     * @param data  数据\n     * @param filename  字节输出流\n     */\n    public static void myserializableutil(object data , string filename){\n        try(objectoutputstream oos = new objectoutputstream(new fileoutputstream(filename))) {\n            oos.writeobject(data);\n        } catch (ioexception e) {\n            e.printstacktrace();\n        }\n    }\n    \n    /**\n     *  反序列化\n     * @param filename 字节输入流\n     * @return 返回获取的对象\n     */\n    public static object mydeserialize(string filename){\n        try (objectinputstream ois = new objectinputstream(new fileinputstream(filename))) {\n            return ois.readobject();\n        }catch (exception e){\n            e.printstacktrace();\n        }\n        return null;\n    }\n}\n\n\npeople类 （存储对象）\n\nimport java.io.ioexception;\nimport java.io.serializable;\nimport java.io.serializable;\nimport java.io.objectinputstream;\nimport java.io.objectoutputstream;\n/**\n * 实现serializable接口\n */\npublic class people implements serializable {\n    string name;\n    //年龄不能序列化\n    static int age;\n    /**人的明细*/\n    haveall haveall;\n    \n    //指定对象序列化\n    private void writeobject(objectoutputstream out) throws ioexception {\n        system.out.println(" 调用 writeobject() 限制!!!");\n        out.writeobject(name);\n        out.writeobject(haveall);\n    }\n    \n    private void readobject(objectinputstream in) throws ioexception, classnotfoundexception{\n        system.out.println(" 调用 readobject() !!!");\n        name =(string) in.readobject();\n        haveall = (haveall) in.readobject();\n    }\n    \n    public people() {\n    }\n    public people(string name , int age , haveall haveall) {\n        this.name = name;\n        this.age = age;\n        this.haveall = haveall;\n    }\n    \n    public void sethaveall(haveall haveall) {\n        this.haveall = haveall;\n    }\n    \n    public void setname(string name) {\n        this.name = name;\n    }\n    \n    public void setage(int age) {\n        this.age = age;\n    }\n    \n    public string getname() {\n        return name;\n    }\n    \n    public int getage() {\n        return age;\n    }\n    \n    public haveall gethaveall() {\n        return haveall;\n    }\n    \n    @override\n    public string tostring() {\n        return "people{" +\n                "name=\'" + name + \'\\\'\' +\n                ", age=" + age +\n                ", haveall=" + haveall +\n                \'}\';\n    }\n}\n\n\nhaveall类 （存储people对象中的对象）\n\nimport java.io.serializable;\nimport java.util.list;\n\npublic class haveall implements serializable {\n    // 余额 & 爱好 & 已有的孩子 & 孩子名字集合\n    // 余额不能序列化对象\n    private transient long money;\n    string house;\n    int childrennum;\n    list<string> childrenname;\n    //不多写了\n    \n    public haveall() { }\n    public haveall(long money , string house ,int childrennum) {\n        this.money = money;\n        this.house = house;\n        this.childrennum = childrennum;\n    }\n    \n    public list<string> getchildrenname() {\n        return childrenname;\n    }\n    \n    public void setchildrenname(list<string> childrenname) {\n        this.childrenname = childrenname;\n    }\n    \n    public void setmoney(long money) {\n        this.money = money;\n    }\n    \n    public void sethouse(string house) {\n        this.house = house;\n    }\n    \n    public void setchildrennum(int childrennum) {\n        this.childrennum = childrennum;\n    }\n    \n    public long getmoney() {\n        return money;\n    }\n    \n    public string gethouse() {\n        return house;\n    }\n    \n    public int getchildrennum() {\n        return childrennum;\n    }\n    \n    @override\n    public string tostring() {\n        return "haveall{" +\n                "money=" + money +\n                ", house=\'" + house + \'\\\'\' +\n                ", childrennum=" + childrennum +\n                \'}\';\n    }\n}\n\n\n\n# externalizable接口 序列化\n\n> 继承接口 serializable\n> \n> 实现类 activationdataflavor ， dataflavor ， mimetype ， mlet ， privatemlet\n\nexternalizable接口 也能实现 序列化 和 反序列化 ，因继承 serializable接口。 使用该接口需要定义 writeexteranl()、 readexternal() 抽象方法才可以实现序列化与反序列化\n\n//模板\nimport java.io.objectinputstream;\nimport java.io.objectoutputstream;\n//写\npublic void writeexternal(objectoutputstream out) throws ioexception\n//读\npublic void readexternal(objectinputstream in) throws ioexception, classnotfoundexception\n\n\n实现方式： 在以上代码中的 people类 更改\n\nimport java.io.ioexception;\nimport java.io.serializable;\nimport java.io.objectinputstream;\nimport java.io.objectoutputstream;\n/**\n * 实现serializable接口\n */\npublic class people implements externalizable {\n    string name;\n    //年龄不能序列化\n    static int age;\n    /**人的明细*/\n    haveall haveall;\n    \n    //指定对象序列化\n public void writeexternal(objectoutputstream out) throws ioexception {\n        system.out.println(" 调用 writeobject() 限制!!!");\n        out.writeobject(name);\n        out.writeobject(haveall);\n    }\n    \npublic void readexternal(objectinputstream in) throws ioexception, classnotfoundexception{\n        system.out.println(" 调用 readobject() !!!");\n        name =(string) in.readobject();\n        haveall = (haveall) in.readobject();\n    }\n    \n   //·····省略\n}\n',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"JavaZip解压缩",frontmatter:{title:"JavaZip解压缩",date:"2020-02-18T00:00:00.000Z",permalink:"/backend/a69655",categories:["后端","Java"],tags:["Java技巧"],author:"柏竹"},regularPath:"/01.%E5%90%8E%E7%AB%AF/03.Java%E6%8B%93%E5%B1%95/05.zip%E8%A7%A3%E5%8E%8B%E7%BC%A9.html",relativePath:"01.后端/03.Java拓展/05.zip解压缩.md",key:"v-4bc1b449",path:"/backend/a69655/",headers:[{level:2,title:"ZIP文件条目",slug:"zip文件条目",normalizedTitle:"zip文件条目",charIndex:17},{level:2,title:"压缩流（压缩文件）",slug:"压缩流-压缩文件",normalizedTitle:"压缩流（压缩文件）",charIndex:231},{level:2,title:"解压流（解压文件）",slug:"解压流-解压文件",normalizedTitle:"解压流（解压文件）",charIndex:6753}],headersStr:"ZIP文件条目 压缩流（压缩文件） 解压流（解压文件）",content:'# JavaZip解压缩\n\n\n# ZIP文件条目\n\n> Class ZipEntry\n> \n> java.lang.Object java.util.zip.ZipEntry\n\nZipEntry类 产生的对象，用来代表代表ZIP压缩文件的进入点\n\n构造方法\n\nZipEntry（String name）\n\nZipEntry（ZipEntry e）\n\n> name： 条目名称 e： zip条目对象\n\n由于方法过多自行查JDK文档 ，后续有代码例子有说明\n\n\n# 压缩流（压缩文件）\n\n> Class ZipOutputStream\n> \n> java.lang.Object java.io.OutputStream java.io.FilterOutputStream java.util.zip.DeflaterOutputStream java.util.zip.ZipOutputStream\n\n大致流程\n\n 1. 创建被压缩的对象 和 压缩包的对象\n 2. 创建 字节输出流 和 压缩输出流\n 3. 为文件创建ZipEntry条目\n 4. 将读取的数据通过输出流写入到硬盘中\n 5. 完成压缩\n\n构造方法\n\nZipOutputStream（OutputStream out） \n\n> out：输出流\n\n方法\n\n修饰符    方法                                  说明\nvoid   close（）                             关闭流\nvoid   closeEntry（）                        关闭当前的ZIP条目，并定位流以写入下一个条目\nvoid   finish（）                            完成编写ZIP输出流的内容，而不关闭底层流\nvoid   putNextEntry（ZipEntry e）            开始编写新的ZIP文件条目，并将流定位到条目数据的开头\nvoid   setComment（String comment）          设置ZIP文件注释\nvoid   write（byte[] b, int off, int len）   将字节数组写入当前的ZIP条目数据\n\n例子1 （老师讲解的例题）\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipOutputStream;\n\npublic class Demo {\n    \n    static void compress(){\n        //创建被压缩的对象\n        File source = new File("E:\\\\png\\\\");\n        //创建压缩包的对象\n        File target = new File("E:\\\\mr.zip");\n        \n        //try括号内的资源会在try语句结束后自动释放，前提是这些可关闭的资源必须实现\n        //创建字节输出流、压缩输出流\n        try(FileOutputStream fis = new FileOutputStream(target);\n            ZipOutputStream zos = new ZipOutputStream(fis)){\n            \n            //判断是否是文件夹\n            if(source.isDirectory()){\n                //遍历文件夹的文件\n                for(File f : source.listFiles()){\n                    addEntry(zos , "" , f);\n                }\n            }else{\n                addEntry(zos,"",source);\n            }\n            \n        }catch (Exception e){\n            e.printStackTrace();\n        }\n        \n    }\n    \n    /*\n    *\n    *   该方法用来写入文件数据 和 重新遍历文件夹\n    * 方法参数：\n    *   zos：压缩流\n    *   base： 文件在压缩包中的路径\n    *   source：被压缩的文件\n    *\n    *  */\n    static void addEntry(ZipOutputStream zos , String base , File source){\n        //判断是否是文件夹\n        if (source.isDirectory()){//判断为文件夹\n            \n            //遍历文件夹的文件\n            for (File file : source.listFiles()){\n                /*\n                *   参数2：\n                *       base：文件路径\n                *       source.getName()：文件夹名称\n                *       File.separator：分隔符（ \\\\ 和 / ）\n                *\n                * */\n                addEntry(zos , base + source.getName() + File.separator , file);\n            }\n            \n        }else{//判断为文件\n            \n            //写入压缩流\n            \n            //创建缓冲区\n            byte[] b = new byte[1024];\n            //创建 字节输入流\n            //source 是文件\n            try(FileInputStream fis = new FileInputStream(source)) {\n                //判断开关\n                int count = -1;\n                \n                //putNextEntry()方法开始编写新的ZIP文件条目，并将流定位到条目数据的开头\n                //实例化ZIP文件条目 条目路径及名称\n                zos.putNextEntry(new ZipEntry(base + source.getName()));\n                // 读取文件 直到读完\n                while((count = fis.read(b)) != -1){\n                    //写入压缩流。 b 缓冲内容\n                    zos.write(b , 0 , count);\n                    //刷新流\n                    zos.flush();\n                }\n                zos.closeEntry();\n            }catch (Exception e){\n                e.printStackTrace();\n            }\n            \n        }\n        \n    }\n    \n    public static void main(String[] args) {\n        compress();\n    }\n}\n\n\n例子2 （个人写的例题）\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipOutputStream;\n\npublic class Demo2 {\n    \n    //压缩方法\n    static void Compression(){\n        \n        \n        File fwj = new File("E:\\\\png\\\\");\n        File target = new File("E:\\\\mr2.zip");\n    \n        FileOutputStream fout = null;\n        ZipOutputStream zout = null;\n        \n        try {\n            fout = new FileOutputStream(target);\n            zout = new ZipOutputStream(fout);\n            \n            //进行压缩的方法\n            //参数2为空，因从压缩包里的根路径开始\n            addEntry(zout,"",fwj);\n            \n        }catch (Exception e){\n            e.printStackTrace();\n        }finally {\n            try {\n                \n                if (zout != null){\n                    zout.close();\n                }\n        \n                if (fout != null){\n                    fout.close();\n                }\n                \n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n    \n        }\n    }\n    \n    /*\n     *\n     *   该方法用来写入文件数据 和 重新遍历文件夹\n     * 方法参数：\n     *   zos：压缩流\n     *   base： 文件在压缩包中的路径\n     *   source：被压缩的文件\n     *\n     *  */\n    static void addEntry(ZipOutputStream zos , String base , File source){\n    \n        //判断是否是文件夹\n        if (source.isDirectory()){\n                //遍历文件夹\n                for (File f : source.listFiles()){\n                    /*\n                     *   参数2：\n                     *       base：文件路径\n                     *       source.getName()：文件夹名称\n                     *       File.separator：分隔符（ \\\\ 和 / ）\n                     *       文件路径\n                     * */\n                    addEntry(zos , base+source.getName()+File.separator , f);\n                }\n                \n        }else{\n            \n            //创建 字节输入流\n            FileInputStream finp = null;\n            \n            try{\n                //字节输入流\n                finp = new FileInputStream(source);\n                //创建条目\n                ZipEntry ze = new ZipEntry(base+source.getName());\n                //新的ZIP文件条目，并将流定位到条目数据的开头\n                zos.putNextEntry(ze);\n                \n                //判断变量\n                int count = -1;\n                //创建缓冲区\n                byte[] b = new byte[1024];\n    \n                // 读取文件 直到读完\n                while((count = finp.read(b)) != -1){\n                    //写入压缩流。 b 缓冲内容\n                    zos.write(b , 0 , count);\n                    //刷新流\n                    zos.flush();\n                }\n                //关闭当前的ZIP条目，并定位流以写入下一个条目\n                zos.closeEntry();\n                \n            }catch (Exception e){\n                e.printStackTrace();\n            }finally {\n                try {\n                    if (finp != null){\n                        finp.close();\n                    }\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            \n        }\n        \n    }\n    \n    public static void main(String[] args) {\n        Compression();\n    }\n}\n\n\n压缩前提要确定要压缩的 文件夹 或 文件 ，还有压缩后的路径（带名称）\n\n\n# 解压流（解压文件）\n\n> Class ZipInputStream java.lang.Object java.io.InputStream java.io.FilterInputStream java.util.zip.InflaterInputStream java.util.zip.ZipInputStream\n\n大致流程\n\n 1. 创建被压缩的对象 和 压缩包的对象\n 2. 创建 字节输入流 和 压缩输入流\n 3. 遍历 字节输入流 中的 压缩包里的条目（ZipEntry条目）\n 4. 按照压缩包里的目条 对应的文件名创建\n 5. 创建 字节输出流写入\n 6. 将 输入流 读取的数据通过 字节输出流 写入到硬盘中\n 7. 完成解压\n\n构造方法\n\nZipInputStream（InputStream in）\n\n> in：输出流\n\n方法\n\n修饰符        方法                                 说明\nint        available（）                        是否读取完目前指定的数据，读取完返回1，否则为0\nvoid       close（）                            关闭流\nvoid       closeEntry（）                       关闭当前的ZIP条目，并定位流以读取下一个条目\nZipEntry   createZipEntry（String name）        为指定的条目名称创建一个新的 ZipEntry对象\nZipEntry   getNextEntry（）                     读取下一个ZIP文件条目，并将流定位在条目数据的开头\nint        read（byte[] b, int off, int len）   从当前ZIP条目读取到字节数组\nlong       skip（long n）                       跳过当前ZIP条目中指定的字节数\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\npublic class Demo4 {\n    \n    //压缩方法\n    static void Compression(){\n    \n        //解压路径及解压后的文件夹名称\n        File dir = new File("E:\\\\nn");\n        //压缩包的路径\n        File source = new File("E:\\\\mr2.zip");\n        //创建空条目\n        ZipEntry entry = null;\n        FileInputStream fis = null;\n        ZipInputStream zis = null;\n        \n        try{\n        \n            fis = new FileInputStream(source);\n            zis = new ZipInputStream(fis);\n            \n            while (true){\n    \n                //获取下一个ZIP文件条目，并将流定位在条目数据的开头\n                entry = zis.getNextEntry();\n                //获取完为空 或 第一次获取失败 跳出循环\n                if (entry == null){\n                    break;\n                }\n                //文件夹跳过本次循环\n                if (entry.isDirectory()){\n                    continue;\n                }\n    \n                //创建文件\n                // dir：解压目的地文件夹\n                File f = new File(dir , entry.getName());\n    \n                /*\n                 *\n                 * getParentFile()方法 返回指定父路径的目录（文件），没有则空（null）\n                 * exists()方法 是否存在该文件\n                 * mkdirs()方法 创建路径名命名的目录，包括任何必需但不存在的父目录\n                 *\n                 * */\n    \n                //安全代码 ，创建压缩包里的文件夹\n                if (!f.getParentFile().exists()){\n                    f.getParentFile().mkdirs();\n                }\n    \n                int count = -1;\n                byte[] buf = new byte[1024];\n                //输出流\n                FileOutputStream fos = new FileOutputStream(f);\n                //压缩流循环读取 压缩包中的文件 直到读完\n                while((count = zis.read(buf)) != -1){\n                    //写入\n                    fos.write(buf , 0 , count);\n                    //流刷新（提升效率）\n                    fos.flush();\n                }\n                //关闭流\n                fos.close();\n                //关闭本次条目，跳到下一个\n                zis.closeEntry();\n            }\n        \n        }catch (Exception e){\n            e.printStackTrace();\n        }finally {\n            \n            if (zis != null){\n                try {\n                    zis.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            if(fis != null){\n                try {\n                    fis.close();\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n            \n        }\n        \n    }\n    \n    public static void main(String[] args) {\n        Compression();\n    }\n}\n\n\n----------------------------------------\n\n以上是个人学习后写出来的代码分享，如果有问题可在下面留言！',normalizedContent:'# javazip解压缩\n\n\n# zip文件条目\n\n> class zipentry\n> \n> java.lang.object java.util.zip.zipentry\n\nzipentry类 产生的对象，用来代表代表zip压缩文件的进入点\n\n构造方法\n\nzipentry（string name）\n\nzipentry（zipentry e）\n\n> name： 条目名称 e： zip条目对象\n\n由于方法过多自行查jdk文档 ，后续有代码例子有说明\n\n\n# 压缩流（压缩文件）\n\n> class zipoutputstream\n> \n> java.lang.object java.io.outputstream java.io.filteroutputstream java.util.zip.deflateroutputstream java.util.zip.zipoutputstream\n\n大致流程\n\n 1. 创建被压缩的对象 和 压缩包的对象\n 2. 创建 字节输出流 和 压缩输出流\n 3. 为文件创建zipentry条目\n 4. 将读取的数据通过输出流写入到硬盘中\n 5. 完成压缩\n\n构造方法\n\nzipoutputstream（outputstream out） \n\n> out：输出流\n\n方法\n\n修饰符    方法                                  说明\nvoid   close（）                             关闭流\nvoid   closeentry（）                        关闭当前的zip条目，并定位流以写入下一个条目\nvoid   finish（）                            完成编写zip输出流的内容，而不关闭底层流\nvoid   putnextentry（zipentry e）            开始编写新的zip文件条目，并将流定位到条目数据的开头\nvoid   setcomment（string comment）          设置zip文件注释\nvoid   write（byte[] b, int off, int len）   将字节数组写入当前的zip条目数据\n\n例子1 （老师讲解的例题）\n\nimport java.io.file;\nimport java.io.fileinputstream;\nimport java.io.fileoutputstream;\nimport java.util.zip.zipentry;\nimport java.util.zip.zipoutputstream;\n\npublic class demo {\n    \n    static void compress(){\n        //创建被压缩的对象\n        file source = new file("e:\\\\png\\\\");\n        //创建压缩包的对象\n        file target = new file("e:\\\\mr.zip");\n        \n        //try括号内的资源会在try语句结束后自动释放，前提是这些可关闭的资源必须实现\n        //创建字节输出流、压缩输出流\n        try(fileoutputstream fis = new fileoutputstream(target);\n            zipoutputstream zos = new zipoutputstream(fis)){\n            \n            //判断是否是文件夹\n            if(source.isdirectory()){\n                //遍历文件夹的文件\n                for(file f : source.listfiles()){\n                    addentry(zos , "" , f);\n                }\n            }else{\n                addentry(zos,"",source);\n            }\n            \n        }catch (exception e){\n            e.printstacktrace();\n        }\n        \n    }\n    \n    /*\n    *\n    *   该方法用来写入文件数据 和 重新遍历文件夹\n    * 方法参数：\n    *   zos：压缩流\n    *   base： 文件在压缩包中的路径\n    *   source：被压缩的文件\n    *\n    *  */\n    static void addentry(zipoutputstream zos , string base , file source){\n        //判断是否是文件夹\n        if (source.isdirectory()){//判断为文件夹\n            \n            //遍历文件夹的文件\n            for (file file : source.listfiles()){\n                /*\n                *   参数2：\n                *       base：文件路径\n                *       source.getname()：文件夹名称\n                *       file.separator：分隔符（ \\\\ 和 / ）\n                *\n                * */\n                addentry(zos , base + source.getname() + file.separator , file);\n            }\n            \n        }else{//判断为文件\n            \n            //写入压缩流\n            \n            //创建缓冲区\n            byte[] b = new byte[1024];\n            //创建 字节输入流\n            //source 是文件\n            try(fileinputstream fis = new fileinputstream(source)) {\n                //判断开关\n                int count = -1;\n                \n                //putnextentry()方法开始编写新的zip文件条目，并将流定位到条目数据的开头\n                //实例化zip文件条目 条目路径及名称\n                zos.putnextentry(new zipentry(base + source.getname()));\n                // 读取文件 直到读完\n                while((count = fis.read(b)) != -1){\n                    //写入压缩流。 b 缓冲内容\n                    zos.write(b , 0 , count);\n                    //刷新流\n                    zos.flush();\n                }\n                zos.closeentry();\n            }catch (exception e){\n                e.printstacktrace();\n            }\n            \n        }\n        \n    }\n    \n    public static void main(string[] args) {\n        compress();\n    }\n}\n\n\n例子2 （个人写的例题）\n\nimport java.io.file;\nimport java.io.fileinputstream;\nimport java.io.fileoutputstream;\nimport java.io.ioexception;\nimport java.util.zip.zipentry;\nimport java.util.zip.zipoutputstream;\n\npublic class demo2 {\n    \n    //压缩方法\n    static void compression(){\n        \n        \n        file fwj = new file("e:\\\\png\\\\");\n        file target = new file("e:\\\\mr2.zip");\n    \n        fileoutputstream fout = null;\n        zipoutputstream zout = null;\n        \n        try {\n            fout = new fileoutputstream(target);\n            zout = new zipoutputstream(fout);\n            \n            //进行压缩的方法\n            //参数2为空，因从压缩包里的根路径开始\n            addentry(zout,"",fwj);\n            \n        }catch (exception e){\n            e.printstacktrace();\n        }finally {\n            try {\n                \n                if (zout != null){\n                    zout.close();\n                }\n        \n                if (fout != null){\n                    fout.close();\n                }\n                \n            } catch (exception e) {\n                e.printstacktrace();\n            }\n    \n        }\n    }\n    \n    /*\n     *\n     *   该方法用来写入文件数据 和 重新遍历文件夹\n     * 方法参数：\n     *   zos：压缩流\n     *   base： 文件在压缩包中的路径\n     *   source：被压缩的文件\n     *\n     *  */\n    static void addentry(zipoutputstream zos , string base , file source){\n    \n        //判断是否是文件夹\n        if (source.isdirectory()){\n                //遍历文件夹\n                for (file f : source.listfiles()){\n                    /*\n                     *   参数2：\n                     *       base：文件路径\n                     *       source.getname()：文件夹名称\n                     *       file.separator：分隔符（ \\\\ 和 / ）\n                     *       文件路径\n                     * */\n                    addentry(zos , base+source.getname()+file.separator , f);\n                }\n                \n        }else{\n            \n            //创建 字节输入流\n            fileinputstream finp = null;\n            \n            try{\n                //字节输入流\n                finp = new fileinputstream(source);\n                //创建条目\n                zipentry ze = new zipentry(base+source.getname());\n                //新的zip文件条目，并将流定位到条目数据的开头\n                zos.putnextentry(ze);\n                \n                //判断变量\n                int count = -1;\n                //创建缓冲区\n                byte[] b = new byte[1024];\n    \n                // 读取文件 直到读完\n                while((count = finp.read(b)) != -1){\n                    //写入压缩流。 b 缓冲内容\n                    zos.write(b , 0 , count);\n                    //刷新流\n                    zos.flush();\n                }\n                //关闭当前的zip条目，并定位流以写入下一个条目\n                zos.closeentry();\n                \n            }catch (exception e){\n                e.printstacktrace();\n            }finally {\n                try {\n                    if (finp != null){\n                        finp.close();\n                    }\n                } catch (ioexception e) {\n                    e.printstacktrace();\n                }\n            }\n            \n        }\n        \n    }\n    \n    public static void main(string[] args) {\n        compression();\n    }\n}\n\n\n压缩前提要确定要压缩的 文件夹 或 文件 ，还有压缩后的路径（带名称）\n\n\n# 解压流（解压文件）\n\n> class zipinputstream java.lang.object java.io.inputstream java.io.filterinputstream java.util.zip.inflaterinputstream java.util.zip.zipinputstream\n\n大致流程\n\n 1. 创建被压缩的对象 和 压缩包的对象\n 2. 创建 字节输入流 和 压缩输入流\n 3. 遍历 字节输入流 中的 压缩包里的条目（zipentry条目）\n 4. 按照压缩包里的目条 对应的文件名创建\n 5. 创建 字节输出流写入\n 6. 将 输入流 读取的数据通过 字节输出流 写入到硬盘中\n 7. 完成解压\n\n构造方法\n\nzipinputstream（inputstream in）\n\n> in：输出流\n\n方法\n\n修饰符        方法                                 说明\nint        available（）                        是否读取完目前指定的数据，读取完返回1，否则为0\nvoid       close（）                            关闭流\nvoid       closeentry（）                       关闭当前的zip条目，并定位流以读取下一个条目\nzipentry   createzipentry（string name）        为指定的条目名称创建一个新的 zipentry对象\nzipentry   getnextentry（）                     读取下一个zip文件条目，并将流定位在条目数据的开头\nint        read（byte[] b, int off, int len）   从当前zip条目读取到字节数组\nlong       skip（long n）                       跳过当前zip条目中指定的字节数\n\nimport java.io.file;\nimport java.io.fileinputstream;\nimport java.io.fileoutputstream;\nimport java.io.ioexception;\nimport java.util.zip.zipentry;\nimport java.util.zip.zipinputstream;\n\npublic class demo4 {\n    \n    //压缩方法\n    static void compression(){\n    \n        //解压路径及解压后的文件夹名称\n        file dir = new file("e:\\\\nn");\n        //压缩包的路径\n        file source = new file("e:\\\\mr2.zip");\n        //创建空条目\n        zipentry entry = null;\n        fileinputstream fis = null;\n        zipinputstream zis = null;\n        \n        try{\n        \n            fis = new fileinputstream(source);\n            zis = new zipinputstream(fis);\n            \n            while (true){\n    \n                //获取下一个zip文件条目，并将流定位在条目数据的开头\n                entry = zis.getnextentry();\n                //获取完为空 或 第一次获取失败 跳出循环\n                if (entry == null){\n                    break;\n                }\n                //文件夹跳过本次循环\n                if (entry.isdirectory()){\n                    continue;\n                }\n    \n                //创建文件\n                // dir：解压目的地文件夹\n                file f = new file(dir , entry.getname());\n    \n                /*\n                 *\n                 * getparentfile()方法 返回指定父路径的目录（文件），没有则空（null）\n                 * exists()方法 是否存在该文件\n                 * mkdirs()方法 创建路径名命名的目录，包括任何必需但不存在的父目录\n                 *\n                 * */\n    \n                //安全代码 ，创建压缩包里的文件夹\n                if (!f.getparentfile().exists()){\n                    f.getparentfile().mkdirs();\n                }\n    \n                int count = -1;\n                byte[] buf = new byte[1024];\n                //输出流\n                fileoutputstream fos = new fileoutputstream(f);\n                //压缩流循环读取 压缩包中的文件 直到读完\n                while((count = zis.read(buf)) != -1){\n                    //写入\n                    fos.write(buf , 0 , count);\n                    //流刷新（提升效率）\n                    fos.flush();\n                }\n                //关闭流\n                fos.close();\n                //关闭本次条目，跳到下一个\n                zis.closeentry();\n            }\n        \n        }catch (exception e){\n            e.printstacktrace();\n        }finally {\n            \n            if (zis != null){\n                try {\n                    zis.close();\n                } catch (ioexception e) {\n                    e.printstacktrace();\n                }\n            }\n            if(fis != null){\n                try {\n                    fis.close();\n                } catch (ioexception e) {\n                    e.printstacktrace();\n                }\n            }\n            \n        }\n        \n    }\n    \n    public static void main(string[] args) {\n        compression();\n    }\n}\n\n\n----------------------------------------\n\n以上是个人学习后写出来的代码分享，如果有问题可在下面留言！',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Lombok简化开发应用",frontmatter:{title:"Lombok简化开发应用",date:"2020-02-18T00:00:00.000Z",permalink:"/backend/b69655",categories:["后端","Java"],tags:["Java技巧"],author:"柏竹"},regularPath:"/01.%E5%90%8E%E7%AB%AF/03.Java%E6%8B%93%E5%B1%95/04.Lombok%E7%AE%80%E5%8C%96%E5%BC%80%E5%8F%91.html",relativePath:"01.后端/03.Java拓展/04.Lombok简化开发.md",key:"v-4de788f0",path:"/backend/b69655/",headers:[{level:2,title:"实例",slug:"实例",normalizedTitle:"实例",charIndex:815},{level:3,title:"val",slug:"val",normalizedTitle:"val",charIndex:123},{level:3,title:"@NonNull",slug:"nonnull",normalizedTitle:"@nonnull",charIndex:173},{level:3,title:"@Cleanup",slug:"cleanup",normalizedTitle:"@cleanup",charIndex:233},{level:3,title:"@ToString",slug:"tostring",normalizedTitle:"@tostring",charIndex:371},{level:3,title:"@EqualsAndHashCode",slug:"equalsandhashcode",normalizedTitle:"@equalsandhashcode",charIndex:433},{level:3,title:"构造方法",slug:"构造方法",normalizedTitle:"构造方法",charIndex:536},{level:3,title:"@Value",slug:"value",normalizedTitle:"@value",charIndex:755}],headersStr:"实例 val @NonNull @Cleanup @ToString @EqualsAndHashCode 构造方法 @Value",content:'# Lombok简化开发应用\n\nLombok是一个Java库，它是款可帮助开发人员减少 Java对象（POJO）的代码冗余，通过注解实现这一目的\n\n常用注解说明：\n\n注解                         用于        说明\nval                        属性声明      将变量声明为 final\n@NonNull                   方法参数、属性   对参数进行是否为空的校验，空则抛出NPE异常\n@Cleanup                   局部变量      当前变量范围内即将执行完毕退出之前会自动清理资源，自动生成try-finally这样的代码来关闭流\n@Getter/@Setter            属性、类      无需手写get、set方法\n@ToString                  类         toString方法 可设置 排除属性、包含类型\n@EqualsAndHashCode         类         自动生成 equals方法和hashCode方法\n@NoArgsConstructor         类         生成无参构造方法\n@RequiredArgsConstructor   类         可指定字段进生成构造方法（静态工厂方法\n@AllArgsConstructor        类         全参数构造方法\n@Data                      类         同时使用了@ToString、@Equals、@HashCode、@Getter、@Setter、@RequiredArgsConstrutor注解\n@Value                     类         属性添加final声明，只提供get\n\n\n# 实例\n\n安装插件 Lombok（IDEA默认捆绑该插件）\n\n添加依赖 pom.xml\n\n<dependency>\n    <groupId>org.projectlombok</groupId>\n    <artifactId>lombok</artifactId>\n    <scope>provided</scope>\n</dependency>\n\n\n\n# val\n\npublic static void main(String[] args) {\n    val sets = new HashSet<String>();\n    val lists = new ArrayList<String>();\n    val maps = new HashMap<String, String>();\n    //=>相当于如下\n    final Set<String> sets2 = new HashSet<>();\n    final List<String> lists2 = new ArrayList<>();\n    final Map<String, String> maps2 = new HashMap<>();\n}\n\n\n\n# @NonNull\n\npublic void notNullExample(@NonNull String string) {\n    string.length();\n}\n//=>相当于\npublic void notNullExample(String string) {\n    if (string != null) {\n        string.length();\n    } else {\n        throw new NullPointerException("null");\n    }\n}\n\n\n\n# @Cleanup\n\npublic static void main(String[] args) {\n    try {\n        @Cleanup InputStream inputStream = new FileInputStream(args[0]);\n    } catch (FileNotFoundException e) {\n        e.printStackTrace();\n    }\n    //=>相当于\n    InputStream inputStream = null;\n    try {\n        inputStream = new FileInputStream(args[0]);\n    } catch (FileNotFoundException e) {\n        e.printStackTrace();\n    } finally {\n        if (inputStream != null) {\n            try {\n                inputStream.close();\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n        }\n    }\n}\n\n\n\n# @ToString\n\n@ToString(exclude = "id", callSuper = true, includeFieldNames = true)\npublic class LombokDemo {\n    private int id;\n    private String name;\n    private int age;\n    public static void main(String[] args) {\n        //输出LombokDemo(super=LombokDemo@48524010, name=null, age=0)\n        System.out.println(new LombokDemo());\n    }\n}\n\n\n\n# @EqualsAndHashCode\n\n@EqualsAndHashCode(exclude = {"id", "shape"}, callSuper = false)\npublic class LombokDemo {\n    private int id;\n    private String shap;\n}\n\n\n\n# 构造方法\n\n@NoArgsConstructor\n@RequiredArgsConstructor(staticName = "of")\n@AllArgsConstructor\npublic class LombokDemo {\n    @NonNull\n    private int id;\n    @NonNull\n    private String shap;\n    private int age;\n    public static void main(String[] args) {\n        new LombokDemo(1, "circle");\n        //使用静态工厂方法\n        LombokDemo.of(2, "circle");\n        //无参构造\n        new LombokDemo();\n        //包含所有参数\n        new LombokDemo(1, "circle", 2);\n    }\n}\n\n\n\n# @Value\n\n@Value\npublic class LombokDemo {\n    @NonNull\n    private int id;\n    @NonNull\n    private String shap;\n    private int age;\n    //相当于 （只有get方法\n    private final int id;\n    public int getId() {\n        return this.id;\n    }\n    ...\n}\n\n\n参考：https://segmentfault.com/a/1190000020181422',normalizedContent:'# lombok简化开发应用\n\nlombok是一个java库，它是款可帮助开发人员减少 java对象（pojo）的代码冗余，通过注解实现这一目的\n\n常用注解说明：\n\n注解                         用于        说明\nval                        属性声明      将变量声明为 final\n@nonnull                   方法参数、属性   对参数进行是否为空的校验，空则抛出npe异常\n@cleanup                   局部变量      当前变量范围内即将执行完毕退出之前会自动清理资源，自动生成try-finally这样的代码来关闭流\n@getter/@setter            属性、类      无需手写get、set方法\n@tostring                  类         tostring方法 可设置 排除属性、包含类型\n@equalsandhashcode         类         自动生成 equals方法和hashcode方法\n@noargsconstructor         类         生成无参构造方法\n@requiredargsconstructor   类         可指定字段进生成构造方法（静态工厂方法\n@allargsconstructor        类         全参数构造方法\n@data                      类         同时使用了@tostring、@equals、@hashcode、@getter、@setter、@requiredargsconstrutor注解\n@value                     类         属性添加final声明，只提供get\n\n\n# 实例\n\n安装插件 lombok（idea默认捆绑该插件）\n\n添加依赖 pom.xml\n\n<dependency>\n    <groupid>org.projectlombok</groupid>\n    <artifactid>lombok</artifactid>\n    <scope>provided</scope>\n</dependency>\n\n\n\n# val\n\npublic static void main(string[] args) {\n    val sets = new hashset<string>();\n    val lists = new arraylist<string>();\n    val maps = new hashmap<string, string>();\n    //=>相当于如下\n    final set<string> sets2 = new hashset<>();\n    final list<string> lists2 = new arraylist<>();\n    final map<string, string> maps2 = new hashmap<>();\n}\n\n\n\n# @nonnull\n\npublic void notnullexample(@nonnull string string) {\n    string.length();\n}\n//=>相当于\npublic void notnullexample(string string) {\n    if (string != null) {\n        string.length();\n    } else {\n        throw new nullpointerexception("null");\n    }\n}\n\n\n\n# @cleanup\n\npublic static void main(string[] args) {\n    try {\n        @cleanup inputstream inputstream = new fileinputstream(args[0]);\n    } catch (filenotfoundexception e) {\n        e.printstacktrace();\n    }\n    //=>相当于\n    inputstream inputstream = null;\n    try {\n        inputstream = new fileinputstream(args[0]);\n    } catch (filenotfoundexception e) {\n        e.printstacktrace();\n    } finally {\n        if (inputstream != null) {\n            try {\n                inputstream.close();\n            } catch (ioexception e) {\n                e.printstacktrace();\n            }\n        }\n    }\n}\n\n\n\n# @tostring\n\n@tostring(exclude = "id", callsuper = true, includefieldnames = true)\npublic class lombokdemo {\n    private int id;\n    private string name;\n    private int age;\n    public static void main(string[] args) {\n        //输出lombokdemo(super=lombokdemo@48524010, name=null, age=0)\n        system.out.println(new lombokdemo());\n    }\n}\n\n\n\n# @equalsandhashcode\n\n@equalsandhashcode(exclude = {"id", "shape"}, callsuper = false)\npublic class lombokdemo {\n    private int id;\n    private string shap;\n}\n\n\n\n# 构造方法\n\n@noargsconstructor\n@requiredargsconstructor(staticname = "of")\n@allargsconstructor\npublic class lombokdemo {\n    @nonnull\n    private int id;\n    @nonnull\n    private string shap;\n    private int age;\n    public static void main(string[] args) {\n        new lombokdemo(1, "circle");\n        //使用静态工厂方法\n        lombokdemo.of(2, "circle");\n        //无参构造\n        new lombokdemo();\n        //包含所有参数\n        new lombokdemo(1, "circle", 2);\n    }\n}\n\n\n\n# @value\n\n@value\npublic class lombokdemo {\n    @nonnull\n    private int id;\n    @nonnull\n    private string shap;\n    private int age;\n    //相当于 （只有get方法\n    private final int id;\n    public int getid() {\n        return this.id;\n    }\n    ...\n}\n\n\n参考：https://segmentfault.com/a/1190000020181422',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Maven",frontmatter:{title:"Maven",author:"柏竹",permalink:"/backend/60chrc",date:"2020-02-18T00:00:00.000Z",categories:["后端","框架"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/04.%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF/01.Maven.html",relativePath:"01.后端/04.框架技术/01.Maven.md",key:"v-256a7c79",path:"/backend/60chrc/",headers:[{level:2,title:"概念",slug:"概念",normalizedTitle:"概念",charIndex:12},{level:3,title:"目录布局",slug:"目录布局",normalizedTitle:"目录布局",charIndex:19},{level:3,title:"仓库",slug:"仓库",normalizedTitle:"仓库",charIndex:536},{level:4,title:"本地仓库",slug:"本地仓库",normalizedTitle:"本地仓库",charIndex:559},{level:4,title:"远程仓库",slug:"远程仓库",normalizedTitle:"远程仓库",charIndex:581},{level:5,title:"中央仓库",slug:"中央仓库",normalizedTitle:"中央仓库",charIndex:620},{level:5,title:"私服",slug:"私服",normalizedTitle:"私服",charIndex:652},{level:4,title:"配置本地仓库",slug:"配置本地仓库",normalizedTitle:"配置本地仓库",charIndex:687},{level:4,title:"配置远程仓库",slug:"配置远程仓库",normalizedTitle:"配置远程仓库",charIndex:852},{level:3,title:"核心文件pom.xml",slug:"核心文件pom-xml",normalizedTitle:"核心文件pom.xml",charIndex:1267},{level:4,title:"packaging",slug:"packaging",normalizedTitle:"packaging",charIndex:2125},{level:4,title:"dependencies",slug:"dependencies",normalizedTitle:"dependencies",charIndex:2294},{level:3,title:"坐标",slug:"坐标",normalizedTitle:"坐标",charIndex:2286},{level:3,title:"生命周期",slug:"生命周期",normalizedTitle:"生命周期",charIndex:3573},{level:4,title:"clean 清理项目",slug:"clean-清理项目",normalizedTitle:"clean 清理项目",charIndex:3607},{level:4,title:"default 构建项目(核心)",slug:"default-构建项目-核心",normalizedTitle:"default 构建项目(核心)",charIndex:3723},{level:4,title:"site 生成项目站点",slug:"site-生成项目站点",normalizedTitle:"site 生成项目站点",charIndex:4134},{level:2,title:"IDEA应用Maven项目",slug:"idea应用maven项目",normalizedTitle:"idea应用maven项目",charIndex:4380},{level:3,title:"IDEA配置",slug:"idea配置",normalizedTitle:"idea配置",charIndex:4398},{level:3,title:"Java项目的创建",slug:"java项目的创建",normalizedTitle:"java项目的创建",charIndex:4466},{level:4,title:"有骨架",slug:"有骨架",normalizedTitle:"有骨架",charIndex:4479},{level:4,title:"无骨架",slug:"无骨架",normalizedTitle:"无骨架",charIndex:4523},{level:3,title:"JavaWeb项目的创建",slug:"javaweb项目的创建",normalizedTitle:"javaweb项目的创建",charIndex:4591},{level:4,title:"有骨架",slug:"有骨架-2",normalizedTitle:"有骨架",charIndex:4479},{level:4,title:"无骨架",slug:"无骨架-2",normalizedTitle:"无骨架",charIndex:4523},{level:3,title:"构建项目",slug:"构建项目",normalizedTitle:"构建项目",charIndex:3731},{level:2,title:"常用命令",slug:"常用命令",normalizedTitle:"常用命令",charIndex:5798},{level:3,title:"mvn compile",slug:"mvn-compile",normalizedTitle:"mvn compile",charIndex:5835},{level:3,title:"mvn clean",slug:"mvn-clean",normalizedTitle:"mvn clean",charIndex:5881},{level:3,title:"mvn test",slug:"mvn-test",normalizedTitle:"mvn test",charIndex:5908},{level:3,title:"mvn package",slug:"mvn-package",normalizedTitle:"mvn package",charIndex:5998},{level:3,title:"mvn install",slug:"mvn-install",normalizedTitle:"mvn install",charIndex:6048},{level:3,title:"组合命令",slug:"组合命令",normalizedTitle:"组合命令",charIndex:6093},{level:3,title:"IDEA命令执行",slug:"idea命令执行",normalizedTitle:"idea命令执行",charIndex:6205},{level:2,title:"Maven依赖",slug:"maven依赖",normalizedTitle:"maven依赖",charIndex:6236},{level:3,title:"依赖管理",slug:"依赖管理",normalizedTitle:"依赖管理",charIndex:6248},{level:4,title:"依赖范围(scope)",slug:"依赖范围-scope",normalizedTitle:"依赖范围(scope)",charIndex:6503},{level:3,title:"依赖传递",slug:"依赖传递",normalizedTitle:"依赖传递",charIndex:6928},{level:3,title:"依赖排除",slug:"依赖排除",normalizedTitle:"依赖排除",charIndex:7183},{level:2,title:"Mavean问题",slug:"mavean问题",normalizedTitle:"mavean问题",charIndex:8009},{level:3,title:"web项目失效",slug:"web项目失效",normalizedTitle:"web项目失效",charIndex:8022}],headersStr:"概念 目录布局 仓库 本地仓库 远程仓库 中央仓库 私服 配置本地仓库 配置远程仓库 核心文件pom.xml packaging dependencies 坐标 生命周期 clean 清理项目 default 构建项目(核心) site 生成项目站点 IDEA应用Maven项目 IDEA配置 Java项目的创建 有骨架 无骨架 JavaWeb项目的创建 有骨架 无骨架 构建项目 常用命令 mvn compile mvn clean mvn test mvn package mvn install 组合命令 IDEA命令执行 Maven依赖 依赖管理 依赖范围(scope) 依赖传递 依赖排除 Mavean问题 web项目失效",content:'# Maven\n\n\n# 概念\n\n\n# 目录布局\n\nMaven创建项目，目录结构都是有标准的模板\n\n目录                   说明\nsrc/main/java        应用程序的源代码的目录\nsrc/main/resources   项目的源文件所在的目录\nsrc/main/filters     资源筛选器文件\nsrc/main/webapp      Web 应用程序源\nsrc/test/java        测试代码所在的目录\nsrc/test/resources   测试资源\nsrc/test/filters     测试资源筛选器文件\nsrc/it               集成测试（主要针对插件）\nsrc/assembly         装配描述符\nsrc/site             网站\npom.xml              核心配置文件,项目的描述文件\ntarget               项目构建的输出文件\nLICENSE.txt          项目许可证\nNOTICE.txt           项目所依赖的库所需的通知和归属\nREADME.txt           项目的读物\n\n\n\n\n# 仓库\n\n专门 存放Maven项目的位置\n\n# 本地仓库\n\n本地上的一个文件夹。首次应用会从远程仓库进行下载的，下次应用会在本地找，没有则下载远程\n\n# 远程仓库\n\n# 中央仓库\n\n官方提供的仓库 ，也是 Macen的默认仓库\n\n# 私服\n\n局域网内架设私有的仓库服务器，用于提供外部远程仓库应用\n\n# 配置本地仓库\n\n在 根目录\\conf\\setting.xml 文件的 settings节点里 添加以下代码\n\n> 我的本地存储位置在 D:\\Maven\\repository\n\n\x3c!-- 配置本地仓库 --\x3e\n<localRepository>D:\\Maven\\repository</localRepository>\n\n\n\n\n# 配置远程仓库\n\n> Macen 默认仓库是 境外，下载速度慢、不便捷\n> \n> 于是我们选择使用 国内阿里云Macen仓库作为中央仓库镜像\n\n在 根目录\\conf\\setting.xml 文件的 mirrors节点里 添加以下代码（更改为阿里云Macen仓库）\n\n\x3c!-- 配置阿里云镜像 --\x3e\n<mirror>\n    \x3c!-- 镜像的唯一标识 --\x3e\n\t<id>nexus-aliyun</id>\n    \x3c!-- 镜像名称 --\x3e\n\t<name>Nexus aliyun</name>\n    \x3c!-- 镜像仓库 Maven地址 --\x3e\n\t<url>http://Maven.aliyun.com/nexus/content/groups/public/</url>\n    \x3c!-- 配置是否为中央仓库镜像，如果是，则central --\x3e\n\t<mirrorOf>*</mirrorOf>\n</mirror>\n\n\n\n# 核心文件pom.xml\n\nPOM是 Maven 工程的基本工作单元，是一个XML文件，包含 了项目的基本信息，用于描述项目如何构建，声明项目依赖\n\n执行任务或目标时，Maven 会在当前目录中查找 POM。它读取 POM，获取所需的配置信息，然后执行目标。\n\n<project xmlns="http://Maven.apache.org/POM/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://Maven.apache.org/POM/4.0.0\nhttp://Maven.apache.org/xsd/Maven-4.0.0.xsd">\n\x3c!-- Maven模型的版本 --\x3e\n<modelVersion>4.0.0</modelVersion>\n\x3c!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如\ncom.companyname.project-group，Maven会将该项目打成的jar包放本地路\n径：/com/companyname/project-group --\x3e\n<groupId>com.Maven</groupId>\n\x3c!-- 项目的唯一ID，一个groupId下面可能多个项目，就是靠artifactId来区分的 --\x3e\n<artifactId>HelloWorld</artifactId>\n\x3c!-- 当前项目版本号：同一个项目开发过程中可以发布多个版本，此处标示0.0.1版 --\x3e\n\x3c!-- 当前项目版本号：每个工程发布后可以发布多个版本，依赖时调取不同的版本，使用不同的版本号\n当前项目版本号，snapshot为快照版本即非正式版本，release为正式发布版本\n--\x3e\n<version>0.0.1-snapshot</version>\n\x3c!--打包类型，一般有jar、war、pom等--\x3e\n<packaging>jar</packaging>\n\x3c!-- 名称：可省略 ,常用于 Maven 生成的文档。--\x3e\n<name>Hello</name>\n\x3c!--项目描述：可省略,常用于 Maven 生成的文档--\x3e\n<description></description>\n\x3c!-- 项目依赖构件配置，配置项目依赖构件的坐标 --\x3e\n<dependencies>\n    \x3c!-- 依赖设置 ，可以有多个dependency节点--\x3e\n    <dependency>\n        \x3c!-- 依赖组织名称 --\x3e\n        <groupId>junit</groupId>\n        \x3c!-- 依赖项目名称 --\x3e\n        <artifactId>junit</artifactId>\n        \x3c!-- 依赖版本名称 --\x3e\n        <version>4.12</version>\n        \x3c!-- 依赖范围：test包下依赖该设置 --\x3e\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n\x3c!-- 项目构建配置，配置编译、运行插件等。--\x3e\n<build>\n\t<plugins>\n        \x3c!--插件--\x3e\n\t\t<plugin>\n\t\t\t<groupId>org.apache.maven.plugins</groupId>\n\t\t\t<artifactId>maven-compiler-plugin</artifactId>\n\t\t\t<version>3.8.0</version>\n\t\t\t<configuration>\n\t\t\t\t<source>1.8</source>\n\t\t\t\t<target>1.8</target>\n\t\t\t</configuration>\n\t\t</plugin>\n\t</plugins>    \n</build>\n</project>\n\n\n# packaging\n\npackaging标签选项，指定项目的类型\n\n项目类型一共有：\n\n * jar ：Java工程\n * pom ：聚合工程\n * war ：Web工程\n\n# dependencies\n\ndependencies标签选项，指定依赖的jar包集，搭配 dependency标签实现\n\n<dependencies>\n\t<dependency>\n\t\t<groupId>junit</groupId>\n\t\t<artifactId>junit</artifactId>\n\t\t<version>4.10</version>\n\t</dependency>\n\t<dependency>\n\t\t<groupId>org.mybatis</groupId>\n\t\t<artifactId>mybatis</artifactId>\n\t\t<version>3.2.8</version>\n\t</dependency>\n</dependencies>\n\n\n\n# 坐标\n\nMaven世界中有大量的构件,需要唯一标识的坐标就可以找到我们想要的坐标（其原理类似于平面几何中的坐标 x、y进行标识唯一位置的点）\n\nMaven坐标组成部分：\n\n> groupId： 当前Maven项目组织名称\n> \n> artifactId： 实际项目名称\n> \n> version： 当前项目的版本 或 所依赖jar包的版本\n\n\n# 生命周期\n\nMaven拥有三套生命周期，他们相互独立互不干扰\n\n# clean 清理项目\n\n阶段           说明\npre-clean    在实际项目清理之前执行所需的流程\nclean        删除上一个版本生成的所有文件\npost-clean   执行完成项目清洁所需的流程\n\n# default 构建项目(核心)\n\n阶段                   说明\ngenerate-resources   生成资源以包含在包中\nprocess-resources    将资源复制并处理到目的地目录中，准备进行包装\ncompile              编译项目的源代码\ntest-compile         将测试源代码编译到测试目的地目录中\ntest                 使用合适的单位测试框架运行测试。这些测试不应要求对代码进行包装或部署\ninstall              将封装安装到本地存储库中，以用作本地其他项目的依赖\ndeploy               在集成或发布环境中完成，将最终包复制到远程存储库，以便与其他开发人员和项目共享\n···                  ···\n\n> 注意：运行任何一个阶段的时候，它前面的所有阶段都会被运行\n\n# site 生成项目站点\n\n阶段            说明\npre-site      在实际项目站点生成之前执行所需的流程\nsite          生成项目的站点文档\npost-site     执行完成站点生成和准备站点部署所需的过程\nsite-deploy   将生成的站点文档部署到指定的 Web 服务器\n\n----------------------------------------\n\n参考文档：http://maven.apache.org/index.html\n\n\n# IDEA应用Maven项目\n\n\n# IDEA配置\n\n 1. 打开所有设置（必须在这里打开设置，否则其他项目无效）\n 2. 设置Maven项目目录\n 3. 运行环境\n\n\n# Java项目的创建\n\n# 有骨架\n\n 1. 创建项目，选择骨架\n 2. 配置项目基本信息\n 3. 确认信息\n\n# 无骨架\n\n只需关闭选中，其他步骤跟有骨架的一致\n\n无骨架创建项目需要自行配置 pom.xml\n\n> 手动将Maven文件夹补齐\n\n\n# JavaWeb项目的创建\n\n# 有骨架\n\n步骤就一步不一样，其他剩下步骤就不赘述了！\n\n# 无骨架\n\n无骨架创建项目后，需要自行配置 JavaWeb信息\n\n 1. 项目配置\n 2. 手动添加Web目录\n 3. 添加创建内容\n\n\n# 构建项目\n\n添加Tomcat插件无需运行本地的Tomcat\n\n 1. 配置 pom.xml\n    \n     \x3c!--配置war包--\x3e\n    <packaging>war</packaging>\n    \n    \x3c!--添加jar依赖--\x3e\n    <dependencies>\n        <dependency>\n            <groupId>javax.servlet</groupId>\n            <artifactId>javax.servlet-api</artifactId>\n            <version>4.0.1</version>\n            <scope>provided</scope>\n        </dependency>\n        <dependency>\n            <groupId>javax.servlet.jsp</groupId>\n            <artifactId>jsp-api</artifactId>\n            <version>2.0</version>\n            <scope>provided</scope>\n        </dependency>\n    </dependencies>\n    \n    \x3c!--添加插件--\x3e\n    <build>\n        <plugins>\n            \x3c!--tomcat插件--\x3e\n            <plugin>\n                <groupId>org.apache.tomcat.maven</groupId>\n                <artifactId>tomcat7-maven-plugin</artifactId>\n                <version>2.0</version>\n                \x3c!--Tomcat配置--\x3e\n                <configuration>\n                    <port>8080</port>\n                    <path>/</path>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n    \n\n 2. 运行配置\n\n\n# 常用命令\n\nMaven命令需要在 pom.xml 所在目录中执行\n\n\n# mvn compile\n\n生成 target目录,该目录中存放了编译后的字节码文件\n\n\n# mvn clean\n\n删除 target目录\n\n\n# mvn test\n\n在 target目录 中生成，surefire、 surefire-reports（测试报告）、test-classes（测试的字节码文件）三个文件夹\n\n\n# mvn package\n\n在 target目录 中生成本项目的 jar包 或 war包 等\n\n\n# mvn install\n\n将打包好的 jar包 安装到本地仓库，方便其他工程应用\n\n\n# 组合命令\n\n组合命令，严格遵守生命周期的执行顺序！\n\n * mvn clean compile\n * mvn clean test\n * mvn clean package\n * mvn clean install\n\n\n# IDEA命令执行\n\n根据下图双击即可运行相应的命令！\n\n\n# Maven依赖\n\n\n# 依赖管理\n\n项目依赖管理 ，pom.xml 文件中定义jar包的GAV坐标\n\n<dependencies>\n\t<dependency>\n        \x3c!--依赖 GAV坐标--\x3e\n\t\t<groupId>junit</groupId>\n\t\t<artifactId>junit</artifactId>\n\t\t<version>4.10</version>\n        \x3c!--依赖范围--\x3e\n\t\t<scope>test</scope>\n\t</dependency>\n</dependencies>\n\n\n# 依赖范围(scope)\n\n依赖范围用于限制依赖的环境应用，指定何时提供依赖及分类路径\n\n依赖范围值(SCOPE)   说明\ncompile（默认值）   项目的所有类路径中提供\n               (为所有类编译提供依赖)\nprovided       编译和测试时需要，jar包不进行打包\n               (以防运行环境已经存在相同的包发生冲突)\nruntime        测试、运行时需要\ntest           测试时需要，但不进行打包\n···            ···\n\n依赖范围       主类编译路径   测试编译路径   打包且编译时有效\ncompile    Y        Y        Y\nprovided   Y        Y        -\nruntime    -        -        Y\ntest       -        Y        -\n\n\n# 依赖传递\n\n在项目往往需要引入多个依赖， 而引入的依赖又会引入其他的依赖，项目会自动引入依赖中的依赖！\n\n假设 A项目 引入 B 和 E 依赖 ，他们有各自的依赖关系\n\nA => B B => C C => D A => E E => D\n\n  A项目\n  |\n  ├── B\n  │   └── C\n  │       └── D(2.0)\n  └── E\n      └── D(1.0)\n\n\n> 最后 A项目 导入了D(1.0)，排除D(2.0)\n> \n> 系统会根据导入的就近原则进行依赖应用\n\n\n# 依赖排除\n\nMaven 的依赖传递过程可选择性的排除依赖。如果依赖中有其他依赖可对其进行排除！\n\n<dependency>\n\t<groupId>junit</groupId>\n\t<artifactId>junit</artifactId>\n\t<version>4.11</version>\n\t\x3c!--排除依赖--\x3e\n\t<exclusions>\n\t\t<exclusion>\n\t\t\t<groupId>org.hamcrest</groupId>\n\t\t\t<artifactId>hamcrest-core</artifactId>\n            \x3c!--排除依赖无需版本号--\x3e\n\t\t</exclusion>\n\t</exclusions>\n</dependency>\n\n\nPS：排除依赖包中所包含的依赖关系，不需要添加版本号\n\n假如我想在 上面假设中排除D(1.0)，引入D(2.0)\n\n···\n\x3c!--引入B依赖--\x3e\n<dependency>\n\t<groupId>B</groupId>\n\t<artifactId>B</artifactId>\n\t<version>0.1</version>\n   \t\x3c!--排除依赖--\x3e\n\t<exclusions>\n        \x3c!--排除 B依赖 中的 依赖C--\x3e\n\t\t<exclusion>\n\t\t\t<groupId>D</groupId>\n\t\t\t<artifactId>D</artifactId>\n            \x3c!--排除依赖无需版本号--\x3e\n\t\t</exclusion>\n\t</exclusions>\n</dependency>\n\x3c!--引入E依赖--\x3e\n<dependency>  \n\t<groupId>E</groupId>\n\t<artifactId>E</artifactId>\n\t<version>0.1</version>\n</dependency> \n···\n\n\n\n# Mavean问题\n\n\n# web项目失效\n\n问题说明：\n\nweb文件夹目录未 被idea标识（文件夹没有小蓝点）\n\n可能原因：\n\n * pom.xml 未配置 packaging标签 未配置war包\n * 项目结构未配置好\n * idea缓存问题\n\n涉及解决方案：\n\n * pom.xml 配置 packaging标签\n   \n   <packaging>war</packaging>\n   \n\n * 项目结构Web配置： 点击操作流程 （指定索引到操作流程）\n\n * 清空idea缓存并重启\n   \n   ',normalizedContent:'# maven\n\n\n# 概念\n\n\n# 目录布局\n\nmaven创建项目，目录结构都是有标准的模板\n\n目录                   说明\nsrc/main/java        应用程序的源代码的目录\nsrc/main/resources   项目的源文件所在的目录\nsrc/main/filters     资源筛选器文件\nsrc/main/webapp      web 应用程序源\nsrc/test/java        测试代码所在的目录\nsrc/test/resources   测试资源\nsrc/test/filters     测试资源筛选器文件\nsrc/it               集成测试（主要针对插件）\nsrc/assembly         装配描述符\nsrc/site             网站\npom.xml              核心配置文件,项目的描述文件\ntarget               项目构建的输出文件\nlicense.txt          项目许可证\nnotice.txt           项目所依赖的库所需的通知和归属\nreadme.txt           项目的读物\n\n\n\n\n# 仓库\n\n专门 存放maven项目的位置\n\n# 本地仓库\n\n本地上的一个文件夹。首次应用会从远程仓库进行下载的，下次应用会在本地找，没有则下载远程\n\n# 远程仓库\n\n# 中央仓库\n\n官方提供的仓库 ，也是 macen的默认仓库\n\n# 私服\n\n局域网内架设私有的仓库服务器，用于提供外部远程仓库应用\n\n# 配置本地仓库\n\n在 根目录\\conf\\setting.xml 文件的 settings节点里 添加以下代码\n\n> 我的本地存储位置在 d:\\maven\\repository\n\n\x3c!-- 配置本地仓库 --\x3e\n<localrepository>d:\\maven\\repository</localrepository>\n\n\n\n\n# 配置远程仓库\n\n> macen 默认仓库是 境外，下载速度慢、不便捷\n> \n> 于是我们选择使用 国内阿里云macen仓库作为中央仓库镜像\n\n在 根目录\\conf\\setting.xml 文件的 mirrors节点里 添加以下代码（更改为阿里云macen仓库）\n\n\x3c!-- 配置阿里云镜像 --\x3e\n<mirror>\n    \x3c!-- 镜像的唯一标识 --\x3e\n\t<id>nexus-aliyun</id>\n    \x3c!-- 镜像名称 --\x3e\n\t<name>nexus aliyun</name>\n    \x3c!-- 镜像仓库 maven地址 --\x3e\n\t<url>http://maven.aliyun.com/nexus/content/groups/public/</url>\n    \x3c!-- 配置是否为中央仓库镜像，如果是，则central --\x3e\n\t<mirrorof>*</mirrorof>\n</mirror>\n\n\n\n# 核心文件pom.xml\n\npom是 maven 工程的基本工作单元，是一个xml文件，包含 了项目的基本信息，用于描述项目如何构建，声明项目依赖\n\n执行任务或目标时，maven 会在当前目录中查找 pom。它读取 pom，获取所需的配置信息，然后执行目标。\n\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0\nhttp://maven.apache.org/xsd/maven-4.0.0.xsd">\n\x3c!-- maven模型的版本 --\x3e\n<modelversion>4.0.0</modelversion>\n\x3c!-- 公司或者组织的唯一标志，并且配置时生成的路径也是由此生成， 如\ncom.companyname.project-group，maven会将该项目打成的jar包放本地路\n径：/com/companyname/project-group --\x3e\n<groupid>com.maven</groupid>\n\x3c!-- 项目的唯一id，一个groupid下面可能多个项目，就是靠artifactid来区分的 --\x3e\n<artifactid>helloworld</artifactid>\n\x3c!-- 当前项目版本号：同一个项目开发过程中可以发布多个版本，此处标示0.0.1版 --\x3e\n\x3c!-- 当前项目版本号：每个工程发布后可以发布多个版本，依赖时调取不同的版本，使用不同的版本号\n当前项目版本号，snapshot为快照版本即非正式版本，release为正式发布版本\n--\x3e\n<version>0.0.1-snapshot</version>\n\x3c!--打包类型，一般有jar、war、pom等--\x3e\n<packaging>jar</packaging>\n\x3c!-- 名称：可省略 ,常用于 maven 生成的文档。--\x3e\n<name>hello</name>\n\x3c!--项目描述：可省略,常用于 maven 生成的文档--\x3e\n<description></description>\n\x3c!-- 项目依赖构件配置，配置项目依赖构件的坐标 --\x3e\n<dependencies>\n    \x3c!-- 依赖设置 ，可以有多个dependency节点--\x3e\n    <dependency>\n        \x3c!-- 依赖组织名称 --\x3e\n        <groupid>junit</groupid>\n        \x3c!-- 依赖项目名称 --\x3e\n        <artifactid>junit</artifactid>\n        \x3c!-- 依赖版本名称 --\x3e\n        <version>4.12</version>\n        \x3c!-- 依赖范围：test包下依赖该设置 --\x3e\n        <scope>test</scope>\n    </dependency>\n</dependencies>\n\x3c!-- 项目构建配置，配置编译、运行插件等。--\x3e\n<build>\n\t<plugins>\n        \x3c!--插件--\x3e\n\t\t<plugin>\n\t\t\t<groupid>org.apache.maven.plugins</groupid>\n\t\t\t<artifactid>maven-compiler-plugin</artifactid>\n\t\t\t<version>3.8.0</version>\n\t\t\t<configuration>\n\t\t\t\t<source>1.8</source>\n\t\t\t\t<target>1.8</target>\n\t\t\t</configuration>\n\t\t</plugin>\n\t</plugins>    \n</build>\n</project>\n\n\n# packaging\n\npackaging标签选项，指定项目的类型\n\n项目类型一共有：\n\n * jar ：java工程\n * pom ：聚合工程\n * war ：web工程\n\n# dependencies\n\ndependencies标签选项，指定依赖的jar包集，搭配 dependency标签实现\n\n<dependencies>\n\t<dependency>\n\t\t<groupid>junit</groupid>\n\t\t<artifactid>junit</artifactid>\n\t\t<version>4.10</version>\n\t</dependency>\n\t<dependency>\n\t\t<groupid>org.mybatis</groupid>\n\t\t<artifactid>mybatis</artifactid>\n\t\t<version>3.2.8</version>\n\t</dependency>\n</dependencies>\n\n\n\n# 坐标\n\nmaven世界中有大量的构件,需要唯一标识的坐标就可以找到我们想要的坐标（其原理类似于平面几何中的坐标 x、y进行标识唯一位置的点）\n\nmaven坐标组成部分：\n\n> groupid： 当前maven项目组织名称\n> \n> artifactid： 实际项目名称\n> \n> version： 当前项目的版本 或 所依赖jar包的版本\n\n\n# 生命周期\n\nmaven拥有三套生命周期，他们相互独立互不干扰\n\n# clean 清理项目\n\n阶段           说明\npre-clean    在实际项目清理之前执行所需的流程\nclean        删除上一个版本生成的所有文件\npost-clean   执行完成项目清洁所需的流程\n\n# default 构建项目(核心)\n\n阶段                   说明\ngenerate-resources   生成资源以包含在包中\nprocess-resources    将资源复制并处理到目的地目录中，准备进行包装\ncompile              编译项目的源代码\ntest-compile         将测试源代码编译到测试目的地目录中\ntest                 使用合适的单位测试框架运行测试。这些测试不应要求对代码进行包装或部署\ninstall              将封装安装到本地存储库中，以用作本地其他项目的依赖\ndeploy               在集成或发布环境中完成，将最终包复制到远程存储库，以便与其他开发人员和项目共享\n···                  ···\n\n> 注意：运行任何一个阶段的时候，它前面的所有阶段都会被运行\n\n# site 生成项目站点\n\n阶段            说明\npre-site      在实际项目站点生成之前执行所需的流程\nsite          生成项目的站点文档\npost-site     执行完成站点生成和准备站点部署所需的过程\nsite-deploy   将生成的站点文档部署到指定的 web 服务器\n\n----------------------------------------\n\n参考文档：http://maven.apache.org/index.html\n\n\n# idea应用maven项目\n\n\n# idea配置\n\n 1. 打开所有设置（必须在这里打开设置，否则其他项目无效）\n 2. 设置maven项目目录\n 3. 运行环境\n\n\n# java项目的创建\n\n# 有骨架\n\n 1. 创建项目，选择骨架\n 2. 配置项目基本信息\n 3. 确认信息\n\n# 无骨架\n\n只需关闭选中，其他步骤跟有骨架的一致\n\n无骨架创建项目需要自行配置 pom.xml\n\n> 手动将maven文件夹补齐\n\n\n# javaweb项目的创建\n\n# 有骨架\n\n步骤就一步不一样，其他剩下步骤就不赘述了！\n\n# 无骨架\n\n无骨架创建项目后，需要自行配置 javaweb信息\n\n 1. 项目配置\n 2. 手动添加web目录\n 3. 添加创建内容\n\n\n# 构建项目\n\n添加tomcat插件无需运行本地的tomcat\n\n 1. 配置 pom.xml\n    \n     \x3c!--配置war包--\x3e\n    <packaging>war</packaging>\n    \n    \x3c!--添加jar依赖--\x3e\n    <dependencies>\n        <dependency>\n            <groupid>javax.servlet</groupid>\n            <artifactid>javax.servlet-api</artifactid>\n            <version>4.0.1</version>\n            <scope>provided</scope>\n        </dependency>\n        <dependency>\n            <groupid>javax.servlet.jsp</groupid>\n            <artifactid>jsp-api</artifactid>\n            <version>2.0</version>\n            <scope>provided</scope>\n        </dependency>\n    </dependencies>\n    \n    \x3c!--添加插件--\x3e\n    <build>\n        <plugins>\n            \x3c!--tomcat插件--\x3e\n            <plugin>\n                <groupid>org.apache.tomcat.maven</groupid>\n                <artifactid>tomcat7-maven-plugin</artifactid>\n                <version>2.0</version>\n                \x3c!--tomcat配置--\x3e\n                <configuration>\n                    <port>8080</port>\n                    <path>/</path>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n    \n\n 2. 运行配置\n\n\n# 常用命令\n\nmaven命令需要在 pom.xml 所在目录中执行\n\n\n# mvn compile\n\n生成 target目录,该目录中存放了编译后的字节码文件\n\n\n# mvn clean\n\n删除 target目录\n\n\n# mvn test\n\n在 target目录 中生成，surefire、 surefire-reports（测试报告）、test-classes（测试的字节码文件）三个文件夹\n\n\n# mvn package\n\n在 target目录 中生成本项目的 jar包 或 war包 等\n\n\n# mvn install\n\n将打包好的 jar包 安装到本地仓库，方便其他工程应用\n\n\n# 组合命令\n\n组合命令，严格遵守生命周期的执行顺序！\n\n * mvn clean compile\n * mvn clean test\n * mvn clean package\n * mvn clean install\n\n\n# idea命令执行\n\n根据下图双击即可运行相应的命令！\n\n\n# maven依赖\n\n\n# 依赖管理\n\n项目依赖管理 ，pom.xml 文件中定义jar包的gav坐标\n\n<dependencies>\n\t<dependency>\n        \x3c!--依赖 gav坐标--\x3e\n\t\t<groupid>junit</groupid>\n\t\t<artifactid>junit</artifactid>\n\t\t<version>4.10</version>\n        \x3c!--依赖范围--\x3e\n\t\t<scope>test</scope>\n\t</dependency>\n</dependencies>\n\n\n# 依赖范围(scope)\n\n依赖范围用于限制依赖的环境应用，指定何时提供依赖及分类路径\n\n依赖范围值(scope)   说明\ncompile（默认值）   项目的所有类路径中提供\n               (为所有类编译提供依赖)\nprovided       编译和测试时需要，jar包不进行打包\n               (以防运行环境已经存在相同的包发生冲突)\nruntime        测试、运行时需要\ntest           测试时需要，但不进行打包\n···            ···\n\n依赖范围       主类编译路径   测试编译路径   打包且编译时有效\ncompile    y        y        y\nprovided   y        y        -\nruntime    -        -        y\ntest       -        y        -\n\n\n# 依赖传递\n\n在项目往往需要引入多个依赖， 而引入的依赖又会引入其他的依赖，项目会自动引入依赖中的依赖！\n\n假设 a项目 引入 b 和 e 依赖 ，他们有各自的依赖关系\n\na => b b => c c => d a => e e => d\n\n  a项目\n  |\n  ├── b\n  │   └── c\n  │       └── d(2.0)\n  └── e\n      └── d(1.0)\n\n\n> 最后 a项目 导入了d(1.0)，排除d(2.0)\n> \n> 系统会根据导入的就近原则进行依赖应用\n\n\n# 依赖排除\n\nmaven 的依赖传递过程可选择性的排除依赖。如果依赖中有其他依赖可对其进行排除！\n\n<dependency>\n\t<groupid>junit</groupid>\n\t<artifactid>junit</artifactid>\n\t<version>4.11</version>\n\t\x3c!--排除依赖--\x3e\n\t<exclusions>\n\t\t<exclusion>\n\t\t\t<groupid>org.hamcrest</groupid>\n\t\t\t<artifactid>hamcrest-core</artifactid>\n            \x3c!--排除依赖无需版本号--\x3e\n\t\t</exclusion>\n\t</exclusions>\n</dependency>\n\n\nps：排除依赖包中所包含的依赖关系，不需要添加版本号\n\n假如我想在 上面假设中排除d(1.0)，引入d(2.0)\n\n···\n\x3c!--引入b依赖--\x3e\n<dependency>\n\t<groupid>b</groupid>\n\t<artifactid>b</artifactid>\n\t<version>0.1</version>\n   \t\x3c!--排除依赖--\x3e\n\t<exclusions>\n        \x3c!--排除 b依赖 中的 依赖c--\x3e\n\t\t<exclusion>\n\t\t\t<groupid>d</groupid>\n\t\t\t<artifactid>d</artifactid>\n            \x3c!--排除依赖无需版本号--\x3e\n\t\t</exclusion>\n\t</exclusions>\n</dependency>\n\x3c!--引入e依赖--\x3e\n<dependency>  \n\t<groupid>e</groupid>\n\t<artifactid>e</artifactid>\n\t<version>0.1</version>\n</dependency> \n···\n\n\n\n# mavean问题\n\n\n# web项目失效\n\n问题说明：\n\nweb文件夹目录未 被idea标识（文件夹没有小蓝点）\n\n可能原因：\n\n * pom.xml 未配置 packaging标签 未配置war包\n * 项目结构未配置好\n * idea缓存问题\n\n涉及解决方案：\n\n * pom.xml 配置 packaging标签\n   \n   <packaging>war</packaging>\n   \n\n * 项目结构web配置： 点击操作流程 （指定索引到操作流程）\n\n * 清空idea缓存并重启\n   \n   ',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Java设计模式",frontmatter:{title:"Java设计模式",date:"2020-02-18T00:00:00.000Z",permalink:"/backend/ea9655",categories:["后端","Java"],tags:["Java技巧","设计模式"],author:"柏竹"},regularPath:"/01.%E5%90%8E%E7%AB%AF/03.Java%E6%8B%93%E5%B1%95/01.Java%20%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html",relativePath:"01.后端/03.Java拓展/01.Java 设计模式.md",key:"v-056e9e9e",path:"/backend/ea9655/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:11},{level:3,title:"分类",slug:"分类",normalizedTitle:"分类",charIndex:188},{level:4,title:"创建型模式",slug:"创建型模式",normalizedTitle:"创建型模式",charIndex:194},{level:4,title:"结构型模式",slug:"结构型模式",normalizedTitle:"结构型模式",charIndex:388},{level:4,title:"行为型模式",slug:"行为型模式",normalizedTitle:"行为型模式",charIndex:616},{level:3,title:"UML",slug:"uml",normalizedTitle:"uml",charIndex:1009},{level:4,title:"类图",slug:"类图",normalizedTitle:"类图",charIndex:1079},{level:3,title:"软件设计原则",slug:"软件设计原则",normalizedTitle:"软件设计原则",charIndex:1254},{level:4,title:"开闭原则",slug:"开闭原则",normalizedTitle:"开闭原则",charIndex:1332},{level:4,title:"里氏代换原则",slug:"里氏代换原则",normalizedTitle:"里氏代换原则",charIndex:1541},{level:4,title:"依赖倒转原则",slug:"依赖倒转原则",normalizedTitle:"依赖倒转原则",charIndex:1846},{level:4,title:"接口隔离原则",slug:"接口隔离原则",normalizedTitle:"接口隔离原则",charIndex:2078},{level:4,title:"迪米特法则",slug:"迪米特法则",normalizedTitle:"迪米特法则",charIndex:2430},{level:4,title:"合成复用原则",slug:"合成复用原则",normalizedTitle:"合成复用原则",charIndex:2616},{level:2,title:"创建者模式",slug:"创建者模式",normalizedTitle:"创建者模式",charIndex:3078},{level:3,title:"单例模式",slug:"单例模式",normalizedTitle:"单例模式",charIndex:247},{level:4,title:"问题",slug:"问题",normalizedTitle:"问题",charIndex:72},{level:3,title:"工厂模式",slug:"工厂模式",normalizedTitle:"工厂模式",charIndex:274},{level:4,title:"简单工厂模式",slug:"简单工厂模式",normalizedTitle:"简单工厂模式",charIndex:7208},{level:4,title:"方法工厂模式",slug:"方法工厂模式",normalizedTitle:"方法工厂模式",charIndex:7218},{level:4,title:"抽象工厂模式",slug:"抽象工厂模式",normalizedTitle:"抽象工厂模式",charIndex:299},{level:4,title:"模式扩展",slug:"模式扩展",normalizedTitle:"模式扩展",charIndex:11032},{level:3,title:"原型模式",slug:"原型模式",normalizedTitle:"原型模式",charIndex:335},{level:3,title:"建造者模式",slug:"建造者模式",normalizedTitle:"建造者模式",charIndex:362},{level:4,title:"模式拓展",slug:"模式拓展",normalizedTitle:"模式拓展",charIndex:12723},{level:3,title:"创建者模式对比",slug:"创建者模式对比",normalizedTitle:"创建者模式对比",charIndex:13350},{level:2,title:"结构型模式",slug:"结构型模式-2",normalizedTitle:"结构型模式",charIndex:388},{level:3,title:"代理模式",slug:"代理模式",normalizedTitle:"代理模式",charIndex:437},{level:4,title:"静态代理",slug:"静态代理",normalizedTitle:"静态代理",charIndex:13842},{level:4,title:"JDK动态代理",slug:"jdk动态代理",normalizedTitle:"jdk动态代理",charIndex:14163},{level:4,title:"CGLIB动态代理",slug:"cglib动态代理",normalizedTitle:"cglib动态代理",charIndex:17806},{level:4,title:"代理模式总结",slug:"代理模式总结",normalizedTitle:"代理模式总结",charIndex:18095},{level:3,title:"适配器模式",slug:"适配器模式",normalizedTitle:"适配器模式",charIndex:460},{level:4,title:"类适配器模式",slug:"类适配器模式",normalizedTitle:"类适配器模式",charIndex:18811},{level:4,title:"对象适配器模式",slug:"对象适配器模式",normalizedTitle:"对象适配器模式",charIndex:19489},{level:4,title:"适配器模式总结",slug:"适配器模式总结",normalizedTitle:"适配器模式总结",charIndex:20159},{level:3,title:"装饰者模式",slug:"装饰者模式",normalizedTitle:"装饰者模式",charIndex:20350},{level:3,title:"桥接模式",slug:"桥接模式",normalizedTitle:"桥接模式",charIndex:514},{level:3,title:"外观模式",slug:"外观模式",normalizedTitle:"外观模式",charIndex:538},{level:3,title:"组合模式",slug:"组合模式",normalizedTitle:"组合模式",charIndex:562},{level:3,title:"享元模式",slug:"享元模式",normalizedTitle:"享元模式",charIndex:589},{level:2,title:"行为型模式",slug:"行为型模式-2",normalizedTitle:"行为型模式",charIndex:616},{level:3,title:"模块模式",slug:"模块模式",normalizedTitle:"模块模式",charIndex:24581},{level:3,title:"策略模式",slug:"策略模式",normalizedTitle:"策略模式",charIndex:930},{level:3,title:"命令模式",slug:"命令模式",normalizedTitle:"命令模式",charIndex:715},{level:3,title:"职责链模式",slug:"职责链模式",normalizedTitle:"职责链模式",charIndex:27127},{level:3,title:"状态模式",slug:"状态模式",normalizedTitle:"状态模式",charIndex:877},{level:3,title:"观察者模式",slug:"观察者模式",normalizedTitle:"观察者模式",charIndex:850},{level:3,title:"中介者模式",slug:"中介者模式",normalizedTitle:"中介者模式",charIndex:797},{level:3,title:"迭代器模式",slug:"迭代器模式",normalizedTitle:"迭代器模式",charIndex:770},{level:3,title:"访问者模式",slug:"访问者模式",normalizedTitle:"访问者模式",charIndex:982},{level:3,title:"备忘录模式",slug:"备忘录模式",normalizedTitle:"备忘录模式",charIndex:824},{level:3,title:"解释器模式",slug:"解释器模式",normalizedTitle:"解释器模式",charIndex:740},{level:2,title:"自定义Spring",slug:"自定义spring",normalizedTitle:"自定义spring",charIndex:33520},{level:3,title:"Ioc 控制反转",slug:"ioc-控制反转",normalizedTitle:"ioc 控制反转",charIndex:33534}],headersStr:"概述 分类 创建型模式 结构型模式 行为型模式 UML 类图 软件设计原则 开闭原则 里氏代换原则 依赖倒转原则 接口隔离原则 迪米特法则 合成复用原则 创建者模式 单例模式 问题 工厂模式 简单工厂模式 方法工厂模式 抽象工厂模式 模式扩展 原型模式 建造者模式 模式拓展 创建者模式对比 结构型模式 代理模式 静态代理 JDK动态代理 CGLIB动态代理 代理模式总结 适配器模式 类适配器模式 对象适配器模式 适配器模式总结 装饰者模式 桥接模式 外观模式 组合模式 享元模式 行为型模式 模块模式 策略模式 命令模式 职责链模式 状态模式 观察者模式 中介者模式 迭代器模式 访问者模式 备忘录模式 解释器模式 自定义Spring Ioc 控制反转",content:'# 设计模式\n\n\n# 概述\n\n软件设计模式 , 又称设计模式 , 是套被反复使用且多数人知晓的 , 代码设计经验的总结 . 是前辈们 在不断出现问题中总结出来的设计模式\n\n必要性\n\n * 提高 思维&编程&设计 能力\n * 使程序 标准化&工程化 , 开发效率大大提升 , 从而缩短软件开发周期\n * 使设计思路 重用性&可读性&可靠性&灵活性&维护性 有进阶的提升\n\n\n# 分类\n\n# 创建型模式\n\n描述 怎样创建对象 , 主要是将 对象的创建与使用分离\n\n该类型有以下设计模式 :\n\n * 单例模式（Singleton Pattern）\n * 工厂模式（Factory Pattern）\n * 抽象工厂模式（Abstract Factory Pattern）\n * 原型模式（Prototype Pattern）\n * 建造者模式（Builder Pattern）\n\n# 结构型模式\n\n描述 如何将 类/对象 按照某种布局组成的结构\n\n该类型有以下设计模式 :\n\n * 代理模式（Proxy Pattern）\n * 适配器模式（Adapter Pattern）\n * 装饰器模式（Decorator Pattern）\n * 桥接模式（Bridge Pattern）\n * 外观模式（Facade Pattern）\n * 组合模式（Composite Pattern）\n * 享元模式（Flyweight Pattern）\n\n# 行为型模式\n\n描述 类/对象 之间怎样相互共同完成单个对象无法单独完成的任务\n\n该类型有以下设计模式 :\n\n * 责任链模式（Chain of Responsibility Pattern）\n * 命令模式（Command Pattern）\n * 解释器模式（Interpreter Pattern）\n * 迭代器模式（Iterator Pattern）\n * 中介者模式（Mediator Pattern）\n * 备忘录模式（Memento Pattern）\n * 观察者模式（Observer Pattern）\n * 状态模式（State Pattern）\n * 空对象模式（Null Object Pattern）\n * 策略模式（Strategy Pattern）\n * 模板模式（Template Pattern）\n * 访问者模式（Visitor Pattern）\n\n\n# UML\n\n统一建模语言 , 用来设计软件的可视化建模语言 . 主要以图形的形式展示出信息\n\nUML从不同角度出发 , 可分为 : 例图 , 类图 , 对象图 , 状态图 , 活动图 , 时序图 , 协作图等...\n\n> 以类图进行讲述 , 更直观的了解UML图\n\n# 类图\n\n类图 是展示一个对象的信息 , 里面包括有 属性&方法&构造方法&方法\n\n示例图 :\n\n\n\n> 通过分割线分割出来的矩形 , 可以看出 类名和属性和方法 是分割区分的 . 还有左侧的锁头代表是否开放的意思\n\n\n# 软件设计原则\n\n在开发中 , 为了提高系统 维护性和可复用性 以及 拓展性和灵活性 , 在开发时候尽量以 6条原则进行开发 , 从而缩短开发周期 !\n\n# 开闭原则\n\n对拓展开放 , 对修改关闭 . 在程序需要拓展时 , 不会影响到源代码 , 实现了热插拔效果\n\n实现一般需要通过 接口/抽象类 的形式进行拓展\n\n示例 :\n\n某软件 皮肤/主题 的设计\n\n官方有默认的主题 , 不过官方提供了自定义的设置 (这意味着可以添加自己喜好的元素进去) . 这一过程 体现出了 应用的拓展性 !\n\n仓库代码 : 01principle.openclosedprinciple\n\n# 里氏代换原则\n\n里氏代换原则 是 面向对象 的基本原则之一 , 任何基类可以出现的地方 , 子类一定可以出现\n\n解释 : 父类有的功能 , 其子类也有 , 但子类不能更改父类原有的功能 (如果重写了就违背了 里氏代换设计原则)\n\n示例 :\n\n长方形和正方形 对象的应用\n\n长方形和正反形 都继承了四边形进行实现 , 并非他们自己继承关系 . 如果是继承关系 , 那么重写的方法会导致子类引用时容易异常问题\n\n仓库示例 : 反例 : 01principle.liskovSubstitutionPrinciple\n\n示例 : 01principle.liskovSubstitutionPrinciple\n\n# 依赖倒转原则\n\n高层模块不应该依赖低层模块 , 两者应该依赖其抽象 (抽象没有依赖细节 , 但需要具体化) , 这样就提高模块间的耦合\n\n示例代码 :\n\n组装电脑案例\n\n一台台式主机电脑 , 需要配件 CPU&硬盘&内存条 等... 计算机才能运行 !\n\n仓库示例 :\n\n反例 : 01principle.dependencyInversionPrinciple\n\n示例 : 01principle.dependencyInversionPrinciple\n\n# 接口隔离原则\n\n父类有多个方法 , 子类自需要使用一个方法 , 那么子类会迫依赖其他方法 !\n\n解决方案 : 以接口形式进行对最小个数方法抽象化 , 以便继承使用\n\n(一个接口实现一个方法)\n\n示例 :\n\n安全门案例\n\n一个品牌的安全门 , 一般有多个功能 , 如: 防盗&防水&防火等功能... , 如果我们以一个接口整合这些功能 , 那么其他品牌没有其功能也会被迫依赖其功能 , 因此 我们将这些功能 , 以最小功能个数为单位进行区分化 进行实现 (类不能多继承 , 接口可以多实现)\n\n仓库示例 :\n\n反例 : 01principle.interfaceSegregationPrinciple\n\n示例 : 01principle.interfaceSegregationPrinciple\n\n# 迪米特法则\n\n迪米特法则 , 又称最小知识原则\n\n如果两个对象无需直接通信 , 那么就不会发生相互调用 , 需要通过第三方进行转发调用 . 其目的是降低耦合度 , 提高模块独立性\n\n示例 : 明星经纪人代理案例\n\n明星投入艺术上 , 很多事情由经纪人负责处理 , 如 粉丝见面&公司合租等业务...\n\n仓库示例 : 01principle.lawOfDemeter\n\n# 合成复用原则\n\n尽量先使用 组合/聚合 等关系关联实现 , 其次考虑继承关系实现\n\n继承复用 优缺点 :\n\n * 继承复用破坏了类的封装性 , 继承会暴露父类实现细节(相对子类是透明的)\n * 父子类耦合度高 . 父类一旦改变其子类也会跟着改变 , 不利维护\n * 限制了复用的灵活性 , 从父类继承来的实现是静态的 , 编译已经定义了 , 所以在运行是不可能发生变化\n\n组合/聚合 优缺点 : (纳入对象 , 成为新对象的一部分 , 可以调用纳入对象的已有功能)\n\n * 维护了类的封装性 , 引入的对象是看不到内部细节 , 相对安全\n * 对象间耦合度低 . 一般引用在 类的成员属性位置上\n * 复用灵活性高 , 在运行时应用 , 新对象可动态的引用与类型相同对象\n\n仓库示例 : 01principle.syntheticReusePrinciple\n\n汽车分类管理程序\n\n汽车 可分为 汽油车&电力车 , 两种类型的车可以分为多中颜色的车因此可以看下图\n\n继承 类图呈现 :\n\n\n\n聚合 类图呈现 :\n\n\n\n\n# 创建者模式\n\n\n# 单例模式\n\n单例模式 一个类只有一个实例 , 且该类是自行创建这个实例的一种模式（我创建我自己）\n\n特点：\n\n * 单例类只有一个实例对象\n * 该单例对象必须由 自己进行创建\n * 单例类对外提供一个访问该单例的全局访问点\n\n优点：\n\n * 能够保证在内存里只有一个实例 , 不会有多余的开销\n * 可避免内存多重占用\n * 可设置全局访问 , 实现优化和资源共享资源的访问\n\n缺点：\n\n * 无接口 , 扩展功能麻烦 , 除了修改源代码（违背了开发原则\n * 不利于并发测试\n\n加载类型 :\n\n * 懒汉式 类加载时不会没有生成单例 , 只有当第一次调用 getlnstance()方法 时去创建单例\n * 饿汉式 类一旦加载就创建一个单例 , 保证在调用 getInstance()方法 之前单例已经存在了 . 如果不使用会造成资源浪费\n\n> 搭配一下 代码示例进行使用\n\n仓库示例 : 01principle.syntheticReusePrinciple\n\n代码示例 :\n\n/** 懒汉式 (双重检查锁机制 volatile关键字&同步锁\n *  该模式的特点是类加载时没有生成单例 , 只有当第一次调用 getlnstance 方法时才去创建这个单例\n */\npublic class LazySingleton {\n    // 静态 保证 所有线程中都是同步\n    private static volatile LazySingleton instance = null;\n    // 构造器 私有化\n    private LazySingleton() {}\n    // 同步锁 防止多线程共同创建可能产生一个以上的实例\n    public static LazySingleton getInstance() {\n    // 第一次判断 , 如果instance不为null , 不进入抢锁阶段 , 直接返回实际\n        if (instance == null) {\n            synchronized (LazySingleton.class) {\n                // 抢到锁之后再次判断是否为空\n                if (instance == null) {\n                    instance = new LazySingleton();\n                }\n            }\n        }\n        return instance;\n    }\n\n}\n\n/** 饿汉式\n *  该模式的特点是类一旦加载就创建一个单例 , 保证在调用 getInstance 方法之前单例已经存在了\n */\npublic class HungrySingleton {\n    // 构造方法私有化\n    private HungrySingleton(){}\n    \n    private static class Singleton {\n        private static final HungrySingleton INSTANCE = new HungrySingleton();\n    }\n    \n    public static HungrySingleton getInstance() {\n        return Singleton.INSTANCE;\n    }\n}\n\n\n> 以上方式以最优解决方案\n\n# 问题\n\n单例模式破坏情况 : (创建的对象并非一个)\n\n * 序列化\n * 反射\n\n仓库示例 :\n\n * 序列化破坏问题 & 序列化解决方案\n * 反射破坏问题 & 反射解决方案\n\n序列化破坏示例 :\n\npackage com.singleton.qaDemo;\n\nimport com.singleton.HungrySingleton;\n\nimport java.io.*;\n\n// 序列化 破坏单例模式\npublic class SerializationBreaks {\n\n    // 桌面a.txt文件\n    private static String path = "C:\\\\Users\\\\Sans\\\\Desktop\\\\a.txt";\n\n    public static void main(String[] args) throws Exception{\n\n        // HungrySingleton类 需要序列化\n        HungrySingleton hungrySingleton = HungrySingleton.getInstance();\n        // 序列化存储\n        writeObjectFile(hungrySingleton);\n        // 反序列化提取\n        HungrySingleton hungrySingleton1 = readObjectFromFile();\n\n        // 根据地址进行判断他们是否相同\n        System.out.println("hungrySingleton = " + hungrySingleton);\n        System.out.println("hungrySingleton1 = " + hungrySingleton1);\n    }\n\n    // 从文件中读取对象\n    public static HungrySingleton readObjectFromFile() throws Exception {\n        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(path));\n        HungrySingleton instance = (HungrySingleton) ois.readObject();\n        return instance;\n    }\n\n    // 写入对象文件\n    public static void writeObjectFile(HungrySingleton instance) throws Exception {\n        ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(path));\n        //将instance对象写出到文件中\n        oos.writeObject(instance);\n    }\n}\n/* 结果 (地址显然就不对了 , 两个对象\nhungrySingleton = com.singleton.HungrySingleton@78308db1\nhungrySingleton1 = com.singleton.HungrySingleton@3d494fbf\n*/\n\n\n序列化 解决方案 :\n\n在序列化类中添加 readResolve()方法 , 在反序列化时会判断该方法是否存在 , 存在则调用其方法 , 否则 new新对象进行返回\n\n// Singleton.INSTANCE 内部类提取出来的单例对象\nSingleton.INSTANCE;private Object readResolve(){\n    return Singleton.INSTANCE;\n}\n\n\n反射破坏示例 :\n\n// 反射 破坏单例模式\npublic class ReflectionDamage {\n    public static void main(String[] args) throws Exception {\n\n        Class aClass = LazySingleton.class;\n        // 获取对象构造方法\n        Constructor cons = aClass.getDeclaredConstructor();\n        // 取消访问检查 (越过权限修饰符\n        cons.setAccessible(true);\n\n        LazySingleton singleton = (LazySingleton) cons.newInstance();\n        LazySingleton singleton2 = (LazySingleton) cons.newInstance();\n\n        System.out.println("singleton = " + singleton);\n        System.out.println("singleton2 = " + singleton2);\n\n    }\n}\n\n\n反射 解决方案 :\n\n通过一个布尔值控制构造方法创建对象 , 如果已经存在了 抛出异常即可\n\n// 控制对象创建\nprivate static Boolean flag = false;\n\nprivate LazySingleton() {\n    synchronized (LazySingleton.class){\n        if (flag){\n            throw new RuntimeException("不能创建多个对象");\n        }\n        flag = true;\n    }\n}\n\n\n\n# 工厂模式\n\n定义一个创建产品对象的工厂接口 , 将产品对象的实际创建工作推迟到具体子工厂类当中 . 这满足创建型模式中所要求的“创建与使用相分离”的特点\n\n3 种实现方式：\n\n * 简单工厂模式\n * 方法工厂模式\n * 抽象工厂模式\n\n工厂了解示例 : 02creatorMode.factory.before\n\n设计一个咖啡类(Coffee) , 并定义其两个子类 美式咖啡(AmericanCoffee)&拿铁咖啡(LatteCoffee) , 再设计一个咖啡店类(CoffeeStore) , 咖啡店具有点咖啡的功能\n\n\n\n# 简单工厂模式\n\n我们把被创建的对象称为“产品” , 把创建产品的对象称为“工厂” . 如果要创建的产品不多 , 只要一个工厂类就可以完成 , 这种模式叫“简单工厂模式”\n\n在简单工厂模式中创建实例的方法通常为 静态方法\n\n简单工厂结构 :\n\n * 抽象产品 : 定义产品规范 , 描述功能特性等..\n * 具体产品 : 继承/实现 抽象产品的子类\n * 具体工厂 : 提供创建产品的方法 , 通过方法获取产品\n\n优点：\n\n * 工厂方法中可以通过明确的值来确定产品（工厂和产品的职责区分明确\n * 用户获取产品对象时 , 只需 静态方法 填写参数获取即可\n * 也可以引入配置文件 , 在不修改客户端代码的情况下 更换/添加 新的具体产品类\n\n缺点：\n\n * 简单工厂模式的工厂类单一 , 负责所有产品的创建 , 职责过重 , 一旦异常 , 整个系统将受影响\n * 使用简单工厂模式会增加系统中类的个数（引入新的工厂类）, 增加系统的复杂度和理解难度\n * 系统扩展困难 , 一旦增加新产品不得不修改工厂逻辑 , 在产品类型较多时 , 可能造成逻辑过于复杂\n * 由于工厂使用了静态方法 , 造成工厂角色无法形成基于继承的等级结构\n\n仓库示例 : 02creatorMode.factory.simple\n\n点咖啡后 , 会通过 咖啡工厂(CoffeeFactory) 进行生成咖啡 !\n\n\n\n简单示例 :\n\n// 抽象产品\ninterface Product{\n    void show();\n}\n\n// 具体产品1\nclass ConcreteProduct1 implements Product{\n    @Override\n    public void show() {\n        System.out.println("产品1");\n    }\n}\n\n// 具体产品2\nclass ConcreteProduct2 implements Product{\n    @Override\n    public void show() {\n        System.out.println("产品2");\n    }\n}\n\nclass ProductFactory{\n    static final int PRODUCT_A = 0;\n    static final int PRODUCT_B = 1;\n    \n    public static Product makeProduct(int productId){\n        switch (productId) {\n            case PRODUCT_A:\n                return new ConcreteProduct1();\n            case PRODUCT_B:\n                return new ConcreteProduct2();\n            default: break;\n        }\n        return null;\n    }\n    \n}\n\n\n> 在原有的基础上通过工厂形式进行获取\n\n# 方法工厂模式\n\n是对 简单工厂模式的进一步抽象化 , 其好处是可以使系统在不修改原来代码的情况下引进新的产品 , 即满足 开闭原则\n\n方法工厂结构 :\n\n * 抽象工厂 : 提供创建产品的接口 , 通过接口进行调取具体工厂来创建产品\n * 具体工厂 : 主要实现抽象方法 , 完成具体产品的创建\n * 抽象产品 : 定义产品规范 , 描述功能特性等...\n * 具体产品 : 实现产品接口 , 最后由其工厂来创建 , 工厂和产品一一对应\n\n优点：\n\n * 用户只需知道工厂名称 , 无需理解工厂创建过程\n * 新产品需要创建对应的具体工厂类\n\n缺点：\n\n * 类的个数容易多（增加复杂度\n\n仓库示例 : 02creatorMode.factory.method\n\n以下是根据不同的咖啡设计出的不同工厂 (AmericanCoffeeFactory&LatteCoffeeFactory) , 实现的接口都有生产咖啡的方法 , 在客户点咖啡后 , 咖啡店只关心咖啡工厂即可提供客户咖啡 (要区分工厂类型) !\n\n\n\n简单示例 :\n\n// 抽象产品：提供产品的接口\ninterface Product{\n    void show();\n}\n\n// 抽象工厂：提供厂的生成方法\ninterface AbstractFactory {\n    Product newProduct();\n}\n\n// 具体产品1\nclass ConcreteProduct1 implements Product{\n    @Override\n    public void show() {\n        System.out.println("显示产品1");\n    }\n}\n\n// 具体产品2\nclass ConcreteProduct2 implements Product{\n    @Override\n    public void show() {\n        System.out.println("显示产品2");\n    }\n}\n\n// 具体工厂1：实现产品生成方法\nclass ConcreteFactory1 implements AbstractFactory {\n    @Override\n    public Product newProduct() {\n        System.out.println("具体工厂1--\x3e具体产品1");\n        return new ConcreteProduct1();\n    }\n}\n\n// 具体工厂2：实现产品生成方法\nclass ConcreteFactory2 implements AbstractFactory {\n    @Override\n    public Product newProduct() {\n        System.out.println("具体工厂2--\x3e具体产品2");\n        return new ConcreteProduct2();\n    }\n}\n\n\n# 抽象工厂模式\n\n抽象工厂 可以理解为 工厂的工厂 . 提供一个 创建相关的/相互依赖的接口 , 无需指定具体类 , 就能得到该品牌(工厂)不同类型的产品(手机/电脑/电子手环 等用电器...)\n\n可以了解为 还TCL品牌不单单只是买电视机 , 还有其他用电器..\n\n抽象工厂结构 :\n\n * 抽象工厂 : 提供产品接口 , 包含有多个创建 产品的方法\n * 具体工厂 : 实现 抽象工厂接口的方法 进行生产产品\n * 抽象产品 : 定义产品 规范&特征&功能 的抽象方法\n * 具体产品 : 实现抽象产品接口 , 创建时可具体化产品信息\n\n优点 :\n\n * 当一个工厂中的多个对象被设计成一起工作时 , 它能保证客户端始终只使用同一品牌(工厂)的对象\n\n缺点 :\n\n * 当该品牌增加新产品时 , 所有相关的工厂类都需要进行修改\n\n仓库示例 : 02creatorMode.factory.abstractFactory\n\n咖啡店添加新产品甜点(Dessert) 分别有 提拉米苏(Tiramisu)&抹茶慕斯(MatchaMousse) , 工厂是根据不同地域产生的不同类型的 咖啡和甜点 , 这些工厂分别有 意大利甜点厂(IatlyDessertFactory)&美国甜点厂(AmericanDessertFactory) . 解决了 方法工厂模式 类爆炸的问题(类多)\n\n\n\n简单示例 :\n\n// 具体工厂：实现产品生成的方法\nclass ConcreteFactory1 implements AbstractFactory {\n    \n    @Override\n    public product1 newProduct1() {\n        System.out.println("具体工厂1--\x3e具体产品1");\n        return new product1();\n    }\n    \n    @Override\n    public product2 newProduct2() {\n        System.out.println("具体工厂1--\x3e具体产品2");\n        return new product2();\n    }\n}\n\n// 产品1\nclass product1 { }\n\n// 产品2\nclass product2 { }\n\n\n# 模式扩展\n\n该扩展是 简单工厂&配置文件 的组合使用 , 主要是解决了工厂对象耦合问题\n\n配置文件已 properties格式进行存储 , 键值对(键 : 名称 ; 值 : 全限定类名)\n\n## 获取产品通过 K 获取 , 对象则是通过 K对应的V 获取\namerican=com.factory.modeConfigFactory.AmericanCoffee\nlatte=com.factory.modeConfigFactory.LatteCoffee\n\n\n仓库代码 : 02creatorMode.factory.modeConfigFactory\n\n\n# 原型模式\n\n用一个已经创建的实例作为原型 , 通过复制该原型对象来创建一个和原型相同的新对象\n\n原型模式结构 :\n\n * 抽象原型类 : 规定具体原型对象必须实现的的 clone()方法\n * 具体原型类 : 实现抽象原型接口 重写 clone()方法 , 返回的是复制原型类\n * 访问测试类 : 使用原型的实例对象进行调用其 clone()方法 来复制对象\n\n克隆模式 :\n\n * 浅克隆 : 克隆新对象的属性和原有对象相同 , 对于非基本数据类型的属性仍会指向原有对象地址\n * 深克隆 : 克隆新对象的属性也会一一拷贝一份 , 且他们引用属性对象的地址和原有引用的地址不同\n\n克隆羊"多莉"实验案例 , 其原型是非克隆羊\n\n仓库示例 了解结构: 02creatorMode.prototype\n\n仓库示例 (浅克隆&深克隆): 02creatorMode.prototype\n\n> PS :\n> \n>  * 克隆前提需要 Cloneable接口 , 并重写 clone()方法 返回其拷贝对象\n>  * 序列化 需要 序列化对象 (实现 Serializable接口)\n>  * JSON化 需要 jar包 (gson)\n\n\n# 建造者模式\n\n将一个复杂对象的构建与表达分离 , 使得相同的构建过程可以有不同的表示\n\n解释 : 将复杂对象进行拆分装配 , 不同 构建器&装配顺序 都会建出 不同对象 (复杂对象拆分创建)\n\n建造者模式结构 :\n\n * 抽象创建者类 (Builder) : 规范化复杂对象创建方式 , 不涉及具体对象创建\n * 具体创建者类 (ConcreteBuilder) : 实现 Builder接口 , 完成复杂产品具体部件创建方法\n * 产品类 (Product) : 复杂对象\n * 指挥者类 (Director) : 调用 Builder方法 , 分别创建复杂对象部件 , 部件创建的顺序是自定义的 , 最终将创建完整的对象进行返回\n\n优点 :\n\n * 构建过程复杂的对象\n * 建造者封装性好\n * 无需知道产品组成细节 , 产品本身和创建过程是以解耦形式创建 , 使得创建时会有不同产品对象\n * 易扩展 , 如有新产品 , 只需创建新即建造者类即可 . 也满足 开闭原则\n\n缺点 :\n\n * 产品会有较多的共同点 , 组成部分相似 , 不适合差异较多的复杂对象使用 , 有范围局限性\n\n仓库示例 : 02creatorMode.creator (PS : 抽象创建者类可以为接口\n\n生产自行车案例\n\n生产自行车是一个复杂的过程 , 它包含了车架(frame)&车座(seat)等组件的生产 . 车架用什么材质 , 车座又用什么材质等组件都需要细化 . 自行车(Bike) 包含有这些组件都需要细化 , MobikeBuilder和 OfoBuilder是具体的建造者 (具体的类型使用的材质) , 抽象建造者(Builder) 里面的组件即将会被 指挥者(Director) 指定的顺序组装 完成 (顺序有指挥者制定)\n\n\n\n仓库示例2 (优化版) : 02creatorMode.creator\n\n> 优化版 整合了指挥者类进行 , 整合后不能以接口形式呈现 , 因 接口只能又抽象方法 (需要构建部件创建顺序)\n> \n> 解释 : 过于复杂的对象需要指挥者创建\n\n# 模式拓展\n\n除了以上用法 , 在开源中也常见的一种使用方式 , 链式构建对象 , 能够更直观构造一个对象的属性 ! 且特别适合单对象的构建 !\n\n示例 :\n\n组装电脑案例\n\n一台台式主机电脑 , 需要配件 CPU&硬盘&内存条 等... 计算机才能运行 !\n\n构造器构建对象方式 : (显然可以看到可读性比较差\n\npublic static void main(String[] args) {\n\t//构建Computer对象 (构造器属性顺序 cpu,硬盘,内存条,主板\n\tComputer computer = new Computer("intel9400","西数硬盘500G","金士顿内存条16G","华硕主板");\n\tSystem.out.println(computer);\n}\n\n\n建造者构建对象方式 :\n\npublic static void main(String[] args) {\n\tComputer computer = new Computer.Builder()\n\t\t.cpu("intel9400")\n        .hardDisk("西数硬盘500G")\n\t\t.mainboard("华硕主板")\n\t\t.memory("金士顿内存条16G")\n\t\t.build();\n\t\tSystem.out.println(phone);\n}\n\n\n仓库示例 : 02creatorMode.creator.extend\n\n\n# 创建者模式对比\n\n应用场景 :\n\n * 单例模式 : 单对象重复引用情况\n * 原型模式 : 多次拷贝原对象情况\n * 工厂模式 : 多对象不同形态情况\n * 建造者模式 : 创建复杂对象情况\n\n创建形式 :\n\n * 单例模式&工厂模式 : 直接new实例对象\n * 原型模式 : 复制对象\n * 建造者模式 : 细分创建对象部件过程\n\n\n# 结构型模式\n\n\n# 代理模式\n\n为对象提供一个代理使其对象可访问 , 访问对象不能直接访问目标引用对象 , 代理对象作为中介进行交互\n\n解释 : 打电话给同事 , 需要引用手机进行与对方交互 (手机充当代理对象) , 不能直接进行对面交互(同事不在附近)\n\n代理模式结构 :\n\n * 抽象目标对象 (Subject) : 通过 接口/抽象类 定义 真实目标对象 即将实现的业务方法\n * 目标对象 (Real Subject) : 具体化抽象目标对象的业务方法 , 是最终要引用的真实目标对象\n * 代理 (Proxy) : 提供了与真实目标对象交互的接口 , 其内部含有对真实主题的引用 , 它可 访问&控制/增强 目标对象的功能\n\n# 静态代理\n\n将 服务性代码 分离出来 . 通过接口进行静态代理\n\n缺点 :\n\n * 每次新添加业务方法 都要添加 , 维护成本高\n\n仓库示例 : 03StructuralPattern.proxy\n\n火车站卖票\n\n早期互联网没有完善时 , 购买票是需要去火车站进行的 , 排队等一系列的操作 , 非常麻烦 . 因此 不少地方也有了 代售点 进行代理卖票 . 以上案例不难看出 , 目标对象是火车站(TrainStation) , 代售点是代理对象(ProxyPoint)\n\n类                     角色\nProxyPoint (代理类)      代理角色\nTrainStation (火车站类)   目标角色\n\n\n\n# JDK动态代理\n\nJDK动态代理 是Java中提供的代理类 . 程序运行的时候 , 根据要被代理的对象 动态生成代理类\n\nJava提供 Proxy.newProxyInstance()方法 获取 代理对象\n\n/** 参数:\n* @param ClassLoader loader : 代理对象的类加载器\n* @param Class<?>[] interfaces : 代理对象要实现的接口列表\n* @param InvocationHandler h :  代理对象的处理程序\n*/\npublic static Object newProxyInstance(ClassLoader loader,\n                                      Class<?>[] interfaces,\n                                      InvocationHandler h)\n                               throws IllegalArgumentException\n\n\nInvocationHandler.invoke()方法 (增强业务)\n\n/** 参数:\n* @param Object proxy : 代理对象\n* @param Method method : 对接口的方法进行封装成的对象\n* @param Object[] args : 调用方法的参数\n* return 对应代理对象方法执行的返回值 (如果 void 则 null)\n*/\npublic Object invoke(Object proxy, Method method, Object[] args)\n        throws Throwable;\n\n\n仓库示例 : 03StructuralPattern.proxy\n\n> 以上实例的代理对象是自动生成的 , 因此我们查看需要借助 阿里巴巴开源 arthas-boot.jar 诊断工具 来查看程序运行中指定类结构\n\n查看 自动生成的代理类 :\n\n 1. 下载 arthas-boot.jar 诊断工具 (仓库同步有)\n 2. 运行程序 , 保持运行状态 (为了防止 main()方法 执行结束 , 在末尾添加死循环) 记住控制台打印的代理类的 全限定类名\n 3. 进入终端 (cmd) , 进入 arthas-boot.jar 路径内 , 执行以下指令 ==java -jar arthas-boot.jar== (执行加载包)\n 4. 选择刚刚运行的Java进程 (根据序号选择进入)\n 5. 选择指定类进行查看 , 输入以下指令 ==jad 全限定类名==\n\n> PS : 该 诊断工具 需要 Java程序也是运行 jdk17版本 , 否则 无法诊断 该Java线程\n\n代码示例 :\n\n// 程序运行过程中自动生成的代理类 (该对象的原代码较多 , 简化去掉不必要代码)\npublic final class $Proxy0 extends Proxy implements SellTickets {\n    // SellTickets接口的sell()方法\n    private static final Method m3;\n\t\n    // 该参数赋予在  Proxy.newProxyInstance()方法 第三个参数赋予\n    public $Proxy0(InvocationHandler invocationHandler) {\n        super(invocationHandler);\n    }\n\n    static {\n        m3 = Class.forName("com.proxy.jdk.SellTickets").getMethod("sell", new Class[0]);\n    }\n\t\n    // 步骤 2  \n    public final void sell() {\n        // 步骤 3\n        this.h.invoke(this, m3, null);\n    }\n}\n\n// Java提供的动态代理相关类\npublic class Proxy implements java.io.Serializable {\n    // 代理对象的处理程序\n\tprotected InvocationHandler h;\n\tprotected Proxy(InvocationHandler h) {\n\t\tthis.h = h;\n\t}\n}\n\n// 代理工厂\n// PS: 该工厂不是代理类 , 而是程序运行过程在内存生成的类\npublic class ProxyFactory {\n\n    // 目标对象\n    private TrainStation station = new TrainStation();\n\n    // 返回单例对象\n    public SellTickets getProxyObject() {\n        return (SellTickets) Proxy.newProxyInstance(\n                station.getClass().getClassLoader(),\n                station.getClass().getInterfaces(),\n                new InvocationHandler() {\n                    @Override\n                    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n                        // 步骤 4\n                        // 增强业务\n                        System.out.println("卖票 前置通知");\n                        // 执行 业务方法 , 并且返回\n                        // 步骤 5\n                        Object obj = method.invoke(station, args);\n                        System.out.println("卖票 后置通知");\n                        return obj;\n                    }\n                }\n        );\n    }\n}\n\npackage com.proxy.jdk;\n\n// 代理模式 jdk动态代理 测试类\npublic class Main {\n    public static void main(String[] args) {\n\n        // 获取代理工厂代理对象\n        ProxyFactory factory = new ProxyFactory();\n        // 获取代理对象 (该对象是动态生成的\n        SellTickets proxyObject = factory.getProxyObject();\n        // 卖票方法\n        // 步骤 1\n        proxyObject.sell();\n        System.out.println("proxyObject = " + proxyObject.getClass());\n        while (true) {}\n    }\n}\n\n\n执行流程解析 : (对应注释步骤走向)\n\n 1. 测试类 调用代理对象 sell()方法\n 2. 多态特性 继承了 SellTickets接口, 代理类 ($Proxy0) 中的 sell()方法\n 3. 代理类 ($Proxy0) 中的 sell()方法 中又调用了 InvocationHandler接口 实现 invoke()方法 (lambda表达式)\n 4. 代理对象业务增强部分 . InvocationHandler.invoke()方法 (详细可看上面方法说明)\n 5. InvocationHandler.invoke()方法中的 invoke()方法 反射调用 真实对象 (TrainStation) 中的 sell()方法\n\n# CGLIB动态代理\n\nCGLIB代理 , 也称子类代理 . 可以看做 JDK动态代理 的升级版\n\n特点 :\n\n * 目标对象无需实现接口也可对外进行代理\n * 代理对象是目标对象的子类 , 因此 也继承了方法\n * 通过 Enhancer类 进行创建代理对象 (和Proxy类 类似 , 创建方式有多种)\n * 依赖外部引入jar包 CGLIB动态代理\n\n> GLIB代理被许多 AOP框架 所使用 , 其底层是通过使用一个小而快的字节码处理框架ASM（Java 字节码操控框架）转换字节码并生成新的类\n\n仓库示例 : 03StructuralPattern.proxy\n\n# 代理模式总结\n\n       JDK动态代理     CGLIB动态代理   静态代理\n效率     较高          偏低于JDK      较高\n复杂度    复杂          复杂          简单\n外部依赖   jdk本身       外部jar包      无\n代理方式   目标对象实现的接口   目标对象        目标对象\n\n动态代理和静态代理 的区别 :\n\n * 动态代理 目标对象的业务方法都会集中在一个集中的方法处理 ; 静态代理 指定方法进行手写中转处理 , 才能实现代理\n * 如果目标对象添加一个方法的情况 ! 动态代理 : 无需重新重写该方法即可代理 静态代理 : 手写添加此方法进行中转处理\n\n优点 :\n\n * 客户端和目标对象 交互是通过代理对象进行交互 , 代理形式能够起到保护目标对象的作用\n * 代理对象能够扩展目标对象的功能 , 满足 开闭原则\n * 分离 客户端和目标对象 , 在一定程度上降低系统耦合度\n\n缺点 :\n\n * 增加系统的复杂度\n\n使用场景 :\n\n * 运程代理 (RPC通信 , 远程调用方法)\n * 防火墙代理 (VPN代理转发)\n * 保护代理 (不同用户提供不同权限)\n\n\n# 适配器模式\n\n适配器模式 是将一个类的接口转换成我们希望的另外一个接口 , 使其兼容运作\n\n适配器模式结构 :\n\n * 目标 (Target) : 当前系统规范的业务接口\n * 适配者 (Adaptee) : 访问与现有的适配器组件库中组件接口\n * 适配器 (Adapter) : 转换器 , 通过 继承/引用适配者 的对象 , 把适配者接口转换成目标接口\n\n# 类适配器模式\n\n定义一个适配器类来实现当前系统的业务接口 , 同时又继承现有组件库中已经存在的组件\n\n仓库示例 : 03StructuralPattern.adapter\n\n读卡器案例\n\n现有台电脑只能读取SD卡 , 而要读取TF卡的话就需要借助适配器模式 . 创建一个读卡器 , 将TF卡中的内容读取出来\n\n类                       角色\nSDcardImpl (SC卡类)       目标\nTFCardImpl (TF卡)        适配者\nSDAdapterTF (SC适配TF类)   适配器\nComputer (计算机类)         应用接口\n\n\n\n核心代码 (继承已有的组件库)\n\n// 适配器类 (SD兼容TF)\n// 实现当前业务接口 SDCard ; 继承了已有组件库 TFCardImpl\npublic class SDAdapterTF extends TFCardImpl implements SDCard{\n\n    @Override\n    public String readSD() {\n        System.out.println("适配器 读TF卡");\n        return readTF();\n    }\n\n    @Override\n    public void writeSD(String msg) {\n        System.out.println("适配器 写TF卡");\n        writeTF(msg);\n    }\n\n}\n\n\n# 对象适配器模式\n\n对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中 , 该类同时实现 当前系统的业务接口\n\n仓库示例 : 03StructuralPattern.adapter\n\n复用以上案例 (结构和上面的大体相同)\n\n\n\n核心代码 (引入适配器类)\n\n// 适配器类 (SD兼容TF)\npublic class SDAdapterTF implements SDCard {\n\n    // 适配者类\n    private TFCard tfCard;\n\n    public SDAdapterTF(TFCard tfCard) {\n        this.tfCard = tfCard;\n    }\n\n    @Override\n    public String readSD() {\n        System.out.println("适配器 读TF卡");\n        return tfCard.readTF();\n    }\n\n    @Override\n    public void writeSD(String msg) {\n        System.out.println("适配器 写TF卡");\n        tfCard.writeTF(msg);\n    }\n\n}\n\n\n> PS : 接口的适配器 , 如果希望重写所有的方法 , 需要创建抽象类(Adapter) , 来重写这些方法 , 如果需要用的时候再进行具体化他们 . 这一过程需要将实现改为继承形式进行应用\n\n# 适配器模式总结\n\n应用场景 :\n\n * 兼容 新老系统业务接口 的对接问题\n * 使用第三方提供的组件 , 组件接口和我们要求的接口不一致 , 可通过适配器调整接口\n\n优点 :\n\n * 客户端通过适配器可直接调用目标接口\n * 将目标类和适配者类解耦 , 解决了目标类和适配者类接口不一致的问题\n * 符合 开闭原则\n\n缺点 :\n\n * 频繁使用会 增加复杂度&降低可读性\n\n\n# 装饰者模式\n\n指在不改变现有对象结构的情况下 , 动态给对象增加一些职责(即增加其额外功能)的模式 , 它属于对象结构型模式\n\n装饰者模式结构 :\n\n * 抽象构件角色(Component) : 定义一个抽象接口以规范准备接收附加责任的对象\n * 具体构件角色(Concrete Component) : 实现抽象构件 , 通过装饰角色为其添加一些职责\n * 抽象装饰角色(Decorator) : 继承/实现 抽象构件 , 其中包含有 具体构建的实例 , 可通过其子类扩展\n * 具体装饰(ConcreteDecorator) : 实现抽象装饰的相关方法 , 并给具体构件对象添加附加的责任\n\n仓库示例 : 03StructuralPattern.decorator\n\n快餐店案例\n\n用装饰者模式编写该案例 . 一家快餐店 有炒面(FriedRice)&炒饭(FriedNoodles)等其他快餐 , 这些餐中可以增添 鸡蛋(Egg)/培根(Bacon) 等配菜 , 这些配菜的添加也是要额外加钱\n\n类                                  角色\nFastFood(快餐类)                      抽象构件角色\nFriedNoodles/FriedRice (炒面/炒饭 类)   具体构件角色\nEgg/Bacon (鸡蛋/培根 类)                具体装饰者\nGarnish(装饰者类)                      抽象装饰角色\n\n\n\n优点 :\n\n * 比继承更加灵活的扩展功能 , 可组合装饰者获取来的结果 . 完美遵循了 开闭原则\n * 修饰类和被修饰类可独立拓展 , 无耦合 . 是继承的替代模式\n\n缺点 :\n\n * 子类容易增多 , 系统的复杂度也随着提高\n\n应用场景 :\n\n * 不能采用继承对系统扩展 / 继承不理系统扩展和维护时 , 可以采用装饰模式 不能继承的情况 :\n   * 系统存在大量的独立扩展 , 每种组合将会产生大量子类 , 子类容易以爆炸性增长\n   * 定义的类不能被继承 (如: final类)\n * 不影响其他对象的情况下 , 以 动态/透明 的方式给单个对象添加职责\n * 当对象的功能要求可动态添加 , 也可 动态撤销时 (直接将其子类移出即可)\n\n\n# 桥接模式\n\n将抽象与实现分离 , 使它们可以独立变化 . 它是用组合关系代替继承关系来实现 , 从而降低了抽象和实现这两个可变维度的耦合度\n\n> 一家公司发行了一款 新品的电饭锅 , 那么该新产品 在代码设计层面上理解 , 只需实现 设定好的规则(实现接口) , 聚合应用即可 (组合应用)\n\n桥接模式结构 :\n\n * 抽象化角色(Abstraction) : 抽象类 , 包含一个对象 实现化角色对象 的引用 , 对象操作的行为\n * 扩展抽象化角色(Refined Abstraction) : 抽象化角色的子类 , 实现操作方法 , 并操作 实现化角色对象\n * 实现化角色(Implementor) : 定义实现接口 , 提供方法 扩展抽象化角色 引用\n * 具体实现化角色(Concrete Implementor) : 具体实现 实现化角色 的方法\n\n优点 :\n\n * 抽象与实现分离 , 扩展能力强 , 符合 开闭原则\n * 实现细节对客户透明\n\n缺点 :\n\n * 聚合关系建立在抽象层 , 添加多个独立维度 , 会增加系统的理解与设计难度\n\n应用场景 :\n\n * 一个类存在两个以上的独立变化维度 (可在抽象层建立不同维度的关联关系)\n * 当一个系统不希望 多层继承/类数急增 的情况\n\n仓库示例 : 03StructuralPattern.bridging\n\n视频播放器\n\n设计个 跨平台视频播放器 , 不同操作系统(OperatingSystem) , 解析视频文件格式(VideoFile)不一样 , 在加上视频文件格式也是多样化的 , 因此我们根据这两个维度进行分析并且实现(操作系统&文件格式) , 采用桥接模式\n\n类                         角色\nVideoFile(视频文件类)          实现化角色\nAVIFile/RmvbFile(视频文件类)   具体实现化角色\nOperatingSystem(操作系统类)    抽象化角色\nWindows/Mac(操作系统类)        扩展抽象化角色\n\n\n\n\n# 外观模式\n\n外观模式 是一种通过为多个复杂的子系统提供一个一致的接口 , 外部直接通过接口访问子系统 , 黑盒子模式(无需关心内部细节) , 降低程序应用可行度\n\n> 请一位管家进行对别墅 , 别墅管理事项有 : 修理花草 , 浇水临花 , 卫生清洁等事项 . 房主只需跟管家说下即可 !\n\n外观模式结构 :\n\n * 外观角色(Facade) : 为多个子系统对外提供一个共同的接口\n * 子系统角色(Sub System) : 实现系统的部分功能 , 客户可以通过外观角色访问它\n\n优点 :\n\n * 降低 子系统与客户端 之间的耦合度\n * 对客户屏蔽了子系统组件 , 减少了客户处 理的对象数目 , 并使得子系统使用起来更加容易\n\n缺点 :\n\n * 不符合 开闭原则\n\n应用场景 :\n\n * 分层结构的应用 , 可简化子系统依赖关系\n * 系统有多个子系统且和客户端有联系时 , 引入外观模式将他们分离 , 使得子系统独立可移植\n\n仓库示例 : 03StructuralPattern.exterior\n\n智能家居案例\n\n随着时代的发展 , 智能家电的普及 , 操作起来也是十分的方便 . 这一过程我们只需和接收信息的终端设备 (智能音响) , 进行统一控制 , 可便一键完成操作\n\n类                                     角色\nIntelligentControlLittleLove(小爱同学类)   外观角色\nAirCondition/Light/Tv (家用设备类)         子系统角色\n\n\n\n\n# 组合模式\n\n把一组相似的对象看做一个单一的对象处理 . 该模式依据树型结构来组合对象 , 用来表示部分整个层次 .\n\n> 在电脑的操作系统中 , 一般有文件系统的管理 , 文件夹和文件我们可以看做单一对象处理 , 虽然文件夹中还会包含 文件/文件夹 , 但我们可以看做一个对象组的树型结构\n\n组合模式结构 :\n\n * 抽象根节点(Component) : 定义系统各层级对象的共有 对象&方法 , 预先定义默认 行为&属性\n * 树枝节点(Composite) : 定义树枝节点行为 , 包含有 树枝和叶子 节点 , 从而形成树型结构\n * 叶子节点(Leaf) : 叶子节点对象 , 无其他节点分支 , 是系统层次遍历的最小单位\n\n优点 :\n\n * 清晰地定义复杂对象的层次结构 , 使用更为便捷\n * 层次的节点添加 , 无需对类库进行修改 , 满足 开闭原则\n\n缺点 :\n\n * 设计复杂 , 层级编辑比较复杂\n\n应用场景 :\n\n * 引用 树型结构 的情况 (如: 文件目录展示 , 多级目录呈现等...\n\n仓库示例 : 03StructuralPattern.combination\n\n系统菜单案例\n\n在系统菜单中 , 我们一般会看到一层一层的菜单结构 , 以树型结构进行呈现出来的信息 , 如图 :\n\n\n\n类                      角色\nMenuComponent(菜单组件类)   抽象根节点\nMenu(菜单类)              树枝节点\nMenuItem(菜单项类)         叶子节点\n\n\n\n\n# 享元模式\n\n运用共享技术以最大利用率进行对象复用 . 主要通过共享以存在的对象进行缩短对象创建的数量 , 避免大量相似对象的开销 , 从而提高资源利用率\n\n> 围棋&五子棋和井字棋中的黑白棋子 , 图像中的坐标点或颜色等信息... , 能把它们相同点提取出来共享 , 能节省大量利用资源\n\n享元模式结构 :\n\n * 抽象享元角色(Flyweight) : 所有享元类的父类/实现接口 , 规范化享元类\n * 具体享元角色(Concrete Flyweight) : 抽象享元角色规定的接口 (这里可以看做结合单例模式进行设计 , 每个独享提供唯一的享元对象 , 但他们的地址相同\n * 非享元角色(Unsharable Flyweight) : 是不可共享的外部状态 , 它以参数形式注入具体享元的相关方法中\n * 享元工厂角色(Flyweight Factory) : 负责 创建&管理 享元角色 . 当客户请求享元对象时 , 享元工厂会检测是否存在满足条件的享元对象 , 存在则提供 , 否则创建新的享元对象 (类似单例模式)\n\n享元模式的状态 :\n\n * 内部状态 : 不会随着环境的改变而改变的可共享部分\n * 外部状态 : 会随着改变而改变 , 是不可以共享的部分\n\n> 连接池中的连接对象 , 保存在连接对象中的 用户名&密码&连接URL等信息 , 创建时就已经设好了 , 不会随环境的改变而改变 , 这些为内部状态 ; 而当每个连接要被回收利用时 , 我们需要将它标记为可用状态 , 这些为外部状态\n\n优点 :\n\n * 缓存共享对象 , 降低内存消耗\n\n缺点 :\n\n * 对象可共享 , 但不同共享的状态外部化 , 使得程序复杂性提高\n\n仓库示例 : 03StructuralPattern.flyweight\n\n俄罗斯方块案例\n\n俄罗斯方块游戏中 , 不同类型的方块都是一个实例对象 , 按照往常操作是需要创建很多实例对象 , 因此需要应用享元模式进行实现 ! (包含有 I&J&L&O&Z&T&S 形状)\n\n类                       角色\nAbstractBox(抽象方块类)      抽象享元角色\nIBox/LBox/OBox(类型方块类)   具体享元角色\nBoxFactory(方块工厂类)       享元工厂角色\n\n\n\n\n# 行为型模式\n\n\n# 模块模式\n\n模块模式 定义一个操作的骨架 , 将部分步骤让其子类执行且不影响骨架的特定步骤\n\n> 去银行办理业务 需要走的流程 : 取号>排队>办理具体业务>服务评价 等流程 , 这些过程当中每个人去银行都是需要走的流程 , 但 办理的业务因人而异\n\n模板结构 :\n\n * 抽象类(Abstract Class) : 方法构件 , 若干个抽象形式的 基本方法&基本方法\n   * 模板方法 : 定义骨架 , 按自定顺序调用其基本方法\n   * 基本方法 : 实现各步骤的方法 , 模板方法的组成部分\n     * 抽象方法(Abstract Method) : 抽象类声明实现其方法 , 并且由子类进行实现 (套娃)\n     * 具体方法(Concrete Method) : 实现抽象的具体方法\n     * 钩子方法(Hook Method) : 判断逻辑方法 , 返回布尔类型\n * 具体实现子类(Concrete Class) : 实现抽象类中的抽象方法和钩子方法 , 顶端组成步骤\n\n优点 :\n\n * 封装不变部分 , 扩展可变部分（不变的 封装在父类中实现 , 可变的 通过子类实现\n * 可变的 部分封装成方法是由子类实现的 , 因此可通过子类扩展功能 , 符合开闭原则\n\n缺点 :\n\n * 每次实现不同功能的子类 , 都会导致类的个数的增加（更为抽象 , 复杂度也就上来了\n * 继承关系的缺陷 , 如果父类新添加抽象方法 , 继承的子类都要重写新添加的方法\n\n应用场景 :\n\n * 算法整体步骤固定 , 个别易变时 , 可通过模板方法进行抽象出来进行实现\n * 父类抽象方法由子类实现 , 子类执行结果会影响父类的结果 , 导致反向控制结构 , 提高复杂度\n\n仓库示例：04BehaviorPattern.templet\n\n炒菜案例\n\n炒菜步骤一般分别 : 倒油 -> 热油 -> 倒蔬菜 -> 倒调味 -> 翻炒 , 这些步骤已模板形式进行模拟 .\n\n类                            说明\nAbstractClass                抽象角色\nConcreteClass_CaiXin(炒菜心类)   具体实现类\nConcreteClass_DaoCai(炒包菜类)   具体实现类\n\n\n# 策略模式\n\n该模式定义一套算法 , 将它们进行封装起来 , 算法之间可相互替换 , 这些算法不会影响到客户预期的结果\n\n> 旅游出行计划 , 如果在网上找游玩攻略 , 会提供出很多推荐游玩等... (提供接口确定行为执行方式)\n\n模式结构 :\n\n * 抽象策略(Strategy) : 通常由 接口/抽象类 实现 . 给角色提出所有具体决策所需的接口\n * 具体策略(Concrete Strategy) : 实现抽象决策类定义的接口 , 提供具体实现的 算法/行为\n * 环境(Context) : 策略类的引用 , 最终客户调用的\n\n优点 :\n\n * 策略 算法/行为 可以自由选择\n * 容易拓展 (利用了 抽象类/接口 多态特性)\n * 避免多重选择语句(if else) 进行判定策略\n\n缺点 :\n\n * 策略类容易多 . 可通过享元模式进行压缩数量\n * 策略类是透明的\n\n应用场景 :\n\n * 系统在多个 算法/行为 中选择一种时 , 进行通过角色策略类进行封装\n * 一个类定义多种行为 , 而且出现了多个选择语句 , 可通过策略类进行替换选择语句\n * 策略 算法/行为 完全独立 , 对客户 策略类实现细节隐藏\n\n仓库示例 : 04BehaviorPattern.tactics\n\n销售案例\n\n销售策略有三种 , 为别为不同假日类型销售 旺季/淡季/平常 价格\n\n类                            角色\nStrategy(抽象类/接口)             抽象策略\nStrategy A/B/C (实现 抽象类/接口)   具体策略\nSalesMan(销售员)                环境角色\n\n\n# 命令模式\n\n命令模式 是将 请求封装为一个对象 , 使请求的 职责和执行 分割出来 , 两者通过命令进行沟通 , 命令对象可进行 存储/传递/调用/增加/管理\n\n> 餐厅中 一般都会有服务员 , 当客人进入餐厅 , 服务员会招待\n\n模式结构 :\n\n * 抽象命令(Command) : 定义命令的接口 , 声明执行的方法\n * 具体命令(Concrete Command) : 实现命令接口 , 通常有 接收者 , 通过接收者的功能完成命令操作\n * 接收者/实现者(Receiver) : 真正执行命令的对象 . (任何类都可成为 , 只要完成需求)\n * 调用者/请求者(Invoker) : 命令对象执行请求 , 通常有 命令对象(多态形式) , 命令对象可以是集合形式 . 并且包含有命令发送执行的入口(执行方法)\n\n优点 :\n\n * 降低系统耦合度(操作和实现解耦)\n * 命令 增删 较快 , 不会影响其他类 , 满足开闭原则\n * 可实现宏命令 . 命令模式和组合模式结合实现\n * 方便实现 撤销/恢复 功能\n\n缺点 :\n\n * 命令模式可能会导致较多的具体命令类\n * 提高系统复杂度\n\n应用场景 :\n\n * 系统需要将请求 接收者/调用者 解耦 , 使得不能直接交互\n * 系统需要在不同时间指定请求 , 将他们进行排队执行请求\n * 系统需要支持命令 撤销(Undo)和恢复(Redo) 操作\n\n仓库示例 : 04BehaviorPattern.command\n\n点菜订单案例 客户点菜后 将点菜记录至订单中 , 订单会由服务员发给厨师(发请求给实现者)...\n\n类                 角色\nCommand           抽象命令\nOrderCommand      具体命令\nSeniorChef(厨师类)   接收者/实现者\nWaitor(服务员类)      调用者/请求者\nOrder(订单类)        实体对象\n\n\n# 职责链模式\n\n职责链模式 是将 请求发送者 和 请求处理者 进行解耦 , 通信是通过记住链的下一个对象的引用而形成的一条链 . 当请求发生时 , 请求会沿着这条链进行传递 , 直到 满足对象条件/到达链的终点 为止 (可能 到达终点也可能没有得到处理)\n\n> 在学校请求中 , 如果请假超过3天 , 就不是班主任能决定的事了 , 因此需要班主任的上级可许才能请假 .\n\n模式结构 :\n\n * 抽象处理者(Handler) : 处理请求抽象类 , 包含 请求处理方法 和 后继连接方法\n * 具体处理者(Concrete Handler) : 请求处理方法的具体实现 , 判断满足条件 , 如果满足则处理 , 否则 请求转让后继连接\n * 客户类(Client) : 创建请求处理链 , 并向链头的具体处理者对象提交请求 , 不用关心 处理细节/传递过程\n\n优点 :\n\n * 降低了 请求发送者 和 请求处理者 耦合度\n * 增强了系统的可扩展性 (按需求添加请去处理类)\n * 增强了 流程链 的灵活度 (链的顺序只需指定下一个即可)\n * 责任分担 , 每个具体处理者 都有自己的处理工作 , 不能处理的传递给下一个 , 明确职责范围 , 符合单一原则\n\n缺点 :\n\n * 不能保证请求一定被接收处理 , 有可能 到达终点也可能没有得到处理\n * 较长的职责链会影响系统处理 , 也会影响 代码调试\n\n仓库示例 : 04BehaviorPattern.chainOfResponsibility\n\n请假案例\n\n公司请求条件 : 请假一天以下的假只需要小组长同意即可 ; 请假1天到3天的假还需 要部门经理同意 ; 请求3天到7天还需要总经理同意才行\n\n类                                                     角色\nHandler                                               抽象处理者\nGroupLeader(组长) / Manager(经理) / GeneralManager(总经理)   具体处理者\nMain                                                  客户类\nLeaveRequest(请假条)                                     实体对象\n\n\n# 状态模式\n\n状态模式 中 包含有很多不同的状态 , 不同的状态有不同的行为 , 这些状态会随着状态对象进行改变而改变的context对象\n\n模式结构 :\n\n * 环境(Context) : 也称上下文 , 定义了各状态程序的对象 , 也维护了状态对象且包含有当前状态的处理\n * 抽象状态(State) : 定义 接口/抽象类 , 里面包含有 状态的所有行为 , 环境对象以及状态的变化方法\n * 具体状态(Concrete State) : 实现抽象状态所对应的行为\n\n优点 :\n\n * 封装转化状态安全\n * 所有状态会封装到一个类中 , 可方便添加新状态 , 且只改变对象状态即可改变行为\n * 状态转换逻辑与状态对象合为一体 , 并非较大的条件语句\n\n缺点 :\n\n * 类数量容易多\n * 模式的结构和实现较为复杂\n * 对 开闭原则 的支持不友好\n\n应用场景 :\n\n * 对象行为取决于状态时 , 并且是在运行时根据状态改变的行为的情况\n * 庞大分支结构\n\n仓库示例 : 04BehaviorPattern.state\n\n电梯案例\n\n电梯在一般情况下包含有 开门/关门/运行/停止 状态 , 并且每个状态都有自己独有的执行行为\n\n类                                                           角色\nContext                                                     环境\nLiftState                                                   抽象状态\nClosingState(关闭) / OpenningState(打开) / RunningState(运行) /   具体状态\nStoppingState(停止)\n\n\n# 观察者模式\n\n观察者模式 定义了一种一对多关系的依赖关系 , 让多个观察者对象同时监听某一个主题对象 , 主题一旦发生变化会通知所有观察者对象\n\n> 这一模式类似于 微信公众号 , 它有 关注-推送 功能 , 只要关注某一公众号后 , 今后推送的内容都会 收到响应推送消息\n\n模式结构 :\n\n * 抽象主题(Subject) : 主题将所有观察者对象以集合形式保存 , 接口提供了 增/删 观察者 和 推送 功能\n * 具体主题(ConcreteSubject) : 实现抽象主题功能 , 对集合中的观察者对象 增/删 的功能 , 和推送关注集合内的观察者对象\n * 抽象观察者(Observer) : 定义了更新接口 , 会随着主题通知时更新自己\n * 具体观察者(ConcreteObserver) : 实现更新功能 , 以便更新自己状态\n\n优点 :\n\n * 降低 主题 - 观察者 耦合关系 , 两者之间有耦合关系\n * 实现广播机制 , 一对多推送通知\n\n缺点 :\n\n * 观察者较多 , 那么发送较为耗时\n\n应用场景 :\n\n * 对象之间存在一对多关系 , 那么一个对象会影响其他对象的改变的情况下\n\n仓库示例 : 04BehaviorPattern.observer\n\n微信公众号案例\n\n当你关注某一公众号后 , 该公众号推送消息给关注公众号的微信用户端 . (DDDD\n\n类                          角色\nSubject                    抽象主题\nSubscriptionSubject(公众号)   具体主题\nObserver                   抽象观察者\nWeixinUser(微信用户)           具体观察者\n\n\n# 中介者模式\n\n定义了一个 中介者角色 进行封装与其他对象之间的交互 , 使原有对象耦合松散 , 且可以独立改变他们之间交互\n\n> 一个公司中 , 同事与同事之间的信息交互 , 可通过 钉钉 直接联系到对方 , 那么这个 钉钉 就可看做为中介对象\n\n模式结构 :\n\n * 抽象中介者(Mediator) : 提供同事对象通信的抽象方法\n * 具体中介者(ConcreteMediator) : 实现通信方法 , 定义同事集合 , 且可添加通信(同事角色的依赖\n * 抽象同事类(Colleague) : 定义有 中介对象 , 同事名称 , 以及 通信所用的方法\n * 具体同事类(Concrete Colleague) : 实现接口对象 , 通信需要通过中介进行交互\n\n优点 :\n\n * 对象之间耦合松散\n * 集中控制交互 , 交互只需通过中介即可\n * 符合 迪米特原则\n\n缺点 :\n\n * 中介者类容易庞大 , 难以维护\n\n应用场景 :\n\n * 系统存在多个对象之间的通信 , 且结构难以维护的情况\n\n仓库示例 : 04BehaviorPattern.mediator\n\n中介租房案例\n\n出租房 一般情况是通过中介进行介绍来 , 和客户进行沟通购买的 , 因此中介的作用 能联系到房主\n\n类                              角色\nMediator                       抽象中介者\nMediatorStructure(通信中介)        具体中介者\nPerson                         抽象同事类\nTenant(租房者) / HouseOwner(房主)   具体同事类\n\n\n# 迭代器模式\n\n提供一个对象 , 按顺序访问集合的对象 , 无需知道底层执行方式来实现\n\n模式结构 :\n\n * 抽象聚合(Aggregate) : 定义 增加/删除 聚合元素以及创建迭代器接口\n * 具体聚合(ConcreteAggregate) : 实现 对象的存储 , 以及 抽象聚合方法 的实例\n * 抽象迭代器(Iterator) : 定义 可访问和遍历元素的接口\n * 具体迭代器(Concretelterator) : 实现 对象的存储 , 以及 抽象迭代器方法 的实例\n\n优点 :\n\n * 可通过自定义迭代器改变迭代算法\n * 扩展性高 , 可在原有代码进行增强 , 满足 开闭原则\n\n缺点 :\n\n * 增加类的个数 , 也会增加系统的复杂度性\n\n应用场景 :\n\n * 需要多种遍历方式时\n * 需要不同聚合结构提供统一的接口时\n * 访问聚合对象的内容无需暴露细节时\n\n仓库示例 : 04BehaviorPattern.iterator\n\n模拟对学生对象迭代器存储实现功能\n\n类                        角色\nStudentAggregate(学生聚合)   抽象聚合\nStudentAggregateImpl     具体聚合\nStudentIterator(学生迭代器)   抽象迭代器\nStudentIteratorImpl      具体迭代器\nStudent(学生)              实体对象\n\n\n# 访问者模式\n\n作用于某些数据结构对各个元素操作 , 且可不改变结构的前提作用这些元素对象的操作\n\n模式结构 :\n\n * 抽象访问者(Visitor) : 定义 固定访问的行为 , 在创建的时候就确定好需要访问的具体元素对象\n * 具体访问者(ConcreteVisitor) : 实现具体访问的行为\n * 抽象元素(Element) : 定义 接受访问方法 , 指定每个元素都有访问的方法\n * 具体元素(ConcreteElement) : 提供 接受方法的具体实现 , 接受后可使用访问者的方法\n * 对象结构(Object Structure) : 定义 具体元素的集合 和 添加具体元素的方法 , 分别将他们理解为容器进行提供访问者进行访问\n\n优点 :\n\n * 扩展性好 , 不修改结构进行添加新功能\n * 复用性好\n * 满足 单一原则 , 行为和访问分离\n\n缺点 :\n\n * 具体元素的细节是公开的 , 违背 迪米特原则\n * 对象结构变化困难 , 添加新元素 , 所有的具体元素都需要添加具体操作 , 违背 开闭原则\n\n应用场景 :\n\n * 对象结构相对稳定的情况\n * 对象结构中的对象需要多种不同不相关的操作的情况\n\n仓库示例 : 04BehaviorPattern.visitor\n\n宠物店喂宠物案例\n\n宠物店多种宠物(具体元素) , 在开店的时候会有不同的客人(访问者)进来 参观访问这些宠物\n\n类                 角色\nPerson(人)         抽象访问者\nOwner / Someone   具体访问者\nAnimal(宠物)        抽象元素\nCat / Dog         具体元素\nHome              对象结构\n\n\n# 备忘录模式\n\n该模式提供了一套 状态恢复机制 , 使得方便返回到特定的历史步骤 , 如果出现问题 , 可返回之前的状态进行操作\n\n模式结构 :\n\n * 发起人(Originator) : 提供 记录当前状态/备份 等其他拓展实现\n * 备忘录(Memento) : 负责 存储发起人状态 , 在需要的时候进行恢复状态\n * 管理者(Caretaker) : 对备忘录进行管理 , 提供 保存/获取 备忘录功能 , 不能对其内容进行 访问/修改\n\n宽窄接口\n\n * 窄接口 : 只能获取备忘录对象 , 不能对备忘录里面的数据进行 访问/修改 . 除了 发起人 , 其他访问的都是 窄接口\n\n * 宽接口 : 与窄接口相反 , 所有人均可访问都是 窄接口\n\n优点 :\n\n * 提供恢复状态机制 , 可恢复某个历史的状态\n * 实现内部状态的封装 , 黑盒备忘录\n * 简化发起人 , 并由管理者进行管理 , 符合 单一原则\n\n缺点 :\n\n * 资源消耗大\n\n应用场景 :\n\n * 需要 保存/恢复 的场景\n * 需要 提供可回滚的场景\n\n仓库示例 : 04BehaviorPattern.memento\n\n游戏战斗案例\n\n模拟游戏战斗存档场景 , 游戏存档状态作为数据 , 在战斗前和战斗后 状态都是不一样的 , 因此我们可以根据这些状态进行恢复存档之类的\n\n白盒备忘录\n\n备忘录角色 对所有需要对象 提供 宽接口\n\n类                             角色\nGameRole(游戏角色)                发起人\nRoleStateMemento(角色状态 备忘)     备忘录\nRoleStateCaretaker(角色状态 管理)   管理者\n\n黑盒备忘录\n\n备忘录角色 对发起人对象 提供 宽接口 , 而其他对象提供窄接口\n\n将 RoleStateMemento管理员 设为私有内部类 , 将其 实现一个 空Memento接口 作为标识应用 , 这样就不会暴露内部操作\n\n类                    角色\nGameRole             发起人\nMemento(窄接口)         管理者\nRoleStateCaretaker   备忘录\n\n\n# 解释器模式\n\n该模式 实现了一个表达式接口 , 接口解释一个特定的上下文 . 例如 : 日常使用的计算器/SQL语句的解析/...\n\n按照特定的规则去抽象化定义\n\n模式结构 :\n\n * 抽象表达式(Abstract Expression) : 定义解释器接口 , 约定解释器的解释操作 , 主要 interpret()方法\n * 终结表达式(Terminal Expression) : 实现抽象表达式 , 解释 interpret()方法 解决运算符相关的操作 , 有结果\n * 非终结表达式(Nonterminal Expression) : 实现抽象表达式 , 解释 interpret()方法 解决运算符相关的操作 , 无结果\n * 环境(Context) : 定义 存储/添加/获取 数据的功能 , 这些数据是等待进行解释的 , 一般情况是公开的\n\n优点 :\n\n * 灵活 , 扩展高\n * 添加新的表达式规则简单\n\n缺点 :\n\n * 应用场景少\n * 结构难以维护\n * 执行效率低(大量递归)\n\n应用场景 :\n\n * 规则简单 , 执行效率不是问题的情况\n * 问题重复出现且用的是简单语言进行表示时\n * 语言句子中以树的形式表示的时候\n\n仓库示例 : 04BehaviorPattern.interpreter\n\n类                            角色\nAbstractExpression           抽象表达式\nVariable(变量运算符)              终结表达式\nMinus(减法运算符) / Plus(加法运算符)   非终结表达式\nContext                      环境\n\n\n# 自定义Spring\n\n\n# Ioc 控制反转\n\n仓库代码 : 链接\n\n**涉及设计模式 : **\n\n * 工厂模式 : BeanFactory工厂\n * 单例模式 : 每个Bean对象都是单例\n * 模板模式 : AbstractApplicationContext类的refresh() 方法 顺序固有了\n * 迭代器模式 : MutablePropertyValues类管理propertyValueList集合 , 使用了迭代器模式',normalizedContent:'# 设计模式\n\n\n# 概述\n\n软件设计模式 , 又称设计模式 , 是套被反复使用且多数人知晓的 , 代码设计经验的总结 . 是前辈们 在不断出现问题中总结出来的设计模式\n\n必要性\n\n * 提高 思维&编程&设计 能力\n * 使程序 标准化&工程化 , 开发效率大大提升 , 从而缩短软件开发周期\n * 使设计思路 重用性&可读性&可靠性&灵活性&维护性 有进阶的提升\n\n\n# 分类\n\n# 创建型模式\n\n描述 怎样创建对象 , 主要是将 对象的创建与使用分离\n\n该类型有以下设计模式 :\n\n * 单例模式（singleton pattern）\n * 工厂模式（factory pattern）\n * 抽象工厂模式（abstract factory pattern）\n * 原型模式（prototype pattern）\n * 建造者模式（builder pattern）\n\n# 结构型模式\n\n描述 如何将 类/对象 按照某种布局组成的结构\n\n该类型有以下设计模式 :\n\n * 代理模式（proxy pattern）\n * 适配器模式（adapter pattern）\n * 装饰器模式（decorator pattern）\n * 桥接模式（bridge pattern）\n * 外观模式（facade pattern）\n * 组合模式（composite pattern）\n * 享元模式（flyweight pattern）\n\n# 行为型模式\n\n描述 类/对象 之间怎样相互共同完成单个对象无法单独完成的任务\n\n该类型有以下设计模式 :\n\n * 责任链模式（chain of responsibility pattern）\n * 命令模式（command pattern）\n * 解释器模式（interpreter pattern）\n * 迭代器模式（iterator pattern）\n * 中介者模式（mediator pattern）\n * 备忘录模式（memento pattern）\n * 观察者模式（observer pattern）\n * 状态模式（state pattern）\n * 空对象模式（null object pattern）\n * 策略模式（strategy pattern）\n * 模板模式（template pattern）\n * 访问者模式（visitor pattern）\n\n\n# uml\n\n统一建模语言 , 用来设计软件的可视化建模语言 . 主要以图形的形式展示出信息\n\numl从不同角度出发 , 可分为 : 例图 , 类图 , 对象图 , 状态图 , 活动图 , 时序图 , 协作图等...\n\n> 以类图进行讲述 , 更直观的了解uml图\n\n# 类图\n\n类图 是展示一个对象的信息 , 里面包括有 属性&方法&构造方法&方法\n\n示例图 :\n\n\n\n> 通过分割线分割出来的矩形 , 可以看出 类名和属性和方法 是分割区分的 . 还有左侧的锁头代表是否开放的意思\n\n\n# 软件设计原则\n\n在开发中 , 为了提高系统 维护性和可复用性 以及 拓展性和灵活性 , 在开发时候尽量以 6条原则进行开发 , 从而缩短开发周期 !\n\n# 开闭原则\n\n对拓展开放 , 对修改关闭 . 在程序需要拓展时 , 不会影响到源代码 , 实现了热插拔效果\n\n实现一般需要通过 接口/抽象类 的形式进行拓展\n\n示例 :\n\n某软件 皮肤/主题 的设计\n\n官方有默认的主题 , 不过官方提供了自定义的设置 (这意味着可以添加自己喜好的元素进去) . 这一过程 体现出了 应用的拓展性 !\n\n仓库代码 : 01principle.openclosedprinciple\n\n# 里氏代换原则\n\n里氏代换原则 是 面向对象 的基本原则之一 , 任何基类可以出现的地方 , 子类一定可以出现\n\n解释 : 父类有的功能 , 其子类也有 , 但子类不能更改父类原有的功能 (如果重写了就违背了 里氏代换设计原则)\n\n示例 :\n\n长方形和正方形 对象的应用\n\n长方形和正反形 都继承了四边形进行实现 , 并非他们自己继承关系 . 如果是继承关系 , 那么重写的方法会导致子类引用时容易异常问题\n\n仓库示例 : 反例 : 01principle.liskovsubstitutionprinciple\n\n示例 : 01principle.liskovsubstitutionprinciple\n\n# 依赖倒转原则\n\n高层模块不应该依赖低层模块 , 两者应该依赖其抽象 (抽象没有依赖细节 , 但需要具体化) , 这样就提高模块间的耦合\n\n示例代码 :\n\n组装电脑案例\n\n一台台式主机电脑 , 需要配件 cpu&硬盘&内存条 等... 计算机才能运行 !\n\n仓库示例 :\n\n反例 : 01principle.dependencyinversionprinciple\n\n示例 : 01principle.dependencyinversionprinciple\n\n# 接口隔离原则\n\n父类有多个方法 , 子类自需要使用一个方法 , 那么子类会迫依赖其他方法 !\n\n解决方案 : 以接口形式进行对最小个数方法抽象化 , 以便继承使用\n\n(一个接口实现一个方法)\n\n示例 :\n\n安全门案例\n\n一个品牌的安全门 , 一般有多个功能 , 如: 防盗&防水&防火等功能... , 如果我们以一个接口整合这些功能 , 那么其他品牌没有其功能也会被迫依赖其功能 , 因此 我们将这些功能 , 以最小功能个数为单位进行区分化 进行实现 (类不能多继承 , 接口可以多实现)\n\n仓库示例 :\n\n反例 : 01principle.interfacesegregationprinciple\n\n示例 : 01principle.interfacesegregationprinciple\n\n# 迪米特法则\n\n迪米特法则 , 又称最小知识原则\n\n如果两个对象无需直接通信 , 那么就不会发生相互调用 , 需要通过第三方进行转发调用 . 其目的是降低耦合度 , 提高模块独立性\n\n示例 : 明星经纪人代理案例\n\n明星投入艺术上 , 很多事情由经纪人负责处理 , 如 粉丝见面&公司合租等业务...\n\n仓库示例 : 01principle.lawofdemeter\n\n# 合成复用原则\n\n尽量先使用 组合/聚合 等关系关联实现 , 其次考虑继承关系实现\n\n继承复用 优缺点 :\n\n * 继承复用破坏了类的封装性 , 继承会暴露父类实现细节(相对子类是透明的)\n * 父子类耦合度高 . 父类一旦改变其子类也会跟着改变 , 不利维护\n * 限制了复用的灵活性 , 从父类继承来的实现是静态的 , 编译已经定义了 , 所以在运行是不可能发生变化\n\n组合/聚合 优缺点 : (纳入对象 , 成为新对象的一部分 , 可以调用纳入对象的已有功能)\n\n * 维护了类的封装性 , 引入的对象是看不到内部细节 , 相对安全\n * 对象间耦合度低 . 一般引用在 类的成员属性位置上\n * 复用灵活性高 , 在运行时应用 , 新对象可动态的引用与类型相同对象\n\n仓库示例 : 01principle.syntheticreuseprinciple\n\n汽车分类管理程序\n\n汽车 可分为 汽油车&电力车 , 两种类型的车可以分为多中颜色的车因此可以看下图\n\n继承 类图呈现 :\n\n\n\n聚合 类图呈现 :\n\n\n\n\n# 创建者模式\n\n\n# 单例模式\n\n单例模式 一个类只有一个实例 , 且该类是自行创建这个实例的一种模式（我创建我自己）\n\n特点：\n\n * 单例类只有一个实例对象\n * 该单例对象必须由 自己进行创建\n * 单例类对外提供一个访问该单例的全局访问点\n\n优点：\n\n * 能够保证在内存里只有一个实例 , 不会有多余的开销\n * 可避免内存多重占用\n * 可设置全局访问 , 实现优化和资源共享资源的访问\n\n缺点：\n\n * 无接口 , 扩展功能麻烦 , 除了修改源代码（违背了开发原则\n * 不利于并发测试\n\n加载类型 :\n\n * 懒汉式 类加载时不会没有生成单例 , 只有当第一次调用 getlnstance()方法 时去创建单例\n * 饿汉式 类一旦加载就创建一个单例 , 保证在调用 getinstance()方法 之前单例已经存在了 . 如果不使用会造成资源浪费\n\n> 搭配一下 代码示例进行使用\n\n仓库示例 : 01principle.syntheticreuseprinciple\n\n代码示例 :\n\n/** 懒汉式 (双重检查锁机制 volatile关键字&同步锁\n *  该模式的特点是类加载时没有生成单例 , 只有当第一次调用 getlnstance 方法时才去创建这个单例\n */\npublic class lazysingleton {\n    // 静态 保证 所有线程中都是同步\n    private static volatile lazysingleton instance = null;\n    // 构造器 私有化\n    private lazysingleton() {}\n    // 同步锁 防止多线程共同创建可能产生一个以上的实例\n    public static lazysingleton getinstance() {\n    // 第一次判断 , 如果instance不为null , 不进入抢锁阶段 , 直接返回实际\n        if (instance == null) {\n            synchronized (lazysingleton.class) {\n                // 抢到锁之后再次判断是否为空\n                if (instance == null) {\n                    instance = new lazysingleton();\n                }\n            }\n        }\n        return instance;\n    }\n\n}\n\n/** 饿汉式\n *  该模式的特点是类一旦加载就创建一个单例 , 保证在调用 getinstance 方法之前单例已经存在了\n */\npublic class hungrysingleton {\n    // 构造方法私有化\n    private hungrysingleton(){}\n    \n    private static class singleton {\n        private static final hungrysingleton instance = new hungrysingleton();\n    }\n    \n    public static hungrysingleton getinstance() {\n        return singleton.instance;\n    }\n}\n\n\n> 以上方式以最优解决方案\n\n# 问题\n\n单例模式破坏情况 : (创建的对象并非一个)\n\n * 序列化\n * 反射\n\n仓库示例 :\n\n * 序列化破坏问题 & 序列化解决方案\n * 反射破坏问题 & 反射解决方案\n\n序列化破坏示例 :\n\npackage com.singleton.qademo;\n\nimport com.singleton.hungrysingleton;\n\nimport java.io.*;\n\n// 序列化 破坏单例模式\npublic class serializationbreaks {\n\n    // 桌面a.txt文件\n    private static string path = "c:\\\\users\\\\sans\\\\desktop\\\\a.txt";\n\n    public static void main(string[] args) throws exception{\n\n        // hungrysingleton类 需要序列化\n        hungrysingleton hungrysingleton = hungrysingleton.getinstance();\n        // 序列化存储\n        writeobjectfile(hungrysingleton);\n        // 反序列化提取\n        hungrysingleton hungrysingleton1 = readobjectfromfile();\n\n        // 根据地址进行判断他们是否相同\n        system.out.println("hungrysingleton = " + hungrysingleton);\n        system.out.println("hungrysingleton1 = " + hungrysingleton1);\n    }\n\n    // 从文件中读取对象\n    public static hungrysingleton readobjectfromfile() throws exception {\n        objectinputstream ois = new objectinputstream(new fileinputstream(path));\n        hungrysingleton instance = (hungrysingleton) ois.readobject();\n        return instance;\n    }\n\n    // 写入对象文件\n    public static void writeobjectfile(hungrysingleton instance) throws exception {\n        objectoutputstream oos = new objectoutputstream(new fileoutputstream(path));\n        //将instance对象写出到文件中\n        oos.writeobject(instance);\n    }\n}\n/* 结果 (地址显然就不对了 , 两个对象\nhungrysingleton = com.singleton.hungrysingleton@78308db1\nhungrysingleton1 = com.singleton.hungrysingleton@3d494fbf\n*/\n\n\n序列化 解决方案 :\n\n在序列化类中添加 readresolve()方法 , 在反序列化时会判断该方法是否存在 , 存在则调用其方法 , 否则 new新对象进行返回\n\n// singleton.instance 内部类提取出来的单例对象\nsingleton.instance;private object readresolve(){\n    return singleton.instance;\n}\n\n\n反射破坏示例 :\n\n// 反射 破坏单例模式\npublic class reflectiondamage {\n    public static void main(string[] args) throws exception {\n\n        class aclass = lazysingleton.class;\n        // 获取对象构造方法\n        constructor cons = aclass.getdeclaredconstructor();\n        // 取消访问检查 (越过权限修饰符\n        cons.setaccessible(true);\n\n        lazysingleton singleton = (lazysingleton) cons.newinstance();\n        lazysingleton singleton2 = (lazysingleton) cons.newinstance();\n\n        system.out.println("singleton = " + singleton);\n        system.out.println("singleton2 = " + singleton2);\n\n    }\n}\n\n\n反射 解决方案 :\n\n通过一个布尔值控制构造方法创建对象 , 如果已经存在了 抛出异常即可\n\n// 控制对象创建\nprivate static boolean flag = false;\n\nprivate lazysingleton() {\n    synchronized (lazysingleton.class){\n        if (flag){\n            throw new runtimeexception("不能创建多个对象");\n        }\n        flag = true;\n    }\n}\n\n\n\n# 工厂模式\n\n定义一个创建产品对象的工厂接口 , 将产品对象的实际创建工作推迟到具体子工厂类当中 . 这满足创建型模式中所要求的“创建与使用相分离”的特点\n\n3 种实现方式：\n\n * 简单工厂模式\n * 方法工厂模式\n * 抽象工厂模式\n\n工厂了解示例 : 02creatormode.factory.before\n\n设计一个咖啡类(coffee) , 并定义其两个子类 美式咖啡(americancoffee)&拿铁咖啡(lattecoffee) , 再设计一个咖啡店类(coffeestore) , 咖啡店具有点咖啡的功能\n\n\n\n# 简单工厂模式\n\n我们把被创建的对象称为“产品” , 把创建产品的对象称为“工厂” . 如果要创建的产品不多 , 只要一个工厂类就可以完成 , 这种模式叫“简单工厂模式”\n\n在简单工厂模式中创建实例的方法通常为 静态方法\n\n简单工厂结构 :\n\n * 抽象产品 : 定义产品规范 , 描述功能特性等..\n * 具体产品 : 继承/实现 抽象产品的子类\n * 具体工厂 : 提供创建产品的方法 , 通过方法获取产品\n\n优点：\n\n * 工厂方法中可以通过明确的值来确定产品（工厂和产品的职责区分明确\n * 用户获取产品对象时 , 只需 静态方法 填写参数获取即可\n * 也可以引入配置文件 , 在不修改客户端代码的情况下 更换/添加 新的具体产品类\n\n缺点：\n\n * 简单工厂模式的工厂类单一 , 负责所有产品的创建 , 职责过重 , 一旦异常 , 整个系统将受影响\n * 使用简单工厂模式会增加系统中类的个数（引入新的工厂类）, 增加系统的复杂度和理解难度\n * 系统扩展困难 , 一旦增加新产品不得不修改工厂逻辑 , 在产品类型较多时 , 可能造成逻辑过于复杂\n * 由于工厂使用了静态方法 , 造成工厂角色无法形成基于继承的等级结构\n\n仓库示例 : 02creatormode.factory.simple\n\n点咖啡后 , 会通过 咖啡工厂(coffeefactory) 进行生成咖啡 !\n\n\n\n简单示例 :\n\n// 抽象产品\ninterface product{\n    void show();\n}\n\n// 具体产品1\nclass concreteproduct1 implements product{\n    @override\n    public void show() {\n        system.out.println("产品1");\n    }\n}\n\n// 具体产品2\nclass concreteproduct2 implements product{\n    @override\n    public void show() {\n        system.out.println("产品2");\n    }\n}\n\nclass productfactory{\n    static final int product_a = 0;\n    static final int product_b = 1;\n    \n    public static product makeproduct(int productid){\n        switch (productid) {\n            case product_a:\n                return new concreteproduct1();\n            case product_b:\n                return new concreteproduct2();\n            default: break;\n        }\n        return null;\n    }\n    \n}\n\n\n> 在原有的基础上通过工厂形式进行获取\n\n# 方法工厂模式\n\n是对 简单工厂模式的进一步抽象化 , 其好处是可以使系统在不修改原来代码的情况下引进新的产品 , 即满足 开闭原则\n\n方法工厂结构 :\n\n * 抽象工厂 : 提供创建产品的接口 , 通过接口进行调取具体工厂来创建产品\n * 具体工厂 : 主要实现抽象方法 , 完成具体产品的创建\n * 抽象产品 : 定义产品规范 , 描述功能特性等...\n * 具体产品 : 实现产品接口 , 最后由其工厂来创建 , 工厂和产品一一对应\n\n优点：\n\n * 用户只需知道工厂名称 , 无需理解工厂创建过程\n * 新产品需要创建对应的具体工厂类\n\n缺点：\n\n * 类的个数容易多（增加复杂度\n\n仓库示例 : 02creatormode.factory.method\n\n以下是根据不同的咖啡设计出的不同工厂 (americancoffeefactory&lattecoffeefactory) , 实现的接口都有生产咖啡的方法 , 在客户点咖啡后 , 咖啡店只关心咖啡工厂即可提供客户咖啡 (要区分工厂类型) !\n\n\n\n简单示例 :\n\n// 抽象产品：提供产品的接口\ninterface product{\n    void show();\n}\n\n// 抽象工厂：提供厂的生成方法\ninterface abstractfactory {\n    product newproduct();\n}\n\n// 具体产品1\nclass concreteproduct1 implements product{\n    @override\n    public void show() {\n        system.out.println("显示产品1");\n    }\n}\n\n// 具体产品2\nclass concreteproduct2 implements product{\n    @override\n    public void show() {\n        system.out.println("显示产品2");\n    }\n}\n\n// 具体工厂1：实现产品生成方法\nclass concretefactory1 implements abstractfactory {\n    @override\n    public product newproduct() {\n        system.out.println("具体工厂1--\x3e具体产品1");\n        return new concreteproduct1();\n    }\n}\n\n// 具体工厂2：实现产品生成方法\nclass concretefactory2 implements abstractfactory {\n    @override\n    public product newproduct() {\n        system.out.println("具体工厂2--\x3e具体产品2");\n        return new concreteproduct2();\n    }\n}\n\n\n# 抽象工厂模式\n\n抽象工厂 可以理解为 工厂的工厂 . 提供一个 创建相关的/相互依赖的接口 , 无需指定具体类 , 就能得到该品牌(工厂)不同类型的产品(手机/电脑/电子手环 等用电器...)\n\n可以了解为 还tcl品牌不单单只是买电视机 , 还有其他用电器..\n\n抽象工厂结构 :\n\n * 抽象工厂 : 提供产品接口 , 包含有多个创建 产品的方法\n * 具体工厂 : 实现 抽象工厂接口的方法 进行生产产品\n * 抽象产品 : 定义产品 规范&特征&功能 的抽象方法\n * 具体产品 : 实现抽象产品接口 , 创建时可具体化产品信息\n\n优点 :\n\n * 当一个工厂中的多个对象被设计成一起工作时 , 它能保证客户端始终只使用同一品牌(工厂)的对象\n\n缺点 :\n\n * 当该品牌增加新产品时 , 所有相关的工厂类都需要进行修改\n\n仓库示例 : 02creatormode.factory.abstractfactory\n\n咖啡店添加新产品甜点(dessert) 分别有 提拉米苏(tiramisu)&抹茶慕斯(matchamousse) , 工厂是根据不同地域产生的不同类型的 咖啡和甜点 , 这些工厂分别有 意大利甜点厂(iatlydessertfactory)&美国甜点厂(americandessertfactory) . 解决了 方法工厂模式 类爆炸的问题(类多)\n\n\n\n简单示例 :\n\n// 具体工厂：实现产品生成的方法\nclass concretefactory1 implements abstractfactory {\n    \n    @override\n    public product1 newproduct1() {\n        system.out.println("具体工厂1--\x3e具体产品1");\n        return new product1();\n    }\n    \n    @override\n    public product2 newproduct2() {\n        system.out.println("具体工厂1--\x3e具体产品2");\n        return new product2();\n    }\n}\n\n// 产品1\nclass product1 { }\n\n// 产品2\nclass product2 { }\n\n\n# 模式扩展\n\n该扩展是 简单工厂&配置文件 的组合使用 , 主要是解决了工厂对象耦合问题\n\n配置文件已 properties格式进行存储 , 键值对(键 : 名称 ; 值 : 全限定类名)\n\n## 获取产品通过 k 获取 , 对象则是通过 k对应的v 获取\namerican=com.factory.modeconfigfactory.americancoffee\nlatte=com.factory.modeconfigfactory.lattecoffee\n\n\n仓库代码 : 02creatormode.factory.modeconfigfactory\n\n\n# 原型模式\n\n用一个已经创建的实例作为原型 , 通过复制该原型对象来创建一个和原型相同的新对象\n\n原型模式结构 :\n\n * 抽象原型类 : 规定具体原型对象必须实现的的 clone()方法\n * 具体原型类 : 实现抽象原型接口 重写 clone()方法 , 返回的是复制原型类\n * 访问测试类 : 使用原型的实例对象进行调用其 clone()方法 来复制对象\n\n克隆模式 :\n\n * 浅克隆 : 克隆新对象的属性和原有对象相同 , 对于非基本数据类型的属性仍会指向原有对象地址\n * 深克隆 : 克隆新对象的属性也会一一拷贝一份 , 且他们引用属性对象的地址和原有引用的地址不同\n\n克隆羊"多莉"实验案例 , 其原型是非克隆羊\n\n仓库示例 了解结构: 02creatormode.prototype\n\n仓库示例 (浅克隆&深克隆): 02creatormode.prototype\n\n> ps :\n> \n>  * 克隆前提需要 cloneable接口 , 并重写 clone()方法 返回其拷贝对象\n>  * 序列化 需要 序列化对象 (实现 serializable接口)\n>  * json化 需要 jar包 (gson)\n\n\n# 建造者模式\n\n将一个复杂对象的构建与表达分离 , 使得相同的构建过程可以有不同的表示\n\n解释 : 将复杂对象进行拆分装配 , 不同 构建器&装配顺序 都会建出 不同对象 (复杂对象拆分创建)\n\n建造者模式结构 :\n\n * 抽象创建者类 (builder) : 规范化复杂对象创建方式 , 不涉及具体对象创建\n * 具体创建者类 (concretebuilder) : 实现 builder接口 , 完成复杂产品具体部件创建方法\n * 产品类 (product) : 复杂对象\n * 指挥者类 (director) : 调用 builder方法 , 分别创建复杂对象部件 , 部件创建的顺序是自定义的 , 最终将创建完整的对象进行返回\n\n优点 :\n\n * 构建过程复杂的对象\n * 建造者封装性好\n * 无需知道产品组成细节 , 产品本身和创建过程是以解耦形式创建 , 使得创建时会有不同产品对象\n * 易扩展 , 如有新产品 , 只需创建新即建造者类即可 . 也满足 开闭原则\n\n缺点 :\n\n * 产品会有较多的共同点 , 组成部分相似 , 不适合差异较多的复杂对象使用 , 有范围局限性\n\n仓库示例 : 02creatormode.creator (ps : 抽象创建者类可以为接口\n\n生产自行车案例\n\n生产自行车是一个复杂的过程 , 它包含了车架(frame)&车座(seat)等组件的生产 . 车架用什么材质 , 车座又用什么材质等组件都需要细化 . 自行车(bike) 包含有这些组件都需要细化 , mobikebuilder和 ofobuilder是具体的建造者 (具体的类型使用的材质) , 抽象建造者(builder) 里面的组件即将会被 指挥者(director) 指定的顺序组装 完成 (顺序有指挥者制定)\n\n\n\n仓库示例2 (优化版) : 02creatormode.creator\n\n> 优化版 整合了指挥者类进行 , 整合后不能以接口形式呈现 , 因 接口只能又抽象方法 (需要构建部件创建顺序)\n> \n> 解释 : 过于复杂的对象需要指挥者创建\n\n# 模式拓展\n\n除了以上用法 , 在开源中也常见的一种使用方式 , 链式构建对象 , 能够更直观构造一个对象的属性 ! 且特别适合单对象的构建 !\n\n示例 :\n\n组装电脑案例\n\n一台台式主机电脑 , 需要配件 cpu&硬盘&内存条 等... 计算机才能运行 !\n\n构造器构建对象方式 : (显然可以看到可读性比较差\n\npublic static void main(string[] args) {\n\t//构建computer对象 (构造器属性顺序 cpu,硬盘,内存条,主板\n\tcomputer computer = new computer("intel9400","西数硬盘500g","金士顿内存条16g","华硕主板");\n\tsystem.out.println(computer);\n}\n\n\n建造者构建对象方式 :\n\npublic static void main(string[] args) {\n\tcomputer computer = new computer.builder()\n\t\t.cpu("intel9400")\n        .harddisk("西数硬盘500g")\n\t\t.mainboard("华硕主板")\n\t\t.memory("金士顿内存条16g")\n\t\t.build();\n\t\tsystem.out.println(phone);\n}\n\n\n仓库示例 : 02creatormode.creator.extend\n\n\n# 创建者模式对比\n\n应用场景 :\n\n * 单例模式 : 单对象重复引用情况\n * 原型模式 : 多次拷贝原对象情况\n * 工厂模式 : 多对象不同形态情况\n * 建造者模式 : 创建复杂对象情况\n\n创建形式 :\n\n * 单例模式&工厂模式 : 直接new实例对象\n * 原型模式 : 复制对象\n * 建造者模式 : 细分创建对象部件过程\n\n\n# 结构型模式\n\n\n# 代理模式\n\n为对象提供一个代理使其对象可访问 , 访问对象不能直接访问目标引用对象 , 代理对象作为中介进行交互\n\n解释 : 打电话给同事 , 需要引用手机进行与对方交互 (手机充当代理对象) , 不能直接进行对面交互(同事不在附近)\n\n代理模式结构 :\n\n * 抽象目标对象 (subject) : 通过 接口/抽象类 定义 真实目标对象 即将实现的业务方法\n * 目标对象 (real subject) : 具体化抽象目标对象的业务方法 , 是最终要引用的真实目标对象\n * 代理 (proxy) : 提供了与真实目标对象交互的接口 , 其内部含有对真实主题的引用 , 它可 访问&控制/增强 目标对象的功能\n\n# 静态代理\n\n将 服务性代码 分离出来 . 通过接口进行静态代理\n\n缺点 :\n\n * 每次新添加业务方法 都要添加 , 维护成本高\n\n仓库示例 : 03structuralpattern.proxy\n\n火车站卖票\n\n早期互联网没有完善时 , 购买票是需要去火车站进行的 , 排队等一系列的操作 , 非常麻烦 . 因此 不少地方也有了 代售点 进行代理卖票 . 以上案例不难看出 , 目标对象是火车站(trainstation) , 代售点是代理对象(proxypoint)\n\n类                     角色\nproxypoint (代理类)      代理角色\ntrainstation (火车站类)   目标角色\n\n\n\n# jdk动态代理\n\njdk动态代理 是java中提供的代理类 . 程序运行的时候 , 根据要被代理的对象 动态生成代理类\n\njava提供 proxy.newproxyinstance()方法 获取 代理对象\n\n/** 参数:\n* @param classloader loader : 代理对象的类加载器\n* @param class<?>[] interfaces : 代理对象要实现的接口列表\n* @param invocationhandler h :  代理对象的处理程序\n*/\npublic static object newproxyinstance(classloader loader,\n                                      class<?>[] interfaces,\n                                      invocationhandler h)\n                               throws illegalargumentexception\n\n\ninvocationhandler.invoke()方法 (增强业务)\n\n/** 参数:\n* @param object proxy : 代理对象\n* @param method method : 对接口的方法进行封装成的对象\n* @param object[] args : 调用方法的参数\n* return 对应代理对象方法执行的返回值 (如果 void 则 null)\n*/\npublic object invoke(object proxy, method method, object[] args)\n        throws throwable;\n\n\n仓库示例 : 03structuralpattern.proxy\n\n> 以上实例的代理对象是自动生成的 , 因此我们查看需要借助 阿里巴巴开源 arthas-boot.jar 诊断工具 来查看程序运行中指定类结构\n\n查看 自动生成的代理类 :\n\n 1. 下载 arthas-boot.jar 诊断工具 (仓库同步有)\n 2. 运行程序 , 保持运行状态 (为了防止 main()方法 执行结束 , 在末尾添加死循环) 记住控制台打印的代理类的 全限定类名\n 3. 进入终端 (cmd) , 进入 arthas-boot.jar 路径内 , 执行以下指令 ==java -jar arthas-boot.jar== (执行加载包)\n 4. 选择刚刚运行的java进程 (根据序号选择进入)\n 5. 选择指定类进行查看 , 输入以下指令 ==jad 全限定类名==\n\n> ps : 该 诊断工具 需要 java程序也是运行 jdk17版本 , 否则 无法诊断 该java线程\n\n代码示例 :\n\n// 程序运行过程中自动生成的代理类 (该对象的原代码较多 , 简化去掉不必要代码)\npublic final class $proxy0 extends proxy implements selltickets {\n    // selltickets接口的sell()方法\n    private static final method m3;\n\t\n    // 该参数赋予在  proxy.newproxyinstance()方法 第三个参数赋予\n    public $proxy0(invocationhandler invocationhandler) {\n        super(invocationhandler);\n    }\n\n    static {\n        m3 = class.forname("com.proxy.jdk.selltickets").getmethod("sell", new class[0]);\n    }\n\t\n    // 步骤 2  \n    public final void sell() {\n        // 步骤 3\n        this.h.invoke(this, m3, null);\n    }\n}\n\n// java提供的动态代理相关类\npublic class proxy implements java.io.serializable {\n    // 代理对象的处理程序\n\tprotected invocationhandler h;\n\tprotected proxy(invocationhandler h) {\n\t\tthis.h = h;\n\t}\n}\n\n// 代理工厂\n// ps: 该工厂不是代理类 , 而是程序运行过程在内存生成的类\npublic class proxyfactory {\n\n    // 目标对象\n    private trainstation station = new trainstation();\n\n    // 返回单例对象\n    public selltickets getproxyobject() {\n        return (selltickets) proxy.newproxyinstance(\n                station.getclass().getclassloader(),\n                station.getclass().getinterfaces(),\n                new invocationhandler() {\n                    @override\n                    public object invoke(object proxy, method method, object[] args) throws throwable {\n                        // 步骤 4\n                        // 增强业务\n                        system.out.println("卖票 前置通知");\n                        // 执行 业务方法 , 并且返回\n                        // 步骤 5\n                        object obj = method.invoke(station, args);\n                        system.out.println("卖票 后置通知");\n                        return obj;\n                    }\n                }\n        );\n    }\n}\n\npackage com.proxy.jdk;\n\n// 代理模式 jdk动态代理 测试类\npublic class main {\n    public static void main(string[] args) {\n\n        // 获取代理工厂代理对象\n        proxyfactory factory = new proxyfactory();\n        // 获取代理对象 (该对象是动态生成的\n        selltickets proxyobject = factory.getproxyobject();\n        // 卖票方法\n        // 步骤 1\n        proxyobject.sell();\n        system.out.println("proxyobject = " + proxyobject.getclass());\n        while (true) {}\n    }\n}\n\n\n执行流程解析 : (对应注释步骤走向)\n\n 1. 测试类 调用代理对象 sell()方法\n 2. 多态特性 继承了 selltickets接口, 代理类 ($proxy0) 中的 sell()方法\n 3. 代理类 ($proxy0) 中的 sell()方法 中又调用了 invocationhandler接口 实现 invoke()方法 (lambda表达式)\n 4. 代理对象业务增强部分 . invocationhandler.invoke()方法 (详细可看上面方法说明)\n 5. invocationhandler.invoke()方法中的 invoke()方法 反射调用 真实对象 (trainstation) 中的 sell()方法\n\n# cglib动态代理\n\ncglib代理 , 也称子类代理 . 可以看做 jdk动态代理 的升级版\n\n特点 :\n\n * 目标对象无需实现接口也可对外进行代理\n * 代理对象是目标对象的子类 , 因此 也继承了方法\n * 通过 enhancer类 进行创建代理对象 (和proxy类 类似 , 创建方式有多种)\n * 依赖外部引入jar包 cglib动态代理\n\n> glib代理被许多 aop框架 所使用 , 其底层是通过使用一个小而快的字节码处理框架asm（java 字节码操控框架）转换字节码并生成新的类\n\n仓库示例 : 03structuralpattern.proxy\n\n# 代理模式总结\n\n       jdk动态代理     cglib动态代理   静态代理\n效率     较高          偏低于jdk      较高\n复杂度    复杂          复杂          简单\n外部依赖   jdk本身       外部jar包      无\n代理方式   目标对象实现的接口   目标对象        目标对象\n\n动态代理和静态代理 的区别 :\n\n * 动态代理 目标对象的业务方法都会集中在一个集中的方法处理 ; 静态代理 指定方法进行手写中转处理 , 才能实现代理\n * 如果目标对象添加一个方法的情况 ! 动态代理 : 无需重新重写该方法即可代理 静态代理 : 手写添加此方法进行中转处理\n\n优点 :\n\n * 客户端和目标对象 交互是通过代理对象进行交互 , 代理形式能够起到保护目标对象的作用\n * 代理对象能够扩展目标对象的功能 , 满足 开闭原则\n * 分离 客户端和目标对象 , 在一定程度上降低系统耦合度\n\n缺点 :\n\n * 增加系统的复杂度\n\n使用场景 :\n\n * 运程代理 (rpc通信 , 远程调用方法)\n * 防火墙代理 (vpn代理转发)\n * 保护代理 (不同用户提供不同权限)\n\n\n# 适配器模式\n\n适配器模式 是将一个类的接口转换成我们希望的另外一个接口 , 使其兼容运作\n\n适配器模式结构 :\n\n * 目标 (target) : 当前系统规范的业务接口\n * 适配者 (adaptee) : 访问与现有的适配器组件库中组件接口\n * 适配器 (adapter) : 转换器 , 通过 继承/引用适配者 的对象 , 把适配者接口转换成目标接口\n\n# 类适配器模式\n\n定义一个适配器类来实现当前系统的业务接口 , 同时又继承现有组件库中已经存在的组件\n\n仓库示例 : 03structuralpattern.adapter\n\n读卡器案例\n\n现有台电脑只能读取sd卡 , 而要读取tf卡的话就需要借助适配器模式 . 创建一个读卡器 , 将tf卡中的内容读取出来\n\n类                       角色\nsdcardimpl (sc卡类)       目标\ntfcardimpl (tf卡)        适配者\nsdadaptertf (sc适配tf类)   适配器\ncomputer (计算机类)         应用接口\n\n\n\n核心代码 (继承已有的组件库)\n\n// 适配器类 (sd兼容tf)\n// 实现当前业务接口 sdcard ; 继承了已有组件库 tfcardimpl\npublic class sdadaptertf extends tfcardimpl implements sdcard{\n\n    @override\n    public string readsd() {\n        system.out.println("适配器 读tf卡");\n        return readtf();\n    }\n\n    @override\n    public void writesd(string msg) {\n        system.out.println("适配器 写tf卡");\n        writetf(msg);\n    }\n\n}\n\n\n# 对象适配器模式\n\n对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中 , 该类同时实现 当前系统的业务接口\n\n仓库示例 : 03structuralpattern.adapter\n\n复用以上案例 (结构和上面的大体相同)\n\n\n\n核心代码 (引入适配器类)\n\n// 适配器类 (sd兼容tf)\npublic class sdadaptertf implements sdcard {\n\n    // 适配者类\n    private tfcard tfcard;\n\n    public sdadaptertf(tfcard tfcard) {\n        this.tfcard = tfcard;\n    }\n\n    @override\n    public string readsd() {\n        system.out.println("适配器 读tf卡");\n        return tfcard.readtf();\n    }\n\n    @override\n    public void writesd(string msg) {\n        system.out.println("适配器 写tf卡");\n        tfcard.writetf(msg);\n    }\n\n}\n\n\n> ps : 接口的适配器 , 如果希望重写所有的方法 , 需要创建抽象类(adapter) , 来重写这些方法 , 如果需要用的时候再进行具体化他们 . 这一过程需要将实现改为继承形式进行应用\n\n# 适配器模式总结\n\n应用场景 :\n\n * 兼容 新老系统业务接口 的对接问题\n * 使用第三方提供的组件 , 组件接口和我们要求的接口不一致 , 可通过适配器调整接口\n\n优点 :\n\n * 客户端通过适配器可直接调用目标接口\n * 将目标类和适配者类解耦 , 解决了目标类和适配者类接口不一致的问题\n * 符合 开闭原则\n\n缺点 :\n\n * 频繁使用会 增加复杂度&降低可读性\n\n\n# 装饰者模式\n\n指在不改变现有对象结构的情况下 , 动态给对象增加一些职责(即增加其额外功能)的模式 , 它属于对象结构型模式\n\n装饰者模式结构 :\n\n * 抽象构件角色(component) : 定义一个抽象接口以规范准备接收附加责任的对象\n * 具体构件角色(concrete component) : 实现抽象构件 , 通过装饰角色为其添加一些职责\n * 抽象装饰角色(decorator) : 继承/实现 抽象构件 , 其中包含有 具体构建的实例 , 可通过其子类扩展\n * 具体装饰(concretedecorator) : 实现抽象装饰的相关方法 , 并给具体构件对象添加附加的责任\n\n仓库示例 : 03structuralpattern.decorator\n\n快餐店案例\n\n用装饰者模式编写该案例 . 一家快餐店 有炒面(friedrice)&炒饭(friednoodles)等其他快餐 , 这些餐中可以增添 鸡蛋(egg)/培根(bacon) 等配菜 , 这些配菜的添加也是要额外加钱\n\n类                                  角色\nfastfood(快餐类)                      抽象构件角色\nfriednoodles/friedrice (炒面/炒饭 类)   具体构件角色\negg/bacon (鸡蛋/培根 类)                具体装饰者\ngarnish(装饰者类)                      抽象装饰角色\n\n\n\n优点 :\n\n * 比继承更加灵活的扩展功能 , 可组合装饰者获取来的结果 . 完美遵循了 开闭原则\n * 修饰类和被修饰类可独立拓展 , 无耦合 . 是继承的替代模式\n\n缺点 :\n\n * 子类容易增多 , 系统的复杂度也随着提高\n\n应用场景 :\n\n * 不能采用继承对系统扩展 / 继承不理系统扩展和维护时 , 可以采用装饰模式 不能继承的情况 :\n   * 系统存在大量的独立扩展 , 每种组合将会产生大量子类 , 子类容易以爆炸性增长\n   * 定义的类不能被继承 (如: final类)\n * 不影响其他对象的情况下 , 以 动态/透明 的方式给单个对象添加职责\n * 当对象的功能要求可动态添加 , 也可 动态撤销时 (直接将其子类移出即可)\n\n\n# 桥接模式\n\n将抽象与实现分离 , 使它们可以独立变化 . 它是用组合关系代替继承关系来实现 , 从而降低了抽象和实现这两个可变维度的耦合度\n\n> 一家公司发行了一款 新品的电饭锅 , 那么该新产品 在代码设计层面上理解 , 只需实现 设定好的规则(实现接口) , 聚合应用即可 (组合应用)\n\n桥接模式结构 :\n\n * 抽象化角色(abstraction) : 抽象类 , 包含一个对象 实现化角色对象 的引用 , 对象操作的行为\n * 扩展抽象化角色(refined abstraction) : 抽象化角色的子类 , 实现操作方法 , 并操作 实现化角色对象\n * 实现化角色(implementor) : 定义实现接口 , 提供方法 扩展抽象化角色 引用\n * 具体实现化角色(concrete implementor) : 具体实现 实现化角色 的方法\n\n优点 :\n\n * 抽象与实现分离 , 扩展能力强 , 符合 开闭原则\n * 实现细节对客户透明\n\n缺点 :\n\n * 聚合关系建立在抽象层 , 添加多个独立维度 , 会增加系统的理解与设计难度\n\n应用场景 :\n\n * 一个类存在两个以上的独立变化维度 (可在抽象层建立不同维度的关联关系)\n * 当一个系统不希望 多层继承/类数急增 的情况\n\n仓库示例 : 03structuralpattern.bridging\n\n视频播放器\n\n设计个 跨平台视频播放器 , 不同操作系统(operatingsystem) , 解析视频文件格式(videofile)不一样 , 在加上视频文件格式也是多样化的 , 因此我们根据这两个维度进行分析并且实现(操作系统&文件格式) , 采用桥接模式\n\n类                         角色\nvideofile(视频文件类)          实现化角色\navifile/rmvbfile(视频文件类)   具体实现化角色\noperatingsystem(操作系统类)    抽象化角色\nwindows/mac(操作系统类)        扩展抽象化角色\n\n\n\n\n# 外观模式\n\n外观模式 是一种通过为多个复杂的子系统提供一个一致的接口 , 外部直接通过接口访问子系统 , 黑盒子模式(无需关心内部细节) , 降低程序应用可行度\n\n> 请一位管家进行对别墅 , 别墅管理事项有 : 修理花草 , 浇水临花 , 卫生清洁等事项 . 房主只需跟管家说下即可 !\n\n外观模式结构 :\n\n * 外观角色(facade) : 为多个子系统对外提供一个共同的接口\n * 子系统角色(sub system) : 实现系统的部分功能 , 客户可以通过外观角色访问它\n\n优点 :\n\n * 降低 子系统与客户端 之间的耦合度\n * 对客户屏蔽了子系统组件 , 减少了客户处 理的对象数目 , 并使得子系统使用起来更加容易\n\n缺点 :\n\n * 不符合 开闭原则\n\n应用场景 :\n\n * 分层结构的应用 , 可简化子系统依赖关系\n * 系统有多个子系统且和客户端有联系时 , 引入外观模式将他们分离 , 使得子系统独立可移植\n\n仓库示例 : 03structuralpattern.exterior\n\n智能家居案例\n\n随着时代的发展 , 智能家电的普及 , 操作起来也是十分的方便 . 这一过程我们只需和接收信息的终端设备 (智能音响) , 进行统一控制 , 可便一键完成操作\n\n类                                     角色\nintelligentcontrollittlelove(小爱同学类)   外观角色\naircondition/light/tv (家用设备类)         子系统角色\n\n\n\n\n# 组合模式\n\n把一组相似的对象看做一个单一的对象处理 . 该模式依据树型结构来组合对象 , 用来表示部分整个层次 .\n\n> 在电脑的操作系统中 , 一般有文件系统的管理 , 文件夹和文件我们可以看做单一对象处理 , 虽然文件夹中还会包含 文件/文件夹 , 但我们可以看做一个对象组的树型结构\n\n组合模式结构 :\n\n * 抽象根节点(component) : 定义系统各层级对象的共有 对象&方法 , 预先定义默认 行为&属性\n * 树枝节点(composite) : 定义树枝节点行为 , 包含有 树枝和叶子 节点 , 从而形成树型结构\n * 叶子节点(leaf) : 叶子节点对象 , 无其他节点分支 , 是系统层次遍历的最小单位\n\n优点 :\n\n * 清晰地定义复杂对象的层次结构 , 使用更为便捷\n * 层次的节点添加 , 无需对类库进行修改 , 满足 开闭原则\n\n缺点 :\n\n * 设计复杂 , 层级编辑比较复杂\n\n应用场景 :\n\n * 引用 树型结构 的情况 (如: 文件目录展示 , 多级目录呈现等...\n\n仓库示例 : 03structuralpattern.combination\n\n系统菜单案例\n\n在系统菜单中 , 我们一般会看到一层一层的菜单结构 , 以树型结构进行呈现出来的信息 , 如图 :\n\n\n\n类                      角色\nmenucomponent(菜单组件类)   抽象根节点\nmenu(菜单类)              树枝节点\nmenuitem(菜单项类)         叶子节点\n\n\n\n\n# 享元模式\n\n运用共享技术以最大利用率进行对象复用 . 主要通过共享以存在的对象进行缩短对象创建的数量 , 避免大量相似对象的开销 , 从而提高资源利用率\n\n> 围棋&五子棋和井字棋中的黑白棋子 , 图像中的坐标点或颜色等信息... , 能把它们相同点提取出来共享 , 能节省大量利用资源\n\n享元模式结构 :\n\n * 抽象享元角色(flyweight) : 所有享元类的父类/实现接口 , 规范化享元类\n * 具体享元角色(concrete flyweight) : 抽象享元角色规定的接口 (这里可以看做结合单例模式进行设计 , 每个独享提供唯一的享元对象 , 但他们的地址相同\n * 非享元角色(unsharable flyweight) : 是不可共享的外部状态 , 它以参数形式注入具体享元的相关方法中\n * 享元工厂角色(flyweight factory) : 负责 创建&管理 享元角色 . 当客户请求享元对象时 , 享元工厂会检测是否存在满足条件的享元对象 , 存在则提供 , 否则创建新的享元对象 (类似单例模式)\n\n享元模式的状态 :\n\n * 内部状态 : 不会随着环境的改变而改变的可共享部分\n * 外部状态 : 会随着改变而改变 , 是不可以共享的部分\n\n> 连接池中的连接对象 , 保存在连接对象中的 用户名&密码&连接url等信息 , 创建时就已经设好了 , 不会随环境的改变而改变 , 这些为内部状态 ; 而当每个连接要被回收利用时 , 我们需要将它标记为可用状态 , 这些为外部状态\n\n优点 :\n\n * 缓存共享对象 , 降低内存消耗\n\n缺点 :\n\n * 对象可共享 , 但不同共享的状态外部化 , 使得程序复杂性提高\n\n仓库示例 : 03structuralpattern.flyweight\n\n俄罗斯方块案例\n\n俄罗斯方块游戏中 , 不同类型的方块都是一个实例对象 , 按照往常操作是需要创建很多实例对象 , 因此需要应用享元模式进行实现 ! (包含有 i&j&l&o&z&t&s 形状)\n\n类                       角色\nabstractbox(抽象方块类)      抽象享元角色\nibox/lbox/obox(类型方块类)   具体享元角色\nboxfactory(方块工厂类)       享元工厂角色\n\n\n\n\n# 行为型模式\n\n\n# 模块模式\n\n模块模式 定义一个操作的骨架 , 将部分步骤让其子类执行且不影响骨架的特定步骤\n\n> 去银行办理业务 需要走的流程 : 取号>排队>办理具体业务>服务评价 等流程 , 这些过程当中每个人去银行都是需要走的流程 , 但 办理的业务因人而异\n\n模板结构 :\n\n * 抽象类(abstract class) : 方法构件 , 若干个抽象形式的 基本方法&基本方法\n   * 模板方法 : 定义骨架 , 按自定顺序调用其基本方法\n   * 基本方法 : 实现各步骤的方法 , 模板方法的组成部分\n     * 抽象方法(abstract method) : 抽象类声明实现其方法 , 并且由子类进行实现 (套娃)\n     * 具体方法(concrete method) : 实现抽象的具体方法\n     * 钩子方法(hook method) : 判断逻辑方法 , 返回布尔类型\n * 具体实现子类(concrete class) : 实现抽象类中的抽象方法和钩子方法 , 顶端组成步骤\n\n优点 :\n\n * 封装不变部分 , 扩展可变部分（不变的 封装在父类中实现 , 可变的 通过子类实现\n * 可变的 部分封装成方法是由子类实现的 , 因此可通过子类扩展功能 , 符合开闭原则\n\n缺点 :\n\n * 每次实现不同功能的子类 , 都会导致类的个数的增加（更为抽象 , 复杂度也就上来了\n * 继承关系的缺陷 , 如果父类新添加抽象方法 , 继承的子类都要重写新添加的方法\n\n应用场景 :\n\n * 算法整体步骤固定 , 个别易变时 , 可通过模板方法进行抽象出来进行实现\n * 父类抽象方法由子类实现 , 子类执行结果会影响父类的结果 , 导致反向控制结构 , 提高复杂度\n\n仓库示例：04behaviorpattern.templet\n\n炒菜案例\n\n炒菜步骤一般分别 : 倒油 -> 热油 -> 倒蔬菜 -> 倒调味 -> 翻炒 , 这些步骤已模板形式进行模拟 .\n\n类                            说明\nabstractclass                抽象角色\nconcreteclass_caixin(炒菜心类)   具体实现类\nconcreteclass_daocai(炒包菜类)   具体实现类\n\n\n# 策略模式\n\n该模式定义一套算法 , 将它们进行封装起来 , 算法之间可相互替换 , 这些算法不会影响到客户预期的结果\n\n> 旅游出行计划 , 如果在网上找游玩攻略 , 会提供出很多推荐游玩等... (提供接口确定行为执行方式)\n\n模式结构 :\n\n * 抽象策略(strategy) : 通常由 接口/抽象类 实现 . 给角色提出所有具体决策所需的接口\n * 具体策略(concrete strategy) : 实现抽象决策类定义的接口 , 提供具体实现的 算法/行为\n * 环境(context) : 策略类的引用 , 最终客户调用的\n\n优点 :\n\n * 策略 算法/行为 可以自由选择\n * 容易拓展 (利用了 抽象类/接口 多态特性)\n * 避免多重选择语句(if else) 进行判定策略\n\n缺点 :\n\n * 策略类容易多 . 可通过享元模式进行压缩数量\n * 策略类是透明的\n\n应用场景 :\n\n * 系统在多个 算法/行为 中选择一种时 , 进行通过角色策略类进行封装\n * 一个类定义多种行为 , 而且出现了多个选择语句 , 可通过策略类进行替换选择语句\n * 策略 算法/行为 完全独立 , 对客户 策略类实现细节隐藏\n\n仓库示例 : 04behaviorpattern.tactics\n\n销售案例\n\n销售策略有三种 , 为别为不同假日类型销售 旺季/淡季/平常 价格\n\n类                            角色\nstrategy(抽象类/接口)             抽象策略\nstrategy a/b/c (实现 抽象类/接口)   具体策略\nsalesman(销售员)                环境角色\n\n\n# 命令模式\n\n命令模式 是将 请求封装为一个对象 , 使请求的 职责和执行 分割出来 , 两者通过命令进行沟通 , 命令对象可进行 存储/传递/调用/增加/管理\n\n> 餐厅中 一般都会有服务员 , 当客人进入餐厅 , 服务员会招待\n\n模式结构 :\n\n * 抽象命令(command) : 定义命令的接口 , 声明执行的方法\n * 具体命令(concrete command) : 实现命令接口 , 通常有 接收者 , 通过接收者的功能完成命令操作\n * 接收者/实现者(receiver) : 真正执行命令的对象 . (任何类都可成为 , 只要完成需求)\n * 调用者/请求者(invoker) : 命令对象执行请求 , 通常有 命令对象(多态形式) , 命令对象可以是集合形式 . 并且包含有命令发送执行的入口(执行方法)\n\n优点 :\n\n * 降低系统耦合度(操作和实现解耦)\n * 命令 增删 较快 , 不会影响其他类 , 满足开闭原则\n * 可实现宏命令 . 命令模式和组合模式结合实现\n * 方便实现 撤销/恢复 功能\n\n缺点 :\n\n * 命令模式可能会导致较多的具体命令类\n * 提高系统复杂度\n\n应用场景 :\n\n * 系统需要将请求 接收者/调用者 解耦 , 使得不能直接交互\n * 系统需要在不同时间指定请求 , 将他们进行排队执行请求\n * 系统需要支持命令 撤销(undo)和恢复(redo) 操作\n\n仓库示例 : 04behaviorpattern.command\n\n点菜订单案例 客户点菜后 将点菜记录至订单中 , 订单会由服务员发给厨师(发请求给实现者)...\n\n类                 角色\ncommand           抽象命令\nordercommand      具体命令\nseniorchef(厨师类)   接收者/实现者\nwaitor(服务员类)      调用者/请求者\norder(订单类)        实体对象\n\n\n# 职责链模式\n\n职责链模式 是将 请求发送者 和 请求处理者 进行解耦 , 通信是通过记住链的下一个对象的引用而形成的一条链 . 当请求发生时 , 请求会沿着这条链进行传递 , 直到 满足对象条件/到达链的终点 为止 (可能 到达终点也可能没有得到处理)\n\n> 在学校请求中 , 如果请假超过3天 , 就不是班主任能决定的事了 , 因此需要班主任的上级可许才能请假 .\n\n模式结构 :\n\n * 抽象处理者(handler) : 处理请求抽象类 , 包含 请求处理方法 和 后继连接方法\n * 具体处理者(concrete handler) : 请求处理方法的具体实现 , 判断满足条件 , 如果满足则处理 , 否则 请求转让后继连接\n * 客户类(client) : 创建请求处理链 , 并向链头的具体处理者对象提交请求 , 不用关心 处理细节/传递过程\n\n优点 :\n\n * 降低了 请求发送者 和 请求处理者 耦合度\n * 增强了系统的可扩展性 (按需求添加请去处理类)\n * 增强了 流程链 的灵活度 (链的顺序只需指定下一个即可)\n * 责任分担 , 每个具体处理者 都有自己的处理工作 , 不能处理的传递给下一个 , 明确职责范围 , 符合单一原则\n\n缺点 :\n\n * 不能保证请求一定被接收处理 , 有可能 到达终点也可能没有得到处理\n * 较长的职责链会影响系统处理 , 也会影响 代码调试\n\n仓库示例 : 04behaviorpattern.chainofresponsibility\n\n请假案例\n\n公司请求条件 : 请假一天以下的假只需要小组长同意即可 ; 请假1天到3天的假还需 要部门经理同意 ; 请求3天到7天还需要总经理同意才行\n\n类                                                     角色\nhandler                                               抽象处理者\ngroupleader(组长) / manager(经理) / generalmanager(总经理)   具体处理者\nmain                                                  客户类\nleaverequest(请假条)                                     实体对象\n\n\n# 状态模式\n\n状态模式 中 包含有很多不同的状态 , 不同的状态有不同的行为 , 这些状态会随着状态对象进行改变而改变的context对象\n\n模式结构 :\n\n * 环境(context) : 也称上下文 , 定义了各状态程序的对象 , 也维护了状态对象且包含有当前状态的处理\n * 抽象状态(state) : 定义 接口/抽象类 , 里面包含有 状态的所有行为 , 环境对象以及状态的变化方法\n * 具体状态(concrete state) : 实现抽象状态所对应的行为\n\n优点 :\n\n * 封装转化状态安全\n * 所有状态会封装到一个类中 , 可方便添加新状态 , 且只改变对象状态即可改变行为\n * 状态转换逻辑与状态对象合为一体 , 并非较大的条件语句\n\n缺点 :\n\n * 类数量容易多\n * 模式的结构和实现较为复杂\n * 对 开闭原则 的支持不友好\n\n应用场景 :\n\n * 对象行为取决于状态时 , 并且是在运行时根据状态改变的行为的情况\n * 庞大分支结构\n\n仓库示例 : 04behaviorpattern.state\n\n电梯案例\n\n电梯在一般情况下包含有 开门/关门/运行/停止 状态 , 并且每个状态都有自己独有的执行行为\n\n类                                                           角色\ncontext                                                     环境\nliftstate                                                   抽象状态\nclosingstate(关闭) / openningstate(打开) / runningstate(运行) /   具体状态\nstoppingstate(停止)\n\n\n# 观察者模式\n\n观察者模式 定义了一种一对多关系的依赖关系 , 让多个观察者对象同时监听某一个主题对象 , 主题一旦发生变化会通知所有观察者对象\n\n> 这一模式类似于 微信公众号 , 它有 关注-推送 功能 , 只要关注某一公众号后 , 今后推送的内容都会 收到响应推送消息\n\n模式结构 :\n\n * 抽象主题(subject) : 主题将所有观察者对象以集合形式保存 , 接口提供了 增/删 观察者 和 推送 功能\n * 具体主题(concretesubject) : 实现抽象主题功能 , 对集合中的观察者对象 增/删 的功能 , 和推送关注集合内的观察者对象\n * 抽象观察者(observer) : 定义了更新接口 , 会随着主题通知时更新自己\n * 具体观察者(concreteobserver) : 实现更新功能 , 以便更新自己状态\n\n优点 :\n\n * 降低 主题 - 观察者 耦合关系 , 两者之间有耦合关系\n * 实现广播机制 , 一对多推送通知\n\n缺点 :\n\n * 观察者较多 , 那么发送较为耗时\n\n应用场景 :\n\n * 对象之间存在一对多关系 , 那么一个对象会影响其他对象的改变的情况下\n\n仓库示例 : 04behaviorpattern.observer\n\n微信公众号案例\n\n当你关注某一公众号后 , 该公众号推送消息给关注公众号的微信用户端 . (dddd\n\n类                          角色\nsubject                    抽象主题\nsubscriptionsubject(公众号)   具体主题\nobserver                   抽象观察者\nweixinuser(微信用户)           具体观察者\n\n\n# 中介者模式\n\n定义了一个 中介者角色 进行封装与其他对象之间的交互 , 使原有对象耦合松散 , 且可以独立改变他们之间交互\n\n> 一个公司中 , 同事与同事之间的信息交互 , 可通过 钉钉 直接联系到对方 , 那么这个 钉钉 就可看做为中介对象\n\n模式结构 :\n\n * 抽象中介者(mediator) : 提供同事对象通信的抽象方法\n * 具体中介者(concretemediator) : 实现通信方法 , 定义同事集合 , 且可添加通信(同事角色的依赖\n * 抽象同事类(colleague) : 定义有 中介对象 , 同事名称 , 以及 通信所用的方法\n * 具体同事类(concrete colleague) : 实现接口对象 , 通信需要通过中介进行交互\n\n优点 :\n\n * 对象之间耦合松散\n * 集中控制交互 , 交互只需通过中介即可\n * 符合 迪米特原则\n\n缺点 :\n\n * 中介者类容易庞大 , 难以维护\n\n应用场景 :\n\n * 系统存在多个对象之间的通信 , 且结构难以维护的情况\n\n仓库示例 : 04behaviorpattern.mediator\n\n中介租房案例\n\n出租房 一般情况是通过中介进行介绍来 , 和客户进行沟通购买的 , 因此中介的作用 能联系到房主\n\n类                              角色\nmediator                       抽象中介者\nmediatorstructure(通信中介)        具体中介者\nperson                         抽象同事类\ntenant(租房者) / houseowner(房主)   具体同事类\n\n\n# 迭代器模式\n\n提供一个对象 , 按顺序访问集合的对象 , 无需知道底层执行方式来实现\n\n模式结构 :\n\n * 抽象聚合(aggregate) : 定义 增加/删除 聚合元素以及创建迭代器接口\n * 具体聚合(concreteaggregate) : 实现 对象的存储 , 以及 抽象聚合方法 的实例\n * 抽象迭代器(iterator) : 定义 可访问和遍历元素的接口\n * 具体迭代器(concretelterator) : 实现 对象的存储 , 以及 抽象迭代器方法 的实例\n\n优点 :\n\n * 可通过自定义迭代器改变迭代算法\n * 扩展性高 , 可在原有代码进行增强 , 满足 开闭原则\n\n缺点 :\n\n * 增加类的个数 , 也会增加系统的复杂度性\n\n应用场景 :\n\n * 需要多种遍历方式时\n * 需要不同聚合结构提供统一的接口时\n * 访问聚合对象的内容无需暴露细节时\n\n仓库示例 : 04behaviorpattern.iterator\n\n模拟对学生对象迭代器存储实现功能\n\n类                        角色\nstudentaggregate(学生聚合)   抽象聚合\nstudentaggregateimpl     具体聚合\nstudentiterator(学生迭代器)   抽象迭代器\nstudentiteratorimpl      具体迭代器\nstudent(学生)              实体对象\n\n\n# 访问者模式\n\n作用于某些数据结构对各个元素操作 , 且可不改变结构的前提作用这些元素对象的操作\n\n模式结构 :\n\n * 抽象访问者(visitor) : 定义 固定访问的行为 , 在创建的时候就确定好需要访问的具体元素对象\n * 具体访问者(concretevisitor) : 实现具体访问的行为\n * 抽象元素(element) : 定义 接受访问方法 , 指定每个元素都有访问的方法\n * 具体元素(concreteelement) : 提供 接受方法的具体实现 , 接受后可使用访问者的方法\n * 对象结构(object structure) : 定义 具体元素的集合 和 添加具体元素的方法 , 分别将他们理解为容器进行提供访问者进行访问\n\n优点 :\n\n * 扩展性好 , 不修改结构进行添加新功能\n * 复用性好\n * 满足 单一原则 , 行为和访问分离\n\n缺点 :\n\n * 具体元素的细节是公开的 , 违背 迪米特原则\n * 对象结构变化困难 , 添加新元素 , 所有的具体元素都需要添加具体操作 , 违背 开闭原则\n\n应用场景 :\n\n * 对象结构相对稳定的情况\n * 对象结构中的对象需要多种不同不相关的操作的情况\n\n仓库示例 : 04behaviorpattern.visitor\n\n宠物店喂宠物案例\n\n宠物店多种宠物(具体元素) , 在开店的时候会有不同的客人(访问者)进来 参观访问这些宠物\n\n类                 角色\nperson(人)         抽象访问者\nowner / someone   具体访问者\nanimal(宠物)        抽象元素\ncat / dog         具体元素\nhome              对象结构\n\n\n# 备忘录模式\n\n该模式提供了一套 状态恢复机制 , 使得方便返回到特定的历史步骤 , 如果出现问题 , 可返回之前的状态进行操作\n\n模式结构 :\n\n * 发起人(originator) : 提供 记录当前状态/备份 等其他拓展实现\n * 备忘录(memento) : 负责 存储发起人状态 , 在需要的时候进行恢复状态\n * 管理者(caretaker) : 对备忘录进行管理 , 提供 保存/获取 备忘录功能 , 不能对其内容进行 访问/修改\n\n宽窄接口\n\n * 窄接口 : 只能获取备忘录对象 , 不能对备忘录里面的数据进行 访问/修改 . 除了 发起人 , 其他访问的都是 窄接口\n\n * 宽接口 : 与窄接口相反 , 所有人均可访问都是 窄接口\n\n优点 :\n\n * 提供恢复状态机制 , 可恢复某个历史的状态\n * 实现内部状态的封装 , 黑盒备忘录\n * 简化发起人 , 并由管理者进行管理 , 符合 单一原则\n\n缺点 :\n\n * 资源消耗大\n\n应用场景 :\n\n * 需要 保存/恢复 的场景\n * 需要 提供可回滚的场景\n\n仓库示例 : 04behaviorpattern.memento\n\n游戏战斗案例\n\n模拟游戏战斗存档场景 , 游戏存档状态作为数据 , 在战斗前和战斗后 状态都是不一样的 , 因此我们可以根据这些状态进行恢复存档之类的\n\n白盒备忘录\n\n备忘录角色 对所有需要对象 提供 宽接口\n\n类                             角色\ngamerole(游戏角色)                发起人\nrolestatememento(角色状态 备忘)     备忘录\nrolestatecaretaker(角色状态 管理)   管理者\n\n黑盒备忘录\n\n备忘录角色 对发起人对象 提供 宽接口 , 而其他对象提供窄接口\n\n将 rolestatememento管理员 设为私有内部类 , 将其 实现一个 空memento接口 作为标识应用 , 这样就不会暴露内部操作\n\n类                    角色\ngamerole             发起人\nmemento(窄接口)         管理者\nrolestatecaretaker   备忘录\n\n\n# 解释器模式\n\n该模式 实现了一个表达式接口 , 接口解释一个特定的上下文 . 例如 : 日常使用的计算器/sql语句的解析/...\n\n按照特定的规则去抽象化定义\n\n模式结构 :\n\n * 抽象表达式(abstract expression) : 定义解释器接口 , 约定解释器的解释操作 , 主要 interpret()方法\n * 终结表达式(terminal expression) : 实现抽象表达式 , 解释 interpret()方法 解决运算符相关的操作 , 有结果\n * 非终结表达式(nonterminal expression) : 实现抽象表达式 , 解释 interpret()方法 解决运算符相关的操作 , 无结果\n * 环境(context) : 定义 存储/添加/获取 数据的功能 , 这些数据是等待进行解释的 , 一般情况是公开的\n\n优点 :\n\n * 灵活 , 扩展高\n * 添加新的表达式规则简单\n\n缺点 :\n\n * 应用场景少\n * 结构难以维护\n * 执行效率低(大量递归)\n\n应用场景 :\n\n * 规则简单 , 执行效率不是问题的情况\n * 问题重复出现且用的是简单语言进行表示时\n * 语言句子中以树的形式表示的时候\n\n仓库示例 : 04behaviorpattern.interpreter\n\n类                            角色\nabstractexpression           抽象表达式\nvariable(变量运算符)              终结表达式\nminus(减法运算符) / plus(加法运算符)   非终结表达式\ncontext                      环境\n\n\n# 自定义spring\n\n\n# ioc 控制反转\n\n仓库代码 : 链接\n\n**涉及设计模式 : **\n\n * 工厂模式 : beanfactory工厂\n * 单例模式 : 每个bean对象都是单例\n * 模板模式 : abstractapplicationcontext类的refresh() 方法 顺序固有了\n * 迭代器模式 : mutablepropertyvalues类管理propertyvaluelist集合 , 使用了迭代器模式',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Dubbo",frontmatter:{title:"Dubbo",author:"柏竹",permalink:"/backend/afbo81",date:"2020-02-18T00:00:00.000Z",categories:["后端","框架"],tags:["分布式"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/04.%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF/05.Apache%20Dubbo.html",relativePath:"01.后端/04.框架技术/05.Apache Dubbo.md",key:"v-21b1d4ee",path:"/backend/afbo81/",headers:[{level:2,title:"环境搭建",slug:"环境搭建",normalizedTitle:"环境搭建",charIndex:185},{level:3,title:"Window 搭建环境",slug:"window-搭建环境",normalizedTitle:"window 搭建环境",charIndex:194},{level:3,title:"Tomcat 控制台页",slug:"tomcat-控制台页",normalizedTitle:"tomcat 控制台页",charIndex:587},{level:3,title:"QA",slug:"qa",normalizedTitle:"qa",charIndex:824},{level:2,title:"首次应用",slug:"首次应用",normalizedTitle:"首次应用",charIndex:1059},{level:3,title:"在bin目录下 Zookeeper 启动 (root权限)",slug:"在bin目录下-zookeeper-启动-root权限",normalizedTitle:"在bin目录下 zookeeper 启动 (root权限)",charIndex:7094},{level:3,title:"Dubbo其他配置",slug:"dubbo其他配置",normalizedTitle:"dubbo其他配置",charIndex:11251},{level:4,title:"包扫描",slug:"包扫描",normalizedTitle:"包扫描",charIndex:11264},{level:4,title:"类扫描",slug:"类扫描",normalizedTitle:"类扫描",charIndex:11661},{level:4,title:"协议",slug:"协议",normalizedTitle:"协议",charIndex:5361},{level:4,title:"负载均衡",slug:"负载均衡",normalizedTitle:"负载均衡",charIndex:161}],headersStr:"环境搭建 Window 搭建环境 Tomcat 控制台页 QA 首次应用 在bin目录下 Zookeeper 启动 (root权限) Dubbo其他配置 包扫描 类扫描 协议 负载均衡",content:'# Dubbo\n\n * 阿里巴巴旗下\n * 高性能Java RPC框架，和Spring无缝整合\n * RPC(运程过程调用) 。两服务器相互调用，此时他们不在同一内存，需要网络进行传递语义和调用的数据\n * 分别讲解构架单体架构、垂直架构、SOA架构、微服务\n\n核心功能：\n\n * 面向接口的远程方法调用\n * 智能容错和负载均衡\n * 服务自动注册 和 发现\n\n\n# 环境搭建\n\n\n# Window 搭建环境\n\n步骤:\n\n 1. 解压 zookeeper.gz 压缩包\n\n 2. 在 解压后的根路径下 创建文件夹 data 和 log 两个\n\n 3. 更改配置 , 拷贝 ==./conf/zoo_sample.cfg== 至本身路径并更改其名为 zoo.cfg\n\n 4. 编辑 zoo.cfg , 将指定内容 ==dataDir=/tmp/zookeeper== 覆盖为以下内容\n    \n    dataDir=../data\n    dataLogDir=../log\n    \n    \n    > zoo.cfg 包含有很多 和 Dobbo相关配置 自行翻译\n\n 5. 初始化加载 , 打开 ==../bin/zkServer==脚本文件 进行加载\n\n 6. 显示 ==binding to port 0.0.0.0/0.0.0.0:2181== 成功\n\n\n# Tomcat 控制台页\n\n 1. 解压 war包项目\n 2. 将解压文件 放到 Tomcat 中的 webapps文件夹下 注意项目文件 : ==WEB-INF/dubbo.properties== 端口/账号 信息\n 3. 启动tomcat\n\n> 注意 :\n> \n>  * Tomcat端口更改为 8080 以外的端口\n>  * 启动 Tomcat前提 , 先启动 zookeeper\n>  * 确定好 JDK 和 JRE 环境 ( 如果没有配好会加载不到上下文\n\n\n# QA\n\n页面控制台 Dubbo 上下文加载失败问题\n\n 1. 环境配置 JRE , 新建环境变量 JRE_HOME变量名 <-> ==C:\\Program Files\\Java\\jre1.8.0_321==值 (JRE根路径\n 2. 环境引入 Path 引入 JRE_HOME ==%JRE_HOME%\\bin==\n\nController层 进行RPC操作传参问题\n\n * 实体对象必须实例化 ( 特别说明特殊类型也不行!!\n * 传递的参尽可能是基本数据类型\n\n\n# 首次应用\n\n应用示例：\n\n提供者项目\n\n 1. 创建提供者 Maven项目 dubbo-project\n\n 2. 配置 依赖、插件 pom.xml\n\n<packaging>war</packaging>\n\n<properties>\n    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>\n    <maven.compiler.source>1.8</maven.compiler.source>\n    <maven.compiler.target>1.8</maven.compiler.target>\n    <spring.version>5.0.5.RELEASE</spring.version>\n</properties>\n\n<dependencies>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-context</artifactId>\n        <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-beans</artifactId>\n        <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-webmvc</artifactId>\n        <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-jdbc</artifactId>\n        <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-aspects</artifactId>\n        <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-jms</artifactId>\n        <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-context-support</artifactId>\n    <version>${spring.version}</version>\n</dependency>\n\x3c!-- dubbo相关 --\x3e\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>dubbo</artifactId>\n    <version>2.6.0</version>\n</dependency>\n<dependency>\n    <groupId>org.apache.zookeeper</groupId>\n    <artifactId>zookeeper</artifactId>\n    <version>3.4.7</version>\n</dependency>\n\n<dependency>\n    <groupId>com.github.sgroschupf</groupId>\n    <artifactId>zkclient</artifactId>\n    <version>0.1</version>\n</dependency>\n<dependency>\n    <groupId>javassist</groupId>\n    <artifactId>javassist</artifactId>\n    <version>3.12.1.GA</version>\n</dependency>\n<dependency>\n    <groupId>com.alibaba</groupId>\n    <artifactId>fastjson</artifactId>\n    <version>1.2.47</version>\n</dependency>\n\n\n</dependencies>\n\n<build>\n    <plugins>\n        \x3c!--Maven Tomcat插件--\x3e\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-compiler-plugin</artifactId>\n            <version>2.3.2</version>\n            <configuration>\n                <source>1.8</source>\n                <target>1.8</target>\n            </configuration>\n        </plugin>\n        <plugin>\n            <groupId>org.apache.tomcat.maven</groupId>\n            <artifactId>tomcat7-maven-plugin</artifactId>\n            <configuration>\n                \x3c!-- 指定端口 --\x3e\n                <port>8082</port>\n                \x3c!-- 请求路径 --\x3e\n                <path>/</path>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n\n\n 3. 配置 连接远端zookeeper并注册 resources/applicationContext-service.xml\n    \n    <?xml version="1.0" encoding="UTF-8"?>\n    <beans xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n           xmlns:p="http://www.springframework.org/schema/p"\n           xmlns:context="http://www.springframework.org/schema/context"\n           xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"\n           xmlns:mvc="http://www.springframework.org/schema/mvc"\n           xmlns="http://www.springframework.org/schema/beans"\n           xsi:schemaLocation="http://www.springframework.org/schema/beans\n           http://www.springframework.org/schema/beans/spring-beans.xsd\n           http://www.springframework.org/schema/mvc\n           http://www.springframework.org/schema/mvc/spring-mvc.xsd\n           http://code.alibabatech.com/schema/dubbo\n           http://code.alibabatech.com/schema/dubbo/dubbo.xsd\n           http://www.springframework.org/schema/context\n           http://www.springframework.org/schema/context/spring-context.xsd">\n        \n        \x3c!-- 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样 --\x3e\n        <dubbo:application name="dubbo-project"/>\n        \x3c!-- 连接服务注册中心zookeeper ip为zookeeper所在服务器的ip地址--\x3e\n        <dubbo:registry address="zookeeper://192.168.230.132:2181"/>\n        \x3c!-- 注册 协议和port 对外提供的端口 (默认20880)--\x3e\n        <dubbo:protocol name="dubbo" port="20881"/>\n        \x3c!-- 扫描指定包，加入@Service注解的类会被发布为服务 --\x3e\n        <dubbo:annotation package="com.sans.service.impl"/>\n    </beans>\n    \n    \n    > 这步IP/Port不知咋填？ （Linux命令得知信息）\n    > \n    > IP地址：ifconfig\n    > \n    > 端口：jsp 查 PID ，根据 PID netstat -tuunpl 查开放端口\n\n 4. 配置 监听器、配置文件加载 web.xml\n    \n    <?xml version="1.0" encoding="UTF-8"?>\n    <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"\n             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"\n             version="4.0">\n    \n        \x3c!--配置文件参数--\x3e\n        <context-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>classpath:applicationContext*.xml</param-value>\n        </context-param>\n    \n        \x3c!--监听--\x3e\n        <listener>\n            <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n        </listener>\n    \n    </web-app>\n    \n\n 5. 业务实现 Service\n    \n    服务接口 HelloService\n    \n    package com.sans.service;\n    \n    /** 服务接口 */\n    public interface HelloService {\n        public String sayHello(String name);\n    }\n    \n    \n    服务实现类 HelloServiceImpl\n    \n    package com.sans.service.impl;\n    \n    import com.alibaba.dubbo.config.annotation.Service;\n    import com.sans.service.HelloService;\n    \n    // 注意使用的jar包\n    @Service\n    public class HelloServiceImpl implements HelloService {\n        @Override\n        public String sayHello(String name) {\n            return "hello : " + name;\n        }\n    }\n    \n    \n    > 注意：@Service注解 是 Dubbo包提供的\n\n 6. Linux 启动 Zookeeper\n    \n    \n    \n\n\n# 在bin目录下 Zookeeper 启动 (root权限)\n\n./zkServer.sh start\n\n\n> **注意：**连接的前提需要==关闭防火墙==\n\n7. 运行测试\n运行连接 : 在Maven执行 Tomcat插件的`run`命令 \n查看注册信息 : 在Linux执行 查看\n\n```sh\n\n## 在bin目录下 进入查看\n./zkCli.sh\n\n## 查看注册列表\nls /\n\n## 查看详细\nls /[注册的名称]\n\n\n01.png\n\n> @Service注解的类服务存在表示注册成功\n\n消费者项目\n\n 1. 拷贝生产者的项目\n\n 2. 编辑项目名称 dubbo-consumer\n\n 3. 配置 tomcat插件端口 pom.xml （我的是8082端口号）\n\n 4. 配置 连接远端zookeeper并注册 resources/applicationContext-web.xml\n    \n    <?xml version="1.0" encoding="UTF-8"?>\n    <beans xmlns="http://www.springframework.org/schema/beans"\n           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n           xmlns:p="http://www.springframework.org/schema/p"\n           xmlns:context="http://www.springframework.org/schema/context"\n           xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"\n           xmlns:mvc="http://www.springframework.org/schema/mvc"\n           xsi:schemaLocation="http://www.springframework.org/schema/beans\n           http://www.springframework.org/schema/beans/spring-beans.xsd\n           http://www.springframework.org/schema/mvc\n           http://www.springframework.org/schema/mvc/spring-mvc.xsd\n           http://code.alibabatech.com/schema/dubbo\n           http://code.alibabatech.com/schema/dubbo/dubbo.xsd\n           http://www.springframework.org/schema/context\n           http://www.springframework.org/schema/context/spring-context.xsd">\n    \n        \x3c!-- 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样 --\x3e\n        <dubbo:application name="dubbo-consumer"/>\n    \n        \x3c!-- 连接服务注册中心zookeeper ip为zookeeper所在服务器的ip地址--\x3e\n        <dubbo:registry address="zookeeper://192.168.230.134:2181"/>\n    \n        \x3c!-- 扫描指定包，加入@RestController注解的类会被发布为服务 --\x3e\n        <dubbo:annotation package="com.sans.controller"/>\n    \n    </beans>\n    \n\n 5. 配置 访问的映射 web.xml\n    \n    <?xml version="1.0" encoding="UTF-8"?>\n    <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"\n             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n             xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"\n             version="4.0">\n    \n        \x3c!--配置文件参数--\x3e\n        <context-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>classpath:applicationContext*.xml</param-value>\n        </context-param>\n    \n        \x3c!--监听--\x3e\n        <listener>\n            <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n        </listener>\n    \n        \x3c!--入口组件 访问映射--\x3e\n        <servlet>\n            <servlet-name>springmvc</servlet-name>\n            <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n            <init-param>\n                <param-name>contextConfigLocation</param-name>\n                <param-value>classpath:applicationContext-web.xml</param-value>\n            </init-param>\n            <load-on-startup>1</load-on-startup>\n        </servlet>\n        <servlet-mapping>\n            <servlet-name>springmvc</servlet-name>\n            <url-pattern>/</url-pattern>\n        </servlet-mapping>\n    \n    </web-app>\n    \n\n 6. 业务实现 Controller 服务接口 HelloService\n    \n    package com.sans.controller;\n    \n    import com.alibaba.dubbo.config.annotation.Reference;\n    import com.sans.service.HelloService;\n    import org.springframework.web.bind.annotation.RequestMapping;\n    import org.springframework.web.bind.annotation.ResponseBody;\n    import org.springframework.web.bind.annotation.RestController;\n    \n    @RestController\n    @RequestMapping("/demo")\n    public class HelloController {\n        \n        // Controller中注入HelloService使用的是Dubbo提供的@Reference注解 (自动注入是无效的)\n        // 注意导包 并非是 jdk\n        @Reference\n        private HelloService helloService;\n        \n        @RequestMapping("/hello")\n        @ResponseBody\n        public String getName(String name) {\n            // 远程调用\n            String result = helloService.sayHello(name);\n            System.out.println("result : " + result);\n            return result;\n        }\n    }\n    \n    \n    > 注意： @Reference注解 是 Dubbo包提供的\n\n 7. 测试 访问 http://localhost:8082/demo/hello?name=test （观察页面返回的数据是否对应）\n    \n    > 测试前提：提供者启动且已经连接服务注册中心zookeeper\n\n\n# Dubbo其他配置\n\n# 包扫描\n\n扫描指定包下的所有类，服务提供者与服务消费者 都需要配置 在 resources 配置资源下的 .xml（以上应用的是扫描包)\n\n提供者 发布服务\n\n\x3c!-- 扫描指定包，加入@Service注解的类 会被发布为服务 --\x3e\n<dubbo:annotation package="com.sans.service.impl"/>\n\n\n消费者 应用服务\n\n\x3c!-- 扫描指定包，加入@RestController注解的类 会被发布为服务 --\x3e\n<dubbo:annotation package="com.sans.controller"/>\n\n\n> 服务类应用：（在以上注解类内自动注入应用）\n> \n> //Dubbo提供的@Reference注解 (用法和自动注入一样) \n> @Reference\n> private HelloService helloService;\n\n# 类扫描\n\n扫描指定包下的指定类，通过以下方式进行发布服务： 在 resources 配置资源下的 .xml\n\n提供者 发布服务\n\n\x3c!-- 扫描指定包的指定类。以下配置相当于 @Service注解 的配置-- >\n\x3c!-- 创建bean--\x3e\n<bean id="helloService" class="com.sans.service.impl.HelloServiceImpl" />\n\x3c!-- dubbo注册服务 (接口)--\x3e\n<dubbo:service interface="com.sans.service.HelloService" ref="helloService"/>\n\n\n> PS：dubbo:service 配置相当于 @Service注解 ，因此必须注释掉 @Service注解\n\n消费者 应用服务\n\n\x3c!-- 生成远程服务代理对象--\x3e\n<dubbo:reference id="helloService" interface="com.sans.service.HelloService"/>\n\x3c!-- 包扫描--\x3e\n<context:component-scan base-package="com.sans.controller"/>\n\n\n> PS：注入类应用时是用 @Autowired注解，并非是 @Reference注解\n\n# 协议\n\n一般配置在提供者一方进行配置 Dubbo支持协议有：dubbo、rmi、http等协议\n\n建议应用Dubbo协议自带的\n\n> Dubbo协议 用于传输小数据量并发的服务调用\n\n同一个项目可配置多个协议，不同服务应用不同协议\n\n\x3c!-- 多协议配置 --\x3e\n<dubbo:protocol name="dubbo" port="20880" />\n<dubbo:protocol name="rmi" port="1099" />\n\x3c!-- 使用dubbo协议暴露服务 --\x3e\n<dubbo:service interface="com.sans.service.HelloService" ref="helloService"\nprotocol="dubbo" />\n\x3c!-- 使用rmi协议暴露服务 --\x3e\n<dubbo:service interface="com.sans.service.DemoService" ref="demoService"\nprotocol="rmi" />\n\n\n> 服务类协议应用：（默认采用Dubbo协议）\n> \n> 如果该服务类使用Dubbo以外的协议需要指定协议\n> \n> @Service(protocol = "rmi")\n> public class HelloServiceImpl implements HelloService {····}\n\n# 负载均衡\n\n将服务集群分担完成共同任务，Dubbo提供有常用的均衡策略\n\n负载均衡可在 服务 提供者/消费者 任意一方配置即可实现\n\n提供者\n\n// 生成前 预定策略\n@Service(loadbalance = "random")\npublic class HelloServiceImpl implements HelloService {····}\n\n\n消费者\n\n// 注入时 应用策略\n@Reference(loadbalance = "random")\nprivate HelloService helloService;\n\n\n> PS：一台电脑集群测试是 Dubbo协议的端口 和 Tomcat的端口 不能一样，以防冲突\n\nSpringBoot+Dubbo',normalizedContent:'# dubbo\n\n * 阿里巴巴旗下\n * 高性能java rpc框架，和spring无缝整合\n * rpc(运程过程调用) 。两服务器相互调用，此时他们不在同一内存，需要网络进行传递语义和调用的数据\n * 分别讲解构架单体架构、垂直架构、soa架构、微服务\n\n核心功能：\n\n * 面向接口的远程方法调用\n * 智能容错和负载均衡\n * 服务自动注册 和 发现\n\n\n# 环境搭建\n\n\n# window 搭建环境\n\n步骤:\n\n 1. 解压 zookeeper.gz 压缩包\n\n 2. 在 解压后的根路径下 创建文件夹 data 和 log 两个\n\n 3. 更改配置 , 拷贝 ==./conf/zoo_sample.cfg== 至本身路径并更改其名为 zoo.cfg\n\n 4. 编辑 zoo.cfg , 将指定内容 ==datadir=/tmp/zookeeper== 覆盖为以下内容\n    \n    datadir=../data\n    datalogdir=../log\n    \n    \n    > zoo.cfg 包含有很多 和 dobbo相关配置 自行翻译\n\n 5. 初始化加载 , 打开 ==../bin/zkserver==脚本文件 进行加载\n\n 6. 显示 ==binding to port 0.0.0.0/0.0.0.0:2181== 成功\n\n\n# tomcat 控制台页\n\n 1. 解压 war包项目\n 2. 将解压文件 放到 tomcat 中的 webapps文件夹下 注意项目文件 : ==web-inf/dubbo.properties== 端口/账号 信息\n 3. 启动tomcat\n\n> 注意 :\n> \n>  * tomcat端口更改为 8080 以外的端口\n>  * 启动 tomcat前提 , 先启动 zookeeper\n>  * 确定好 jdk 和 jre 环境 ( 如果没有配好会加载不到上下文\n\n\n# qa\n\n页面控制台 dubbo 上下文加载失败问题\n\n 1. 环境配置 jre , 新建环境变量 jre_home变量名 <-> ==c:\\program files\\java\\jre1.8.0_321==值 (jre根路径\n 2. 环境引入 path 引入 jre_home ==%jre_home%\\bin==\n\ncontroller层 进行rpc操作传参问题\n\n * 实体对象必须实例化 ( 特别说明特殊类型也不行!!\n * 传递的参尽可能是基本数据类型\n\n\n# 首次应用\n\n应用示例：\n\n提供者项目\n\n 1. 创建提供者 maven项目 dubbo-project\n\n 2. 配置 依赖、插件 pom.xml\n\n<packaging>war</packaging>\n\n<properties>\n    <project.build.sourceencoding>utf-8</project.build.sourceencoding>\n    <maven.compiler.source>1.8</maven.compiler.source>\n    <maven.compiler.target>1.8</maven.compiler.target>\n    <spring.version>5.0.5.release</spring.version>\n</properties>\n\n<dependencies>\n    <dependency>\n        <groupid>org.springframework</groupid>\n        <artifactid>spring-context</artifactid>\n        <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n        <groupid>org.springframework</groupid>\n        <artifactid>spring-beans</artifactid>\n        <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n        <groupid>org.springframework</groupid>\n        <artifactid>spring-webmvc</artifactid>\n        <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n        <groupid>org.springframework</groupid>\n        <artifactid>spring-jdbc</artifactid>\n        <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n        <groupid>org.springframework</groupid>\n        <artifactid>spring-aspects</artifactid>\n        <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n        <groupid>org.springframework</groupid>\n        <artifactid>spring-jms</artifactid>\n        <version>${spring.version}</version>\n    </dependency>\n    <dependency>\n        <groupid>org.springframework</groupid>\n        <artifactid>spring-context-support</artifactid>\n    <version>${spring.version}</version>\n</dependency>\n\x3c!-- dubbo相关 --\x3e\n<dependency>\n    <groupid>com.alibaba</groupid>\n    <artifactid>dubbo</artifactid>\n    <version>2.6.0</version>\n</dependency>\n<dependency>\n    <groupid>org.apache.zookeeper</groupid>\n    <artifactid>zookeeper</artifactid>\n    <version>3.4.7</version>\n</dependency>\n\n<dependency>\n    <groupid>com.github.sgroschupf</groupid>\n    <artifactid>zkclient</artifactid>\n    <version>0.1</version>\n</dependency>\n<dependency>\n    <groupid>javassist</groupid>\n    <artifactid>javassist</artifactid>\n    <version>3.12.1.ga</version>\n</dependency>\n<dependency>\n    <groupid>com.alibaba</groupid>\n    <artifactid>fastjson</artifactid>\n    <version>1.2.47</version>\n</dependency>\n\n\n</dependencies>\n\n<build>\n    <plugins>\n        \x3c!--maven tomcat插件--\x3e\n        <plugin>\n            <groupid>org.apache.maven.plugins</groupid>\n            <artifactid>maven-compiler-plugin</artifactid>\n            <version>2.3.2</version>\n            <configuration>\n                <source>1.8</source>\n                <target>1.8</target>\n            </configuration>\n        </plugin>\n        <plugin>\n            <groupid>org.apache.tomcat.maven</groupid>\n            <artifactid>tomcat7-maven-plugin</artifactid>\n            <configuration>\n                \x3c!-- 指定端口 --\x3e\n                <port>8082</port>\n                \x3c!-- 请求路径 --\x3e\n                <path>/</path>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n\n\n 3. 配置 连接远端zookeeper并注册 resources/applicationcontext-service.xml\n    \n    <?xml version="1.0" encoding="utf-8"?>\n    <beans xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n           xmlns:p="http://www.springframework.org/schema/p"\n           xmlns:context="http://www.springframework.org/schema/context"\n           xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"\n           xmlns:mvc="http://www.springframework.org/schema/mvc"\n           xmlns="http://www.springframework.org/schema/beans"\n           xsi:schemalocation="http://www.springframework.org/schema/beans\n           http://www.springframework.org/schema/beans/spring-beans.xsd\n           http://www.springframework.org/schema/mvc\n           http://www.springframework.org/schema/mvc/spring-mvc.xsd\n           http://code.alibabatech.com/schema/dubbo\n           http://code.alibabatech.com/schema/dubbo/dubbo.xsd\n           http://www.springframework.org/schema/context\n           http://www.springframework.org/schema/context/spring-context.xsd">\n        \n        \x3c!-- 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样 --\x3e\n        <dubbo:application name="dubbo-project"/>\n        \x3c!-- 连接服务注册中心zookeeper ip为zookeeper所在服务器的ip地址--\x3e\n        <dubbo:registry address="zookeeper://192.168.230.132:2181"/>\n        \x3c!-- 注册 协议和port 对外提供的端口 (默认20880)--\x3e\n        <dubbo:protocol name="dubbo" port="20881"/>\n        \x3c!-- 扫描指定包，加入@service注解的类会被发布为服务 --\x3e\n        <dubbo:annotation package="com.sans.service.impl"/>\n    </beans>\n    \n    \n    > 这步ip/port不知咋填？ （linux命令得知信息）\n    > \n    > ip地址：ifconfig\n    > \n    > 端口：jsp 查 pid ，根据 pid netstat -tuunpl 查开放端口\n\n 4. 配置 监听器、配置文件加载 web.xml\n    \n    <?xml version="1.0" encoding="utf-8"?>\n    <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"\n             xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n             xsi:schemalocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"\n             version="4.0">\n    \n        \x3c!--配置文件参数--\x3e\n        <context-param>\n            <param-name>contextconfiglocation</param-name>\n            <param-value>classpath:applicationcontext*.xml</param-value>\n        </context-param>\n    \n        \x3c!--监听--\x3e\n        <listener>\n            <listener-class>org.springframework.web.context.contextloaderlistener</listener-class>\n        </listener>\n    \n    </web-app>\n    \n\n 5. 业务实现 service\n    \n    服务接口 helloservice\n    \n    package com.sans.service;\n    \n    /** 服务接口 */\n    public interface helloservice {\n        public string sayhello(string name);\n    }\n    \n    \n    服务实现类 helloserviceimpl\n    \n    package com.sans.service.impl;\n    \n    import com.alibaba.dubbo.config.annotation.service;\n    import com.sans.service.helloservice;\n    \n    // 注意使用的jar包\n    @service\n    public class helloserviceimpl implements helloservice {\n        @override\n        public string sayhello(string name) {\n            return "hello : " + name;\n        }\n    }\n    \n    \n    > 注意：@service注解 是 dubbo包提供的\n\n 6. linux 启动 zookeeper\n    \n    \n    \n\n\n# 在bin目录下 zookeeper 启动 (root权限)\n\n./zkserver.sh start\n\n\n> **注意：**连接的前提需要==关闭防火墙==\n\n7. 运行测试\n运行连接 : 在maven执行 tomcat插件的`run`命令 \n查看注册信息 : 在linux执行 查看\n\n```sh\n\n## 在bin目录下 进入查看\n./zkcli.sh\n\n## 查看注册列表\nls /\n\n## 查看详细\nls /[注册的名称]\n\n\n01.png\n\n> @service注解的类服务存在表示注册成功\n\n消费者项目\n\n 1. 拷贝生产者的项目\n\n 2. 编辑项目名称 dubbo-consumer\n\n 3. 配置 tomcat插件端口 pom.xml （我的是8082端口号）\n\n 4. 配置 连接远端zookeeper并注册 resources/applicationcontext-web.xml\n    \n    <?xml version="1.0" encoding="utf-8"?>\n    <beans xmlns="http://www.springframework.org/schema/beans"\n           xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n           xmlns:p="http://www.springframework.org/schema/p"\n           xmlns:context="http://www.springframework.org/schema/context"\n           xmlns:dubbo="http://code.alibabatech.com/schema/dubbo"\n           xmlns:mvc="http://www.springframework.org/schema/mvc"\n           xsi:schemalocation="http://www.springframework.org/schema/beans\n           http://www.springframework.org/schema/beans/spring-beans.xsd\n           http://www.springframework.org/schema/mvc\n           http://www.springframework.org/schema/mvc/spring-mvc.xsd\n           http://code.alibabatech.com/schema/dubbo\n           http://code.alibabatech.com/schema/dubbo/dubbo.xsd\n           http://www.springframework.org/schema/context\n           http://www.springframework.org/schema/context/spring-context.xsd">\n    \n        \x3c!-- 当前应用名称，用于注册中心计算应用间依赖关系，注意：消费者和提供者应用名不要一样 --\x3e\n        <dubbo:application name="dubbo-consumer"/>\n    \n        \x3c!-- 连接服务注册中心zookeeper ip为zookeeper所在服务器的ip地址--\x3e\n        <dubbo:registry address="zookeeper://192.168.230.134:2181"/>\n    \n        \x3c!-- 扫描指定包，加入@restcontroller注解的类会被发布为服务 --\x3e\n        <dubbo:annotation package="com.sans.controller"/>\n    \n    </beans>\n    \n\n 5. 配置 访问的映射 web.xml\n    \n    <?xml version="1.0" encoding="utf-8"?>\n    <web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"\n             xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n             xsi:schemalocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"\n             version="4.0">\n    \n        \x3c!--配置文件参数--\x3e\n        <context-param>\n            <param-name>contextconfiglocation</param-name>\n            <param-value>classpath:applicationcontext*.xml</param-value>\n        </context-param>\n    \n        \x3c!--监听--\x3e\n        <listener>\n            <listener-class>org.springframework.web.context.contextloaderlistener</listener-class>\n        </listener>\n    \n        \x3c!--入口组件 访问映射--\x3e\n        <servlet>\n            <servlet-name>springmvc</servlet-name>\n            <servlet-class>org.springframework.web.servlet.dispatcherservlet</servlet-class>\n            <init-param>\n                <param-name>contextconfiglocation</param-name>\n                <param-value>classpath:applicationcontext-web.xml</param-value>\n            </init-param>\n            <load-on-startup>1</load-on-startup>\n        </servlet>\n        <servlet-mapping>\n            <servlet-name>springmvc</servlet-name>\n            <url-pattern>/</url-pattern>\n        </servlet-mapping>\n    \n    </web-app>\n    \n\n 6. 业务实现 controller 服务接口 helloservice\n    \n    package com.sans.controller;\n    \n    import com.alibaba.dubbo.config.annotation.reference;\n    import com.sans.service.helloservice;\n    import org.springframework.web.bind.annotation.requestmapping;\n    import org.springframework.web.bind.annotation.responsebody;\n    import org.springframework.web.bind.annotation.restcontroller;\n    \n    @restcontroller\n    @requestmapping("/demo")\n    public class hellocontroller {\n        \n        // controller中注入helloservice使用的是dubbo提供的@reference注解 (自动注入是无效的)\n        // 注意导包 并非是 jdk\n        @reference\n        private helloservice helloservice;\n        \n        @requestmapping("/hello")\n        @responsebody\n        public string getname(string name) {\n            // 远程调用\n            string result = helloservice.sayhello(name);\n            system.out.println("result : " + result);\n            return result;\n        }\n    }\n    \n    \n    > 注意： @reference注解 是 dubbo包提供的\n\n 7. 测试 访问 http://localhost:8082/demo/hello?name=test （观察页面返回的数据是否对应）\n    \n    > 测试前提：提供者启动且已经连接服务注册中心zookeeper\n\n\n# dubbo其他配置\n\n# 包扫描\n\n扫描指定包下的所有类，服务提供者与服务消费者 都需要配置 在 resources 配置资源下的 .xml（以上应用的是扫描包)\n\n提供者 发布服务\n\n\x3c!-- 扫描指定包，加入@service注解的类 会被发布为服务 --\x3e\n<dubbo:annotation package="com.sans.service.impl"/>\n\n\n消费者 应用服务\n\n\x3c!-- 扫描指定包，加入@restcontroller注解的类 会被发布为服务 --\x3e\n<dubbo:annotation package="com.sans.controller"/>\n\n\n> 服务类应用：（在以上注解类内自动注入应用）\n> \n> //dubbo提供的@reference注解 (用法和自动注入一样) \n> @reference\n> private helloservice helloservice;\n\n# 类扫描\n\n扫描指定包下的指定类，通过以下方式进行发布服务： 在 resources 配置资源下的 .xml\n\n提供者 发布服务\n\n\x3c!-- 扫描指定包的指定类。以下配置相当于 @service注解 的配置-- >\n\x3c!-- 创建bean--\x3e\n<bean id="helloservice" class="com.sans.service.impl.helloserviceimpl" />\n\x3c!-- dubbo注册服务 (接口)--\x3e\n<dubbo:service interface="com.sans.service.helloservice" ref="helloservice"/>\n\n\n> ps：dubbo:service 配置相当于 @service注解 ，因此必须注释掉 @service注解\n\n消费者 应用服务\n\n\x3c!-- 生成远程服务代理对象--\x3e\n<dubbo:reference id="helloservice" interface="com.sans.service.helloservice"/>\n\x3c!-- 包扫描--\x3e\n<context:component-scan base-package="com.sans.controller"/>\n\n\n> ps：注入类应用时是用 @autowired注解，并非是 @reference注解\n\n# 协议\n\n一般配置在提供者一方进行配置 dubbo支持协议有：dubbo、rmi、http等协议\n\n建议应用dubbo协议自带的\n\n> dubbo协议 用于传输小数据量并发的服务调用\n\n同一个项目可配置多个协议，不同服务应用不同协议\n\n\x3c!-- 多协议配置 --\x3e\n<dubbo:protocol name="dubbo" port="20880" />\n<dubbo:protocol name="rmi" port="1099" />\n\x3c!-- 使用dubbo协议暴露服务 --\x3e\n<dubbo:service interface="com.sans.service.helloservice" ref="helloservice"\nprotocol="dubbo" />\n\x3c!-- 使用rmi协议暴露服务 --\x3e\n<dubbo:service interface="com.sans.service.demoservice" ref="demoservice"\nprotocol="rmi" />\n\n\n> 服务类协议应用：（默认采用dubbo协议）\n> \n> 如果该服务类使用dubbo以外的协议需要指定协议\n> \n> @service(protocol = "rmi")\n> public class helloserviceimpl implements helloservice {····}\n\n# 负载均衡\n\n将服务集群分担完成共同任务，dubbo提供有常用的均衡策略\n\n负载均衡可在 服务 提供者/消费者 任意一方配置即可实现\n\n提供者\n\n// 生成前 预定策略\n@service(loadbalance = "random")\npublic class helloserviceimpl implements helloservice {····}\n\n\n消费者\n\n// 注入时 应用策略\n@reference(loadbalance = "random")\nprivate helloservice helloservice;\n\n\n> ps：一台电脑集群测试是 dubbo协议的端口 和 tomcat的端口 不能一样，以防冲突\n\nspringboot+dubbo',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Activiti",frontmatter:{title:"Activiti",author:"柏竹",permalink:"/backend/60chrp",date:"2020-02-18T00:00:00.000Z",categories:["后端","框架"],tags:["工作流"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/04.%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF/02.Activiti%E5%B7%A5%E4%BD%9C%E6%B5%81.html",relativePath:"01.后端/04.框架技术/02.Activiti工作流.md",key:"v-b074d626",path:"/backend/60chrp/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:129},{level:2,title:"首次应用",slug:"首次应用",normalizedTitle:"首次应用",charIndex:318},{level:3,title:"Jar包引入",slug:"jar包引入",normalizedTitle:"jar包引入",charIndex:425},{level:3,title:"生成数据库",slug:"生成数据库",normalizedTitle:"生成数据库",charIndex:368},{level:4,title:"JDBC生成",slug:"jdbc生成",normalizedTitle:"jdbc生成",charIndex:3798},{level:4,title:"Spring生成",slug:"spring生成",normalizedTitle:"spring生成",charIndex:3786},{level:3,title:"流程绘制",slug:"流程绘制",normalizedTitle:"流程绘制",charIndex:378},{level:4,title:"图形符号",slug:"图形符号",normalizedTitle:"图形符号",charIndex:6286},{level:3,title:"流程引擎",slug:"流程引擎",normalizedTitle:"流程引擎",charIndex:389},{level:3,title:"部署流程",slug:"部署流程",normalizedTitle:"部署流程",charIndex:6953},{level:4,title:"单文件部署",slug:"单文件部署",normalizedTitle:"单文件部署",charIndex:7009},{level:4,title:"压缩包部署",slug:"压缩包部署",normalizedTitle:"压缩包部署",charIndex:7720},{level:3,title:"启动流程",slug:"启动流程",normalizedTitle:"启动流程",charIndex:8537},{level:3,title:"流程业务",slug:"流程业务",normalizedTitle:"流程业务",charIndex:416},{level:4,title:"查询部署流程",slug:"查询部署流程",normalizedTitle:"查询部署流程",charIndex:9682},{level:4,title:"查看定义流程",slug:"查看定义流程",normalizedTitle:"查看定义流程",charIndex:9859},{level:4,title:"个人任务",slug:"个人任务",normalizedTitle:"个人任务",charIndex:10058},{level:4,title:"流程推进",slug:"流程推进",normalizedTitle:"流程推进",charIndex:10238},{level:4,title:"流程删除",slug:"流程删除",normalizedTitle:"流程删除",charIndex:10365},{level:2,title:"Activiti API",slug:"activiti-api",normalizedTitle:"activiti api",charIndex:67},{level:3,title:"ProcessEngine",slug:"processengine",normalizedTitle:"processengine",charIndex:4027},{level:3,title:"DeploymentBuilder",slug:"deploymentbuilder",normalizedTitle:"deploymentbuilder",charIndex:10817},{level:3,title:"DeploymentQuery",slug:"deploymentquery",normalizedTitle:"deploymentquery",charIndex:9827},{level:3,title:"ProcessInstance",slug:"processinstance",normalizedTitle:"processinstance",charIndex:8610},{level:3,title:"ProcessInstanceQuery",slug:"processinstancequery",normalizedTitle:"processinstancequery",charIndex:13227},{level:3,title:"Task",slug:"task",normalizedTitle:"task",charIndex:6401},{level:3,title:"TaskQuery",slug:"taskquery",normalizedTitle:"taskquery",charIndex:10193},{level:3,title:"Query",slug:"query",normalizedTitle:"query",charIndex:9837},{level:3,title:"Service",slug:"service",normalizedTitle:"service",charIndex:6418},{level:4,title:"RepositoryService",slug:"repositoryservice",normalizedTitle:"repositoryservice",charIndex:6966},{level:4,title:"RuntimeService",slug:"runtimeservice",normalizedTitle:"runtimeservice",charIndex:8555},{level:4,title:"TaskService",slug:"taskservice",normalizedTitle:"taskservice",charIndex:10083},{level:4,title:"HistoryService",slug:"historyservice",normalizedTitle:"historyservice",charIndex:16283},{level:2,title:"Activiti 数据库",slug:"activiti-数据库",normalizedTitle:"activiti 数据库",charIndex:19263},{level:3,title:"常用表",slug:"常用表",normalizedTitle:"常用表",charIndex:19402},{level:3,title:"所有表",slug:"所有表",normalizedTitle:"所有表",charIndex:19663},{level:4,title:"actgebytearray",slug:"act-ge-bytearray",normalizedTitle:"actgebytearray",charIndex:null},{level:4,title:"actgeproperty",slug:"act-ge-property",normalizedTitle:"actgeproperty",charIndex:null},{level:4,title:"acthiactinst",slug:"act-hi-actinst",normalizedTitle:"acthiactinst",charIndex:null},{level:4,title:"acthiattachment",slug:"act-hi-attachment",normalizedTitle:"acthiattachment",charIndex:null},{level:4,title:"acthicomment",slug:"act-hi-comment",normalizedTitle:"acthicomment",charIndex:null},{level:4,title:"acthidetail",slug:"act-hi-detail",normalizedTitle:"acthidetail",charIndex:null},{level:4,title:"acthiidentitylink",slug:"act-hi-identitylink",normalizedTitle:"acthiidentitylink",charIndex:null},{level:4,title:"acthiprocinst",slug:"act-hi-procinst",normalizedTitle:"acthiprocinst",charIndex:null},{level:4,title:"acthitaskinst",slug:"act-hi-taskinst",normalizedTitle:"acthitaskinst",charIndex:null},{level:4,title:"acthivarinst",slug:"act-hi-varinst",normalizedTitle:"acthivarinst",charIndex:null},{level:4,title:"actidgroup",slug:"act-id-group",normalizedTitle:"actidgroup",charIndex:null},{level:4,title:"actidinfo",slug:"act-id-info",normalizedTitle:"actidinfo",charIndex:null},{level:4,title:"actidmembership",slug:"act-id-membership",normalizedTitle:"actidmembership",charIndex:null},{level:4,title:"actiduser",slug:"act-id-user",normalizedTitle:"actiduser",charIndex:null},{level:4,title:"actredeployment",slug:"act-re-deployment",normalizedTitle:"actredeployment",charIndex:null},{level:4,title:"actremodel",slug:"act-re-model",normalizedTitle:"actremodel",charIndex:null},{level:4,title:"actreprocdef",slug:"act-re-procdef",normalizedTitle:"actreprocdef",charIndex:null},{level:4,title:"actruevent_subscr",slug:"act-ru-event-subscr",normalizedTitle:"actruevent_subscr",charIndex:null},{level:4,title:"actruexecution",slug:"act-ru-execution",normalizedTitle:"actruexecution",charIndex:null},{level:4,title:"actruidentitylink",slug:"act-ru-identitylink",normalizedTitle:"actruidentitylink",charIndex:null},{level:4,title:"actrujob",slug:"act-ru-job",normalizedTitle:"actrujob",charIndex:null},{level:4,title:"actrutask",slug:"act-ru-task",normalizedTitle:"actrutask",charIndex:null},{level:4,title:"actruvariable",slug:"act-ru-variable",normalizedTitle:"actruvariable",charIndex:null},{level:2,title:"IDEA应用Activiti",slug:"idea应用activiti",normalizedTitle:"idea应用activiti",charIndex:41297},{level:2,title:"SSM整合Activiti",slug:"ssm整合activiti",normalizedTitle:"ssm整合activiti",charIndex:41666}],headersStr:"简介 首次应用 Jar包引入 生成数据库 JDBC生成 Spring生成 流程绘制 图形符号 流程引擎 部署流程 单文件部署 压缩包部署 启动流程 流程业务 查询部署流程 查看定义流程 个人任务 流程推进 流程删除 Activiti API ProcessEngine DeploymentBuilder DeploymentQuery ProcessInstance ProcessInstanceQuery Task TaskQuery Query Service RepositoryService RuntimeService TaskService HistoryService Activiti 数据库 常用表 所有表 actgebytearray actgeproperty acthiactinst acthiattachment acthicomment acthidetail acthiidentitylink acthiprocinst acthitaskinst acthivarinst actidgroup actidinfo actidmembership actiduser actredeployment actremodel actreprocdef actruevent_subscr actruexecution actruidentitylink actrujob actrutask actruvariable IDEA应用Activiti SSM整合Activiti",content:'# Activiti\n\nActiviti5手册：http://shouce.jb51.net/activiti/#download\n\nActiviti API：https://www.activiti.org/javadocs/index.html\n\n\n# 简介\n\nActiviti工作流。由多任务人协同完成的一个复杂的业务流的框架\n\n它能够对业务流程自动化的管理，而且也是多人共同完成的一个流程任务的业务\n\n特点：\n\n * 图形化，把复杂的业务流进行图形化处理\n * 数据化，图形化的业务部署到流程数据库中\n * 流程表，流程数据库，共有23张表\n * API，提供了一套API，业务对象\n * 持久层： MyBatis实现\n\n\n# 首次应用\n\n应用的前提首先需要深层数据库，需要数据库进行\n\n步骤：\n\n 1. 引入jar包\n 2. 生成数据库\n 3. 流程绘制\n 4. 创建流程引擎\n 5. 流程部署\n 6. 流程启动\n 7. 流程业务\n\n\n# Jar包引入\n\nJar包下载：https://mvnrepository.com/artifact/org.activiti/activiti-engine\n\nMaven引入：\n\n<dependencies>\n    \x3c!--activiti的核心包--\x3e\n    <dependency>\n        <groupId>org.activiti</groupId>\n        <artifactId>activiti-engine</artifactId>\n        <version>6.0.0</version>\n    </dependency>\n    <dependency>\n        <groupId>org.activiti</groupId>\n        <artifactId>activiti-spring</artifactId>\n        <version>6.0.0</version>\n    </dependency>\n    <dependency>\n        <groupId>org.activiti</groupId>\n        <artifactId>activiti-bpmn-model</artifactId>\n        <version>6.0.0</version>\n    </dependency>\n    <dependency>\n        <groupId>javax.servlet</groupId>\n        <artifactId>servlet-api</artifactId>\n        <version>2.5</version>\n    </dependency>\n    <dependency>\n        <groupId>org.activiti</groupId>\n        <artifactId>activiti-bpmn-converter</artifactId>\n        <version>6.0.0</version>\n    </dependency>\n    <dependency>\n        <groupId>org.activiti</groupId>\n        <artifactId>activiti-json-converter</artifactId>\n        <version>6.0.0</version>\n    </dependency>\n    <dependency>\n        <groupId>org.activiti</groupId>\n        <artifactId>activiti-bpmn-layout</artifactId>\n        <version>6.0.0</version>\n    </dependency>\n    <dependency>\n        <groupId>org.activiti.cloud</groupId>\n        <artifactId>activiti-cloud-services-api</artifactId>\n        <version>7-201710-EA</version>\n    </dependency>\n    <dependency>\n        <groupId>aspectj</groupId>\n        <artifactId>aspectjweaver</artifactId>\n        <version>1.5.4</version>\n    </dependency>\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <version>5.1.40</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-test</artifactId>\n        <version>5.0.7.RELEASE</version>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-core</artifactId>\n        <version>4.1.6.RELEASE</version>\n    </dependency>\n    <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis</artifactId>\n        <version>3.4.5</version>\n    </dependency>\n    <dependency>\n        <groupId>commons-dbcp</groupId>\n        <artifactId>commons-dbcp</artifactId>\n        <version>1.4</version>\n    </dependency>\n    <dependency>\n        <groupId>junit</groupId>\n        <artifactId>junit</artifactId>\n        <version>4.12</version>\n    </dependency>\n    <dependency>\n        <groupId>log4j</groupId>\n        <artifactId>log4j</artifactId>\n        <version>1.2.17</version>\n    </dependency>\n    <dependency>\n        <groupId>org.slf4j</groupId>\n        <artifactId>slf4j-log4j12</artifactId>\n        <version>1.7.21</version>\n    </dependency>\n    <dependency>\n        <groupId>org.slf4j</groupId>\n        <artifactId>slf4j-api</artifactId>\n        <version>1.7.25</version>\n    </dependency>\n    <dependency>\n        <groupId>commons-io</groupId>\n        <artifactId>commons-io</artifactId>\n        <version>2.6</version>\n    </dependency>\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n        <version>1.16.18</version>\n        <scope>provided</scope>\n    </dependency>\n</dependencies>\n\n\n\n# 生成数据库\n\nActiviti生成库的方式有两种分别是：\n\n * Java程序 纯JDBC 生成\n * Spring生成\n\n# JDBC生成\n\n步骤：\n\n 1. 创建 配置文件 引擎对象\n 2. 配置 数据库连接源\n 3. 解决 重复覆盖问题\n 4. 获取 流程引擎对象\n\n@Test\npublic void jdbc() {\n    /** 步骤：\n     *  1. 创建 配置文件对象\n     *  2. 配置 数据库连接源\n     *  3. 解决 重复覆盖问题\n     *  4. 获取 流程引擎对象\n     */\n\n    // 1. 流程引擎 配置对象\n    ProcessEngineConfiguration config = ProcessEngineConfiguration.createStandaloneProcessEngineConfiguration();\n\n    // 2. 连接库的数据源配置\n    config.setJdbcDriver("com.mysql.cj.jdbc.Driver");\n    config.setJdbcUrl("jdbc:mysql://localhost:3306/activiti?serverTimezone=UTC");\n    config.setJdbcUsername("root");\n    config.setJdbcPassword("root");\n\n    // 3. 解决已存在被覆盖问题\n    config.setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE);\n\n    // 4. 获取 流程引擎对象\n    ProcessEngine processEngine = config.buildProcessEngine();\n    System.out.println("processEngine = " + processEngine);\n}\n\n\n# Spring生成\n\n> spring loc 配置启动应用即可，搭建主要在 loc 中托管 配置文件对象！！\n\nactiviti.cfg.xml配置文件\n\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:context="http://www.springframework.org/schema/context" \n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xsi:schemaLocation="\n       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd\n">\n\n    <bean id="processEngineConfiguration"\n          class="org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration">\n        \x3c!-- 连接数据的配置 --\x3e\n        <property name="jdbcDriver" value="com.mysql.cj.jdbc.Driver"/>\n        <property name="jdbcUrl"\n                  value="jdbc:mysql://localhost:3306/activiti?serverTimezone=UTC"/>\n        <property name="jdbcUsername" value="root"/>\n        <property name="jdbcPassword" value="root"/>\n        \x3c!-- 没有表创建表 --\x3e\n        <property name="databaseSchemaUpdate" value="true"/>\n        \x3c!--\n            其余可以在这里进行其他配置\n        --\x3e\n    </bean>\n\n</beans>\n\n\n测试启动\n\n@Test\npublic void spring() {\n    ProcessEngineConfiguration config = ProcessEngineConfiguration.createProcessEngineConfigurationFromResource("activiti.cfg.xml");\n\n    config.buildProcessEngine();\n    System.out.println("config = " + config);\n}\n\n\n\n# 流程绘制\n\nBPMN是 activit定义绘制的流程图，它主要用来描述业务流程的基本的符号，一般情况是通过工具进行绘制的一个流程图，流程图的原始文件其实是 XML形式 的文件\n\n绘制方式有很多中：（可以自行选择\n\n * eclipse自带的绘制工具\n\n * idea插件 Activiti BPMN visualize 缺陷：不能添加侦听器功能\n\n * 第三方绘制工具 Camunda\n   \n   缺陷：部分标签名不同，导致兼容问题 组件手册：https://docs.camunda.io/docs/components/\n\n# 图形符号\n\n事件Event （圆形\n\n * Start Event 启动事件\n\n * Intermediate Event 中间事件\n\n * End Event 结束时间\n\n活动Activity （长方形 圆角\n\n * User Task 用户任务 （用户\n * Service Task 服务任务 （齿轮\n * Sub Process 子流程 （添加\n\n网关Gateway\n\n。。。。\n\n流向\n\n。。。。\n\n\n# 流程引擎\n\n工作流引擎 的创建主要有两种方式：\n\n * new 硬编码生成\n * loc 容器托管生成\n\n> 上面生成数据库的步骤也有！\n\nnew 硬编码生成\n\nProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();\n\n\nloc 容器托管生成\n\nProcessEngineConfiguration processEngineConfiguration = ProcessEngineConfiguration.createProcessEngineConfigurationFromResource("activiti.cfg.xml");\n// 获取流程引擎对象:通过 ProcessEngineConfiguration 创建 ProcessEngine\nProcessEngine processEngine = processEngineConfiguration.buildProcessEngine();\n\n\n\n# 部署流程\n\n流程部署通过 RepositoryService资源管理类 进行部署，部署形式有两种方式：\n\n * 单文件部署 bpmn文件 和 png文件 逐个处理\n * 压缩包流程部署 bpmn文件 和 png文件 zip压缩统一处理\n\n部署信息涉及表有：\n\n * act_re_deployment\n * act_re_procdef\n * act_ge_bytearray\n * act_ge_property\n\n# 单文件部署\n\n@Test\npublic void deploy() {\n    // 流程引擎\n    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();\n    Deployment deploy = processEngine.getRepositoryService()\n            .createDeployment()\n            .name("请假流程")\n            .addClasspathResource("diagram/askForLeave.bpmn20.xml")\n            .addClasspathResource("image/askForLeave.png")\n            .deploy();\n    // 输出信息代表成功 （部署的 id/name\n    System.out.println("deploy.getId() = " + deploy.getId());\n    System.out.println("deploy.getName() = " + deploy.getName());\n}\n\n\n# 压缩包部署\n\n@Test\npublic void deployProcessByZip() {\n    // 获取流程引擎\n    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();\n    RepositoryService repositoryService = processEngine.getRepositoryService();\n    // 流程部署\n    // 解释：通过 类加载器src的根路径下找 bpmn/evection.zip 加载读取为二进制流\n    InputStream inputStream = this.getClass().getClassLoader().getResourceAsStream("bpmn/evection.zip");\n    // 使用 InputStream 构造 ZipInputStream\n    ZipInputStream zipInputStream = new ZipInputStream(inputStream);\n    // 使用压缩包的流，进行流程的部署\n    Deployment deploy = repositoryService.createDeployment()\n            .addZipInputStream(zipInputStream)\n            .deploy();\n    // 输出信息代表成功 （部署的 id/name\n    System.out.println("deploy.getId() = " + deploy.getId());\n    System.out.println("deploy.getName() = " + deploy.getName());\n}\n\n\n\n# 启动流程\n\n流程部署完成以后，通过 RuntimeService流程运行管理类 启动实例，是根据流程定义的 key进行启动\n\n该启动的 startProcessInstanceByKey()方法 重载了4个方法：(划分参数说明)\n\n * startProcessInstanceByKey(String key) 根据部署后的key进行启动流程（key在库中的 act_re_procdef.KEY_字段查到\n * startProcessInstanceByKey(String key, String businessKey) 根据key进行启动，并且 绑定关联key （用于绑定 任务id/单子id 的关键信息 在库中的 act_hi_procinst.BUSINESS_KEY_字段查到\n * startProcessInstanceByKey(String key, Map<String, Object> map) 根据key进行启动，并且 设置流程变量 （在表绘制的时候会根据指定key赋予value值\n * startProcessInstanceByKey(String key, String businessKey, Map<String, Object> map) 以上说明的功能已经要点都有（启动key、绑定关联key、设置流程变量）\n\n@Test\npublic void startprocess() {\n    // 请假流程key\n    String key = "askForLeave";\n    // 请假单id (leave.12)\n    int id = 12;\n    String businessKey = "leave."+id;\n    // map 传递流程变量\n    Map<String, Object> map = new HashMap<>();\n    map.put("name","张三");\n    ProcessInstance pi = processEngine.getRuntimeService().\n            startProcessInstanceByKey(key,businessKey,map);\n    System.out.println("pi.getId(): " + pi.getId());\n    System.out.println("pi.getProcessDefinitionId(): " + pi.getProcessDefinitionId());\n}\n\n\n\n# 流程业务\n\n流程业务可以根据以下API进行详细操作，以下展示常用的 流程业务操作\n\n# 查询部署流程\n\n@Autowired\nprivate RepositoryService repositoryService;\npublic List<Deployment> findAllDeployment() {\n    return repositoryService.createDeploymentQuery().list();\n}\n\n\n# 查看定义流程\n\n@Autowired\nprivate RepositoryService repositoryService;\npublic List<ProcessDefinition> findAllProcessDefinitions() {\n    return repositoryService.createProcessDefinitionQuery().list();\n}\n\n\n# 个人任务\n\n@Autowired\nprivate TaskService taskService;\npublic List<Task> findTaskListByAssignee(String name) {\n    return taskService.createTaskQuery().taskAssignee(name).list();\n}\n\n\n# 流程推进\n\n@Autowired\nprivate TaskService taskService;\npublic void endTask(String TaskId) {\n    taskService.complete(TaskId);\n}\n\n\n# 流程删除\n\n@Autowired\nprivate RepositoryService repositoryService;\npublic void testDel(String id) {\n    // 参数2：强制删除与该部署的流程 相关的历史/运行信息\n    repositoryService.deleteDeployment(id, true);\n}\n\n\n> 更多业务功能，可根据以下的API进行操作\n\n\n# Activiti API\n\n官方API：https://www.activiti.org/javadocs/index.html\n\n\n# ProcessEngine\n\norg.activiti.engine.ProcessEngine 流程引擎配置接口\n\n提供 工作流操作的所有服务的访问以下都是\n\n类型       方法          说明\nvoid     close()     关闭\nString   getName()   在配置 中的进程引擎名称，没有则默认\n\n\n# DeploymentBuilder\n\norg.activiti.engine.repository.DeploymentBuilder 创建新部署的生成器接口\n\n构建器实例可以通过 RepositoryService 获得createDeployment()\n\n可以在调用 deploy() 操作之前 将多个 资源/配置 添加到一个部署中。部署后，不能对返回的部署进行任何更改，可以销毁构建器实例 （点击应用实例\n\n常用方法\n\n类型                  方法                                                             说明\nDeployment          deploy()                                                       部署流程\nDeploymentBuilder   addClasspathResource(String resource)                          添加指定路径资源\nDeploymentBuilder   addInputStream(String resourceName, InputStream inputStream)   添加流形式的资源\nDeploymentBuilder   addZipInputStream(ZipInputStream zipInputStream)               添加指定zip资源\nDeploymentBuilder   name(String name)                                              为流程指定名称\nDeploymentBuilder   category(String category)                                      为流程指定类别\n更多自行API             https://www.activiti.org/javadocs/index.html                   ....\n\n\n# DeploymentQuery\n\norg.activiti.engine.repository.DeploymentQuery 部署查询接口\n\n常用方法\n\n类型                方法                                                      说明\nDeploymentQuery   deploymentCategory(String category)                     选择部署类型\nDeploymentQuery   deploymentCategoryNotEquals(String categoryNotEquals)   选择类型取反\nDeploymentQuery   deploymentId(String deploymentId)                       选择部署id\nDeploymentQuery   deploymentName(String name)                             选择部署name\nDeploymentQuery   deploymentNameLike(String nameLike)                     模糊选择部署name\nDeploymentQuery   processDefinitionKey(String key)                        选择流程key\nDeploymentQuery   processDefinitionKeyLike(String keyLike)                模糊选择流程key\n更多自行API           https://www.activiti.org/javadocs/index.html            ...\n\n\n# ProcessInstance\n\norg.activiti.engine.runtime.ProcessInstance 流程实例接口\n\n常用方法\n\n类型        方法                                             说明\nString    getBusinessKey()                               获取业务key\nString    getDeploymentId()                              获取部署id\nString    getDescription()                               获取 流程描述\nString    getName()                                      获取 流程name\nString    getProcessDefinitionId()                       获取流程id\nString    getProcessDefinitionKey()                      获取流程key\nString    getProcessDefinitionName()                     获取流程name\n更多自行API   https://www.activiti.org/javadocs/index.html   ....\n\n\n# ProcessInstanceQuery\n\norg.activiti.engine.runtime.ProcessInstanceQuery 流程实例查询接口\n\n常用方法\n\n类型                     方法                                               说明\nProcessInstanceQuery   processInstanceId(String id)                     选择流程实例id\nProcessInstanceQuery   processInstanceIds(Set<String> ids)              选择流程实例多个id\nProcessInstanceQuery   processInstanceBusinessKey(String businessKey)   选择流程实例的业务id\n更多自行API                https://www.activiti.org/javadocs/index.html     ....\n\n\n# Task\n\norg.activiti.engine.task.Task 用户任务接口\n\n常用方法\n\n类型                方法                                                    说明\nvoid              delegate(String userId)                               将任务委托指定id的用户\nDelegationState   getDelegationState()                                  获取任务状态(代办/解决)\nboolean           isSuspended()                                         任务是否挂起\nvoid              setAssignee(String assignee)                          设置任务委托人\nvoid              setCategory(String category)                          设置任务类型\nvoid              setDelegationState(DelegationState delegationState)   设置任务状态(代办/解决)\nvoid              setDescription(String description)                    设置任务描述\nvoid              setDueDate(Date dueDate)                              设置任务截止时间\nvoid              setFormKey(String formKey)                            设置任务表单键\nvoid              setName(String name)                                  设置任务名称\nvoid              setOwner(String owner)                                设置任务负责人id\nvoid              setPriority(int priority)                             设置任务重要程度\n更多自行API           https://www.activiti.org/javadocs/index.html          ....\n\n\n# TaskQuery\n\norg.activiti.engine.task.TaskQuery\n\n常用方法\n\n类型          方法                                                     说明\nTaskQuery   active()                                               选择活动的任务\nTaskQuery   excludeSubtasks()                                      选择没有父节点的任务\nTaskQuery   suspended()                                            选择被挂起的任务\nTaskQuery   taskDelegationState(DelegationState delegationState)   选择指定状态的任务\nTaskQuery   taskUnassigned()                                       选择没有委托人的任务\n更多自行API     https://www.activiti.org/javadocs/index.html           ....\n\n\n# Query\n\norg.activiti.engine.query.Query<T extends Query<?, ?>, U>\n\n该接口用于在以上业务查询功能\n\n常用方法\n\n类型        方法                                             说明\nT         asc()                                          对结果指定属性进行升序排序\nlong      count()                                        获取结果数\nT         desc()                                         对结果指定属性进行降序排序\nList<U>   list()                                         查询并获取集合\nList<U>   listPage(int firstResult, int maxResults)      查询并获取集合（开始位置 , 总量数）\nU         singleResult()                                 查询满足提交的结果（一条\n更多自行API   https://www.activiti.org/javadocs/index.html   ....\n\n\n# Service\n\nActiviti提供了许多Service服务接口，用于 用户业务流程的操作和查看\n\nservice总览\n\nSERVICE名称           说明\nRepositoryService   资源管理接口\nRuntimeService      流程运行管理接口\nTaskService         任务管理接口\nHistoryService      历史管理接口\n\n# RepositoryService\n\norg.activiti.engine.RepositoryService 资源管理接口\n\n**作用：**管理流程发布包 和 流程定义 的操作\n\n常用方法\n\n类型                  方法                                                       说明\nDeploymentBuilder   createDeployment()                                       部署流程\nDeploymentQuery     createDeploymentQuery()                                  查询部署\nList<String>        getDeploymentResourceNames(String deploymentId)          根据id查资源列表\nList<String>        getDeploymentResourceNames(String deploymentName)        根据name查资源列表\nvoid                deleteDeployment(String deploymentId, boolean cascade)   删除部署资源，运行过程实例是否强制删除\n                    getResourceAsStream()                                    \n更多自行API             https://www.activiti.org/javadocs/index.html             ....\n\n# RuntimeService\n\norg.activiti.engine.RuntimeService 流程运行管理接口\n\n**作用：**获取关于流程执行的相关信息\n\n常用方法\n\n类型                     方法                                             说明\nProcessInstance        startProcessInstanceByKey()                    启动流程\nProcessInstanceQuery   createProcessInstanceQuery()                   查询正在运行的流程\n更多自行API                https://www.activiti.org/javadocs/index.html   ....\n\n# TaskService\n\norg.activiti.engine.TaskService 任务管理接口\n\n**作用：**获取与 任务/操作相关 的信息\n\n常用方法\n\n类型          方法                                                           说明\nTaskQuery   createTaskQuery()                                            创建任务查询对象\nvoid        complete(String id)                                          推进任务\nvoid        complete(String id, Map<String, Object> variables)           推进任务，成功后并填充参数\nComment     addComment(String taskId, String processInstanceId, String   添加批注。指定 任务id、流程实例id、消息\n            message)\nComment     addComment(String taskId, String processInstanceId, String   添加批注。指定 任务id、自定义类型、流程实例id、消息\n            type, String message)\n更多自行API     https://www.activiti.org/javadocs/index.html                 ....\n\n# HistoryService\n\norg.activiti.engine.HistoryService 历史管理接口\n\n**作用：**查询历史信息，执行流程时，引擎会保存很多数据（根据配置)\n\n> 这与运行时服务不同，因为该运行时信息只包含任何给定时刻的实际运行时状态，并且针对运行时流程执行性能进行了优化。历史信息经过优化，便于查询，并在持久存储中保持永久性\n\n常用方法\n\n类型                               方法                                                        说明\nHistoricProcessInstanceQuery     createHistoricProcessInstanceQuery()                      流程实例查询\nHistoricTaskInstanceQuery        createHistoricTaskInstanceQuery()                         任务实例查询\nHistoricVariableInstanceQuery    createHistoricVariableInstanceQuery()                     变量历史查询\nProcessInstanceHistoryLogQuery   createProcessInstanceHistoryLogQuery(String               流程实例日志查询\n                                 processInstanceId)\nvoid                             deleteHistoricProcessInstance(String processInstanceId)   删除指定流程实例id历史记录\nvoid                             deleteHistoricTaskInstance(String taskId)                 删除指定任务id历史记录\n更多自行API                          https://www.activiti.org/javadocs/index.html              ....\n\n\n# Activiti 数据库\n\nActiviti数据库有23张表，他们大致分类有：\n\n表名前缀       说明\nact_re_*   流程定义 和 流程资源\nact_ru_*   运行时、流程实例、任务、变量\nact_hi_*   流程历史\nact_ge_*   通用表\n\n\n# 常用表\n\n表名                  说明\nact_ge_bytearray    通用流程定义/流程资源\nact_re_deployment   部署流程信息\nact_re_procdef      已部署的流程定义\nact_ru_execution    运行时流程执行实例\nact_ru_task         运行时任务\nact_re_procdef      已部署的流程定义\nact_hi_procinst     历史的流程实例\nact_hi_taskinst     历史的任务实例\n\n\n# 所有表\n\n表名                    说明\nact_ge_bytearray      通用流程定义/流程资源\nact_ge_property       系统相关属性\nact_hi_actinst        历史的流程节点\nact_hi_attachment     历史的流程附件\nact_hi_comment        历史的说明信息（批注\nact_hi_detail         历史的流程运行中的细节信息\nact_hi_identitylink   历史的流程运行过程中用户关系\nact_hi_procinst       历史的流程实例\nact_hi_taskinst       历史的任务实例\nact_hi_varinst        历史的流程运行中的变量信息\nact_id_group          用户组信息表\nact_id_info           用户详细信息表\nact_id_membership     用户与用户组对应信息表\nact_id_user           用户信息表\nact_re_deployment     部署流程信息\nact_re_model          模型信息\nact_re_procdef        已部署的流程定义\nact_ru_event_subscr   运行时事件\nact_ru_execution      运行时流程执行实例\nact_ru_identitylink   运行时用户关系信息，存储任务节点的参与信息\nact_ru_job            运行时作业\nact_ru_task           运行时任务\nact_ru_variable       运行时变量表\n\n# act_ge_bytearray\n\n二进制数据表，存储通用的流程定义和流程资源\n\n> 保存流程定义图片和xml、Serializable(序列化)的变量，即保存所有二进制数据，特别注意类路径部署时候，不要把svn等隐藏文件或者其他与流程无关的文件也一起部署到该表中，会造成一些错误（可能导致流程定义无法删除）\n\n字段名称             字段描述      数据类型             主键   为空   取值说明\nID_              ID_       nvarchar(64)     √         主键ID\nREV_             乐观锁       int                   √    Version(版本)\nNAME_            名称        nvarchar(255)         √    部署的文件名称，如：leave.bpmn.png,leave.bpmn20.xml\nDEPLOYMENT_ID_   部署ID      nvarchar(64)          √    部署表ID\nBYTES_           字节        varbinary(max)        √    部署文件\nGENERATED_       是否是引擎生成   tinyint               √    0为用户生成，1为activiti生成\n\n索引\n\n名称                    字段               类型               说明\nACT_FK_BYTEARR_DEPL   DEPLOYMENT_ID_   DEPLOYMENT_ID_   ID部署\n\n# act_ge_property\n\n属性数据表，存储整个流程引擎级别的数据\n\n字段名称     字段描述   数据类型            主键   为空   取值说明\nNAME_    名称     nvarchar(64)    √         schema.versionschema.historynext.dbid\nVALUE_   值      nvarchar(300)        √    5.create(5.)\nREV_     乐观锁    int                  √    version\n\n# act_hi_actinst\n\n历史节点表，历史活动信息\n\n> 这里记录流程流转过的所有节点，与HI_TASKINST不同的是，taskinst只记录usertask内容\n\n字段名称                 字段描述          数据类型            主键   为空   取值说明\nID_                  ID_           nvarchar(64)    √         \nPROC_DEF_ID_         流程定义ID        nvarchar(64)              \nPROC_INST_ID_        流程实例ID        nvarchar(64)              \nEXECUTION_ID_        执行实例ID        nvarchar(64)              \nACT_ID_              节点ID          nvarchar(225)             节点定义ID\nTASK_ID_             任务实例ID        nvarchar(64)         √    任务实例ID 其他节点类型实例ID在这里为空\nCALL_PROC_INST_ID_   调用外部的流程实例ID   nvarchar(64)         √    调用外部流程的流程实例ID’\nACT_NAME_            节点名称          nvarchar(225)        √    节点定义名称\nACT_TYPE_            节点类型          nvarchar(225)             如startEvent、userTask\nASSIGNEE_            签收人           nvarchar(64)         √    节点签收人\nSTART_TIME_          开始时间          datetime                  2013-09-15 11:30:00\nEND_TIME_            结束时间          datetime             √    2013-09-15 11:30:00\nDURATION_            耗时            numeric(19,0)        √    毫秒值\n\n索引\n\n名称                             字段              类型\nACT_IDX_HI_ACT_INST_START      START_TIME_     NORMAL\nACT_IDX_HI_ACT_INST_END        END_TIME_       NORMAL\nACT_IDX_HI_ACT_INST_PROCINST   PROC_INST_ID_   NORMAL\nACT_IDX_HI_ACT_INST_EXEC       EXECUTION_ID_   NORMAL\n\n# act_hi_attachment\n\n历史附件表\n\n字段名称            字段描述     数据类型             主键   为空   取值说明\nID_             ID_      nvarchar(64)     √         主键ID\nREV_            乐观锁      integer               √    Version\nUSER_ID_        用户ID     nvarchar(255)         √    用户ID\nNAME_           名称       nvarchar(255)         √    附件名称\nDESCRIPTION_    描述       nvarchar(4000)        √    描述\nTYPE_           类型       nvarchar(255)         √    附件类型\nTASK_ID_        任务实例ID   nvarchar(64)          √    节点实例ID\nPROC_INST_ID_   流程实例ID   nvarchar(64)          √    流程实例ID\nURL_            URL_     nvarchar(4000)        √    附件地址\nCONTENT_ID_     字节表的ID   nvarchar(64)          √    ACT_GE_BYTEARRAY的ID\n\n# act_hi_comment\n\n字段名称            字段描述     数据类型             主键   为空   取值说明\nID_             ID_      nvarchar(64)     √         主键ID\nTYPE_           类型       nvarchar(255)         √    类型：event（事件）comment（意见）\nTIME_           时间       datetime                   填写时间\nUSER_ID_        用户ID     nvarchar(64)          √    填写人\nTASK_ID_        节点任务ID   nvarchar(64)          √    节点实例ID\nPROC_INST_ID_   流程实例ID   nvarchar(255)         √    流程实例ID\nACTION_         行为类型     nvarchar(64)          √    见备注1\nMESSAGE_        基本内容     nvarchar(4000)        √    用于存放流程产生的信息，比如审批意见\nFULL_MSG_       全部内容     varbinary(max)        √    附件地址\n\n# act_hi_detail\n\n历史详情表\n\n流程中产生的变量详细，包括控制流程流转的变量，业务表单中填写的流程需要用到的变量等\n\n字段名称            字段描述      数据类型               主键   为空   取值说明\nID_             ID_       nvarchar(64)       √         主键\nTYPE_           类型        nvarchar(255)                见备注2\nPROC_INST_ID_   流程实例ID    nvarchar(64)            √    流程实例ID\nEXECUTION_ID_   执行实例ID    nvarchar(64)            √    执行实例ID\nTASK_ID_        任务实例ID    nvarchar(64)            √    任务实例ID\nACT_INST_ID_    节点实例ID    nvarchar(64)            √    ACT_HI_ACTINST表的ID\nNAME_           名称        nvarchar(255)                名称\nVAR_TYPE_       参数类型      nvarchar(255)           √    见备注3\nREV_            乐观锁       int                     √    Version\nTIME_           时间戳       datetime                     创建时间\nBYTEARRAY_ID_   字节表ID     nvarchar                √    ACT_GE_BYTEARRAY表的ID\nDOUBLE_         DOUBLE_   double precision        √    存储变量类型为Double\nLONG_           LONG_     numeric                 √    存储变量类型为long\nTEXT_           TEXT_     nvarchar                √    存储变量值类型为String\nTEXT2_          TEXT2_    nvarchar                √    此处存储的是JPA持久化对象时，才会有值。此值为对象ID\n\n索引\n\n名称                            字段              类型\nACT_IDX_HI_DETAIL_PROC_INST   PROC_INST_ID_   NORMAL\nACT_IDX_HI_DETAIL_ACT_INST    ACT_INST_ID_    NORMAL\nACT_IDX_HI_DETAIL_TIME        TIME_           NORMAL\nACT_IDX_HI_DETAIL_NAME        NAME_           NORMAL\nACT_IDX_HI_DETAIL_TASK_ID     TASK_ID_        NORMAL\n\n# act_hi_identitylink\n\n历史流程人员表\n\n任务参与者数据表。主要存储历史节点参与者的信息\n\n字段名称            字段描述     数据类型            主键   为空   取值说明\nID_             ID_      nvarchar(64)    √         ID_\nGROUP_ID_       组ID      nvarchar(255)        √    组ID\nTYPE_           类型       nvarchar(255)        √    备注4\nUSER_ID_        用户ID     nvarchar(255)        √    用户ID\nTASK_ID_        节点实例ID   nvarchar(64)         √    节点实例ID\nPROC_INST_ID_   流程实例ID   nvarchar(64)         √    流程实例ID\n\n索引\n\n名称                              字段              类型\nACT_IDX_HI_IDENT_LNK_USER       USER_ID_        NORMAL\nACT_IDX_HI_IDENT_LNK_TASK       TASK_ID_        NORMAL\nACT_IDX_HI_IDENT_LNK_PROCINST   PROC_INST_ID_   NORMAL\n\n# act_hi_procinst\n\n历史流程实例表\n\n字段名称                         字段描述      数据类型             主键   为空   取值说明\nID_                          ID_       nvarchar(64)     √         主键ID\nPROC_INST_ID_                流程实例ID    nvarchar(64)               流程实例ID\nBUSINESS_KEY_                业务主键      nvarchar(255)         √    业务主键，业务表单的ID\nPROC_DEF_ID_                 流程定义ID    nvarchar(64)               流程定义ID\nSTART_TIME_                  开始时间      datetime                   开始时间\nEND_TIME_                    结束时间      datetime              √    结束时间\nDURATION_                    耗时        Numeric(19)           √    耗时\nSTART_USER_ID_               起草人       nvarchar(255)         √    起草人\nSTART_ACT_ID_                开始节点ID    nvarchar(255)         √    起草环节ID\nEND_ACT_ID_                  结束节点ID    nvarchar(255)         √    结束环节ID\nSUPER_PROCESS_INSTANCE_ID_   父流程实例ID   nvarchar(64)          √    父流程实例ID\nDELETE_REASON_               删除原因      nvarchar(4000)        √    删除原因\n\n索引\n\n名称                        字段                             类型\nPROC_INST_ID_             PROC_INST_ID_                  UNIQUE\nACT_UNIQ_HI_BUS_KEY       PROC_DEF_ID_ , BUSINESS_KEY_   UNIQUE\nACT_IDX_HI_PRO_INST_END   END_TIME_                      NORMAL\nACT_IDX_HI_PRO_I_BUSKEY   BUSINESS_KEY_                  NORMAL\n\n# act_hi_taskinst\n\n历史任务实例表\n\n字段名称              字段描述           数据类型             主键   为空   取值说明\nID_               ID_            nvarchar(64)     √         主键ID\nPROC_DEF_ID_      流程定义ID         nvarchar(64)          √    流程定义ID\nTASK_DEF_KEY_     节点定义ID         nvarchar(255)         √    节点定义ID\nPROC_INST_ID_     流程实例ID         nvarchar(64)          √    流程实例ID\nEXECUTION_ID_     执行实例ID         nvarchar(64)          √    执行实例ID\nNAME_             名称             varchar(255)          √    名称\nPARENT_TASK_ID_   父节点实例ID        nvarchar(64)          √    父节点实例ID\nDESCRIPTION_      描述             nvarchar(400)         √    描述\nOWNER_            实际签收人 任务的拥有者   nvarchar(255)         √    签收人（默认为空，只有在委托时才有值）\nASSIGNEE_         签收人或被委托        nvarchar(255)         √    签收人或被委托\nSTART_TIME_       开始时间           datetime                   开始时间\nCLAIM_TIME_       提醒时间           datetime              √    提醒时间\nEND_TIME_         结束时间           datetime              √    结束时间\nDURATION_         耗时             numeric(19)           √    耗时\nDELETE_REASON_    删除原因           nvarchar(4000)        √    删除原因(completed,deleted)\nPRIORITY_         优先级别           int                   √    优先级别\nDUE_DATE_         过期时间           datetime              √    过期时间，表明任务应在多长时间内完成\nFORM_KEY_         节点定义的formkey   nvarchar(255)         √    desinger节点定义的form_key属性\n\n# act_hi_varinst\n\n历史变量表\n\n字段名称            字段描述      数据类型            主键   为空   取值说明\nID_             ID_       nvarchar(64)    √         ID_\nPROC_INST_ID_   流程实例ID    nvarchar(64)         √    流程实例ID\nEXECUTION_ID_   执行实例ID    nvarchar(255)        √    执行实例ID\nTASK_ID_        任务实例ID    nvarchar(64)         √    任务实例ID\nNAME_           名称        nvarchar(64)              参数名称(英文)\nVAR_TYPE_       参数类型      varchar(255)         √    备注5\nREV_            乐观锁       nvarchar(64)         √    乐观锁 Version\nBYTEARRAY_ID_   字节表ID     nvarchar(400)        √    ACT_GE_BYTEARRAY表的主键\nDOUBLE_         DOUBLE_   nvarchar(255)        √    存储DoubleType类型的数据\nLONG_           LONG_     nvarchar(255)        √    存储LongType类型的数据\nTEXT_           TEXT_     datetime             √    备注6\nTEXT2_          TEXT2_    datetime             √    此处存储的是JPA持久化对象时，才会有值。此值为对象ID\n\n索引\n\n名称                             字段                  类型\nACT_IDX_HI_PROCVAR_PROC_INST   PROC_INST_ID_       NORMAL\nACT_IDX_HI_PROCVAR_NAME_TYPE   NAME_ , VAR_TYPE_   NORMAL\n\n# act_id_group\n\n用户组信息表\n\n字段名称    字段描述   数据类型            主键   为空   取值说明\nID_     ID_    nvarchar(64)    √         主键ID\nREV_    乐观锁    int                  √    乐观锁Version\nNAME_   名称     nvarchar(255)        √    组名称\nTYPE_   类型     nvarchar(255)        √    类型\n\n# act_id_info\n\n用户扩展信息表\n\n字段名称         字段描述   数据类型            主键   为空   取值说明\nID_          ID_    nvarchar(64)    √         主键ID\nREV_         乐观锁    int                  √    乐观锁Version\nUSER_ID_     用户ID   nvarchar(64)         √    \nTYPE_        类型     nvarchar(64)         √    \nKEY_                nvarchar(255)        √    \nVALUE_              nvarchar(255)        √    \nPASSWORD_           Image                √    \nPARENT_ID_          nvarchar(255)        √    \n\n# act_id_membership\n\n用户与分组对应信息表\n\n用来保存用户的分组信息\n\n字段名称       字段描述    数据类型           主键   为空   取值说明\nUSER_ID    用户ID    nvarchar(64)   √         \nGROUP_ID   用户组ID   nvarchar(64)   √         \n\n索引\n\n名称                  字段          类型\nACT_FK_MEMB_GROUP   GROUP_ID_   NORMAL\n\n# act_id_user\n\n用户信息表\n\n字段名称          字段描述     数据类型            主键   为空   取值说明\nID_           ID_      nvarchar(64)    √         主键ID\nREV_          乐观锁      int                  √    乐观锁Version\nFIRST_        姓        nvarchar(255)        √    \nLAST_         名        nvarchar(255)        √    \nEMAIL_        EMAIL_   nvarchar(255)        √    \nPWD_          密码       nvarchar(255)        √    \nPICTURE_ID_   图片ID     nvarchar(64)         √    \n\n# act_re_deployment\n\n部署信息表\n\n部署流程定义时需要被持久化保存下来的信息\n\n字段名称           字段描述   数据类型            主键   为空   取值说明\nID_            ID_    nvarchar(64)    √         主键ID\nNAME_          部署名称   nvarchar(255)        √    部署文件名\nCATEGORY_      分类     nvarchar(255)        √    类别\nDEPLOY_TIME_   部署时间   datetime             √    部署时间\n\n# act_re_model\n\n流程设计模型部署表\n\n流程设计器设计流程后，保存数据到该表\n\n字段名称                            字段描述         数据类型            主键   为空   取值说明\nID_                             ID_          nvarchar(64)    √         ID_\nREV_                            乐观锁          int                  √    乐观锁\nNAME_                           名称           nvarchar(255)        √    名称\nKEY_                            KEY_         nvarchar(255)        √    分类\nCATEGORY_                       分类           nvarchar(255)        √    分类\nCREATE_TIME_                    创建时间         datetime             √    创建时间\nLAST_UPDATE_TIME_               最新修改时间       datetime             √    最新修改时间\nVERSION_                        版本           int                  √    版本\nMETA_INFO_                      META_INFO_   nvarchar(255)        √    以json格式保存流程定义的信息\nDEPLOYMENT_ID_                  部署ID         nvarchar(255)        √    部署ID\nEDITOR_SOURCE_VALUE_ID_                      datetime             √    \nEDITOR_SOURCE_EXTRA_VALUE_ID_                datetime             √    \n\n索引\n\n名称                          字段                              类型\nACT_FK_MODEL_SOURCE         EDITOR_SOURCE_VALUE_ID_         NORMAL\nACT_FK_MODEL_SOURCE_EXTRA   EDITOR_SOURCE_EXTRA_VALUE_ID_   NORMAL\nACT_FK_MODEL_DEPLOYMENT     DEPLOYMENT_ID_                  NORMAL\n\n# act_re_procdef\n\n流程定义数据表\n\n> 业务流程定义数据表。此表和 act_re_deployment 是多对一的关系，一个部署的bar包里可能包含多个流程定义文件，每个流程定义文件都会有一条记录在 act_re_procdef表内，每个流程定义的数据，都会对于 act_ge_bytearray表内的一个资源文件和 PNG 图片文件。和 act_ge_bytearray的关联是通过程序用 act_ge_bytearray.NAME 与 act_re_procdef.NAME 完成的，在数据库表结构中没有体现。\n\n字段名称                  字段描述              数据类型             主键   为空   取值说明\nID_                   ID_               nvarchar(64)     √         ID_\nREV_                  乐观锁               int                   √    乐观锁\nCATEGORY_             分类                nvarchar(255)         √    流程定义的Namespace就是类别\nNAME_                 名称                nvarchar(255)         √    名称\nKEY_                  定义的KEY            nvarchar(255)              流程定义ID\nVERSION_              版本                int                        版本\nDEPLOYMENT_ID_        部署表ID             nvarchar(64)          √    部署表ID\nRESOURCE_NAME_        bpmn文件名称          nvarchar(4000)        √    流程bpmn文件名称\nDGRM_RESOURCE_NAME_   png图片名称           nvarchar(4000)        √    流程图片名称\nDESCRIPTION_          描述                nvarchar(4000)        √    描述\nHAS_START_FORM_KEY_   是否存在开始节点formKey   tinyint               √    start节点是否存在formKey 0否 1是\nSUSPENSION_STATE_     是否挂起              tinyint               √    1 激活 2挂起\n\n索引\n\n名称                 字段                类型\nACT_UNIQ_PROCDEF   KEY_ , VERSION_   UNIQUE\n\n# act_ru_event_subscr\n\n> 事件订阅表（act_ru_event_subscr）\n\n事件订阅表。此表包含所有当前存在的事件订阅。它包括预期事件的类型，名称和配置，以及有关相应流程实例和执行的信息。\n\n字段名称             字段描述     数据类型            主键   为空   取值说明\nID_              事件ID     nvarchar(64)    √         事件ID\nREV_             版本       int                  √    乐观锁Version\nEVENT_TYPE_      事件类型     nvarchar(255)             事件类型\nEVENT_NAME_      事件名称     nvarchar(255)        √    事件名称\nEXECUTION_ID_    执行实例ID   nvarchar(64)         √    执行实例ID\nPROC_INST_ID_    流程实例ID   nvarchar(64)         √    流程实例ID\nACTIVITY_ID_     活动实例ID   nvarchar(64)         √    活动实例ID\nCONFIGURATION_   配置       nvarchar(255)        √    配置\nCREATED_         是否创建     datetime                  默认值 当前系统时间戳CURRENT_TIMESTAMP\n\n索引\n\n名称                             字段               类型\nACT_IDX_EVENT_SUBSCR_CONFIG_   CONFIGURATION_   NORMAL\nACT_FK_EVENT_EXEC              EXECUTION_ID_    NORMAL\n\n# act_ru_execution\n\n> 运行时流程执行实例表( act_ru_execution )\n\n字段名称                字段描述              数据类型            主键   为空   取值说明\nID_                 ID_               nvarchar(64)    √         ID_\nREV_                乐观锁               int                  √    乐观锁\nPROC_INST_ID_       流程实例ID            nvarchar(64)              流程实例ID\nBUSINESS_KEY_       业务主键ID            nvarchar(255)        √    业务主键ID\nPARENT_ID_          父节点实例ID           nvarchar(64)         √    父节点实例ID\nPROC_DEF_ID_        流程定义ID            nvarchar(64)         √    流程定义ID\nSUPER_EXEC_         SUPER_EXEC_       nvarchar(64)         √    SUPER_EXEC_\nACT_ID_             节点实例ID            nvarchar(255)        √    节点实例ID即ACT_HI_ACTINST中ID\nIS_ACTIVE_          是否存活              tinyint              √    是否存活\nIS_CONCURRENT_      是否并行              tinyint              √    是否为并行(true/false）\nIS_SCOPE_           IS_SCOPE_         tinyint              √    IS_SCOPE_\nIS_EVENT_SCOPE_     IS_EVENT_SCOPE_   tinyint              √    IS_EVENT_SCOPE_\nSUSPENSION_STATE_   是否挂起              tinyint              √    挂起状态 1激活 2挂起\nCACHED_ENT_STATE_                     int                  √    \n\n索引\n\n名称                    字段                             类型\nACT_UNIQ_RU_BUS_KEY   PROC_DEF_ID_ , BUSINESS_KEY_   UNIQUE\nACT_IDX_EXEC_BUSKEY   BUSINESS_KEY_                  NORMAL\nACT_FK_EXE_PROCINST   PROC_INST_ID_                  NORMAL\nACT_FK_EXE_PARENT     PARENT_ID_                     NORMAL\nACT_FK_EXE_SUPER      SUPER_EXEC_                    NORMAL\n\n# act_ru_identitylink\n\n> 运行时流程人员表( act_ru_identitylink )\n\n任务参与者数据表。主要存储当前节点参与者的信息。\n\n字段名称            字段描述     数据类型            主键   为空   取值说明\nID_             ID_      nvarchar(64)    √         ID_\nREV_            乐观锁      int                  √    乐观锁\nGROUP_ID_       组ID      nvarchar(64)         √    组ID\nTYPE_           类型       nvarchar(255)        √    备注7\nUSER_ID_        用户ID     nvarchar(64)         √    用户ID\nTASK_ID_        节点实例ID   nvarchar(64)         √    节点实例ID\nPROC_INST_ID_   流程实例ID   nvarchar(64)         √    流程实例ID\nPROC_DEF_ID_    流程定义ID   nvarchar(255)        √    流程定义ID\n\n索引\n\n名称                        字段              类型\nACT_IDX_IDENT_LNK_USER    USER_ID_        NORMAL\nACT_IDX_IDENT_LNK_GROUP   GROUP_ID_       NORMAL\nACT_IDX_ATHRZ_PROCEDEF    PROC_DEF_ID_    NORMAL\nACT_FK_TSKASS_TASK        TASK_ID_        NORMAL\nACT_FK_IDL_PROCINST       PROC_INST_ID_   NORMAL\n\n# act_ru_job\n\n> 运行时定时任务数据表( act_ru_job )\n\n字段名称                   字段描述     数据类型             主键   为空   取值说明\nID_                    标识       nvarchar(64)     √         标识\nREV_                   版本       int                   √    版本\nTYPE_                  类型       nvarchar(255)              类型\nLOCK_EXP_TIME_         锁定释放时间   datetime              √    锁定释放时间\nLOCK_OWNER_            挂起者      nvarchar(255)         √    挂起者\nEXCLUSIVE_                      bit                   √    \nEXECUTION_ID_          执行实例ID   nvarchar(64)          √    执行实例ID\nPROCESS_INSTANCE_ID_   流程实例ID   nvarchar(64)          √    流程实例ID\nPROC_DEF_ID_           流程定义ID   nvarchar(64)          √    流程定义ID\nRETRIES_                        int                   √    \nEXCEPTION_STACK_ID_    异常信息ID   nvarchar(64)          √    异常信息ID\nEXCEPTION_MSG_         异常信息     nvarchar(4000)        √    异常信息\nDUEDATE_               到期时间     datetime              √    到期时间\nREPEAT_                重复       nvarchar(255)         √    重复\nHANDLER_TYPE_          处理类型     nvarchar(255)         √    处理类型\nHANDLER_CFG_                    nvarchar(4000)        √    标识\n\n索引\n\n名称                     字段                    类型\nACT_FK_JOB_EXCEPTION   EXCEPTION_STACK_ID_   NORMAL\n\n# act_ru_task\n\n> 运行时任务节点表( act_ru_task )\n\n字段名称                字段描述       数据类型             主键   为空   取值说明\nID_                 ID_        nvarchar(64)     √         ID_\nREV_                乐观锁        int                   √    乐观锁\nEXECUTION_ID_       执行实例ID     nvarchar(64)          √    执行实例ID\nPROC_INST_ID_       流程实例ID     nvarchar(64)          √    流程实例ID\nPROC_DEF_ID_        流程定义ID     nvarchar(64)          √    流程定义ID\nNAME_               节点定义名称     nvarchar(255)         √    节点定义名称\nPARENT_TASK_ID_     父节点实例ID    nvarchar(64)          √    父节点实例ID\nDESCRIPTION_        节点定义描述     nvarchar(4000)        √    节点定义描述\nTASK_DEF_KEY_       节点定义的KEY   nvarchar(255)         √    任务定义的ID\nOWNER_              实际签收人      nvarchar(255)         √    拥有者（一般情况下为空，只有在委托时才有值）\nASSIGNEE_           签收人或委托人    nvarchar(255)         √    签收人或委托人\nDELEGATION_         委托类型       nvarchar(64)          √    备注8\nPRIORITY_           优先级别       int                   √    优先级别，默认为：50\nCREATE_TIME_        创建时间       datetime              √    创建时间\nDUE_DATE_           过期时间       datetime              √    耗时\nSUSPENSION_STATE_   是否挂起       int                   √    1代表激活 2代表挂起\n\n索引\n\n名称                     字段              类型\nACT_IDX_TASK_CREATE    CREATE_TIME_    NORMAL\nACT_FK_TASK_EXE        EXECUTION_ID_   NORMAL\nACT_FK_TASK_PROCINST   PROC_INST_ID_   NORMAL\nACT_FK_TASK_PROCDEF    PROC_DEF_ID_    NORMAL\n\n# act_ru_variable\n\n> 运行时流程变量数据表( act_ru_variable )\n\n字段名称            字段描述      数据类型             主键   为空   取值说明\nID_             ID_       nvarchar(64)     √         主键标识\nREV_            乐观锁       int                   √    乐观锁\nTYPE_           类型        nvarchar(255)              备注9\nNAME_           名称        nvarchar(255)              变量名称\nEXECUTION_ID_   执行实例ID    nvarchar(64)          √    执行的ID\nPROC_INST_ID_   流程实例ID    nvarchar(64)          √    流程实例ID\nTASK_ID_        节点实例ID    nvarchar(64)          √    节点实例ID(Local）\nBYTEARRAY_ID_   字节表ID     nvarchar(64)          √    字节表的ID（ACT_GE_BYTEARRAY）\nDOUBLE_         DOUBLE_   float                 √    存储变量类型为Double\nLONG_           LONG_     numeric(19)           √    存储变量类型为long\nTEXT_           TEXT_     nvarchar(4000)        √    存储变量值类型为String 如此处存储持久化对象时，值jpa对象的class\nTEXT2_          TEXT2_    nvarchar(4000)        √    此处存储的是JPA持久化对象时，才会有值。此值为对象ID\n\n索引\n\n名称                         字段              类型\nACT_IDX_VARIABLE_TASK_ID   TASK_ID_        NORMAL\nACT_FK_VAR_EXE             EXECUTION_ID_   NORMAL\nACT_FK_VAR_PROCINST        PROC_INST_ID_   NORMAL\nACT_FK_VAR_BYTEARRAY       BYTEARRAY_ID_   NORMAL\n\n\n# IDEA应用Activiti\n\nIDEA安装插件：Activiti BPMN visualize\n\n安装第三方：Camunda （Camunda应用：https://zhuanlan.zhihu.com/p/375908620\n\nQA：有了Activiti BPMN visualize为什么还要安装呢？\n\n 1. idea2021不能兼容常用的actiBPM\n 2. Activiti BPMN visualize 会找不到加入监听器的功能\n 3. 关于 assignee 失效 解决办法：将camunda 替换为 activiti，命名空间改为activity的命名空间，\n    1. 加入xmlns:activiti=“http://activiti.org/bpmn”\n    2. camunda改为activiti\n\n\n# SSM整合Activiti\n\n步骤：\n\n 1. 引入Activiti配置。在Spring的xml配置中引入 ====\n\n 2. 配置Activiti配置 activiti-context.xml\n    \n    <?xml version="1.0" encoding="UTF-8"?>\n    <beans xmlns="http://www.springframework.org/schema/beans"\n           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n           xsi:schemaLocation="http://www.springframework.org/schema/beans \n           http://www.springframework.org/schema/beans/spring-beans.xsd\n    ">\n    \n        \x3c!-- spring负责创建流程引擎的配置文件 --\x3e\n        <bean id="processEngineConfiguration" class="org.activiti.spring.SpringProcessEngineConfiguration">\n            \x3c!-- 数据源 --\x3e\n            <property name="dataSource" ref="dataSource"/>\n            \x3c!-- 配置事务管理器，统一事务 --\x3e\n            <property name="transactionManager" ref="transManager"/>\n            \x3c!-- 设置建表策略，如果没有表，自动创建表 --\x3e\n            <property name="databaseSchemaUpdate" value="true"/>\n        </bean>\n        \x3c!-- 创建流程引擎对象 --\x3e\n        <bean id="processEngine" class="org.activiti.spring.ProcessEngineFactoryBean">\n            <property name="processEngineConfiguration" ref="processEngineConfiguration"/>\n        </bean>\n    \n        \x3c!-- 由流程引擎对象，提供的方法，创建项目中使用的Activiti工作流的Service --\x3e\n        <bean id="repositoryService" factory-bean="processEngine" factory-method="getRepositoryService"/>\n        <bean id="runtimeService" factory-bean="processEngine" factory-method="getRuntimeService"/>\n        <bean id="taskService" factory-bean="processEngine" factory-method="getTaskService"/>\n        <bean id="historyService" factory-bean="processEngine" factory-method="getHistoryService"/>\n        <bean id="formService" factory-bean="processEngine" factory-method="getFormService"/>\n    \n    </beans>\n    \n    \n    > PS： Spring配置的上下中有 事务(transManager)、数据库连接源(dataSource)\n\n 3. Serivce业务应用。自动注入服务对象即可\n    \n    @Service\n    public class ActivitiServiceImpl implements ActivitiService {\n    \t@Autowired\n        private RepositoryService repositoryService;\n        @Autowired\n        private RuntimeService runtimeService;\n        @Autowired\n        private TaskService taskService;\n        @Autowired\n        private HistoryService historyService;\n        @Autowired\n        private FormService formService;\n        \n        ....\n    }\n    ',normalizedContent:'# activiti\n\nactiviti5手册：http://shouce.jb51.net/activiti/#download\n\nactiviti api：https://www.activiti.org/javadocs/index.html\n\n\n# 简介\n\nactiviti工作流。由多任务人协同完成的一个复杂的业务流的框架\n\n它能够对业务流程自动化的管理，而且也是多人共同完成的一个流程任务的业务\n\n特点：\n\n * 图形化，把复杂的业务流进行图形化处理\n * 数据化，图形化的业务部署到流程数据库中\n * 流程表，流程数据库，共有23张表\n * api，提供了一套api，业务对象\n * 持久层： mybatis实现\n\n\n# 首次应用\n\n应用的前提首先需要深层数据库，需要数据库进行\n\n步骤：\n\n 1. 引入jar包\n 2. 生成数据库\n 3. 流程绘制\n 4. 创建流程引擎\n 5. 流程部署\n 6. 流程启动\n 7. 流程业务\n\n\n# jar包引入\n\njar包下载：https://mvnrepository.com/artifact/org.activiti/activiti-engine\n\nmaven引入：\n\n<dependencies>\n    \x3c!--activiti的核心包--\x3e\n    <dependency>\n        <groupid>org.activiti</groupid>\n        <artifactid>activiti-engine</artifactid>\n        <version>6.0.0</version>\n    </dependency>\n    <dependency>\n        <groupid>org.activiti</groupid>\n        <artifactid>activiti-spring</artifactid>\n        <version>6.0.0</version>\n    </dependency>\n    <dependency>\n        <groupid>org.activiti</groupid>\n        <artifactid>activiti-bpmn-model</artifactid>\n        <version>6.0.0</version>\n    </dependency>\n    <dependency>\n        <groupid>javax.servlet</groupid>\n        <artifactid>servlet-api</artifactid>\n        <version>2.5</version>\n    </dependency>\n    <dependency>\n        <groupid>org.activiti</groupid>\n        <artifactid>activiti-bpmn-converter</artifactid>\n        <version>6.0.0</version>\n    </dependency>\n    <dependency>\n        <groupid>org.activiti</groupid>\n        <artifactid>activiti-json-converter</artifactid>\n        <version>6.0.0</version>\n    </dependency>\n    <dependency>\n        <groupid>org.activiti</groupid>\n        <artifactid>activiti-bpmn-layout</artifactid>\n        <version>6.0.0</version>\n    </dependency>\n    <dependency>\n        <groupid>org.activiti.cloud</groupid>\n        <artifactid>activiti-cloud-services-api</artifactid>\n        <version>7-201710-ea</version>\n    </dependency>\n    <dependency>\n        <groupid>aspectj</groupid>\n        <artifactid>aspectjweaver</artifactid>\n        <version>1.5.4</version>\n    </dependency>\n    <dependency>\n        <groupid>mysql</groupid>\n        <artifactid>mysql-connector-java</artifactid>\n        <version>5.1.40</version>\n    </dependency>\n    <dependency>\n        <groupid>org.springframework</groupid>\n        <artifactid>spring-test</artifactid>\n        <version>5.0.7.release</version>\n    </dependency>\n    <dependency>\n        <groupid>org.springframework</groupid>\n        <artifactid>spring-core</artifactid>\n        <version>4.1.6.release</version>\n    </dependency>\n    <dependency>\n        <groupid>org.mybatis</groupid>\n        <artifactid>mybatis</artifactid>\n        <version>3.4.5</version>\n    </dependency>\n    <dependency>\n        <groupid>commons-dbcp</groupid>\n        <artifactid>commons-dbcp</artifactid>\n        <version>1.4</version>\n    </dependency>\n    <dependency>\n        <groupid>junit</groupid>\n        <artifactid>junit</artifactid>\n        <version>4.12</version>\n    </dependency>\n    <dependency>\n        <groupid>log4j</groupid>\n        <artifactid>log4j</artifactid>\n        <version>1.2.17</version>\n    </dependency>\n    <dependency>\n        <groupid>org.slf4j</groupid>\n        <artifactid>slf4j-log4j12</artifactid>\n        <version>1.7.21</version>\n    </dependency>\n    <dependency>\n        <groupid>org.slf4j</groupid>\n        <artifactid>slf4j-api</artifactid>\n        <version>1.7.25</version>\n    </dependency>\n    <dependency>\n        <groupid>commons-io</groupid>\n        <artifactid>commons-io</artifactid>\n        <version>2.6</version>\n    </dependency>\n    <dependency>\n        <groupid>org.projectlombok</groupid>\n        <artifactid>lombok</artifactid>\n        <version>1.16.18</version>\n        <scope>provided</scope>\n    </dependency>\n</dependencies>\n\n\n\n# 生成数据库\n\nactiviti生成库的方式有两种分别是：\n\n * java程序 纯jdbc 生成\n * spring生成\n\n# jdbc生成\n\n步骤：\n\n 1. 创建 配置文件 引擎对象\n 2. 配置 数据库连接源\n 3. 解决 重复覆盖问题\n 4. 获取 流程引擎对象\n\n@test\npublic void jdbc() {\n    /** 步骤：\n     *  1. 创建 配置文件对象\n     *  2. 配置 数据库连接源\n     *  3. 解决 重复覆盖问题\n     *  4. 获取 流程引擎对象\n     */\n\n    // 1. 流程引擎 配置对象\n    processengineconfiguration config = processengineconfiguration.createstandaloneprocessengineconfiguration();\n\n    // 2. 连接库的数据源配置\n    config.setjdbcdriver("com.mysql.cj.jdbc.driver");\n    config.setjdbcurl("jdbc:mysql://localhost:3306/activiti?servertimezone=utc");\n    config.setjdbcusername("root");\n    config.setjdbcpassword("root");\n\n    // 3. 解决已存在被覆盖问题\n    config.setdatabaseschemaupdate(processengineconfiguration.db_schema_update_true);\n\n    // 4. 获取 流程引擎对象\n    processengine processengine = config.buildprocessengine();\n    system.out.println("processengine = " + processengine);\n}\n\n\n# spring生成\n\n> spring loc 配置启动应用即可，搭建主要在 loc 中托管 配置文件对象！！\n\nactiviti.cfg.xml配置文件\n\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:context="http://www.springframework.org/schema/context" \n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xsi:schemalocation="\n       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd\n">\n\n    <bean id="processengineconfiguration"\n          class="org.activiti.engine.impl.cfg.standaloneprocessengineconfiguration">\n        \x3c!-- 连接数据的配置 --\x3e\n        <property name="jdbcdriver" value="com.mysql.cj.jdbc.driver"/>\n        <property name="jdbcurl"\n                  value="jdbc:mysql://localhost:3306/activiti?servertimezone=utc"/>\n        <property name="jdbcusername" value="root"/>\n        <property name="jdbcpassword" value="root"/>\n        \x3c!-- 没有表创建表 --\x3e\n        <property name="databaseschemaupdate" value="true"/>\n        \x3c!--\n            其余可以在这里进行其他配置\n        --\x3e\n    </bean>\n\n</beans>\n\n\n测试启动\n\n@test\npublic void spring() {\n    processengineconfiguration config = processengineconfiguration.createprocessengineconfigurationfromresource("activiti.cfg.xml");\n\n    config.buildprocessengine();\n    system.out.println("config = " + config);\n}\n\n\n\n# 流程绘制\n\nbpmn是 activit定义绘制的流程图，它主要用来描述业务流程的基本的符号，一般情况是通过工具进行绘制的一个流程图，流程图的原始文件其实是 xml形式 的文件\n\n绘制方式有很多中：（可以自行选择\n\n * eclipse自带的绘制工具\n\n * idea插件 activiti bpmn visualize 缺陷：不能添加侦听器功能\n\n * 第三方绘制工具 camunda\n   \n   缺陷：部分标签名不同，导致兼容问题 组件手册：https://docs.camunda.io/docs/components/\n\n# 图形符号\n\n事件event （圆形\n\n * start event 启动事件\n\n * intermediate event 中间事件\n\n * end event 结束时间\n\n活动activity （长方形 圆角\n\n * user task 用户任务 （用户\n * service task 服务任务 （齿轮\n * sub process 子流程 （添加\n\n网关gateway\n\n。。。。\n\n流向\n\n。。。。\n\n\n# 流程引擎\n\n工作流引擎 的创建主要有两种方式：\n\n * new 硬编码生成\n * loc 容器托管生成\n\n> 上面生成数据库的步骤也有！\n\nnew 硬编码生成\n\nprocessengine processengine = processengines.getdefaultprocessengine();\n\n\nloc 容器托管生成\n\nprocessengineconfiguration processengineconfiguration = processengineconfiguration.createprocessengineconfigurationfromresource("activiti.cfg.xml");\n// 获取流程引擎对象:通过 processengineconfiguration 创建 processengine\nprocessengine processengine = processengineconfiguration.buildprocessengine();\n\n\n\n# 部署流程\n\n流程部署通过 repositoryservice资源管理类 进行部署，部署形式有两种方式：\n\n * 单文件部署 bpmn文件 和 png文件 逐个处理\n * 压缩包流程部署 bpmn文件 和 png文件 zip压缩统一处理\n\n部署信息涉及表有：\n\n * act_re_deployment\n * act_re_procdef\n * act_ge_bytearray\n * act_ge_property\n\n# 单文件部署\n\n@test\npublic void deploy() {\n    // 流程引擎\n    processengine processengine = processengines.getdefaultprocessengine();\n    deployment deploy = processengine.getrepositoryservice()\n            .createdeployment()\n            .name("请假流程")\n            .addclasspathresource("diagram/askforleave.bpmn20.xml")\n            .addclasspathresource("image/askforleave.png")\n            .deploy();\n    // 输出信息代表成功 （部署的 id/name\n    system.out.println("deploy.getid() = " + deploy.getid());\n    system.out.println("deploy.getname() = " + deploy.getname());\n}\n\n\n# 压缩包部署\n\n@test\npublic void deployprocessbyzip() {\n    // 获取流程引擎\n    processengine processengine = processengines.getdefaultprocessengine();\n    repositoryservice repositoryservice = processengine.getrepositoryservice();\n    // 流程部署\n    // 解释：通过 类加载器src的根路径下找 bpmn/evection.zip 加载读取为二进制流\n    inputstream inputstream = this.getclass().getclassloader().getresourceasstream("bpmn/evection.zip");\n    // 使用 inputstream 构造 zipinputstream\n    zipinputstream zipinputstream = new zipinputstream(inputstream);\n    // 使用压缩包的流，进行流程的部署\n    deployment deploy = repositoryservice.createdeployment()\n            .addzipinputstream(zipinputstream)\n            .deploy();\n    // 输出信息代表成功 （部署的 id/name\n    system.out.println("deploy.getid() = " + deploy.getid());\n    system.out.println("deploy.getname() = " + deploy.getname());\n}\n\n\n\n# 启动流程\n\n流程部署完成以后，通过 runtimeservice流程运行管理类 启动实例，是根据流程定义的 key进行启动\n\n该启动的 startprocessinstancebykey()方法 重载了4个方法：(划分参数说明)\n\n * startprocessinstancebykey(string key) 根据部署后的key进行启动流程（key在库中的 act_re_procdef.key_字段查到\n * startprocessinstancebykey(string key, string businesskey) 根据key进行启动，并且 绑定关联key （用于绑定 任务id/单子id 的关键信息 在库中的 act_hi_procinst.business_key_字段查到\n * startprocessinstancebykey(string key, map<string, object> map) 根据key进行启动，并且 设置流程变量 （在表绘制的时候会根据指定key赋予value值\n * startprocessinstancebykey(string key, string businesskey, map<string, object> map) 以上说明的功能已经要点都有（启动key、绑定关联key、设置流程变量）\n\n@test\npublic void startprocess() {\n    // 请假流程key\n    string key = "askforleave";\n    // 请假单id (leave.12)\n    int id = 12;\n    string businesskey = "leave."+id;\n    // map 传递流程变量\n    map<string, object> map = new hashmap<>();\n    map.put("name","张三");\n    processinstance pi = processengine.getruntimeservice().\n            startprocessinstancebykey(key,businesskey,map);\n    system.out.println("pi.getid(): " + pi.getid());\n    system.out.println("pi.getprocessdefinitionid(): " + pi.getprocessdefinitionid());\n}\n\n\n\n# 流程业务\n\n流程业务可以根据以下api进行详细操作，以下展示常用的 流程业务操作\n\n# 查询部署流程\n\n@autowired\nprivate repositoryservice repositoryservice;\npublic list<deployment> findalldeployment() {\n    return repositoryservice.createdeploymentquery().list();\n}\n\n\n# 查看定义流程\n\n@autowired\nprivate repositoryservice repositoryservice;\npublic list<processdefinition> findallprocessdefinitions() {\n    return repositoryservice.createprocessdefinitionquery().list();\n}\n\n\n# 个人任务\n\n@autowired\nprivate taskservice taskservice;\npublic list<task> findtasklistbyassignee(string name) {\n    return taskservice.createtaskquery().taskassignee(name).list();\n}\n\n\n# 流程推进\n\n@autowired\nprivate taskservice taskservice;\npublic void endtask(string taskid) {\n    taskservice.complete(taskid);\n}\n\n\n# 流程删除\n\n@autowired\nprivate repositoryservice repositoryservice;\npublic void testdel(string id) {\n    // 参数2：强制删除与该部署的流程 相关的历史/运行信息\n    repositoryservice.deletedeployment(id, true);\n}\n\n\n> 更多业务功能，可根据以下的api进行操作\n\n\n# activiti api\n\n官方api：https://www.activiti.org/javadocs/index.html\n\n\n# processengine\n\norg.activiti.engine.processengine 流程引擎配置接口\n\n提供 工作流操作的所有服务的访问以下都是\n\n类型       方法          说明\nvoid     close()     关闭\nstring   getname()   在配置 中的进程引擎名称，没有则默认\n\n\n# deploymentbuilder\n\norg.activiti.engine.repository.deploymentbuilder 创建新部署的生成器接口\n\n构建器实例可以通过 repositoryservice 获得createdeployment()\n\n可以在调用 deploy() 操作之前 将多个 资源/配置 添加到一个部署中。部署后，不能对返回的部署进行任何更改，可以销毁构建器实例 （点击应用实例\n\n常用方法\n\n类型                  方法                                                             说明\ndeployment          deploy()                                                       部署流程\ndeploymentbuilder   addclasspathresource(string resource)                          添加指定路径资源\ndeploymentbuilder   addinputstream(string resourcename, inputstream inputstream)   添加流形式的资源\ndeploymentbuilder   addzipinputstream(zipinputstream zipinputstream)               添加指定zip资源\ndeploymentbuilder   name(string name)                                              为流程指定名称\ndeploymentbuilder   category(string category)                                      为流程指定类别\n更多自行api             https://www.activiti.org/javadocs/index.html                   ....\n\n\n# deploymentquery\n\norg.activiti.engine.repository.deploymentquery 部署查询接口\n\n常用方法\n\n类型                方法                                                      说明\ndeploymentquery   deploymentcategory(string category)                     选择部署类型\ndeploymentquery   deploymentcategorynotequals(string categorynotequals)   选择类型取反\ndeploymentquery   deploymentid(string deploymentid)                       选择部署id\ndeploymentquery   deploymentname(string name)                             选择部署name\ndeploymentquery   deploymentnamelike(string namelike)                     模糊选择部署name\ndeploymentquery   processdefinitionkey(string key)                        选择流程key\ndeploymentquery   processdefinitionkeylike(string keylike)                模糊选择流程key\n更多自行api           https://www.activiti.org/javadocs/index.html            ...\n\n\n# processinstance\n\norg.activiti.engine.runtime.processinstance 流程实例接口\n\n常用方法\n\n类型        方法                                             说明\nstring    getbusinesskey()                               获取业务key\nstring    getdeploymentid()                              获取部署id\nstring    getdescription()                               获取 流程描述\nstring    getname()                                      获取 流程name\nstring    getprocessdefinitionid()                       获取流程id\nstring    getprocessdefinitionkey()                      获取流程key\nstring    getprocessdefinitionname()                     获取流程name\n更多自行api   https://www.activiti.org/javadocs/index.html   ....\n\n\n# processinstancequery\n\norg.activiti.engine.runtime.processinstancequery 流程实例查询接口\n\n常用方法\n\n类型                     方法                                               说明\nprocessinstancequery   processinstanceid(string id)                     选择流程实例id\nprocessinstancequery   processinstanceids(set<string> ids)              选择流程实例多个id\nprocessinstancequery   processinstancebusinesskey(string businesskey)   选择流程实例的业务id\n更多自行api                https://www.activiti.org/javadocs/index.html     ....\n\n\n# task\n\norg.activiti.engine.task.task 用户任务接口\n\n常用方法\n\n类型                方法                                                    说明\nvoid              delegate(string userid)                               将任务委托指定id的用户\ndelegationstate   getdelegationstate()                                  获取任务状态(代办/解决)\nboolean           issuspended()                                         任务是否挂起\nvoid              setassignee(string assignee)                          设置任务委托人\nvoid              setcategory(string category)                          设置任务类型\nvoid              setdelegationstate(delegationstate delegationstate)   设置任务状态(代办/解决)\nvoid              setdescription(string description)                    设置任务描述\nvoid              setduedate(date duedate)                              设置任务截止时间\nvoid              setformkey(string formkey)                            设置任务表单键\nvoid              setname(string name)                                  设置任务名称\nvoid              setowner(string owner)                                设置任务负责人id\nvoid              setpriority(int priority)                             设置任务重要程度\n更多自行api           https://www.activiti.org/javadocs/index.html          ....\n\n\n# taskquery\n\norg.activiti.engine.task.taskquery\n\n常用方法\n\n类型          方法                                                     说明\ntaskquery   active()                                               选择活动的任务\ntaskquery   excludesubtasks()                                      选择没有父节点的任务\ntaskquery   suspended()                                            选择被挂起的任务\ntaskquery   taskdelegationstate(delegationstate delegationstate)   选择指定状态的任务\ntaskquery   taskunassigned()                                       选择没有委托人的任务\n更多自行api     https://www.activiti.org/javadocs/index.html           ....\n\n\n# query\n\norg.activiti.engine.query.query<t extends query<?, ?>, u>\n\n该接口用于在以上业务查询功能\n\n常用方法\n\n类型        方法                                             说明\nt         asc()                                          对结果指定属性进行升序排序\nlong      count()                                        获取结果数\nt         desc()                                         对结果指定属性进行降序排序\nlist<u>   list()                                         查询并获取集合\nlist<u>   listpage(int firstresult, int maxresults)      查询并获取集合（开始位置 , 总量数）\nu         singleresult()                                 查询满足提交的结果（一条\n更多自行api   https://www.activiti.org/javadocs/index.html   ....\n\n\n# service\n\nactiviti提供了许多service服务接口，用于 用户业务流程的操作和查看\n\nservice总览\n\nservice名称           说明\nrepositoryservice   资源管理接口\nruntimeservice      流程运行管理接口\ntaskservice         任务管理接口\nhistoryservice      历史管理接口\n\n# repositoryservice\n\norg.activiti.engine.repositoryservice 资源管理接口\n\n**作用：**管理流程发布包 和 流程定义 的操作\n\n常用方法\n\n类型                  方法                                                       说明\ndeploymentbuilder   createdeployment()                                       部署流程\ndeploymentquery     createdeploymentquery()                                  查询部署\nlist<string>        getdeploymentresourcenames(string deploymentid)          根据id查资源列表\nlist<string>        getdeploymentresourcenames(string deploymentname)        根据name查资源列表\nvoid                deletedeployment(string deploymentid, boolean cascade)   删除部署资源，运行过程实例是否强制删除\n                    getresourceasstream()                                    \n更多自行api             https://www.activiti.org/javadocs/index.html             ....\n\n# runtimeservice\n\norg.activiti.engine.runtimeservice 流程运行管理接口\n\n**作用：**获取关于流程执行的相关信息\n\n常用方法\n\n类型                     方法                                             说明\nprocessinstance        startprocessinstancebykey()                    启动流程\nprocessinstancequery   createprocessinstancequery()                   查询正在运行的流程\n更多自行api                https://www.activiti.org/javadocs/index.html   ....\n\n# taskservice\n\norg.activiti.engine.taskservice 任务管理接口\n\n**作用：**获取与 任务/操作相关 的信息\n\n常用方法\n\n类型          方法                                                           说明\ntaskquery   createtaskquery()                                            创建任务查询对象\nvoid        complete(string id)                                          推进任务\nvoid        complete(string id, map<string, object> variables)           推进任务，成功后并填充参数\ncomment     addcomment(string taskid, string processinstanceid, string   添加批注。指定 任务id、流程实例id、消息\n            message)\ncomment     addcomment(string taskid, string processinstanceid, string   添加批注。指定 任务id、自定义类型、流程实例id、消息\n            type, string message)\n更多自行api     https://www.activiti.org/javadocs/index.html                 ....\n\n# historyservice\n\norg.activiti.engine.historyservice 历史管理接口\n\n**作用：**查询历史信息，执行流程时，引擎会保存很多数据（根据配置)\n\n> 这与运行时服务不同，因为该运行时信息只包含任何给定时刻的实际运行时状态，并且针对运行时流程执行性能进行了优化。历史信息经过优化，便于查询，并在持久存储中保持永久性\n\n常用方法\n\n类型                               方法                                                        说明\nhistoricprocessinstancequery     createhistoricprocessinstancequery()                      流程实例查询\nhistorictaskinstancequery        createhistorictaskinstancequery()                         任务实例查询\nhistoricvariableinstancequery    createhistoricvariableinstancequery()                     变量历史查询\nprocessinstancehistorylogquery   createprocessinstancehistorylogquery(string               流程实例日志查询\n                                 processinstanceid)\nvoid                             deletehistoricprocessinstance(string processinstanceid)   删除指定流程实例id历史记录\nvoid                             deletehistorictaskinstance(string taskid)                 删除指定任务id历史记录\n更多自行api                          https://www.activiti.org/javadocs/index.html              ....\n\n\n# activiti 数据库\n\nactiviti数据库有23张表，他们大致分类有：\n\n表名前缀       说明\nact_re_*   流程定义 和 流程资源\nact_ru_*   运行时、流程实例、任务、变量\nact_hi_*   流程历史\nact_ge_*   通用表\n\n\n# 常用表\n\n表名                  说明\nact_ge_bytearray    通用流程定义/流程资源\nact_re_deployment   部署流程信息\nact_re_procdef      已部署的流程定义\nact_ru_execution    运行时流程执行实例\nact_ru_task         运行时任务\nact_re_procdef      已部署的流程定义\nact_hi_procinst     历史的流程实例\nact_hi_taskinst     历史的任务实例\n\n\n# 所有表\n\n表名                    说明\nact_ge_bytearray      通用流程定义/流程资源\nact_ge_property       系统相关属性\nact_hi_actinst        历史的流程节点\nact_hi_attachment     历史的流程附件\nact_hi_comment        历史的说明信息（批注\nact_hi_detail         历史的流程运行中的细节信息\nact_hi_identitylink   历史的流程运行过程中用户关系\nact_hi_procinst       历史的流程实例\nact_hi_taskinst       历史的任务实例\nact_hi_varinst        历史的流程运行中的变量信息\nact_id_group          用户组信息表\nact_id_info           用户详细信息表\nact_id_membership     用户与用户组对应信息表\nact_id_user           用户信息表\nact_re_deployment     部署流程信息\nact_re_model          模型信息\nact_re_procdef        已部署的流程定义\nact_ru_event_subscr   运行时事件\nact_ru_execution      运行时流程执行实例\nact_ru_identitylink   运行时用户关系信息，存储任务节点的参与信息\nact_ru_job            运行时作业\nact_ru_task           运行时任务\nact_ru_variable       运行时变量表\n\n# act_ge_bytearray\n\n二进制数据表，存储通用的流程定义和流程资源\n\n> 保存流程定义图片和xml、serializable(序列化)的变量，即保存所有二进制数据，特别注意类路径部署时候，不要把svn等隐藏文件或者其他与流程无关的文件也一起部署到该表中，会造成一些错误（可能导致流程定义无法删除）\n\n字段名称             字段描述      数据类型             主键   为空   取值说明\nid_              id_       nvarchar(64)     √         主键id\nrev_             乐观锁       int                   √    version(版本)\nname_            名称        nvarchar(255)         √    部署的文件名称，如：leave.bpmn.png,leave.bpmn20.xml\ndeployment_id_   部署id      nvarchar(64)          √    部署表id\nbytes_           字节        varbinary(max)        √    部署文件\ngenerated_       是否是引擎生成   tinyint               √    0为用户生成，1为activiti生成\n\n索引\n\n名称                    字段               类型               说明\nact_fk_bytearr_depl   deployment_id_   deployment_id_   id部署\n\n# act_ge_property\n\n属性数据表，存储整个流程引擎级别的数据\n\n字段名称     字段描述   数据类型            主键   为空   取值说明\nname_    名称     nvarchar(64)    √         schema.versionschema.historynext.dbid\nvalue_   值      nvarchar(300)        √    5.create(5.)\nrev_     乐观锁    int                  √    version\n\n# act_hi_actinst\n\n历史节点表，历史活动信息\n\n> 这里记录流程流转过的所有节点，与hi_taskinst不同的是，taskinst只记录usertask内容\n\n字段名称                 字段描述          数据类型            主键   为空   取值说明\nid_                  id_           nvarchar(64)    √         \nproc_def_id_         流程定义id        nvarchar(64)              \nproc_inst_id_        流程实例id        nvarchar(64)              \nexecution_id_        执行实例id        nvarchar(64)              \nact_id_              节点id          nvarchar(225)             节点定义id\ntask_id_             任务实例id        nvarchar(64)         √    任务实例id 其他节点类型实例id在这里为空\ncall_proc_inst_id_   调用外部的流程实例id   nvarchar(64)         √    调用外部流程的流程实例id’\nact_name_            节点名称          nvarchar(225)        √    节点定义名称\nact_type_            节点类型          nvarchar(225)             如startevent、usertask\nassignee_            签收人           nvarchar(64)         √    节点签收人\nstart_time_          开始时间          datetime                  2013-09-15 11:30:00\nend_time_            结束时间          datetime             √    2013-09-15 11:30:00\nduration_            耗时            numeric(19,0)        √    毫秒值\n\n索引\n\n名称                             字段              类型\nact_idx_hi_act_inst_start      start_time_     normal\nact_idx_hi_act_inst_end        end_time_       normal\nact_idx_hi_act_inst_procinst   proc_inst_id_   normal\nact_idx_hi_act_inst_exec       execution_id_   normal\n\n# act_hi_attachment\n\n历史附件表\n\n字段名称            字段描述     数据类型             主键   为空   取值说明\nid_             id_      nvarchar(64)     √         主键id\nrev_            乐观锁      integer               √    version\nuser_id_        用户id     nvarchar(255)         √    用户id\nname_           名称       nvarchar(255)         √    附件名称\ndescription_    描述       nvarchar(4000)        √    描述\ntype_           类型       nvarchar(255)         √    附件类型\ntask_id_        任务实例id   nvarchar(64)          √    节点实例id\nproc_inst_id_   流程实例id   nvarchar(64)          √    流程实例id\nurl_            url_     nvarchar(4000)        √    附件地址\ncontent_id_     字节表的id   nvarchar(64)          √    act_ge_bytearray的id\n\n# act_hi_comment\n\n字段名称            字段描述     数据类型             主键   为空   取值说明\nid_             id_      nvarchar(64)     √         主键id\ntype_           类型       nvarchar(255)         √    类型：event（事件）comment（意见）\ntime_           时间       datetime                   填写时间\nuser_id_        用户id     nvarchar(64)          √    填写人\ntask_id_        节点任务id   nvarchar(64)          √    节点实例id\nproc_inst_id_   流程实例id   nvarchar(255)         √    流程实例id\naction_         行为类型     nvarchar(64)          √    见备注1\nmessage_        基本内容     nvarchar(4000)        √    用于存放流程产生的信息，比如审批意见\nfull_msg_       全部内容     varbinary(max)        √    附件地址\n\n# act_hi_detail\n\n历史详情表\n\n流程中产生的变量详细，包括控制流程流转的变量，业务表单中填写的流程需要用到的变量等\n\n字段名称            字段描述      数据类型               主键   为空   取值说明\nid_             id_       nvarchar(64)       √         主键\ntype_           类型        nvarchar(255)                见备注2\nproc_inst_id_   流程实例id    nvarchar(64)            √    流程实例id\nexecution_id_   执行实例id    nvarchar(64)            √    执行实例id\ntask_id_        任务实例id    nvarchar(64)            √    任务实例id\nact_inst_id_    节点实例id    nvarchar(64)            √    act_hi_actinst表的id\nname_           名称        nvarchar(255)                名称\nvar_type_       参数类型      nvarchar(255)           √    见备注3\nrev_            乐观锁       int                     √    version\ntime_           时间戳       datetime                     创建时间\nbytearray_id_   字节表id     nvarchar                √    act_ge_bytearray表的id\ndouble_         double_   double precision        √    存储变量类型为double\nlong_           long_     numeric                 √    存储变量类型为long\ntext_           text_     nvarchar                √    存储变量值类型为string\ntext2_          text2_    nvarchar                √    此处存储的是jpa持久化对象时，才会有值。此值为对象id\n\n索引\n\n名称                            字段              类型\nact_idx_hi_detail_proc_inst   proc_inst_id_   normal\nact_idx_hi_detail_act_inst    act_inst_id_    normal\nact_idx_hi_detail_time        time_           normal\nact_idx_hi_detail_name        name_           normal\nact_idx_hi_detail_task_id     task_id_        normal\n\n# act_hi_identitylink\n\n历史流程人员表\n\n任务参与者数据表。主要存储历史节点参与者的信息\n\n字段名称            字段描述     数据类型            主键   为空   取值说明\nid_             id_      nvarchar(64)    √         id_\ngroup_id_       组id      nvarchar(255)        √    组id\ntype_           类型       nvarchar(255)        √    备注4\nuser_id_        用户id     nvarchar(255)        √    用户id\ntask_id_        节点实例id   nvarchar(64)         √    节点实例id\nproc_inst_id_   流程实例id   nvarchar(64)         √    流程实例id\n\n索引\n\n名称                              字段              类型\nact_idx_hi_ident_lnk_user       user_id_        normal\nact_idx_hi_ident_lnk_task       task_id_        normal\nact_idx_hi_ident_lnk_procinst   proc_inst_id_   normal\n\n# act_hi_procinst\n\n历史流程实例表\n\n字段名称                         字段描述      数据类型             主键   为空   取值说明\nid_                          id_       nvarchar(64)     √         主键id\nproc_inst_id_                流程实例id    nvarchar(64)               流程实例id\nbusiness_key_                业务主键      nvarchar(255)         √    业务主键，业务表单的id\nproc_def_id_                 流程定义id    nvarchar(64)               流程定义id\nstart_time_                  开始时间      datetime                   开始时间\nend_time_                    结束时间      datetime              √    结束时间\nduration_                    耗时        numeric(19)           √    耗时\nstart_user_id_               起草人       nvarchar(255)         √    起草人\nstart_act_id_                开始节点id    nvarchar(255)         √    起草环节id\nend_act_id_                  结束节点id    nvarchar(255)         √    结束环节id\nsuper_process_instance_id_   父流程实例id   nvarchar(64)          √    父流程实例id\ndelete_reason_               删除原因      nvarchar(4000)        √    删除原因\n\n索引\n\n名称                        字段                             类型\nproc_inst_id_             proc_inst_id_                  unique\nact_uniq_hi_bus_key       proc_def_id_ , business_key_   unique\nact_idx_hi_pro_inst_end   end_time_                      normal\nact_idx_hi_pro_i_buskey   business_key_                  normal\n\n# act_hi_taskinst\n\n历史任务实例表\n\n字段名称              字段描述           数据类型             主键   为空   取值说明\nid_               id_            nvarchar(64)     √         主键id\nproc_def_id_      流程定义id         nvarchar(64)          √    流程定义id\ntask_def_key_     节点定义id         nvarchar(255)         √    节点定义id\nproc_inst_id_     流程实例id         nvarchar(64)          √    流程实例id\nexecution_id_     执行实例id         nvarchar(64)          √    执行实例id\nname_             名称             varchar(255)          √    名称\nparent_task_id_   父节点实例id        nvarchar(64)          √    父节点实例id\ndescription_      描述             nvarchar(400)         √    描述\nowner_            实际签收人 任务的拥有者   nvarchar(255)         √    签收人（默认为空，只有在委托时才有值）\nassignee_         签收人或被委托        nvarchar(255)         √    签收人或被委托\nstart_time_       开始时间           datetime                   开始时间\nclaim_time_       提醒时间           datetime              √    提醒时间\nend_time_         结束时间           datetime              √    结束时间\nduration_         耗时             numeric(19)           √    耗时\ndelete_reason_    删除原因           nvarchar(4000)        √    删除原因(completed,deleted)\npriority_         优先级别           int                   √    优先级别\ndue_date_         过期时间           datetime              √    过期时间，表明任务应在多长时间内完成\nform_key_         节点定义的formkey   nvarchar(255)         √    desinger节点定义的form_key属性\n\n# act_hi_varinst\n\n历史变量表\n\n字段名称            字段描述      数据类型            主键   为空   取值说明\nid_             id_       nvarchar(64)    √         id_\nproc_inst_id_   流程实例id    nvarchar(64)         √    流程实例id\nexecution_id_   执行实例id    nvarchar(255)        √    执行实例id\ntask_id_        任务实例id    nvarchar(64)         √    任务实例id\nname_           名称        nvarchar(64)              参数名称(英文)\nvar_type_       参数类型      varchar(255)         √    备注5\nrev_            乐观锁       nvarchar(64)         √    乐观锁 version\nbytearray_id_   字节表id     nvarchar(400)        √    act_ge_bytearray表的主键\ndouble_         double_   nvarchar(255)        √    存储doubletype类型的数据\nlong_           long_     nvarchar(255)        √    存储longtype类型的数据\ntext_           text_     datetime             √    备注6\ntext2_          text2_    datetime             √    此处存储的是jpa持久化对象时，才会有值。此值为对象id\n\n索引\n\n名称                             字段                  类型\nact_idx_hi_procvar_proc_inst   proc_inst_id_       normal\nact_idx_hi_procvar_name_type   name_ , var_type_   normal\n\n# act_id_group\n\n用户组信息表\n\n字段名称    字段描述   数据类型            主键   为空   取值说明\nid_     id_    nvarchar(64)    √         主键id\nrev_    乐观锁    int                  √    乐观锁version\nname_   名称     nvarchar(255)        √    组名称\ntype_   类型     nvarchar(255)        √    类型\n\n# act_id_info\n\n用户扩展信息表\n\n字段名称         字段描述   数据类型            主键   为空   取值说明\nid_          id_    nvarchar(64)    √         主键id\nrev_         乐观锁    int                  √    乐观锁version\nuser_id_     用户id   nvarchar(64)         √    \ntype_        类型     nvarchar(64)         √    \nkey_                nvarchar(255)        √    \nvalue_              nvarchar(255)        √    \npassword_           image                √    \nparent_id_          nvarchar(255)        √    \n\n# act_id_membership\n\n用户与分组对应信息表\n\n用来保存用户的分组信息\n\n字段名称       字段描述    数据类型           主键   为空   取值说明\nuser_id    用户id    nvarchar(64)   √         \ngroup_id   用户组id   nvarchar(64)   √         \n\n索引\n\n名称                  字段          类型\nact_fk_memb_group   group_id_   normal\n\n# act_id_user\n\n用户信息表\n\n字段名称          字段描述     数据类型            主键   为空   取值说明\nid_           id_      nvarchar(64)    √         主键id\nrev_          乐观锁      int                  √    乐观锁version\nfirst_        姓        nvarchar(255)        √    \nlast_         名        nvarchar(255)        √    \nemail_        email_   nvarchar(255)        √    \npwd_          密码       nvarchar(255)        √    \npicture_id_   图片id     nvarchar(64)         √    \n\n# act_re_deployment\n\n部署信息表\n\n部署流程定义时需要被持久化保存下来的信息\n\n字段名称           字段描述   数据类型            主键   为空   取值说明\nid_            id_    nvarchar(64)    √         主键id\nname_          部署名称   nvarchar(255)        √    部署文件名\ncategory_      分类     nvarchar(255)        √    类别\ndeploy_time_   部署时间   datetime             √    部署时间\n\n# act_re_model\n\n流程设计模型部署表\n\n流程设计器设计流程后，保存数据到该表\n\n字段名称                            字段描述         数据类型            主键   为空   取值说明\nid_                             id_          nvarchar(64)    √         id_\nrev_                            乐观锁          int                  √    乐观锁\nname_                           名称           nvarchar(255)        √    名称\nkey_                            key_         nvarchar(255)        √    分类\ncategory_                       分类           nvarchar(255)        √    分类\ncreate_time_                    创建时间         datetime             √    创建时间\nlast_update_time_               最新修改时间       datetime             √    最新修改时间\nversion_                        版本           int                  √    版本\nmeta_info_                      meta_info_   nvarchar(255)        √    以json格式保存流程定义的信息\ndeployment_id_                  部署id         nvarchar(255)        √    部署id\neditor_source_value_id_                      datetime             √    \neditor_source_extra_value_id_                datetime             √    \n\n索引\n\n名称                          字段                              类型\nact_fk_model_source         editor_source_value_id_         normal\nact_fk_model_source_extra   editor_source_extra_value_id_   normal\nact_fk_model_deployment     deployment_id_                  normal\n\n# act_re_procdef\n\n流程定义数据表\n\n> 业务流程定义数据表。此表和 act_re_deployment 是多对一的关系，一个部署的bar包里可能包含多个流程定义文件，每个流程定义文件都会有一条记录在 act_re_procdef表内，每个流程定义的数据，都会对于 act_ge_bytearray表内的一个资源文件和 png 图片文件。和 act_ge_bytearray的关联是通过程序用 act_ge_bytearray.name 与 act_re_procdef.name 完成的，在数据库表结构中没有体现。\n\n字段名称                  字段描述              数据类型             主键   为空   取值说明\nid_                   id_               nvarchar(64)     √         id_\nrev_                  乐观锁               int                   √    乐观锁\ncategory_             分类                nvarchar(255)         √    流程定义的namespace就是类别\nname_                 名称                nvarchar(255)         √    名称\nkey_                  定义的key            nvarchar(255)              流程定义id\nversion_              版本                int                        版本\ndeployment_id_        部署表id             nvarchar(64)          √    部署表id\nresource_name_        bpmn文件名称          nvarchar(4000)        √    流程bpmn文件名称\ndgrm_resource_name_   png图片名称           nvarchar(4000)        √    流程图片名称\ndescription_          描述                nvarchar(4000)        √    描述\nhas_start_form_key_   是否存在开始节点formkey   tinyint               √    start节点是否存在formkey 0否 1是\nsuspension_state_     是否挂起              tinyint               √    1 激活 2挂起\n\n索引\n\n名称                 字段                类型\nact_uniq_procdef   key_ , version_   unique\n\n# act_ru_event_subscr\n\n> 事件订阅表（act_ru_event_subscr）\n\n事件订阅表。此表包含所有当前存在的事件订阅。它包括预期事件的类型，名称和配置，以及有关相应流程实例和执行的信息。\n\n字段名称             字段描述     数据类型            主键   为空   取值说明\nid_              事件id     nvarchar(64)    √         事件id\nrev_             版本       int                  √    乐观锁version\nevent_type_      事件类型     nvarchar(255)             事件类型\nevent_name_      事件名称     nvarchar(255)        √    事件名称\nexecution_id_    执行实例id   nvarchar(64)         √    执行实例id\nproc_inst_id_    流程实例id   nvarchar(64)         √    流程实例id\nactivity_id_     活动实例id   nvarchar(64)         √    活动实例id\nconfiguration_   配置       nvarchar(255)        √    配置\ncreated_         是否创建     datetime                  默认值 当前系统时间戳current_timestamp\n\n索引\n\n名称                             字段               类型\nact_idx_event_subscr_config_   configuration_   normal\nact_fk_event_exec              execution_id_    normal\n\n# act_ru_execution\n\n> 运行时流程执行实例表( act_ru_execution )\n\n字段名称                字段描述              数据类型            主键   为空   取值说明\nid_                 id_               nvarchar(64)    √         id_\nrev_                乐观锁               int                  √    乐观锁\nproc_inst_id_       流程实例id            nvarchar(64)              流程实例id\nbusiness_key_       业务主键id            nvarchar(255)        √    业务主键id\nparent_id_          父节点实例id           nvarchar(64)         √    父节点实例id\nproc_def_id_        流程定义id            nvarchar(64)         √    流程定义id\nsuper_exec_         super_exec_       nvarchar(64)         √    super_exec_\nact_id_             节点实例id            nvarchar(255)        √    节点实例id即act_hi_actinst中id\nis_active_          是否存活              tinyint              √    是否存活\nis_concurrent_      是否并行              tinyint              √    是否为并行(true/false）\nis_scope_           is_scope_         tinyint              √    is_scope_\nis_event_scope_     is_event_scope_   tinyint              √    is_event_scope_\nsuspension_state_   是否挂起              tinyint              √    挂起状态 1激活 2挂起\ncached_ent_state_                     int                  √    \n\n索引\n\n名称                    字段                             类型\nact_uniq_ru_bus_key   proc_def_id_ , business_key_   unique\nact_idx_exec_buskey   business_key_                  normal\nact_fk_exe_procinst   proc_inst_id_                  normal\nact_fk_exe_parent     parent_id_                     normal\nact_fk_exe_super      super_exec_                    normal\n\n# act_ru_identitylink\n\n> 运行时流程人员表( act_ru_identitylink )\n\n任务参与者数据表。主要存储当前节点参与者的信息。\n\n字段名称            字段描述     数据类型            主键   为空   取值说明\nid_             id_      nvarchar(64)    √         id_\nrev_            乐观锁      int                  √    乐观锁\ngroup_id_       组id      nvarchar(64)         √    组id\ntype_           类型       nvarchar(255)        √    备注7\nuser_id_        用户id     nvarchar(64)         √    用户id\ntask_id_        节点实例id   nvarchar(64)         √    节点实例id\nproc_inst_id_   流程实例id   nvarchar(64)         √    流程实例id\nproc_def_id_    流程定义id   nvarchar(255)        √    流程定义id\n\n索引\n\n名称                        字段              类型\nact_idx_ident_lnk_user    user_id_        normal\nact_idx_ident_lnk_group   group_id_       normal\nact_idx_athrz_procedef    proc_def_id_    normal\nact_fk_tskass_task        task_id_        normal\nact_fk_idl_procinst       proc_inst_id_   normal\n\n# act_ru_job\n\n> 运行时定时任务数据表( act_ru_job )\n\n字段名称                   字段描述     数据类型             主键   为空   取值说明\nid_                    标识       nvarchar(64)     √         标识\nrev_                   版本       int                   √    版本\ntype_                  类型       nvarchar(255)              类型\nlock_exp_time_         锁定释放时间   datetime              √    锁定释放时间\nlock_owner_            挂起者      nvarchar(255)         √    挂起者\nexclusive_                      bit                   √    \nexecution_id_          执行实例id   nvarchar(64)          √    执行实例id\nprocess_instance_id_   流程实例id   nvarchar(64)          √    流程实例id\nproc_def_id_           流程定义id   nvarchar(64)          √    流程定义id\nretries_                        int                   √    \nexception_stack_id_    异常信息id   nvarchar(64)          √    异常信息id\nexception_msg_         异常信息     nvarchar(4000)        √    异常信息\nduedate_               到期时间     datetime              √    到期时间\nrepeat_                重复       nvarchar(255)         √    重复\nhandler_type_          处理类型     nvarchar(255)         √    处理类型\nhandler_cfg_                    nvarchar(4000)        √    标识\n\n索引\n\n名称                     字段                    类型\nact_fk_job_exception   exception_stack_id_   normal\n\n# act_ru_task\n\n> 运行时任务节点表( act_ru_task )\n\n字段名称                字段描述       数据类型             主键   为空   取值说明\nid_                 id_        nvarchar(64)     √         id_\nrev_                乐观锁        int                   √    乐观锁\nexecution_id_       执行实例id     nvarchar(64)          √    执行实例id\nproc_inst_id_       流程实例id     nvarchar(64)          √    流程实例id\nproc_def_id_        流程定义id     nvarchar(64)          √    流程定义id\nname_               节点定义名称     nvarchar(255)         √    节点定义名称\nparent_task_id_     父节点实例id    nvarchar(64)          √    父节点实例id\ndescription_        节点定义描述     nvarchar(4000)        √    节点定义描述\ntask_def_key_       节点定义的key   nvarchar(255)         √    任务定义的id\nowner_              实际签收人      nvarchar(255)         √    拥有者（一般情况下为空，只有在委托时才有值）\nassignee_           签收人或委托人    nvarchar(255)         √    签收人或委托人\ndelegation_         委托类型       nvarchar(64)          √    备注8\npriority_           优先级别       int                   √    优先级别，默认为：50\ncreate_time_        创建时间       datetime              √    创建时间\ndue_date_           过期时间       datetime              √    耗时\nsuspension_state_   是否挂起       int                   √    1代表激活 2代表挂起\n\n索引\n\n名称                     字段              类型\nact_idx_task_create    create_time_    normal\nact_fk_task_exe        execution_id_   normal\nact_fk_task_procinst   proc_inst_id_   normal\nact_fk_task_procdef    proc_def_id_    normal\n\n# act_ru_variable\n\n> 运行时流程变量数据表( act_ru_variable )\n\n字段名称            字段描述      数据类型             主键   为空   取值说明\nid_             id_       nvarchar(64)     √         主键标识\nrev_            乐观锁       int                   √    乐观锁\ntype_           类型        nvarchar(255)              备注9\nname_           名称        nvarchar(255)              变量名称\nexecution_id_   执行实例id    nvarchar(64)          √    执行的id\nproc_inst_id_   流程实例id    nvarchar(64)          √    流程实例id\ntask_id_        节点实例id    nvarchar(64)          √    节点实例id(local）\nbytearray_id_   字节表id     nvarchar(64)          √    字节表的id（act_ge_bytearray）\ndouble_         double_   float                 √    存储变量类型为double\nlong_           long_     numeric(19)           √    存储变量类型为long\ntext_           text_     nvarchar(4000)        √    存储变量值类型为string 如此处存储持久化对象时，值jpa对象的class\ntext2_          text2_    nvarchar(4000)        √    此处存储的是jpa持久化对象时，才会有值。此值为对象id\n\n索引\n\n名称                         字段              类型\nact_idx_variable_task_id   task_id_        normal\nact_fk_var_exe             execution_id_   normal\nact_fk_var_procinst        proc_inst_id_   normal\nact_fk_var_bytearray       bytearray_id_   normal\n\n\n# idea应用activiti\n\nidea安装插件：activiti bpmn visualize\n\n安装第三方：camunda （camunda应用：https://zhuanlan.zhihu.com/p/375908620\n\nqa：有了activiti bpmn visualize为什么还要安装呢？\n\n 1. idea2021不能兼容常用的actibpm\n 2. activiti bpmn visualize 会找不到加入监听器的功能\n 3. 关于 assignee 失效 解决办法：将camunda 替换为 activiti，命名空间改为activity的命名空间，\n    1. 加入xmlns:activiti=“http://activiti.org/bpmn”\n    2. camunda改为activiti\n\n\n# ssm整合activiti\n\n步骤：\n\n 1. 引入activiti配置。在spring的xml配置中引入 ====\n\n 2. 配置activiti配置 activiti-context.xml\n    \n    <?xml version="1.0" encoding="utf-8"?>\n    <beans xmlns="http://www.springframework.org/schema/beans"\n           xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n           xsi:schemalocation="http://www.springframework.org/schema/beans \n           http://www.springframework.org/schema/beans/spring-beans.xsd\n    ">\n    \n        \x3c!-- spring负责创建流程引擎的配置文件 --\x3e\n        <bean id="processengineconfiguration" class="org.activiti.spring.springprocessengineconfiguration">\n            \x3c!-- 数据源 --\x3e\n            <property name="datasource" ref="datasource"/>\n            \x3c!-- 配置事务管理器，统一事务 --\x3e\n            <property name="transactionmanager" ref="transmanager"/>\n            \x3c!-- 设置建表策略，如果没有表，自动创建表 --\x3e\n            <property name="databaseschemaupdate" value="true"/>\n        </bean>\n        \x3c!-- 创建流程引擎对象 --\x3e\n        <bean id="processengine" class="org.activiti.spring.processenginefactorybean">\n            <property name="processengineconfiguration" ref="processengineconfiguration"/>\n        </bean>\n    \n        \x3c!-- 由流程引擎对象，提供的方法，创建项目中使用的activiti工作流的service --\x3e\n        <bean id="repositoryservice" factory-bean="processengine" factory-method="getrepositoryservice"/>\n        <bean id="runtimeservice" factory-bean="processengine" factory-method="getruntimeservice"/>\n        <bean id="taskservice" factory-bean="processengine" factory-method="gettaskservice"/>\n        <bean id="historyservice" factory-bean="processengine" factory-method="gethistoryservice"/>\n        <bean id="formservice" factory-bean="processengine" factory-method="getformservice"/>\n    \n    </beans>\n    \n    \n    > ps： spring配置的上下中有 事务(transmanager)、数据库连接源(datasource)\n\n 3. serivce业务应用。自动注入服务对象即可\n    \n    @service\n    public class activitiserviceimpl implements activitiservice {\n    \t@autowired\n        private repositoryservice repositoryservice;\n        @autowired\n        private runtimeservice runtimeservice;\n        @autowired\n        private taskservice taskservice;\n        @autowired\n        private historyservice historyservice;\n        @autowired\n        private formservice formservice;\n        \n        ....\n    }\n    ',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Shiro",frontmatter:{title:"Shiro",author:"柏竹",permalink:"/backend/40kn38",date:"2020-02-18T00:00:00.000Z",categories:["后端","框架"],tags:["安全"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/04.%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF/03.Shiro%E5%AE%89%E5%85%A8%E6%A1%86%E6%9E%B6.html",relativePath:"01.后端/04.框架技术/03.Shiro安全框架.md",key:"v-439f0503",path:"/backend/40kn38/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:12},{level:2,title:"术语",slug:"术语",normalizedTitle:"术语",charIndex:218},{level:2,title:"Shiro API",slug:"shiro-api",normalizedTitle:"shiro api",charIndex:774},{level:3,title:"Subject",slug:"subject",normalizedTitle:"subject",charIndex:591},{level:3,title:"SecurityManager",slug:"securitymanager",normalizedTitle:"securitymanager",charIndex:1875},{level:3,title:"Realm",slug:"realm",normalizedTitle:"realm",charIndex:624},{level:4,title:"AuthenticatingRealm",slug:"authenticatingrealm",normalizedTitle:"authenticatingrealm",charIndex:2616},{level:4,title:"AuthorizingRealm",slug:"authorizingrealm",normalizedTitle:"authorizingrealm",charIndex:2637},{level:3,title:"Spring配置API",slug:"spring配置api",normalizedTitle:"spring配置api",charIndex:4619},{level:4,title:"ShiroFilterFactoryBean",slug:"shirofilterfactorybean",normalizedTitle:"shirofilterfactorybean",charIndex:4634},{level:4,title:"DefaultWebSecurityManager",slug:"defaultwebsecuritymanager",normalizedTitle:"defaultwebsecuritymanager",charIndex:6259},{level:4,title:"CredentialsMatcher",slug:"credentialsmatcher",normalizedTitle:"credentialsmatcher",charIndex:6780},{level:4,title:"AuthorizationAttributeSourceAdvisor",slug:"authorizationattributesourceadvisor",normalizedTitle:"authorizationattributesourceadvisor",charIndex:7395},{level:3,title:"配置文件 *.ini",slug:"配置文件-ini",normalizedTitle:"配置文件 *.ini",charIndex:7846},{level:4,title:"[main]",slug:"main",normalizedTitle:"[main]",charIndex:7989},{level:4,title:"[users]",slug:"users",normalizedTitle:"[users]",charIndex:7999},{level:4,title:"[roles]",slug:"roles",normalizedTitle:"[roles]",charIndex:8021},{level:4,title:"[urls]",slug:"urls",normalizedTitle:"[urls]",charIndex:8032},{level:2,title:"首次应用",slug:"首次应用",normalizedTitle:"首次应用",charIndex:9896},{level:3,title:"单元测试",slug:"单元测试",normalizedTitle:"单元测试",charIndex:2276},{level:3,title:"JavaWeb整合",slug:"javaweb整合",normalizedTitle:"javaweb整合",charIndex:11298},{level:2,title:"认证入口",slug:"认证入口",normalizedTitle:"认证入口",charIndex:12737},{level:2,title:"角色/权限 无权重定向",slug:"角色-权限-无权重定向",normalizedTitle:"角色/权限 无权重定向",charIndex:12771},{level:2,title:"成功页",slug:"成功页",normalizedTitle:"成功页",charIndex:12823},{level:3,title:"业务方法",slug:"业务方法",normalizedTitle:"业务方法",charIndex:16203},{level:2,title:"执行流程",slug:"执行流程",normalizedTitle:"执行流程",charIndex:16976},{level:3,title:"认证",slug:"认证",normalizedTitle:"认证",charIndex:100},{level:3,title:"授权",slug:"授权",normalizedTitle:"授权",charIndex:48},{level:2,title:"过滤器",slug:"过滤器",normalizedTitle:"过滤器",charIndex:4731},{level:3,title:"自定义过滤器",slug:"自定义过滤器",normalizedTitle:"自定义过滤器",charIndex:19147}],headersStr:"简介 术语 Shiro API Subject SecurityManager Realm AuthenticatingRealm AuthorizingRealm Spring配置API ShiroFilterFactoryBean DefaultWebSecurityManager CredentialsMatcher AuthorizationAttributeSourceAdvisor 配置文件 *.ini [main] [users] [roles] [urls] 首次应用 单元测试 JavaWeb整合 认证入口 角色/权限 无权重定向 成功页 业务方法 执行流程 认证 授权 过滤器 自定义过滤器",content:'# Shiro\n\n\n# 简介\n\nApache Shiro是开源的安全框架，可以完全处理身份验证，授权，会话加密等\n\n**官网：**https://shiro.apache.org/\n\n特点：\n\n * 认证 用户行为，指定登录认证\n * 授权 访问控制，指定谁可以访问\n * 会话管理 管理用户特定会话，即使在非 Web/JEB 应用程序中\n * 加密 加密算法保证数据安全\n\n> Shiro开发团队称为 应用程序安全的四个基石\n\n\n# 术语\n\nShiro的术语较多，它包含有很多常用的知识，因此特意说明\n\n官方文档：https://shiro.apache.org/architecture.html\n\n * Authentication 认证 用户行为，指定登录认证\n * Authorization 授权 访问控制，指定谁可以访问\n * Cryptography密码 密码是用于 加密/解密 的算法。 算法通常依赖于密钥的一条信息\n * Credential 凭证 证书是验证用户/主体的身份的一条信息。\n * Cryptography 加密 将有效信息 转化为 看不懂且不受欢迎的信息，因此达到无人能读取的目的\n * 哈希 哈希函数是输入源且单向不可逆的，转化为 编码的哈希值。一般称为 消息\n * 权限 应用程序的初始功能，在当中用户需要凭证才有权能进行应用这些功能\n * Subject 主体 用户的标识属性，用户相关的都包含在内\n * Realm 领域 领域是可以访问特定于应用程序的安全数据具有1对1关联\n * Role角色 偏向人们思维理解，去定义角色进行区分权限。不同角色有不同的权限\n * Session 会话 一段时间内与软件交互的单个用户的过程\n * 主题 用户特定的视图。可以看做是一个 外部运行的进程/守护进程\n\n\n# Shiro API\n\nShiro API手册：https://tool.oschina.net/uploads/apidocs/shiro-core-1.2.0/overview-summary.html\n\n\n# Subject\n\norg.apache.shiro.subject接口，用户对象的描述，也是主体 主要提供了用户认证的操作入口，包括身份验证（登录/注销）、授权（访问控制）和会话访问\n\n> Subject 原意是和 User 一样，由于很多应用程序又有 用户User类 相同的名称，因此 Shiro 尽可能的排除这些冲突，把类名设为 Subject。此外在 Subject 是安全世界中公认的命名存在\n\n常用方法\n\n返回                    方法                                     说明\nPrincipalCollection   ==getPrincipals()==                    获取凭证集合\nboolean               ==isPermitted(String permission)==     是否有指定权限 (多方式\nboolean               ==hasRole(String roleIdentifier)==     是否为指定角色（多方式\nboolean               ==isAuthenticated()==                  是否通过身份认证\nboolean               ==isRemembered()==                     是否被记住\nSession               ==getSession()==                       获取 会话Session\nvoid                  ==login(AuthenticationToken token)==   认证登录\nvoid                  ==logout()==                           退出登录\n\n> login()方法是登录主要入口，认证失败 可能抛出以下异常：\n> \n>  * UnknownAccountException 用户名异常（不存在\n>  * IncorrectCredentialsException 密码不匹配异常\n>  * LockedAccountException 用户名被锁定，不能登录\n\n\n# SecurityManager\n\norg.apache.shiro.mgt.SecurityManager接口，安全管理器，封装 Shiro功能\n\n为单个应用程序中的所有主体(用户)执行所有安全操作\n\n> SecurityManager接口 扩展了 Authenticator、 Authorizer、SessionManager接口三个接口，将三个接口整合到一个接口中进行简化应用，三个接口作用分别是：\n> \n>  * org.apache.shiro.authc.Authenticator：账号身份认证（也是登录的主要入口\n>  * org.apache.shiro.authz.Authorizer：为指定主体 执行授权 (权限控制)操作\n>  * org.apache.shiro.session.mgt.SessionManager：管理程序Session的 创建、维护、清理\n\n步骤实例：单元测试\n\n> 在通过以上的单元测试可得知，一旦 SecurityManager 执行完毕，在此之后我们只需关心 ==SecurityUtils.getSubject()== 即可（实质上就是 SecurityManager 保证了 Subject 的安全操作\n\n\n# Realm\n\norg.apache.shiro.realm接口，安全组件，可以访问特定的应用程序的安全实体（如：用户账号、角色、权限）信息来确认 认证/授权 的操作（也是受 SecurityManager安全管理器 控制的\n\n一般 Realm 会通过 JDBC数据源、ini配置源、等其他源，进行获取需要匹配的认证信息\n\n> Realm通常与数据库源进行打交道，进行认证信息。实现信息 认证/授权，一般会通过 AuthenticatingRealm/ AuthorizingRealm 进行操作\n\n# AuthenticatingRealm\n\norg.apache.shiro.realm.AuthenticatingRealm抽象类，身份认证缓存，在用户登录有将用户信息缓存起来，防止频繁认证！\n\n实现需要重写 ==doGetAuthenticationInfo(AuthenticationToken token)==方法 实现用户认证\n\n/**\n *  身份信息认证\n * @param token 用户在身份验证期间提交主体和支持凭据的合并（包含有用户输入的凭证信息 (常见的 用户名/密码)\n */\n@Override\nprotected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n    String userName = (String) token.getPrincipal();\n    User user = null;\n    try {\n        // 业务查询库账号数据\n        user = sysService.findUserByUserName(userName);\n        if (user == null) return null;\n    } catch (Exception e) {\n        throw new RuntimeException(e);\n    }\n\n    /** 说明：应用了MD5加密\n    \t参数\n     *   1. Object principal 首要（主体\n     *   2. Object hashedCredentials 凭证（库密码\n     *   3. ByteSource credentialsSalt 盐（秘钥\n     *   4. String realmName 领域名 （自定义Realm名称\n     */\n    return new SimpleAuthenticationInfo(activeUser, user.getPassword(),\n            ByteSource.Util.bytes(user.getSalt()), "CustomRealm");\n}\n\n\n> ==doGetAuthenticationInfo()== 实现返回是 AuthenticationInfo实例，该实例支持密码的加密（加密算法可以自行选择！\n\n# AuthorizingRealm\n\norg.apache.shiro.realm.AuthorizingRealm抽象类，实现自动执行角色和权限的自动检查（每次执行检查相关都会跑一边检查权限\n\n> 该抽象类继承了 AuthenticatingRealm抽象类 ，整合了 角色权限分配/认证的功能\n\n实现需要重写 ==doGetAuthorizationInfo(PrincipalCollection collection)==方法 分配权限\n\n/**\n *  获取角色信息授权\n * @param collection 标识主体的对象，包含主体的相关信息\n */\n@Override\nprotected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection collection) {\n\t// ActiveUser封装了 Permissions权限、Role角色\n    ActiveUser activeUser = (ActiveUser) collection.getPrimaryPrincipal();\n\n    // 角色列表\n    List<String> permissions = new ArrayList<>();\n    for (SysPermission sysPermission : activeUser.getPermissions()) {\n        permissions.add(sysPermission.getPercode());\n    }\n\n    // 授权\n    SimpleAuthorizationInfo info = new SimpleAuthorizationInfo();\n    info.addStringPermissions(permissions);\n    info.addRole(activeUser.getUsercode());\n    return info;\n}\n\n\n\n# Spring配置API\n\n# ShiroFilterFactoryBean\n\norg.apache.shiro.spring.web.ShiroFilterFactoryBean类，基于Spring的Web程序的Shiro主过滤器\n\n主要属性\n\n类型                    属性名                        说明\nSecurityManager       securityManager            安全管理配置\nMap<String, Filter>   filters                    自定义/重写的 过滤器配置\nMap<String, String>   filterChainDefinitionMap   Shiro过滤器链\nString                loginUrl                   认证提交入口的URL配置\nString                successUrl                 认证成功入口的URL配置\nString                unauthorizedUrl            无权访问从定向URL配置\n\n步骤：\n\n 1. 在 web.xml文件 先声明过滤器\n    \n    \x3c!-- Shiro过滤器 --\x3e\n    <filter>\n        <filter-name>shiroFilter</filter-name>\n        <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>\n        \x3c!-- 设置true由servlet容器控制filter的生命周期 --\x3e\n        <init-param>\n            <param-name>targetFilterLifecycle</param-name>\n            <param-value>true</param-value>\n        </init-param>\n        \x3c!-- 设置spring容器filter的bean id，如果不设置则找与filter-name一致的bean (保险使用防止不同过滤器名称--\x3e\n        <init-param>\n            <param-name>targetBeanName</param-name>\n            <param-value>shiroFilter</param-value>\n        </init-param>\n    </filter>\n    <filter-mapping>\n        <filter-name>shiroFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n    \n    \n    > **注意：**这里的 过滤器名称 与 Bean id 匹配，否则spring找不到匹配的Bean。 过滤器的 targetBeanName属性可以指定过滤器名称 进行修正与Bean id的匹配\n\n 2. 在 Spring配置中配置\n\n<bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean">\n    <property name="securityManager" ref="securityManager"/>\n    <-- 以上的配置属性根据个人需求进行配置值即可 --\x3e\n    ....\n</bean>\n\n\n# DefaultWebSecurityManager\n\norg.apache.shiro.web.mgt.DefaultWebSecurityManager类，安全管理器（和 SecurityManager 是关联配置 基于Web实现任何程序需要HTTP连接的应用，一般是搭配其他管理器进行应用（其他管理器有点多自行查询\n\n如图配置：\n\n\x3c!-- securityManager安全管理器 --\x3e\n<bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager">\n\t<property name="realm" ref="customRealm" />\n    <property name="cacheManager" ref="cacheManager"/>\n    <property name="sessionManager" ref="sessionManager"/>\n    <property name="rememberMeManager" ref="rememberMeManager"/>\n</bean>\n\n\n# CredentialsMatcher\n\norg.apache.shiro.authc.credential.CredentialsMatcher接口，凭证适配器（用于加密适配密码等\n\n> 如果自定义Realm，配置了凭证适配器，认证方式会按照凭证适配器的逻辑进行匹配账号\n\n步骤：\n\n 1. 添加 凭证适配器Bean （以下 凭证适配器应用了MD5算法的加密\n    \n    <bean id="credentialsMatcher" class="org.apache.shiro.authc.credential.HashedCredentialsMatcher">\n        <property name="hashAlgorithmName" value="md5"/>\n        <property name="hashIterations" value="2"/>\n    </bean>\n    \n\n 2. 自定义领域添加凭证适配器Bean\n    \n    \x3c!-- 自定义领域 --\x3e\n    <bean name="customRealm" class="com.sans.shiro.CustomRealm">\n        <property name="credentialsMatcher" ref="credentialsMatcher"/>\n    </bean>\n    \n\n# AuthorizationAttributeSourceAdvisor\n\norg.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor类，权限管理器\n\nShrio默认是不会有 处理/捕获 异常，因此该类主要是给 授权/认证 失败所抛出的异常给与对应的处理(友善的回复\n\n<bean  class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor">\n\t<property name="securityManager" ref="securityManager" />\n</bean>\n\n\n> **注意：**配置主要配置在Spring整体的上下文中。如果不是在Spring上下文的整体中，则需要配置在 SpringMVC的配置中 ，这一回复过程是交给SpringMVC进行处理的！\n\n\n# 配置文件 *.ini\n\nini 基本上是一种文本配置，由唯一命名的部分组织的 键/值对组成。每个部分都可以被视为单个定义Properties\n\n官方配置文档：https://shiro.apache.org/configuration.html\n\nShiro ini主要配置:\n\n * [main]\n * [users]\n * [users]\n * [roles]\n * [urls]\n\n# [main]\n\n配置应用程序的实例依赖项（例如：Realms配置\n\n> 可以理解为是低配版的 spring loc容器配置\n\n为了能够更直观的理解，以下配置库连接的示例：\n\n[main]\nnewUser = com.pojo.MyUser\n\nmyRealm = com.shiro.DatabaseRealm\nmyRealm.connectionTimeout = 30000\nmyRealm.username = jsmith\nmyRealm.password = secret\nmyRealm.user = $newUser\n\nsecurityManager.sessionManager.globalSessionTimeout = 1800000\n\n\n定义对象\n\n[main]\n## 实例化新对象，并为对象进行配置\nmyRealm = com.shiro.DatabaseRealm\n\n\n设置对象属性值\n\n...\nmyRealm.connectionTimeout = 30000\nmyRealm.username = jsmith\nmyRealm.password = secret\n...\n\n\n> 本质的调用 setter()方法进行 赋予值的\n\n属性值如果为对象则需要通过 $美元符号 作为前缀定义\n\n...\nnewUser = com.pojo.MyUser\n...\n## 实体属性形式 : MyUser user;\nmyRealm.user = $newUser\n...\n\n\n> 属性对象也是通过 setter()方法 进行赋予值的。==myRealm.setUser(newUser)==\n\n嵌套属性\n\n为最终要到达的属性设置值\n\n...\nsecurityManager.sessionManager.globalSessionTimeout = 1800000\n...\n\n\n> 换个角度可以理解为：==securityManager.getSessionManager().setGlobalSessionTimeout(1800000)==\n\n# [users]\n\n一组静态用户账户（一般在 测试 或 运行时不需要创建用户 的环境下配置应用\n\n[users]\nadmin = sans\nlonestarr = vespa, goodguy, useroperation\ndarkhelmet = ludicrousspeed, badguy, schwartz\n\n\n每行格式\n\n每行都要满足的格式形式：\n\n==username = password , rolename1 , rolename2 , ...==\n\n * username ：用户名\n * password ：用户密码\n * 密码后的 ,逗号分隔 值都是分配给该用户角色的名称 (可选角色\n\n# [roles]\n\n权限 和 用户 定义关联（一般在 测试 或 运行时不需要创建用户 的环境下配置应用\n\n## \'admin\' 角色具有所有权限，由通配符 \'\' 指示\nadmin = *\n## \'useroperation\' 角色 可以用 user的任何功能\nuseroperation = user:*\n## \'usercr\' 角色 只能用 user的create和delete功能\nusercr = user:create,user:delete\n\n\n每行格式\n\n每行都要满足的格式形式：\n\n==rolename = permissionDefinition1 , permissionDefinition2 , ...==\n\n * rolename : 角色名称\n * permissionDefinition : 权限\n\n# [urls]\n\nJavaWeb请求地址配置\n\n[urls]\n/index.html = anon\n/user/create = anon\n/user/** = authc\n/rest/** = authc, rest\n\n\n每行格式\n\n==uri = filter1 , filter2 , ...==\n\n * uri ：路由\n * filter ：过滤器 （Shiro有套默认的过滤器\n\nDIY过滤器\n\n[main]\n...\nmyFilter = com.sans.filters.MyFilter\n...\n[urls]\n...\n/some/path/** = myFilter\n\n\n\n# 首次应用\n\n\n# 单元测试\n\n实现步骤：\n\n 1. 引入jar\n\n 2. 配置文件 .ini (shiro-first.ini)\n    \n    #用户信息配置\n    [users]\n    #用户帐号和密码\n    zhangsan = 111111\n    lishi = 333333\n    \n\n 3. 单元测试 测试前提需要shiro环境！\n    \n    1. 初始化 Security Manager环境 ==Factory factory = new IniSecurityManagerFactory(<配置文件>)==\n    \n    2. 配置安全管理环境\n       \n       // 实例安全管理看空间\n       SecurityManager instance = factory.getInstance();\n       // 设置安全管理\n       SecurityUtils.setSecurityManager(instance);\n       \n    \n    3. 获取认证主体 ==Subject subject = SecurityUtils.getSubject();==\n    \n    4. 主题认证 （toke封装 ==UsernamePasswordToken token = new UsernamePasswordToken()==\n    \n    5. 认证信息 （该方法可能会抛出登录可能出现的异常 ==subject.login(token);==\n    \n    6. 验证登录成功\n       \n       ==subject.isAuthenticated()==\n    \n    示例：\n    \n    @Test\n    public void defaultTest() {\n        Factory<SecurityManager> factory = new IniSecurityManagerFactory("classpath:shiro-first.ini");\n        // 实例安全管理看空间\n        SecurityManager instance = factory.getInstance();\n        // 设置安全管理\n        SecurityUtils.setSecurityManager(instance);\n        // 获取认证主体\n        Subject subject = SecurityUtils.getSubject();\n        UsernamePasswordToken token = new UsernamePasswordToken("lishi", "333333");\n        subject.login(token);\n        boolean authenticated = subject.isAuthenticated();\n        System.out.println("是否可行？" + authenticated);\n    }\n    \n    /* 控制台结果\n    \t是否可行？true\n    */\n    \n\n\n# JavaWeb整合\n\n**JavaWeb应用：**https://shiro.apache.org/web.html\n\n**集成SpringBoot：**https://shiro.apache.org/spring-boot.html#web_applications\n\n实现步骤： （只讲有关Shiro配置\n\n 1. 配置文件 web.xml、shiro.ini\n    \n    web.xml\n    \n    \x3c!-- ShiroFilter 初始化Shiro环境 --\x3e\n    <filter>\n        <filter-name>shiroFilter</filter-name>\n        <filter-class>org.apache.shiro.web.servlet.ShiroFilter</filter-class>\n    </filter>\n    <filter-mapping>\n        <filter-name>shiroFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n    \n    \x3c!-- 加载 *.ini , 并构建 WebSecurityManager。\n        里面包含有很多过滤器链 --\x3e\n    <listener>\n        <listener-class>org.apache.shiro.web.env.EnvironmentLoaderListener</listener-class>\n    </listener>\n    \n    \x3c!-- 自定义 .ini文件名 以及位置 --\x3e\n    \x3c!--<context-param>--\x3e\n    \x3c!--    <param-name>shiroConfigLocations</param-name>--\x3e\n    \x3c!--    <param-value>classpath:shiroDiy.ini</param-value>--\x3e\n    \x3c!--</context-param>--\x3e\n    \n    \n    > PS：\n    > \n    >  * ShiroFilter过滤器 接收所有请求，进行 识别/校验 ，如果触发安全校验，会遍历一次过滤器链。链中的 请求处理的配置，在 shiro.ini文件 中进行\n    > \n    >  * EnvironmentLoaderListener类 Shiro环境加载，加载 shiro.ini文件以及过滤器链\n    > \n    >  * Shiro默认是自动加载 shiro.ini文件名（无需配置），如果 是自定义名称 *.ini，则需要以下配置\n    >    \n    >    <context-param>\n    >        <param-name>shiroConfigLocations</param-name>\n    >        <param-value>classpath:shiroDiy.ini</param-value>\n    >    </context-param>\n    >    \n    \n    shiro.ini\n    \n    [main]\n    \n    \n\n\n# 认证入口\n\nshiro.loginUrl = /login\n\n\n# 角色/权限 无权重定向\n\nshiro.unauthorizedUrl = /error.jsp\n\n\n# 成功页\n\nshiro.successUrl = /success.jsp\n\n[urls] / = anon /logout = logout /** = authc\n\n[users] zhangsan=123123\n\n\n2. 配置登录入口启动运行即可\n\n> **注意：**FormAuthenticationFilter表单过滤器\n>\n> 表单指定的属性名称：（如果使用默认的过滤器情况下\n>\n> - 账号：`username`\n> - 密码：`password`\n> - 记住：`rememberMe` \n\n### SSM整合\n\nSSM整合通过代理实现，更为贴近Spring功能的应用和实现\n\n**步骤：**\n\n1. `web.xml`配置，添加代理过滤器\n\n```xml\n<filter>\n    <filter-name>shiroFilter</filter-name>\n    <filter-class>org.springframework.web.filter.DelegatingFilterProxy</filter-class>\n    \x3c!-- 设置true由servlet容器控制filter的生命周期 --\x3e\n    <init-param>\n        <param-name>targetFilterLifecycle</param-name>\n        <param-value>true</param-value>\n    </init-param>\n    \x3c!-- 设置spring容器filter的bean id，如果不设置则找与filter-name一致的bean --\x3e\n    <init-param>\n        <param-name>targetBeanName</param-name>\n        <param-value>shiroFilter</param-value>\n    </init-param>\n</filter>\n<filter-mapping>\n    <filter-name>shiroFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n\n\n> **注意：**过滤器名称 与 Bean id 匹配，否则spring找不到匹配的Bean\n\n 2. Spring配置\n    \n    <?xml version="1.0" encoding="UTF-8"?>\n    <beans xmlns="http://www.springframework.org/schema/beans"\n           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc"\n           xmlns:context="http://www.springframework.org/schema/context"\n           xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"\n           xsi:schemaLocation="http://www.springframework.org/schema/beans\n    \t\thttp://www.springframework.org/schema/beans/spring-beans-3.2.xsd\n    \t\thttp://www.springframework.org/schema/mvc\n    \t\thttp://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd\n    \t\thttp://www.springframework.org/schema/context\n    \t\thttp://www.springframework.org/schema/context/spring-context-3.2.xsd\n    \t\thttp://www.springframework.org/schema/aop\n    \t\thttp://www.springframework.org/schema/aop/spring-aop-3.2.xsd\n    \t\thttp://www.springframework.org/schema/tx\n    \t\thttp://www.springframework.org/schema/tx/spring-tx-3.2.xsd\n    ">\n        \x3c!-- 启动Aop --\x3e\n        <aop:config proxy-target-class="true"/>\n        \n        <bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean">\n            \x3c!-- 安全管理器 --\x3e\n            <property name="securityManager" ref="securityManager"/>\n            \x3c!-- loginUrl 认证地址 --\x3e\n            <property name="loginUrl" value="/login"/>\n            \x3c!-- 认证成功 --\x3e\n            <property name="successUrl" value="/first" />\n            \x3c!-- 未授权定义的跳转 --\x3e\n            <property name="unauthorizedUrl" value="/refuse.jsp"/>\n            <property name="filterChainDefinitions">\n                <value>\n                    ...\n                    \x3c!-- 权限分配 --\x3e\n                    ...\n                    /**=authc\n                </value>\n            </property>\n        </bean>\n    \n        \x3c!-- 注解Shiro支持 --\x3e\n        <bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor">\n            <property name="securityManager" ref="securityManager"/>\n        </bean>\n    \n        \x3c!-- securityManager安全管理 --\x3e\n        <bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager">\n            <property name="realm" ref="customRealm" />\n        </bean>\n    \n    </beans>\n    \n    \n    > **注意：**注解Shiro支持，需要Spring上下文/在SpringMVC中进行配置否者无效\n\n\n# 业务方法\n\n获取当前指定的主题 Subject\n\nSubject subject = SecurityUtils.getSubject();\n\n\n> Subject 原意是和 User 一样，由于很多应用程序又有 用户User类 相同的名称，因此 Shiro 尽可能的排除这些冲突，把类名设为 Subject。此外在 Subject 是安全世界中公认的命名存在\n\n用户会话\n\nSession session = subject.getSession();\n\n\n> 该会话不依赖于环境进行获取（如：HTTP，Web环境等\n\n检查是否允许指定操作（角色/权限\n\nif(!currentUser.isAuthenticeted()){\n\tUsernamePasswordToken token = new UsernamePasswordToken("张三", "123123");\n\ttoken.setRememberMe(true);\n    subject.login(token);\n}\n\n\n识别主体\n\nsubject.getPrincipal()\n\n\n查看是否有权对某对象进行执行 (查库中的特定字段Code判断是否含有功能凭证的角色\n\nif (subject.isPermitted( "item:create" ) ) {\n    log.info("有权创建！");\n} else {\n    log.info("无权创建！");\n}\n\n\n判断是否为指定角色\n\nif(subject.hasRole("admin")){\n    log.info("是admin角色")\n}else{\n    log.info("不是admin角色")\n}\n\n\n用户注销 删除所有标识信息并使其会话失效\n\nsubject.logout();\n\n\n\n# 执行流程\n\n\n# 认证\n\n\n\n 1. 通过 ini配置文件 创建 securityManager安全管理器\n 2. 调用 subject.login()方法 执行提交认证（带参数的token\n 3. securityManager认证（最终由 ModularRealmAuthenticator 进行认证处理\n 4. ModularRealmAuthenticator 调用 IniRealm 去ini配置文件查询用户信息\n 5. IniRealm根据 token 中，查询用户信息（账号密码 查到的返回 用户信息，否则null\n 6. ModularRealmAuthenticator 接收 IniRealm返回Authentication认证信息\n\n\n# 授权\n\n\n\n 1. 对subject进行授权，调用方法 isPermitted()方法 （指定权限key\n 2. SecurityManager执行授权，通过ModularRealmAuthorizer进行授权\n 3. ModularRealmAuthorizer执行 Realm （从数据库查询权限数据 Realm授权方法：doGetAuthorizationInfo()\n 4. Realm从数据库查询权限数据，返回ModularRealmAuthorizer\n 5. ModularRealmAuthorizer调用PermissionResolver进行权限串比对\n 6. 通过比对permission权限进行赋予权限\n\n\n# 过滤器\n\n过滤器名称               全限定名类                                                              说明\nanon                org.apache.shiro.web.filter.authc.AnonymousFilter                  不执行安全检查进行访问\nauthc               org.apache.shiro.web.filter.authc.FormAuthenticationFilter         身份认证才能访问，否则重定向 loginUrl进行登录认证\nauthcBasic          org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter    身份认证才能访问，否则要求用户通过HTTP Basic协议进行登录认证\nauthcBearer         org.apache.shiro.web.filter.authc.BearerHttpAuthenticationFilter   身份认证才能访问，否则要求用户通过特定的HTTP持有者协议进行登录认证\ninvalidRequest      org.apache.shiro.web.filter.InvalidRequestFilter                   阻止恶意请求。将请求无效化（400\nlogout              org.apache.shiro.web.filter.authc.LogoutFilter                     立即注销当前用户，并重定向至 loginUrl\nnoSessionCreation   org.apache.shiro.web.filter.session.NoSessionCreationFilter        会话未建立调用时，会禁用所有调用\nperms               org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter   用户是否有权访问，没有则拒绝\nport                org.apache.shiro.web.filter.authz.PortFilter                       请求特定的端口，则重定向至该端口的同一 URL\nrest                org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter       明确请求访问权限，动词映射方式\nroles               org.apache.shiro.web.filter.authz.RolesAuthorizationFilter         用户是否为指定角色（角色可分配业务功能\nssl                 org.apache.shiro.web.filter.authz.SslFilter                        通过SSL请求\nuser                org.apache.shiro.web.filter.authc.UserFilter                       是否记住用户，已知用户允许请求，否则重定向loginUrl进行登录认证\n\n\n# 自定义过滤器\n\n自定义可以根据个人设定进行功能实现\n\n步骤：\n\n 1. 创建 自定义过滤器类 MyFilter ，并继承 AuthorizationFilter类 实现 isAccessAllowed()方法\n    \n    public class MyFilter extends AuthorizationFilter {\n        /**\n         * 是否允许访问\n         * @param request     请求\n         * @param response    响应\n         * @param mappedValue URL规则映射中映射到此过滤器的过滤器特定配置值\n         * @return true允许访问；否则拒绝访问\n         */\n        @Override\n        protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) throws Exception {\n            ...\n            return false;\n        }\n    }\n    \n\n 2. 在 Spring中的 shrio配置中 添加过滤器Bean，并引入映射（引入过滤器\n    \n    <-- 引入过滤器Bean （需要过滤器的全限定名 --\x3e\n    <bean id="myCustomFilter" class="com.sans.filter.MyFilter"/>\n    <bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean">\n        ....\n        \x3c!-- 添加自定义过滤器Filter --\x3e\n        <property name="filters">\n            <map>\n                <entry key="cusf" value-ref="myCustomFilter"/>\n            </map>\n        </property>\n        <property name="filterChainDefinitions">\n            <value>\n                \x3c!-- 过滤指定路径 --\x3e\n                /some/path/** = cusf\n                ...\n            </value>\n        </property>\n    </bean>\n    ',normalizedContent:'# shiro\n\n\n# 简介\n\napache shiro是开源的安全框架，可以完全处理身份验证，授权，会话加密等\n\n**官网：**https://shiro.apache.org/\n\n特点：\n\n * 认证 用户行为，指定登录认证\n * 授权 访问控制，指定谁可以访问\n * 会话管理 管理用户特定会话，即使在非 web/jeb 应用程序中\n * 加密 加密算法保证数据安全\n\n> shiro开发团队称为 应用程序安全的四个基石\n\n\n# 术语\n\nshiro的术语较多，它包含有很多常用的知识，因此特意说明\n\n官方文档：https://shiro.apache.org/architecture.html\n\n * authentication 认证 用户行为，指定登录认证\n * authorization 授权 访问控制，指定谁可以访问\n * cryptography密码 密码是用于 加密/解密 的算法。 算法通常依赖于密钥的一条信息\n * credential 凭证 证书是验证用户/主体的身份的一条信息。\n * cryptography 加密 将有效信息 转化为 看不懂且不受欢迎的信息，因此达到无人能读取的目的\n * 哈希 哈希函数是输入源且单向不可逆的，转化为 编码的哈希值。一般称为 消息\n * 权限 应用程序的初始功能，在当中用户需要凭证才有权能进行应用这些功能\n * subject 主体 用户的标识属性，用户相关的都包含在内\n * realm 领域 领域是可以访问特定于应用程序的安全数据具有1对1关联\n * role角色 偏向人们思维理解，去定义角色进行区分权限。不同角色有不同的权限\n * session 会话 一段时间内与软件交互的单个用户的过程\n * 主题 用户特定的视图。可以看做是一个 外部运行的进程/守护进程\n\n\n# shiro api\n\nshiro api手册：https://tool.oschina.net/uploads/apidocs/shiro-core-1.2.0/overview-summary.html\n\n\n# subject\n\norg.apache.shiro.subject接口，用户对象的描述，也是主体 主要提供了用户认证的操作入口，包括身份验证（登录/注销）、授权（访问控制）和会话访问\n\n> subject 原意是和 user 一样，由于很多应用程序又有 用户user类 相同的名称，因此 shiro 尽可能的排除这些冲突，把类名设为 subject。此外在 subject 是安全世界中公认的命名存在\n\n常用方法\n\n返回                    方法                                     说明\nprincipalcollection   ==getprincipals()==                    获取凭证集合\nboolean               ==ispermitted(string permission)==     是否有指定权限 (多方式\nboolean               ==hasrole(string roleidentifier)==     是否为指定角色（多方式\nboolean               ==isauthenticated()==                  是否通过身份认证\nboolean               ==isremembered()==                     是否被记住\nsession               ==getsession()==                       获取 会话session\nvoid                  ==login(authenticationtoken token)==   认证登录\nvoid                  ==logout()==                           退出登录\n\n> login()方法是登录主要入口，认证失败 可能抛出以下异常：\n> \n>  * unknownaccountexception 用户名异常（不存在\n>  * incorrectcredentialsexception 密码不匹配异常\n>  * lockedaccountexception 用户名被锁定，不能登录\n\n\n# securitymanager\n\norg.apache.shiro.mgt.securitymanager接口，安全管理器，封装 shiro功能\n\n为单个应用程序中的所有主体(用户)执行所有安全操作\n\n> securitymanager接口 扩展了 authenticator、 authorizer、sessionmanager接口三个接口，将三个接口整合到一个接口中进行简化应用，三个接口作用分别是：\n> \n>  * org.apache.shiro.authc.authenticator：账号身份认证（也是登录的主要入口\n>  * org.apache.shiro.authz.authorizer：为指定主体 执行授权 (权限控制)操作\n>  * org.apache.shiro.session.mgt.sessionmanager：管理程序session的 创建、维护、清理\n\n步骤实例：单元测试\n\n> 在通过以上的单元测试可得知，一旦 securitymanager 执行完毕，在此之后我们只需关心 ==securityutils.getsubject()== 即可（实质上就是 securitymanager 保证了 subject 的安全操作\n\n\n# realm\n\norg.apache.shiro.realm接口，安全组件，可以访问特定的应用程序的安全实体（如：用户账号、角色、权限）信息来确认 认证/授权 的操作（也是受 securitymanager安全管理器 控制的\n\n一般 realm 会通过 jdbc数据源、ini配置源、等其他源，进行获取需要匹配的认证信息\n\n> realm通常与数据库源进行打交道，进行认证信息。实现信息 认证/授权，一般会通过 authenticatingrealm/ authorizingrealm 进行操作\n\n# authenticatingrealm\n\norg.apache.shiro.realm.authenticatingrealm抽象类，身份认证缓存，在用户登录有将用户信息缓存起来，防止频繁认证！\n\n实现需要重写 ==dogetauthenticationinfo(authenticationtoken token)==方法 实现用户认证\n\n/**\n *  身份信息认证\n * @param token 用户在身份验证期间提交主体和支持凭据的合并（包含有用户输入的凭证信息 (常见的 用户名/密码)\n */\n@override\nprotected authenticationinfo dogetauthenticationinfo(authenticationtoken token) throws authenticationexception {\n    string username = (string) token.getprincipal();\n    user user = null;\n    try {\n        // 业务查询库账号数据\n        user = sysservice.finduserbyusername(username);\n        if (user == null) return null;\n    } catch (exception e) {\n        throw new runtimeexception(e);\n    }\n\n    /** 说明：应用了md5加密\n    \t参数\n     *   1. object principal 首要（主体\n     *   2. object hashedcredentials 凭证（库密码\n     *   3. bytesource credentialssalt 盐（秘钥\n     *   4. string realmname 领域名 （自定义realm名称\n     */\n    return new simpleauthenticationinfo(activeuser, user.getpassword(),\n            bytesource.util.bytes(user.getsalt()), "customrealm");\n}\n\n\n> ==dogetauthenticationinfo()== 实现返回是 authenticationinfo实例，该实例支持密码的加密（加密算法可以自行选择！\n\n# authorizingrealm\n\norg.apache.shiro.realm.authorizingrealm抽象类，实现自动执行角色和权限的自动检查（每次执行检查相关都会跑一边检查权限\n\n> 该抽象类继承了 authenticatingrealm抽象类 ，整合了 角色权限分配/认证的功能\n\n实现需要重写 ==dogetauthorizationinfo(principalcollection collection)==方法 分配权限\n\n/**\n *  获取角色信息授权\n * @param collection 标识主体的对象，包含主体的相关信息\n */\n@override\nprotected authorizationinfo dogetauthorizationinfo(principalcollection collection) {\n\t// activeuser封装了 permissions权限、role角色\n    activeuser activeuser = (activeuser) collection.getprimaryprincipal();\n\n    // 角色列表\n    list<string> permissions = new arraylist<>();\n    for (syspermission syspermission : activeuser.getpermissions()) {\n        permissions.add(syspermission.getpercode());\n    }\n\n    // 授权\n    simpleauthorizationinfo info = new simpleauthorizationinfo();\n    info.addstringpermissions(permissions);\n    info.addrole(activeuser.getusercode());\n    return info;\n}\n\n\n\n# spring配置api\n\n# shirofilterfactorybean\n\norg.apache.shiro.spring.web.shirofilterfactorybean类，基于spring的web程序的shiro主过滤器\n\n主要属性\n\n类型                    属性名                        说明\nsecuritymanager       securitymanager            安全管理配置\nmap<string, filter>   filters                    自定义/重写的 过滤器配置\nmap<string, string>   filterchaindefinitionmap   shiro过滤器链\nstring                loginurl                   认证提交入口的url配置\nstring                successurl                 认证成功入口的url配置\nstring                unauthorizedurl            无权访问从定向url配置\n\n步骤：\n\n 1. 在 web.xml文件 先声明过滤器\n    \n    \x3c!-- shiro过滤器 --\x3e\n    <filter>\n        <filter-name>shirofilter</filter-name>\n        <filter-class>org.springframework.web.filter.delegatingfilterproxy</filter-class>\n        \x3c!-- 设置true由servlet容器控制filter的生命周期 --\x3e\n        <init-param>\n            <param-name>targetfilterlifecycle</param-name>\n            <param-value>true</param-value>\n        </init-param>\n        \x3c!-- 设置spring容器filter的bean id，如果不设置则找与filter-name一致的bean (保险使用防止不同过滤器名称--\x3e\n        <init-param>\n            <param-name>targetbeanname</param-name>\n            <param-value>shirofilter</param-value>\n        </init-param>\n    </filter>\n    <filter-mapping>\n        <filter-name>shirofilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n    \n    \n    > **注意：**这里的 过滤器名称 与 bean id 匹配，否则spring找不到匹配的bean。 过滤器的 targetbeanname属性可以指定过滤器名称 进行修正与bean id的匹配\n\n 2. 在 spring配置中配置\n\n<bean id="shirofilter" class="org.apache.shiro.spring.web.shirofilterfactorybean">\n    <property name="securitymanager" ref="securitymanager"/>\n    <-- 以上的配置属性根据个人需求进行配置值即可 --\x3e\n    ....\n</bean>\n\n\n# defaultwebsecuritymanager\n\norg.apache.shiro.web.mgt.defaultwebsecuritymanager类，安全管理器（和 securitymanager 是关联配置 基于web实现任何程序需要http连接的应用，一般是搭配其他管理器进行应用（其他管理器有点多自行查询\n\n如图配置：\n\n\x3c!-- securitymanager安全管理器 --\x3e\n<bean id="securitymanager" class="org.apache.shiro.web.mgt.defaultwebsecuritymanager">\n\t<property name="realm" ref="customrealm" />\n    <property name="cachemanager" ref="cachemanager"/>\n    <property name="sessionmanager" ref="sessionmanager"/>\n    <property name="remembermemanager" ref="remembermemanager"/>\n</bean>\n\n\n# credentialsmatcher\n\norg.apache.shiro.authc.credential.credentialsmatcher接口，凭证适配器（用于加密适配密码等\n\n> 如果自定义realm，配置了凭证适配器，认证方式会按照凭证适配器的逻辑进行匹配账号\n\n步骤：\n\n 1. 添加 凭证适配器bean （以下 凭证适配器应用了md5算法的加密\n    \n    <bean id="credentialsmatcher" class="org.apache.shiro.authc.credential.hashedcredentialsmatcher">\n        <property name="hashalgorithmname" value="md5"/>\n        <property name="hashiterations" value="2"/>\n    </bean>\n    \n\n 2. 自定义领域添加凭证适配器bean\n    \n    \x3c!-- 自定义领域 --\x3e\n    <bean name="customrealm" class="com.sans.shiro.customrealm">\n        <property name="credentialsmatcher" ref="credentialsmatcher"/>\n    </bean>\n    \n\n# authorizationattributesourceadvisor\n\norg.apache.shiro.spring.security.interceptor.authorizationattributesourceadvisor类，权限管理器\n\nshrio默认是不会有 处理/捕获 异常，因此该类主要是给 授权/认证 失败所抛出的异常给与对应的处理(友善的回复\n\n<bean  class="org.apache.shiro.spring.security.interceptor.authorizationattributesourceadvisor">\n\t<property name="securitymanager" ref="securitymanager" />\n</bean>\n\n\n> **注意：**配置主要配置在spring整体的上下文中。如果不是在spring上下文的整体中，则需要配置在 springmvc的配置中 ，这一回复过程是交给springmvc进行处理的！\n\n\n# 配置文件 *.ini\n\nini 基本上是一种文本配置，由唯一命名的部分组织的 键/值对组成。每个部分都可以被视为单个定义properties\n\n官方配置文档：https://shiro.apache.org/configuration.html\n\nshiro ini主要配置:\n\n * [main]\n * [users]\n * [users]\n * [roles]\n * [urls]\n\n# [main]\n\n配置应用程序的实例依赖项（例如：realms配置\n\n> 可以理解为是低配版的 spring loc容器配置\n\n为了能够更直观的理解，以下配置库连接的示例：\n\n[main]\nnewuser = com.pojo.myuser\n\nmyrealm = com.shiro.databaserealm\nmyrealm.connectiontimeout = 30000\nmyrealm.username = jsmith\nmyrealm.password = secret\nmyrealm.user = $newuser\n\nsecuritymanager.sessionmanager.globalsessiontimeout = 1800000\n\n\n定义对象\n\n[main]\n## 实例化新对象，并为对象进行配置\nmyrealm = com.shiro.databaserealm\n\n\n设置对象属性值\n\n...\nmyrealm.connectiontimeout = 30000\nmyrealm.username = jsmith\nmyrealm.password = secret\n...\n\n\n> 本质的调用 setter()方法进行 赋予值的\n\n属性值如果为对象则需要通过 $美元符号 作为前缀定义\n\n...\nnewuser = com.pojo.myuser\n...\n## 实体属性形式 : myuser user;\nmyrealm.user = $newuser\n...\n\n\n> 属性对象也是通过 setter()方法 进行赋予值的。==myrealm.setuser(newuser)==\n\n嵌套属性\n\n为最终要到达的属性设置值\n\n...\nsecuritymanager.sessionmanager.globalsessiontimeout = 1800000\n...\n\n\n> 换个角度可以理解为：==securitymanager.getsessionmanager().setglobalsessiontimeout(1800000)==\n\n# [users]\n\n一组静态用户账户（一般在 测试 或 运行时不需要创建用户 的环境下配置应用\n\n[users]\nadmin = sans\nlonestarr = vespa, goodguy, useroperation\ndarkhelmet = ludicrousspeed, badguy, schwartz\n\n\n每行格式\n\n每行都要满足的格式形式：\n\n==username = password , rolename1 , rolename2 , ...==\n\n * username ：用户名\n * password ：用户密码\n * 密码后的 ,逗号分隔 值都是分配给该用户角色的名称 (可选角色\n\n# [roles]\n\n权限 和 用户 定义关联（一般在 测试 或 运行时不需要创建用户 的环境下配置应用\n\n## \'admin\' 角色具有所有权限，由通配符 \'\' 指示\nadmin = *\n## \'useroperation\' 角色 可以用 user的任何功能\nuseroperation = user:*\n## \'usercr\' 角色 只能用 user的create和delete功能\nusercr = user:create,user:delete\n\n\n每行格式\n\n每行都要满足的格式形式：\n\n==rolename = permissiondefinition1 , permissiondefinition2 , ...==\n\n * rolename : 角色名称\n * permissiondefinition : 权限\n\n# [urls]\n\njavaweb请求地址配置\n\n[urls]\n/index.html = anon\n/user/create = anon\n/user/** = authc\n/rest/** = authc, rest\n\n\n每行格式\n\n==uri = filter1 , filter2 , ...==\n\n * uri ：路由\n * filter ：过滤器 （shiro有套默认的过滤器\n\ndiy过滤器\n\n[main]\n...\nmyfilter = com.sans.filters.myfilter\n...\n[urls]\n...\n/some/path/** = myfilter\n\n\n\n# 首次应用\n\n\n# 单元测试\n\n实现步骤：\n\n 1. 引入jar\n\n 2. 配置文件 .ini (shiro-first.ini)\n    \n    #用户信息配置\n    [users]\n    #用户帐号和密码\n    zhangsan = 111111\n    lishi = 333333\n    \n\n 3. 单元测试 测试前提需要shiro环境！\n    \n    1. 初始化 security manager环境 ==factory factory = new inisecuritymanagerfactory(<配置文件>)==\n    \n    2. 配置安全管理环境\n       \n       // 实例安全管理看空间\n       securitymanager instance = factory.getinstance();\n       // 设置安全管理\n       securityutils.setsecuritymanager(instance);\n       \n    \n    3. 获取认证主体 ==subject subject = securityutils.getsubject();==\n    \n    4. 主题认证 （toke封装 ==usernamepasswordtoken token = new usernamepasswordtoken()==\n    \n    5. 认证信息 （该方法可能会抛出登录可能出现的异常 ==subject.login(token);==\n    \n    6. 验证登录成功\n       \n       ==subject.isauthenticated()==\n    \n    示例：\n    \n    @test\n    public void defaulttest() {\n        factory<securitymanager> factory = new inisecuritymanagerfactory("classpath:shiro-first.ini");\n        // 实例安全管理看空间\n        securitymanager instance = factory.getinstance();\n        // 设置安全管理\n        securityutils.setsecuritymanager(instance);\n        // 获取认证主体\n        subject subject = securityutils.getsubject();\n        usernamepasswordtoken token = new usernamepasswordtoken("lishi", "333333");\n        subject.login(token);\n        boolean authenticated = subject.isauthenticated();\n        system.out.println("是否可行？" + authenticated);\n    }\n    \n    /* 控制台结果\n    \t是否可行？true\n    */\n    \n\n\n# javaweb整合\n\n**javaweb应用：**https://shiro.apache.org/web.html\n\n**集成springboot：**https://shiro.apache.org/spring-boot.html#web_applications\n\n实现步骤： （只讲有关shiro配置\n\n 1. 配置文件 web.xml、shiro.ini\n    \n    web.xml\n    \n    \x3c!-- shirofilter 初始化shiro环境 --\x3e\n    <filter>\n        <filter-name>shirofilter</filter-name>\n        <filter-class>org.apache.shiro.web.servlet.shirofilter</filter-class>\n    </filter>\n    <filter-mapping>\n        <filter-name>shirofilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n    \n    \x3c!-- 加载 *.ini , 并构建 websecuritymanager。\n        里面包含有很多过滤器链 --\x3e\n    <listener>\n        <listener-class>org.apache.shiro.web.env.environmentloaderlistener</listener-class>\n    </listener>\n    \n    \x3c!-- 自定义 .ini文件名 以及位置 --\x3e\n    \x3c!--<context-param>--\x3e\n    \x3c!--    <param-name>shiroconfiglocations</param-name>--\x3e\n    \x3c!--    <param-value>classpath:shirodiy.ini</param-value>--\x3e\n    \x3c!--</context-param>--\x3e\n    \n    \n    > ps：\n    > \n    >  * shirofilter过滤器 接收所有请求，进行 识别/校验 ，如果触发安全校验，会遍历一次过滤器链。链中的 请求处理的配置，在 shiro.ini文件 中进行\n    > \n    >  * environmentloaderlistener类 shiro环境加载，加载 shiro.ini文件以及过滤器链\n    > \n    >  * shiro默认是自动加载 shiro.ini文件名（无需配置），如果 是自定义名称 *.ini，则需要以下配置\n    >    \n    >    <context-param>\n    >        <param-name>shiroconfiglocations</param-name>\n    >        <param-value>classpath:shirodiy.ini</param-value>\n    >    </context-param>\n    >    \n    \n    shiro.ini\n    \n    [main]\n    \n    \n\n\n# 认证入口\n\nshiro.loginurl = /login\n\n\n# 角色/权限 无权重定向\n\nshiro.unauthorizedurl = /error.jsp\n\n\n# 成功页\n\nshiro.successurl = /success.jsp\n\n[urls] / = anon /logout = logout /** = authc\n\n[users] zhangsan=123123\n\n\n2. 配置登录入口启动运行即可\n\n> **注意：**formauthenticationfilter表单过滤器\n>\n> 表单指定的属性名称：（如果使用默认的过滤器情况下\n>\n> - 账号：`username`\n> - 密码：`password`\n> - 记住：`rememberme` \n\n### ssm整合\n\nssm整合通过代理实现，更为贴近spring功能的应用和实现\n\n**步骤：**\n\n1. `web.xml`配置，添加代理过滤器\n\n```xml\n<filter>\n    <filter-name>shirofilter</filter-name>\n    <filter-class>org.springframework.web.filter.delegatingfilterproxy</filter-class>\n    \x3c!-- 设置true由servlet容器控制filter的生命周期 --\x3e\n    <init-param>\n        <param-name>targetfilterlifecycle</param-name>\n        <param-value>true</param-value>\n    </init-param>\n    \x3c!-- 设置spring容器filter的bean id，如果不设置则找与filter-name一致的bean --\x3e\n    <init-param>\n        <param-name>targetbeanname</param-name>\n        <param-value>shirofilter</param-value>\n    </init-param>\n</filter>\n<filter-mapping>\n    <filter-name>shirofilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n\n\n> **注意：**过滤器名称 与 bean id 匹配，否则spring找不到匹配的bean\n\n 2. spring配置\n    \n    <?xml version="1.0" encoding="utf-8"?>\n    <beans xmlns="http://www.springframework.org/schema/beans"\n           xmlns:xsi="http://www.w3.org/2001/xmlschema-instance" xmlns:mvc="http://www.springframework.org/schema/mvc"\n           xmlns:context="http://www.springframework.org/schema/context"\n           xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx"\n           xsi:schemalocation="http://www.springframework.org/schema/beans\n    \t\thttp://www.springframework.org/schema/beans/spring-beans-3.2.xsd\n    \t\thttp://www.springframework.org/schema/mvc\n    \t\thttp://www.springframework.org/schema/mvc/spring-mvc-3.2.xsd\n    \t\thttp://www.springframework.org/schema/context\n    \t\thttp://www.springframework.org/schema/context/spring-context-3.2.xsd\n    \t\thttp://www.springframework.org/schema/aop\n    \t\thttp://www.springframework.org/schema/aop/spring-aop-3.2.xsd\n    \t\thttp://www.springframework.org/schema/tx\n    \t\thttp://www.springframework.org/schema/tx/spring-tx-3.2.xsd\n    ">\n        \x3c!-- 启动aop --\x3e\n        <aop:config proxy-target-class="true"/>\n        \n        <bean id="shirofilter" class="org.apache.shiro.spring.web.shirofilterfactorybean">\n            \x3c!-- 安全管理器 --\x3e\n            <property name="securitymanager" ref="securitymanager"/>\n            \x3c!-- loginurl 认证地址 --\x3e\n            <property name="loginurl" value="/login"/>\n            \x3c!-- 认证成功 --\x3e\n            <property name="successurl" value="/first" />\n            \x3c!-- 未授权定义的跳转 --\x3e\n            <property name="unauthorizedurl" value="/refuse.jsp"/>\n            <property name="filterchaindefinitions">\n                <value>\n                    ...\n                    \x3c!-- 权限分配 --\x3e\n                    ...\n                    /**=authc\n                </value>\n            </property>\n        </bean>\n    \n        \x3c!-- 注解shiro支持 --\x3e\n        <bean class="org.apache.shiro.spring.security.interceptor.authorizationattributesourceadvisor">\n            <property name="securitymanager" ref="securitymanager"/>\n        </bean>\n    \n        \x3c!-- securitymanager安全管理 --\x3e\n        <bean id="securitymanager" class="org.apache.shiro.web.mgt.defaultwebsecuritymanager">\n            <property name="realm" ref="customrealm" />\n        </bean>\n    \n    </beans>\n    \n    \n    > **注意：**注解shiro支持，需要spring上下文/在springmvc中进行配置否者无效\n\n\n# 业务方法\n\n获取当前指定的主题 subject\n\nsubject subject = securityutils.getsubject();\n\n\n> subject 原意是和 user 一样，由于很多应用程序又有 用户user类 相同的名称，因此 shiro 尽可能的排除这些冲突，把类名设为 subject。此外在 subject 是安全世界中公认的命名存在\n\n用户会话\n\nsession session = subject.getsession();\n\n\n> 该会话不依赖于环境进行获取（如：http，web环境等\n\n检查是否允许指定操作（角色/权限\n\nif(!currentuser.isauthenticeted()){\n\tusernamepasswordtoken token = new usernamepasswordtoken("张三", "123123");\n\ttoken.setrememberme(true);\n    subject.login(token);\n}\n\n\n识别主体\n\nsubject.getprincipal()\n\n\n查看是否有权对某对象进行执行 (查库中的特定字段code判断是否含有功能凭证的角色\n\nif (subject.ispermitted( "item:create" ) ) {\n    log.info("有权创建！");\n} else {\n    log.info("无权创建！");\n}\n\n\n判断是否为指定角色\n\nif(subject.hasrole("admin")){\n    log.info("是admin角色")\n}else{\n    log.info("不是admin角色")\n}\n\n\n用户注销 删除所有标识信息并使其会话失效\n\nsubject.logout();\n\n\n\n# 执行流程\n\n\n# 认证\n\n\n\n 1. 通过 ini配置文件 创建 securitymanager安全管理器\n 2. 调用 subject.login()方法 执行提交认证（带参数的token\n 3. securitymanager认证（最终由 modularrealmauthenticator 进行认证处理\n 4. modularrealmauthenticator 调用 inirealm 去ini配置文件查询用户信息\n 5. inirealm根据 token 中，查询用户信息（账号密码 查到的返回 用户信息，否则null\n 6. modularrealmauthenticator 接收 inirealm返回authentication认证信息\n\n\n# 授权\n\n\n\n 1. 对subject进行授权，调用方法 ispermitted()方法 （指定权限key\n 2. securitymanager执行授权，通过modularrealmauthorizer进行授权\n 3. modularrealmauthorizer执行 realm （从数据库查询权限数据 realm授权方法：dogetauthorizationinfo()\n 4. realm从数据库查询权限数据，返回modularrealmauthorizer\n 5. modularrealmauthorizer调用permissionresolver进行权限串比对\n 6. 通过比对permission权限进行赋予权限\n\n\n# 过滤器\n\n过滤器名称               全限定名类                                                              说明\nanon                org.apache.shiro.web.filter.authc.anonymousfilter                  不执行安全检查进行访问\nauthc               org.apache.shiro.web.filter.authc.formauthenticationfilter         身份认证才能访问，否则重定向 loginurl进行登录认证\nauthcbasic          org.apache.shiro.web.filter.authc.basichttpauthenticationfilter    身份认证才能访问，否则要求用户通过http basic协议进行登录认证\nauthcbearer         org.apache.shiro.web.filter.authc.bearerhttpauthenticationfilter   身份认证才能访问，否则要求用户通过特定的http持有者协议进行登录认证\ninvalidrequest      org.apache.shiro.web.filter.invalidrequestfilter                   阻止恶意请求。将请求无效化（400\nlogout              org.apache.shiro.web.filter.authc.logoutfilter                     立即注销当前用户，并重定向至 loginurl\nnosessioncreation   org.apache.shiro.web.filter.session.nosessioncreationfilter        会话未建立调用时，会禁用所有调用\nperms               org.apache.shiro.web.filter.authz.permissionsauthorizationfilter   用户是否有权访问，没有则拒绝\nport                org.apache.shiro.web.filter.authz.portfilter                       请求特定的端口，则重定向至该端口的同一 url\nrest                org.apache.shiro.web.filter.authz.httpmethodpermissionfilter       明确请求访问权限，动词映射方式\nroles               org.apache.shiro.web.filter.authz.rolesauthorizationfilter         用户是否为指定角色（角色可分配业务功能\nssl                 org.apache.shiro.web.filter.authz.sslfilter                        通过ssl请求\nuser                org.apache.shiro.web.filter.authc.userfilter                       是否记住用户，已知用户允许请求，否则重定向loginurl进行登录认证\n\n\n# 自定义过滤器\n\n自定义可以根据个人设定进行功能实现\n\n步骤：\n\n 1. 创建 自定义过滤器类 myfilter ，并继承 authorizationfilter类 实现 isaccessallowed()方法\n    \n    public class myfilter extends authorizationfilter {\n        /**\n         * 是否允许访问\n         * @param request     请求\n         * @param response    响应\n         * @param mappedvalue url规则映射中映射到此过滤器的过滤器特定配置值\n         * @return true允许访问；否则拒绝访问\n         */\n        @override\n        protected boolean isaccessallowed(servletrequest request, servletresponse response, object mappedvalue) throws exception {\n            ...\n            return false;\n        }\n    }\n    \n\n 2. 在 spring中的 shrio配置中 添加过滤器bean，并引入映射（引入过滤器\n    \n    <-- 引入过滤器bean （需要过滤器的全限定名 --\x3e\n    <bean id="mycustomfilter" class="com.sans.filter.myfilter"/>\n    <bean id="shirofilter" class="org.apache.shiro.spring.web.shirofilterfactorybean">\n        ....\n        \x3c!-- 添加自定义过滤器filter --\x3e\n        <property name="filters">\n            <map>\n                <entry key="cusf" value-ref="mycustomfilter"/>\n            </map>\n        </property>\n        <property name="filterchaindefinitions">\n            <value>\n                \x3c!-- 过滤指定路径 --\x3e\n                /some/path/** = cusf\n                ...\n            </value>\n        </property>\n    </bean>\n    ',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"MySQL",frontmatter:{title:"MySQL",author:"柏竹",permalink:"/backend/621sa1",date:"2020-02-18T00:00:00.000Z",categories:["后端"],tags:["数据库"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/05.%E6%95%B0%E6%8D%AE%E5%BA%93/01.MySQL.html",relativePath:"01.后端/05.数据库/01.MySQL.md",key:"v-1f123e21",path:"/backend/621sa1/",headers:[{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:12},{level:2,title:"卸载",slug:"卸载",normalizedTitle:"卸载",charIndex:845},{level:2,title:"数据类型",slug:"数据类型",normalizedTitle:"数据类型",charIndex:1001},{level:3,title:"整型数据",slug:"整型数据",normalizedTitle:"整型数据",charIndex:1010},{level:3,title:"浮点型",slug:"浮点型",normalizedTitle:"浮点型",charIndex:1318},{level:3,title:"日期 时间类型",slug:"日期-时间类型",normalizedTitle:"日期 时间类型",charIndex:1508},{level:3,title:"字符串型",slug:"字符串型",normalizedTitle:"字符串型",charIndex:2111},{level:3,title:"二进制数据类型",slug:"二进制数据类型",normalizedTitle:"二进制数据类型",charIndex:2213},{level:3,title:"大文本数据类型",slug:"大文本数据类型",normalizedTitle:"大文本数据类型",charIndex:2348},{level:3,title:"大数据二进制类型",slug:"大数据二进制类型",normalizedTitle:"大数据二进制类型",charIndex:2484},{level:3,title:"枚举型",slug:"枚举型",normalizedTitle:"枚举型",charIndex:2621},{level:3,title:"多选项",slug:"多选项",normalizedTitle:"多选项",charIndex:2667},{level:2,title:"DDL 库操作",slug:"ddl-库操作",normalizedTitle:"ddl 库操作",charIndex:2699},{level:3,title:"创建数据库",slug:"创建数据库",normalizedTitle:"创建数据库",charIndex:2809},{level:3,title:"查看数据库",slug:"查看数据库",normalizedTitle:"查看数据库",charIndex:3233},{level:3,title:"修改数据库",slug:"修改数据库",normalizedTitle:"修改数据库",charIndex:3347},{level:3,title:"删除数据库",slug:"删除数据库",normalizedTitle:"删除数据库",charIndex:3699},{level:3,title:"选择数据库",slug:"选择数据库",normalizedTitle:"选择数据库",charIndex:3732},{level:2,title:"DDL 表操作",slug:"ddl-表操作",normalizedTitle:"ddl 表操作",charIndex:3755},{level:3,title:"创建表",slug:"创建表",normalizedTitle:"创建表",charIndex:3870},{level:3,title:"查看表",slug:"查看表",normalizedTitle:"查看表",charIndex:4212},{level:3,title:"修改表",slug:"修改表",normalizedTitle:"修改表",charIndex:4309},{level:3,title:"删除表",slug:"删除表",normalizedTitle:"删除表",charIndex:4710},{level:2,title:"DML 数据操作",slug:"dml-数据操作",normalizedTitle:"dml 数据操作",charIndex:4738},{level:3,title:"插入数据",slug:"插入数据",normalizedTitle:"插入数据",charIndex:4850},{level:3,title:"更改数据",slug:"更改数据",normalizedTitle:"更改数据",charIndex:5143},{level:3,title:"删除数据",slug:"删除数据",normalizedTitle:"删除数据",charIndex:3699},{level:2,title:"DCL 安全访问",slug:"dcl-安全访问",normalizedTitle:"dcl 安全访问",charIndex:5618},{level:3,title:"创建用户",slug:"创建用户",normalizedTitle:"创建用户",charIndex:5704},{level:3,title:"授权用户",slug:"授权用户",normalizedTitle:"授权用户",charIndex:5816},{level:3,title:"查询权限",slug:"查询权限",normalizedTitle:"查询权限",charIndex:5936},{level:3,title:"撤销权限",slug:"撤销权限",normalizedTitle:"撤销权限",charIndex:6026},{level:3,title:"删除用户",slug:"删除用户",normalizedTitle:"删除用户",charIndex:6086},{level:3,title:"权限刷新",slug:"权限刷新",normalizedTitle:"权限刷新",charIndex:6119},{level:2,title:"DQL 数据查询",slug:"dql-数据查询",normalizedTitle:"dql 数据查询",charIndex:6166},{level:3,title:"普通查询",slug:"普通查询",normalizedTitle:"普通查询",charIndex:6863},{level:4,title:"条件查询 (WHERE)",slug:"条件查询-where",normalizedTitle:"条件查询 (where)",charIndex:6871},{level:4,title:"指定查询 (IN)",slug:"指定查询-in",normalizedTitle:"指定查询 (in)",charIndex:7164},{level:4,title:"范围查询 (BETWEEN  AND)",slug:"范围查询-between-and",normalizedTitle:"范围查询 (between  and)",charIndex:null},{level:4,title:"空值查询 (NULL)",slug:"空值查询-null",normalizedTitle:"空值查询 (null)",charIndex:7613},{level:4,title:"过滤查询 (DISTINCT )",slug:"过滤查询-distinct",normalizedTitle:"过滤查询 (distinct )",charIndex:7779},{level:4,title:"模糊查询 (LIKE)",slug:"模糊查询-like",normalizedTitle:"模糊查询 (like)",charIndex:7902},{level:4,title:"多条件查询  (AND)",slug:"多条件查询-and",normalizedTitle:"多条件查询  (and)",charIndex:null},{level:4,title:"多条件查询 (OR)",slug:"多条件查询-or",normalizedTitle:"多条件查询 (or)",charIndex:8379},{level:3,title:"高级查询",slug:"高级查询",normalizedTitle:"高级查询",charIndex:8682},{level:4,title:"聚合函数",slug:"聚合函数",normalizedTitle:"聚合函数",charIndex:8690},{level:5,title:"记数函数 (COUNT)",slug:"记数函数-count",normalizedTitle:"记数函数 (count)",charIndex:8698},{level:5,title:"求和函数 (SUM)",slug:"求和函数-sum",normalizedTitle:"求和函数 (sum)",charIndex:8868},{level:5,title:"平均值函数 (AVG)",slug:"平均值函数-avg",normalizedTitle:"平均值函数 (avg)",charIndex:9111},{level:5,title:"最大值函数 (MAX)",slug:"最大值函数-max",normalizedTitle:"最大值函数 (max)",charIndex:9249},{level:5,title:"最小值函数 (MIN)",slug:"最小值函数-min",normalizedTitle:"最小值函数 (min)",charIndex:9392},{level:4,title:"顺序查询 (ORDER BY)",slug:"顺序查询-order-by",normalizedTitle:"顺序查询 (order by)",charIndex:9535},{level:4,title:"分组查询 (GROUP BY)",slug:"分组查询-group-by",normalizedTitle:"分组查询 (group by)",charIndex:9927},{level:4,title:"限制查询 (LIMIT)",slug:"限制查询-limit",normalizedTitle:"限制查询 (limit)",charIndex:10732},{level:3,title:"别名",slug:"别名",normalizedTitle:"别名",charIndex:6321},{level:4,title:"表别名",slug:"表别名",normalizedTitle:"表别名",charIndex:11147},{level:4,title:"字段别名",slug:"字段别名",normalizedTitle:"字段别名",charIndex:11243},{level:3,title:"多表关系",slug:"多表关系",normalizedTitle:"多表关系",charIndex:11422},{level:4,title:"连接查询(CROSS JOIN)",slug:"连接查询-cross-join",normalizedTitle:"连接查询(cross join)",charIndex:18806},{level:4,title:"自然连接(NATURAL JOIN)",slug:"自然连接-natural-join",normalizedTitle:"自然连接(natural join)",charIndex:19027},{level:4,title:"合并结果集 (UNION)",slug:"合并结果集-union",normalizedTitle:"合并结果集 (union)",charIndex:19203},{level:4,title:"内连接 (INNER JOIN)",slug:"内连接-inner-join",normalizedTitle:"内连接 (inner join)",charIndex:19506},{level:4,title:"外连接 (OUTER JOIN)",slug:"外连接-outer-join",normalizedTitle:"外连接 (outer join)",charIndex:20269},{level:4,title:"子查询",slug:"子查询",normalizedTitle:"子查询",charIndex:20886},{level:5,title:"where中子查询",slug:"where中子查询",normalizedTitle:"where中子查询",charIndex:20980},{level:5,title:"from中子查询",slug:"from中子查询",normalizedTitle:"from中子查询",charIndex:21179},{level:5,title:"select中子查询",slug:"select中子查询",normalizedTitle:"select中子查询",charIndex:21420},{level:5,title:"IN",slug:"in",normalizedTitle:"in",charIndex:466},{level:5,title:"EXISTS",slug:"exists",normalizedTitle:"exists",charIndex:2964},{level:5,title:"ANY",slug:"any",normalizedTitle:"any",charIndex:22218},{level:5,title:"ALL",slug:"all",normalizedTitle:"all",charIndex:1122},{level:5,title:"比较运算符",slug:"比较运算符",normalizedTitle:"比较运算符",charIndex:19530},{level:3,title:"查新执行顺序",slug:"查新执行顺序",normalizedTitle:"查新执行顺序",charIndex:23081},{level:3,title:"SQL优化",slug:"sql优化",normalizedTitle:"sql优化",charIndex:23358},{level:2,title:"完整性",slug:"完整性",normalizedTitle:"完整性",charIndex:3906},{level:3,title:"实体完整性",slug:"实体完整性",normalizedTitle:"实体完整性",charIndex:23829},{level:4,title:"单字段主键",slug:"单字段主键",normalizedTitle:"单字段主键",charIndex:23838},{level:4,title:"唯一约束",slug:"唯一约束",normalizedTitle:"唯一约束",charIndex:23984},{level:4,title:"字段自动增加",slug:"字段自动增加",normalizedTitle:"字段自动增加",charIndex:24029},{level:3,title:"域完整性",slug:"域完整性",normalizedTitle:"域完整性",charIndex:24110},{level:4,title:"数据类型",slug:"数据类型-2",normalizedTitle:"数据类型",charIndex:1001},{level:4,title:"非空约束",slug:"非空约束",normalizedTitle:"非空约束",charIndex:23678},{level:4,title:"默认约束",slug:"默认约束",normalizedTitle:"默认约束",charIndex:24173},{level:4,title:"无符号约束",slug:"无符号约束",normalizedTitle:"无符号约束",charIndex:23803},{level:4,title:"约束范围",slug:"约束范围",normalizedTitle:"约束范围",charIndex:24263},{level:3,title:"引用完整性",slug:"引用完整性",normalizedTitle:"引用完整性",charIndex:24314},{level:4,title:"外键约束",slug:"外键约束",normalizedTitle:"外键约束",charIndex:23656},{level:2,title:"索引",slug:"索引",normalizedTitle:"索引",charIndex:23405},{level:3,title:"索引创建",slug:"索引创建",normalizedTitle:"索引创建",charIndex:25274},{level:4,title:"单列索引 (NORMAL)",slug:"单列索引-normal",normalizedTitle:"单列索引 (normal)",charIndex:25649},{level:4,title:"唯一索引 (UNIQUE )",slug:"唯一索引-unique",normalizedTitle:"唯一索引 (unique )",charIndex:26065},{level:4,title:"全文索引 (FULLTEXT)",slug:"全文索引-fulltext",normalizedTitle:"全文索引 (fulltext)",charIndex:26202},{level:4,title:"空间索引 (SPATIAL)",slug:"空间索引-spatial",normalizedTitle:"空间索引 (spatial)",charIndex:26392},{level:3,title:"索引删除",slug:"索引删除",normalizedTitle:"索引删除",charIndex:26624},{level:2,title:"函数",slug:"函数",normalizedTitle:"函数",charIndex:8692},{level:3,title:"数学函数",slug:"数学函数",normalizedTitle:"数学函数",charIndex:26703},{level:3,title:"字符串函数",slug:"字符串函数",normalizedTitle:"字符串函数",charIndex:27111},{level:3,title:"日期与时间的函数",slug:"日期与时间的函数",normalizedTitle:"日期与时间的函数",charIndex:27576},{level:3,title:"条件判断函数",slug:"条件判断函数",normalizedTitle:"条件判断函数",charIndex:28269},{level:3,title:"加密函数",slug:"加密函数",normalizedTitle:"加密函数",charIndex:28627},{level:2,title:"事务",slug:"事务",normalizedTitle:"事务",charIndex:28789},{level:3,title:"事务ACID特性",slug:"事务acid特性",normalizedTitle:"事务acid特性",charIndex:29077},{level:3,title:"事务安全问题",slug:"事务安全问题",normalizedTitle:"事务安全问题",charIndex:29363},{level:3,title:"事务隔离级别",slug:"事务隔离级别",normalizedTitle:"事务隔离级别",charIndex:29514},{level:4,title:"未提交 (READ  UNCOMMITTED)",slug:"未提交-read-uncommitted",normalizedTitle:"未提交 (read  uncommitted)",charIndex:null},{level:4,title:"已读提交 (READ  COMMITTED)",slug:"已读提交-read-committed",normalizedTitle:"已读提交 (read  committed)",charIndex:null},{level:4,title:"可重复读 (REPEATABLE READ)",slug:"可重复读-repeatable-read",normalizedTitle:"可重复读 (repeatable read)",charIndex:30597},{level:4,title:"顺序读 (SERIALIZABLE)",slug:"顺序读-serializable",normalizedTitle:"顺序读 (serializable)",charIndex:31026},{level:3,title:"隔离级别锁的情况",slug:"隔离级别锁的情况",normalizedTitle:"隔离级别锁的情况",charIndex:31112}],headersStr:"安装 卸载 数据类型 整型数据 浮点型 日期 时间类型 字符串型 二进制数据类型 大文本数据类型 大数据二进制类型 枚举型 多选项 DDL 库操作 创建数据库 查看数据库 修改数据库 删除数据库 选择数据库 DDL 表操作 创建表 查看表 修改表 删除表 DML 数据操作 插入数据 更改数据 删除数据 DCL 安全访问 创建用户 授权用户 查询权限 撤销权限 删除用户 权限刷新 DQL 数据查询 普通查询 条件查询 (WHERE) 指定查询 (IN) 范围查询 (BETWEEN  AND) 空值查询 (NULL) 过滤查询 (DISTINCT ) 模糊查询 (LIKE) 多条件查询  (AND) 多条件查询 (OR) 高级查询 聚合函数 记数函数 (COUNT) 求和函数 (SUM) 平均值函数 (AVG) 最大值函数 (MAX) 最小值函数 (MIN) 顺序查询 (ORDER BY) 分组查询 (GROUP BY) 限制查询 (LIMIT) 别名 表别名 字段别名 多表关系 连接查询(CROSS JOIN) 自然连接(NATURAL JOIN) 合并结果集 (UNION) 内连接 (INNER JOIN) 外连接 (OUTER JOIN) 子查询 where中子查询 from中子查询 select中子查询 IN EXISTS ANY ALL 比较运算符 查新执行顺序 SQL优化 完整性 实体完整性 单字段主键 唯一约束 字段自动增加 域完整性 数据类型 非空约束 默认约束 无符号约束 约束范围 引用完整性 外键约束 索引 索引创建 单列索引 (NORMAL) 唯一索引 (UNIQUE ) 全文索引 (FULLTEXT) 空间索引 (SPATIAL) 索引删除 函数 数学函数 字符串函数 日期与时间的函数 条件判断函数 加密函数 事务 事务ACID特性 事务安全问题 事务隔离级别 未提交 (READ  UNCOMMITTED) 已读提交 (READ  COMMITTED) 可重复读 (REPEATABLE READ) 顺序读 (SERIALIZABLE) 隔离级别锁的情况",content:"# MySQL\n\n\n# 安装\n\n点击官方链接下载\n\n配置环境\n\n在MySQL根目录下的 bin文件 在 变量 Path 增添 。如\n\nD:\\MySQL\\mysql-8.0.22-winx64\\bin\n\n\n配置文件\n\n在MySQL根目录下的新建 my.ini文件 和 data文件夹 , 配置参数\n\n[mysql]\n# 设置mysql客户端默认字符集\ndefault-character-set=utf8\n[mysqld] \n# 设置3306端口\nport = 3306 \n# 设置MySQL根目录\nbasedir=D:\\MySQL\\mysql-8.0.22-winx64\n# 设置MySQL数据库数据存放目录\ndatadir=D:\\MySQL\\mysql-8.0.22-winx64\\data \n# 允许最大连接数\nmax_connections=200 \n# 服务端使用的字符集默认为UTF8\ncharacter-set-server=utf8 \n# 创建新表时将使用的默认存储引擎\ndefault-storage-engine=INNODB\n# 设置时间戳\nexplicit_defaults_for_timestamp=true\n\n\n安装MySQL\n\n初始化数据库 在MySQL的根目录 bin文件夹 里 ，管理员身份打开cmd执行指令\n\nmysqld --initialize-insecure --user=mysql\n\n\n查看是否安装 然后安装执行，cmd执行指令\n\nmysqld install\n\n\n如果未提示成功，请用管理员身份打开重新执行cmd执行指令\n\n启动MySQL服务。cmd执行指令\n\nnet start mysql\n\n\n也可以在 控制面板 打开服务 进行启动 MySQL服务\n\n进入myslq，无密码执行，cmd执行指令\n\nmysql -uroot -p\n\n\n> PS：如果本地IP访问不到，需要重新启动服务，在cmd 进入 bin文件夹 进行启动服务\n\n\n# 卸载\n\n 1. 管理员运行cmd关闭 MySQL服务，cmd执行指令\n\nnet stop mysql8\n\n\n 2. 删除MySQL服务\n\nsc delete mysql8 \n或者 \nmysql remove mysql8\n\n\n 3. 删除mysqlDB目录文件(安装MySQL时my.ini指定的目录)\n\n\n# 数据类型\n\n\n# 整型数据\n\n整型数据        字节数   无符号的取值范围                 有符号的取值范围\nTINYINT     1     0~225                    -125~127\nSMALLINT    2     0-65535                  -32768~32768\nMEDIUMINT   3     0~16777215               ···\nINT         4     0-4294967295             ···\nBIGINT      8     0~18446744073709551615   \n\n\n# 浮点型\n\n浮点型 数据             字节数   说明\nFLOAT[(M,D)]       4     M指定显示长度，D指定小数位数，浮点\nDOUBLE[(M,D)]      8     M指定显示长度，D指定小数位数，浮点\n定点数型数据             -     -\nDECIMAL(()M , 2)   M+2   定点数，存储 高精度数据\n\n\n# 日期 时间类型\n\n数据类型             字节数   取值范围                                      日期格式                  零值\nYEAR             1     1901~2155                                 yyyy                  0000\nDATE             4     1000-01-01-9999-12-3                      yyyy-MM-dd            0000-00-00\nTIME             3     -838:59:59-838:59:59                      HH:mm:ss              00:00:00\nDATETIME         8     11                                        yyyy-MM-dd HH:mm:ss   0000-00-00 00:00:00\nTIMESTAMP(时间戳)   4     1970-01-01 00:00:01~2038-01-19 03:14:07   yyyy-MM-dd HH:mm:ss   0000-00-00 00:00:00\n\n\n# 字符串型\n\n字符串类型(单位：字节)        字节状态   优点\nCHAR((int)Max)      固定     查询快\nVARCHAR((int)Max)   动态     省空间\n\n\n# 二进制数据类型\n\n二进制数据类型(单位：长度)        长度状态\nBINARY((int)Max)      固定\nVARBINARY((int)Max)   动态\n\nBINARY类型的长度是固定的，如果长度不足最大长度,后面用“0”对齐，直到指定长度。\n\n\n# 大文本数据类型\n\n大文本数据类型      存储范围(单位：字节)\nTINYTEXT     0~255字节\nTEXT         0~65535字节\nMEDIUMTEXT   0~16777215字节\nLONGTEXT     0~4294967295字节\n\n\n# 大数据二进制类型\n\n特殊二进制类型      存储范围(单位：字节)\nTINYBLOB     0~255字节\nBLOB         0-65535字节\nMEDIUMBLOB   0~16777215字节\nLONGBLOB     0-4294967295字节\n\n\n# 枚举型\n\nENUM枚举型，单选项\n\nENUM('值1','值2'···'值n')\n\n\n\n# 多选项\n\nSET('值1','值2'···'值n')\n\n\n\n# DDL 库操作\n\nDDL (Data Definition Language)：数据定义语言，操作增删改查的操作\n\n**操作关键字 : ** CREATE , DROP , ALTER , SHOW , USE\n\n\n# 创建数据库\n\nSQL语句                                                     说明\n==CREATE DATABASE 库名;==                                   创建库\n==CREATE DATABASE IF NOT EXISTS 库名;==                     判断不存在，则创建\n==CREATE DATABASE 库名 CHARACTER SET 编码方式;==                指定编码创建\n==CREATE DATABASE 库名 CHARACTER SET 编码方式 COLLATE 排序规则;==   指定编码和排序规则创建\n\n> CREATE DATABASE ：创建数据库 IF NOT EXISTS ：检查是否已存在的状态 CHARACTER SET：设置编码方式 COLLATE ：排序规则\n\n\n# 查看数据库\n\n查看当前数据库： ==SHOW DATABASES;==\n\n查看创建的库： ==SHOW CREATE DATABASE 库名;==\n\n查看当前所选的数据库： ==SELECT DATABASE();==\n\n\n# 修改数据库\n\nSQL语句                                                    说明\n==ALTER DATABASE 库名;==                                   修改库\n==ALTER DATABASE 库名 CHARACTER SET 编码方式;==                指定编码更改\n==ALTER DATABASE 库名 CHARACTER SET 编码方式 COLLATE 排序规则;==   指定编码和排序规则更改\n\n> ALTER DATABASE ：修改数据库 IF NOT EXISTS ：检查是否已存在的状态 CHARACTER SET ：设置编码方式 COLLATE ：排序规则\n\n\n# 删除数据库\n\n==DROP DATABASE 库名;==\n\n\n# 选择数据库\n\n==USE 库名;==\n\n\n# DDL 表操作\n\nDDL (Data Definition Language):数据定义语言，定义数据库对象:库、表、列等\n\n**操作关键字 : ** CREATE , DROP , ALTER , SHOW , USE\n\n\n# 创建表\n\nCREATE TABLE 表名(\n   字段名1 数据类型 [完整性约束条件] [COMMENT '注释内容'],\n   字段名2 数据类型 [完整性约束条件] [COMMENT '注释内容'],\n   ·······\n   字段名n 数据类型 [完整性约束条件] [COMMENT '注释内容'],\n   [完整性约束条件](字段1,字段2,·····,字段n)\n)[编码集设置];\n\n\n> **编码集设置 : ** CHARACTER SET 字符集名 [校对规则] **校对规则 : ** COLLATE 校对名\n\n快速创建拷贝表\n\nCREATE TABLE 表名 AS SELECT * FROM 拷贝表\n\n\n> PS : AS 后面 是拷贝制定查询的数据\n\n\n# 查看表\n\n查看指定表字段结构 ==DESC 表名;==\n\n查看当前数据库所有表 ==SHOW TABLES;==\n\n查看表的详细结构 ==SHOW CREATE TABLE 表名;==\n\n\n# 修改表\n\n修改表名\n\n==RENAME TABLE 表名 TO 新表名;== ==ALTER TABLE 表名 RENAME 新表名;==\n\n增加字段\n\n==ALTER TABLE 表名 ADD 字段名 数据类型;==\n\n字段 修改 与 顺序\n\nALTER TABLE 表名 MODIFY 字段名 数据类型 [更改字段循序 | 完整性约束条件] [COMMENT '内容'];\n\n\n> 更改字段循序 : FIRST | AFTER 字段名2\n> \n> FIRST：指定字段为表的第一个 AFTER：指定字段插入字段2的后面\n\n修改字段名\n\n==ALTER TABLE 表名 CHANGE 字段名 新字段名 新字段类型;==\n\n修改表字符集\n\n==ALTER TABLE 表名 CHARACTER SET 字符集类型;==\n\n删除字段\n\n==ALTER TABLE 表名 DROP 字段名;==\n\n\n# 删除表\n\n==DROP TABLE 表名;==\n\n\n# DML 数据操作\n\nDML (Data Manipulation Language):数据操作语言，定义数据库记录(数据)增删改 的操作\n\n**操作关键字 : ** INSERT , UPDATA , DELECT\n\n\n# 插入数据\n\n一条数据添加 ==INSERT INTO 表名 [(字段名1 [，字段名2. . .])] VALUES(值1 [,值2. . .]);== 多条数据添加 ==INSERT INTO 表名 [(字段名)] VALUES (字段值1),(字段值2)...;==\n\n注意：\n\n * 插入字段与它的数据类型位置是一一对应的\n * 数据类型对应的值，字段值是非数值，则两侧必须添加单引号\n * null设置为空\n * 数据的大小应在字段的数据类型规定范围内\n * 如果要插入所有字段数据时可以省写字段，但必须按表中字段顺序写值\n * 尽可能避免字段数据值写入的是 null\n\n\n# 更改数据\n\n更改单表数据 ==UPDATE 表名 SET 字段名1 = 字段值1 [,字段名2 = 值2..] [WHERE 条件表达式];== 更改多表数据 ==UPDATE 表名1 , 表名2  SET {修改字段值，可跨表修改} [WHERE 条件表达式];==\n\n注意：\n\n * 逻辑运算符有： and(并且)、or(或者)、not(取非)\n * 如果更改字段无条件表达式，则指定全部该字段的值一致\n\n\n# 删除数据\n\n==DELETE FROM 表名 [WHERE 条件表达式];== ==TRUNCATE TABLE 表名;== 多表删除 ==DELETE {表名1,表名2...} FROM {表名1,表名2...} [WHERE 条件表达式];==\n\n注意：\n\n * 如果无条件表达式，则删除全部数据\n * DELETE删除可找回\n * TRUNCATE删除不可找回，类似格式化数据，执行快\n * 不能删除某列的值(可修改数据值置NULL)\n * 多表删除 建议WHERE过滤他们字段的关系\n * 多表中的每张表需要逗号分隔\n\n\n# DCL 安全访问\n\nDCL (Data Control Language)︰数据控制语言，用来定义访问权限和安全级别\n\n操作关键字： GRANT , REVOKE\n\n\n# 创建用户\n\n==CREATE USER 用户名@指定ip IDENTIFIED BY 密码;== ==CREATE USER 用户名@'%' IDENTIFIED BY 密码;==\n\n指定ip / 任意ip 可登录\n\n\n# 授权用户\n\n==GRANT 权限1[,权限2...权限n] ON 库名.* TO 用户名@指定ip;== ==GRANT ALL ON *.* TO 用户名@指定ip;==\n\n指定权限 / 所有权限 用户授权 (指定权限自行查询)\n\n\n# 查询权限\n\n==SHOW GRANTS FOR 用户名@指定IP;== ==SHOW GRANTS FOR 用户名@‘%’;==\n\n查询指定 / 查询所有 IP的权限情况\n\n\n# 撤销权限\n\n==REVOKE 权限1[,权限2...权限n] ON 库名.* FROM 用户名@指定IP;==\n\n\n# 删除用户\n\n==DROP USER 用户名@指定IP==\n\n\n# 权限刷新\n\n==flush privileges;==\n\n> 修改后需要刷新生效权限\n\n\n# DQL 数据查询\n\nDQL(Data Query Language)：数据查询语言，用来查询记录(数据)查询 数据库执行DQL语句不会对数据进行改变，而是让数据库发送结果集给客户端 查询返回的结果集是一张虚拟表\n\n操作关键字： SELECT\n\nSELECT的语法结构：\n\nSELECT (* | {字段名1 [别名][,字段名2[别名]····,字段名n[别名]]} ) FROM 表名 [可选参数];\n\n\nSELECT * FROM 表名;\n\n\n> 可选参数：\n> \n>  * [WHERE 条件表达式];\n>  * [GROUP BY 字段名 [HAVING 条件表达式2]] ;\n>  * [ORDER BY 字段名 [ASC | DESC]];\n>  * [LIMIT [OFFSET] (int)记录数];\n\n * 别名：代替字段名\n * **DISTINCT：**过滤表字段中重复的值(数据)，如果指定是多个字段，而且指定的字段值相同，则过滤重复的值！！！\n * **WHERE：**指定查询条件\n * **GROUP BY：**将查询结果按指定字段进行分组\n   * **HAVING：**对分组后的结果进行过滤\n * **ORDER BY：**将查询结果按指定字段进行排序，排列方式有参数ASC(升序)、DESC(降序)控制，默认为ASC(升序)\n * **LIMIT：**限制查询结果的数量，后面有可有两个参数\n   * **OFFSET：**表示偏移量，如果偏移量为0则从第一条开始,。不指定参数1，其默认值为0。\n   * **记录数：**表示返回查询记录的条数\n\n\n# 普通查询\n\n# 条件查询 (WHERE)\n\n··· WHERE (条件表达式);\n\n# 查询 age大于等于25 \nSELECT * FROM stu WHERE age>=25;\n# 查询 age大于等于25 指定显示 sname\nSELECT sname FROM stu WHERE age>=25;\n# 查询 指定gender值非male\nSELECT * FROM stu WHERE gender!='male';\nSELECT * FROM stu WHERE gender<>'male';\nSELECT * FROM stu WHERE NOT gender='male';\n\n\n# 指定查询 (IN)\n\n查指定字段\n\n··· WHERE 字段名 [NOT] IN (值1，值2，···);\n\n# 查询 指定sid\nSELECT * FROM stu WHERE sid IN ('S_1011' , 'S_1004');\n# 查询 指定sid \nSELECT * FROM stu WHERE sid NOT IN ('S_1011' , 'S_1004');\n\n\n# 范围查询 (BETWEEN AND)\n\n查指定字段的范围值\n\n··· WHERE 字段名 [NOT] BETWEEN (int)值1 AND (int)值2;\n\n# 查询 指定age 12 - 28的范围\nSELECT * FROM stu WHERE age BETWEEN 12 AND 28;\n# 查询 指定age 非12 - 28的范围\nSELECT * FROM stu WHERE age NOT BETWEEN 12 AND 28;\n\n\n查询字段名的值1和值2的范围，前提2值必须大于1值\n\n# 空值查询 (NULL)\n\n查字段NULL值\n\n··· WHERE 字段名 IS [NOT] NULL;\n\n# 查询 age为空的\nSELECT * FROM stu WHERE age IS NULL;\n# 查询 gender不为空的\nSELECT * FROM stu WHERE gender IS NOT NULL;\n\n\n# 过滤查询 (DISTINCT )\n\n过滤重复字段\n\nSELECT DISTINCT * | {字段1,字段2...字段n} FROM 表名 [···];\n\n# 查询表中不重复的字段\nSELECT DISTINCT * FROM stu;\n\n\n# 模糊查询 (LIKE)\n\n寻找匹配的字符串\n\n··· WHERE 字段名 [NOT] LIKE '匹配字符串%_';\n\n# 查询 sname 前缀有字符 l \nSELECT * FROM stu WHERE sname LIKE 'l%';\n# 查询 sname 第5个字符为 S \nSELECT * FROM stu WHERE sname LIKE '_____S%';\n\n\n注意：\n\n> % 任意0 - n个字符 _ 一个字符，通配符(未知数) \\ 进行转义 \\% 为 %\n\n# 多条件查询 (AND)\n\n(交集)连接两个或者多个查询条件\n\n··· WHERE 条件表达式1 [AND 条件表达式2 [··· AND 条件表达式n]];\n\n#查询 age>16 && age<28\nSELECT * FROM stu WHERE age>16 AND age<28;\n#查询 age>16 && age<28 且不能有 25\nSELECT * FROM stu WHERE age>16 AND age<28 AND age != 25;\n\n\n# 多条件查询 (OR)\n\n(并集)记录满足任意一个条件即被查出\n\n··· WHERE 条件表达式1 [OR 条件表达式2 [··· OR 条件表达式n]];\n\n# 查询 age<16 || age>28\nSELECT * FROM stu WHERE age<16 OR age>28;\n# 查询 age<16 || age>28 且不能有 5\nSELECT * FROM stu WHERE  age != 5 AND age<16 OR age>28;\n\n\nOR和AND一起用的情况： AND的优先级高于OR，因此当两者在一起使用时，应该先运算AND两边的条件表达式，再运算OR两边的条件表达式\n\n\n# 高级查询\n\n# 聚合函数\n\n# 记数函数 (COUNT)\n\n统计不为null的记录条数\n\nSELECT COUNT((*) | (字段名)) \nFROM 表名 [···];\n\n# 查询 emp2表 总记录数\nSELECT COUNT(*) FROM emp2 ;\n# 查询 emp2表 comm记录数\nSELECT COUNT(comm) FROM emp2 ;\n\n\n# 求和函数 (SUM)\n\n求出表中某个字段所有值的总和\n\nSELECT SUM(字段名1)[,SUM(字段名2)...,SUM(字段名n)] \nFROM 表名 [···];\n\n# 查询 emp2表 sal字段总和 \nSELECT SUM(sal) FROM emp2;\n# 查询 emp2表 sal+comm字段 总和(IFNULL(comm , 0) 如果字段值为NULL 则至为0)\nSELECT SUM(sal+ IFNULL(comm , 0) ) FROM emp2;\n\n\n# 平均值函数 (AVG)\n\n求出某个字段所有值的平均值\n\nSELECT AVG(字段名1)[,AVG(字段名2)...,AVG(字段名n)] \nFROM 表名 [···];\n\n# 查询 emp2表 sal字段平均值\nSELECT AVG(sal) FROM emp2;\n\n\n# 最大值函数 (MAX)\n\n用于求出某个字段的最大值，语法格式:\n\nSELECT MAX(字段名1)[,MAX(字段名2)...,MAX(字段名n)] \nFROM 表名 [···];\n\n# 查询 emp2表 mgr字段最大值\nSELECT MAX(mgr) FROM emp2;\n\n\n# 最小值函数 (MIN)\n\n用于求出某个字段的最小值，语法格式:\n\nSELECT MIN(字段名1)[,MIN(字段名2)...,MIN(字段名n)] \nFROM 表名 [···];\n\n# 查询 emp2表 mgr字段最小值\nSELECT MIN(mgr) FROM emp2;\n\n\n# 顺序查询 (ORDER BY)\n\n对查询结果进行排序，语法格式:\n\nSELECT * | {字段1,字段2...字段n} FROM 表名 \nORDER BY 字段名1 [ASC | DESC] [,字段名2 [ASC| DESC]...,字段名n [ASC | DESC]];\n\n# 查询 排序 emp2 表的 mgr(降序)\nSELECT * FROM emp2 ORDER BY mgr DESC;\n# 查询 排序 emp2表 的 先排序mar ，相同值的情况排序sal (默认升序)\nSELECT * FROM emp2 ORDER BY mgr , sal ;\n\n\nORDER BY：指定字段进行排序 SELECT：指定查询的字段 ASC升序(默认)、DESC降序\n\n注意：指定字段升序排列时，某条字段值为NULL,则这条记录会在第一条显示，因NULL值被认为是最小值\n\n# 分组查询 (GROUP BY)\n\n对字段值进行分组查询\n\nSELECT 字段名1 | [···] FROM 表名\nGROUP BY 字段名1,字段2,···[HAVING 条件表达式 | ···];\n\n# 查询 emp2表 以daptno字段分组 进行sal求和 \nSELECT deptno , SUM(sal) FROM emp2 GROUP BY deptno;\n# 查询 emp2表 以daptno字段分组 每个dapthon分组的记录数 并排序\nSELECT deptno , COUNT(*) FROM emp2 GROUP BY deptno ORDER BY deptno;\n# 查询 emp2表 以daptno字段分组 deptno值为30 过滤\nSELECT deptno , SUM(sal) FROM emp2 GROUP BY deptno HAVING deptno != 30;\n# 查询 emp2表 以daptno字段分组 mgr值小于7800 过滤\nSELECT deptno , COUNT(*) FROM emp2 WHERE mgr>7800 GROUP BY deptno;\n\n\n注意：\n\n 1. GROUP BY后面的字段 是指定字段进行分组\n 2. 聚合函数一起使用\n 3. 查询过滤使用 HAVING 并非 WHERE\n 4. HAVING不能单独出现，只能存在GROUP BY后面\n 5. 非指定字段分组不能显示字段 如：(指定字段分组是deptno字段，但不能显示empno字段) SELECT empno , SUM(sal) FROM emp2 GROUP BY deptno;\n 6. 指定分组的字段可进行排序\n\nWHERE和HAVING区别\n\nWHERE语句：分组前进行过滤,不能使用聚合函数 HAVING语句：分组后进行过滤，可使用聚合函数\n\n# 限制查询 (LIMIT)\n\n限制查询结果的数量\n\nSELECT 字段名1[,字段名2,...字段n] FROM 表名 \nLIMIT [(int)偏移量，](int)显示数;\n\n# 查询 emp2表 sal最小5个\nSELECT * FROM emp2 ORDER BY sal LIMIT 0 , 5;\n# 查询 emp2表 sal最大5个\nSELECT * FROM emp2 ORDER BY sal DESC LIMIT 0 , 5;\n\n\n批量分页查询的情况\n\n如果有大量数据比如：10页，每页有10条 ，共有100条！ 第一页0，第二页10，第三页20····第九页90\n\npagelndex 页码数、pagesize 每页显示的条数\n\n==LIMIT (pageindex-1)*pagesize , pagesize;==\n\n\n# 别名\n\n在查询数据时，可以为表和字段取别名，这个别名可以代替其指定的表和字段。\n\n# 表别名\n\n可以为表取一个别名,用这个别名来代替表的名称。别名格式:\n\nSELECT (* | 字段) FROM 表名 别名 [...];\n\n\nAS:用于指定表名的别名,它可以省略不写。\n\n# 字段别名\n\n为字段取一个别名,用这个别名来代替表的名称。别名格式:\n\nSELECT (* | 字段名1 [别名][,字段名2[别名]····,字段名n[别名]]) FROM 表名 [...];\n# 或者：\nSELECT (* | 字段名1 [AS 别名][,字段名2[AS 别名]····,字段名n[AS 别名]]) FROM 表名 [...];\n\n\n\n# 多表关系\n\n多对一 在多对一的表关系中，应将外键建在多的一方\n\n多对多 为了实现数据表多对多的关系，需要定义第三方中间表来保存两个关系表的外键\n\n一对一 一对一的对应关系中，需要分清主从关系，通常在从表中建立外键\n\n表创建及测试调用例子 复制导入 sql脚本导入\n\nSET NAMES utf8mb4;\nSET FOREIGN_KEY_CHECKS = 0;\n\n-- ----------------------------\n-- Table structure for category\n-- ----------------------------\nDROP TABLE IF EXISTS `category`;\nCREATE TABLE `category`  (\n  `cid` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,\n  `cname` varchar(100) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  PRIMARY KEY (`cid`) USING BTREE\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- Records of category\n-- ----------------------------\nINSERT INTO `category` VALUES ('c001', '电器');\nINSERT INTO `category` VALUES ('c002', '服饰');\nINSERT INTO `category` VALUES ('c003', '化妆品');\nINSERT INTO `category` VALUES ('c004', '书籍');\n\n-- ----------------------------\n-- Table structure for class\n-- ----------------------------\nDROP TABLE IF EXISTS `class`;\nCREATE TABLE `class`  (\n  `classid` int(0) NOT NULL AUTO_INCREMENT,\n  `classname` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  PRIMARY KEY (`classid`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- Records of class\n-- ----------------------------\nINSERT INTO `class` VALUES (1, '红龙班');\nINSERT INTO `class` VALUES (2, '卫冕班');\nINSERT INTO `class` VALUES (3, '神州班');\nINSERT INTO `class` VALUES (4, '航天班');\n\n-- ----------------------------\n-- Table structure for orderitem\n-- ----------------------------\nDROP TABLE IF EXISTS `orderitem`;\nCREATE TABLE `orderitem`  (\n  `oid` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `pid` varchar(50) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- Records of orderitem\n-- ----------------------------\n\n-- ----------------------------\n-- Table structure for orders\n-- ----------------------------\nDROP TABLE IF EXISTS `orders`;\nCREATE TABLE `orders`  (\n  `oid` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,\n  `totalprice` double NULL DEFAULT NULL,\n  `uid` int(0) NULL DEFAULT NULL,\n  PRIMARY KEY (`oid`) USING BTREE\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- Records of orders\n-- ----------------------------\n\n-- ----------------------------\n-- Table structure for products\n-- ----------------------------\nDROP TABLE IF EXISTS `products`;\nCREATE TABLE `products`  (\n  `pid` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,\n  `name` varchar(40) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `price` double NULL DEFAULT NULL,\n  `category_id` varchar(32) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  PRIMARY KEY (`pid`) USING BTREE\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- Records of products\n-- ----------------------------\nINSERT INTO `products` VALUES ('p001', '联想', 5000, 'c001');\nINSERT INTO `products` VALUES ('p002', '海尔', 3000, 'c001');\nINSERT INTO `products` VALUES ('p003', '雷神', 5000, 'c001');\nINSERT INTO `products` VALUES ('p004', 'JACKJONES', 800, 'c002');\nINSERT INTO `products` VALUES ('p005', '真维斯', 200, 'c002');\nINSERT INTO `products` VALUES ('p006', '花花公子', 440, 'c002');\nINSERT INTO `products` VALUES ('p007', '劲霸', 2000, 'c002');\nINSERT INTO `products` VALUES ('p008', '香奈儿', 800, 'c003');\nINSERT INTO `products` VALUES ('p009', '相宜本草', 200, 'c003');\nINSERT INTO `products` VALUES ('p010', '梅明子', 200, NULL);\n\n-- ----------------------------\n-- Table structure for scores\n-- ----------------------------\nDROP TABLE IF EXISTS `scores`;\nCREATE TABLE `scores`  (\n  `sid` int(0) NOT NULL AUTO_INCREMENT,\n  `score` int(0) NULL DEFAULT NULL,\n  `subjectid` int(0) NULL DEFAULT NULL,\n  `studentid` int(0) NULL DEFAULT NULL,\n  PRIMARY KEY (`sid`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 13 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- Records of scores\n-- ----------------------------\nINSERT INTO `scores` VALUES (1, 43, 1, 1);\nINSERT INTO `scores` VALUES (2, 100, 2, 1);\nINSERT INTO `scores` VALUES (3, 54, 3, 1);\nINSERT INTO `scores` VALUES (4, 34, 1, 2);\nINSERT INTO `scores` VALUES (5, 52, 2, 2);\nINSERT INTO `scores` VALUES (6, 32, 3, 2);\nINSERT INTO `scores` VALUES (7, 41, 1, 3);\nINSERT INTO `scores` VALUES (8, 86, 3, 3);\nINSERT INTO `scores` VALUES (9, 98, 2, 3);\nINSERT INTO `scores` VALUES (10, 78, 3, 4);\nINSERT INTO `scores` VALUES (11, 76, 2, 4);\nINSERT INTO `scores` VALUES (12, 54, 1, 4);\n\n-- ----------------------------\n-- Table structure for student\n-- ----------------------------\nDROP TABLE IF EXISTS `student`;\nCREATE TABLE `student`  (\n  `studentid` int(0) NOT NULL AUTO_INCREMENT,\n  `studentname` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `password` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `sex` char(1) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `classid` int(0) NULL DEFAULT NULL,\n  `test` int(0) NULL DEFAULT NULL,\n  PRIMARY KEY (`studentid`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 10 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- Records of student\n-- ----------------------------\nINSERT INTO `student` VALUES (1, '黑猫', '111111', '女', 1, 10);\nINSERT INTO `student` VALUES (2, '大鲸', '2222', '男', 3, 20);\nINSERT INTO `student` VALUES (3, '白兔', '3333', '女', 3, 30);\nINSERT INTO `student` VALUES (4, '柏竹', '4444', '男', NULL, 40);\nINSERT INTO `student` VALUES (5, '棕熊', '5555', '男', 5, 50);\nINSERT INTO `student` VALUES (6, '智乃', '6666', '女', 3, 60);\nINSERT INTO `student` VALUES (7, '蕾姆', '7777', '女', 2, 70);\nINSERT INTO `student` VALUES (8, '艾米', '8888', '女', 1, 80);\nINSERT INTO `student` VALUES (9, '纱雾', '9999', '女', 2, 90);\n\n-- ----------------------------\n-- Table structure for subject\n-- ----------------------------\nDROP TABLE IF EXISTS `subject`;\nCREATE TABLE `subject`  (\n  `subjectid` int(0) NOT NULL AUTO_INCREMENT,\n  `subjectname` varchar(10) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  PRIMARY KEY (`subjectid`) USING BTREE\n) ENGINE = InnoDB AUTO_INCREMENT = 5 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- Records of subject\n-- ----------------------------\nINSERT INTO `subject` VALUES (1, 'Java');\nINSERT INTO `subject` VALUES (2, 'MySQL');\nINSERT INTO `subject` VALUES (3, 'HTML');\n\n-- ----------------------------\n-- Table structure for users\n-- ----------------------------\nDROP TABLE IF EXISTS `users`;\nCREATE TABLE `users`  (\n  `userid` int(0) NULL DEFAULT NULL,\n  `username` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n  `upass` varchar(20) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL\n) ENGINE = InnoDB CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Dynamic;\n\n-- ----------------------------\n-- Records of users\n-- ----------------------------\n\nSET FOREIGN_KEY_CHECKS = 1;\n\n\n# 连接查询(CROSS JOIN)\n\n交叉连接又称 笛卡尔积 ，返回结果的是 被连接的两个表中所有字段行乘积\n\nSELECT {* | 查询字段} FROM 表1 CROSS JOIN 表2 [WHERE 条件表达式];\n# 或者(简写)\nSELECT {* | 查询字段} FROM 表1,表2 [WHERE 条件表达式];\n\n# 将学生与班级交叉查询\nSELECT * FROM student CROSS JOIN class;\n\n\n# 自然连接(NATURAL JOIN)\n\n特殊的等值连接，前提两表字段属性必须相同，且字段名也要相同，无须添加连接条件，得出的结果是消除重复的字段\n\nSELECT {* | 查询字段} FROM 表1 NATURAL JOIN 表2;\n\n# 查询学生所在的班级\nSELECT * FROM student NATURAL JOIN class;\n\n\n# 合并结果集 (UNION)\n\n连接查询的过程中，通过添加过滤条件来限制查询结果，使查询结果更加精确(ALL去除重复的记录)\n\n应用场景：\n\n * 查询列数类型一致可合并！！！\n * 查询两表相同列数类型进行合并结果\n\nSELECT {* | 查询字段} FROM 表1 UNION [ALL]\nSELECT {* | 查询字段} FROM 表2;\n\n# 合并两表数据\nSELECT studentid,studentname FROM student UNION \nSELECT subjectid,subjectname FROM subject;\n\n\n注意： 合并前提必须将两表的列数和类型一致\n\n# 内连接 (INNER JOIN)\n\n内连接使用 比较运算符，对两表中指定字段值进行比较，列出与连接条件匹配的数据行 ，字段值符合匹配的进行连接，组合成新的记录(无视不匹配的字段)\n\n# \nSELECT  {* | 查询字段}  FROM  表1  INNER  JOIN  表2  ON  {表1.关系字段 = 表2.关系字段 | WHERE 条件表达式} ;\n# 或者 SQL92写法\nSELECT {* | 查询字段}  FROM  表1,表2  WHERE  表1.关系字段 = 表2.关系字段;\n# 或者 SQL99写法\nSELECT {* | 查询字段} FROM 表1 JOIN 表2 ON 表1.关系字段 = 表2.关系字段 WHERE 约束;\n\n# 查询 与班关联的学生(已经分配班级的学生)\nSELECT * FROM student JOIN class ON student.classid = class.classid;\n\n# 查询花子所有成绩\nSELECT subjectname,score \nFROM\n\tscores , subject , student \nWHERE\n\tscores.subjectid = subject.subjectid \n\tAND scores.studentid = student.studentid \n\tAND student.studentname = '花儿';\n\n# 查询 所有科目的平均值\nSELECT subjectname , AVG( score ) \nFROM\n\tscores JOIN subject \n\tON scores.subjectid = subject.subjectid \nGROUP BY\n\tsubjectname;\n\n\n# 外连接 (OUTER JOIN)\n\n外连接 弥补了内连接查询不匹配的条件，查出不满足条件的可能 外连接包括： 左连接 / 右连接\n\n左连接 指定左表的所有记录，所有满足连接条件的记录。如果左表的某条记录在右表中不存在，则在右表中显示为空值\n\n主表 为左边，从表 为右边\n\n右连接 右连接与左连接正好相反\n\n主表 为右边，从表 为左边\n\n# 可将 {LEFT|RIGHT} OUTER JOIN 进行缩写为 {LEFT|RIGHT} JOIN\nSELECT {*|查询字段} FROM 主表 {LEFT|RIGHT} JOIN 从表 ON 主表.字段 = 从表.字段;\n# 左外连接\nSELECT {*|查询字段} FROM 主表 LEFT JOIN 从表 ON 主表.字段 = 从表.字段;\n# 右外连接\nSELECT {*|查询字段} FROM 主表 RIGHT JOIN 从表 ON 主表.字段 = 从表.字段;\n\n# 左外查询\nSELECT * FROM\n\tstudent LEFT JOIN class \n\tON student.classid = class.classid;\n# 右外查询\nSELECT * FROM\n\tstudent RIGHT JOIN class \n\tON student.classid = class.classid;\n\n\n注意： 主表会显示所有字段，空值或不匹配条件的字段均可查询！！！\n\n# 子查询\n\n子查询是指一个查询语句 嵌套在另一个 查询语句内部的查询 在执行查询语句时，首先会执行子查询中的语句，然后将返回的结果作为外层查询的过滤条件，子查询必须返回是一个字段数据\n\n# where中子查询\n\n常用于聚合函数的子查询 比较 约束（子查询只能单条结果）\n\nSELECT * FROM 表 WHERE ...(子查询)\n\n# 查询和 智乃 同班的学生\nSELECT studentname FROM student WHERE classid = (\n\tSELECT classid FROM student WHERE studentname = \"智乃\"\n);\n\n\n# from中子查询\n\n将子查询的临时表当做一个表进行应用 （子查询能多条结果）\n\nSELECT * FROM (子查询) 别名 WHERE ...\n\n# 查出每个同学所有科目的平均分数\nSELECT studentname,c.avg FROM (\n\tSELECT sid,avg(score) avg FROM scores GROUP BY sid\n)c JOIN student s ON c.sid = s.studentid\n\n\nPS : 使用临时表需要手动指定表名\n\n# select中子查询\n\n将结果进行展示，在 两表有字段关联约束进行查询使用（子查询只能单条结果）\n\nSELECT (子查询),... FROM 表\n\n\n\n\n# IN\n\n内层查询语句仅仅返回一个数据字段，数据字段中的值将供外层查询语句进行比较操作\n\nSELECT {* | 查询字段} FROM 表名1 WHERE 字段 [NOT] IN(SELECT 字段 FROM 表名2 WHERE 条件表达式);\n\n# 查询 三班有多少女生\nSELECT studentname FROM student WHERE classid IN(\n    SELECT classid FROM class WHERE classid = 3\n)AND sex = '女';\n# 查询 与‘智乃’同一个班的学生\nSELECT studentname FROM\tstudent WHERE classid IN( \n    SELECT classid FROM student WHERE studentname = '智乃' \n);\n\n\n注意： IN 后面子查询返回结果要和IN前的字段匹配\n\n# EXISTS\n\n参数可以是任意一个子查询， 这个子查询的作用相当于测试，返回 布尔值 , 如果 TRUE 外层查询才会执行\n\nSELECT  {* | 查询字段}  FROM  表名1  WHERE  [NOT]  EXISTS  (SELECT  字段  FROM  表名2  WHERE  条件表达式);\n\n# 测试 两表关系(匹配显示，不匹配不显示)\nSELECT\n\tstudentid,\n\tstudentname \nFROM student WHERE\n\tEXISTS ( SELECT * FROM class WHERE class.classid = student.classid );\n\n\n# ANY\n\n满足任意一个条件，子查询返回的字段列表进行比较，将不匹配的过滤\n\nSELECT * FROM 表名 WHERE [NOT] 字段 {比较运算符} ANY(SELECT 字段 FROM 表名);\n\n# 查询 已经分配班级的学生\nSELECT classid,studentname FROM student \nWHERE\n\tclassid = ANY(SELECT classid FROM class);\n#或 (结果一样)\nSELECT classid,studentname FROM student \nWHERE\n\tclassid IN( SELECT classid FROM class);\n\n\n# ALL\n\n子查询返回的字段列表结果需同时满足所有内层查询条件，否则查询为空\n\nSELECT * FROM 表名 WHERE [NOT] 字段 {比较运算符} ALL(SELECT 字段 FROM 表名);\n \n# 查询 test 高于蕾姆的同学\nSELECT studentname,test FROM student \nWHERE \n\ttest > ALL(SELECT test FROM student WHERE studentname = '蕾姆');\t\n# 查询 匹配错班级的同学(数据错乱)\nSELECT classid,studentname FROM student \nWHERE\n\tclassid > ALL(SELECT classid FROM class);\n#或 (结果一样)\nSELECT classid,studentname FROM student \nWHERE\n\tclassid NOT IN( SELECT classid FROM class);\n\n\n# 比较运算符\n\nANY 和 ALL 都用到比较运算符，但还可以使用其他运算符\n\nSELECT * FROM 表名 WHERE [NOT] 字段 {比较运算符} (SELECT 字段 FROM 表名)\n\n\n\n# 查新执行顺序\n\n书写顺序：\n\nSELECT DISTINCT ... FROM ... JOIN ... ON ... WHERE ... \n\tGROUP BY ... HAVING ... ORDER BY ... DESC LIMIT ...\n\n\n执行顺序：\n\n 1.  FROM\n 2.  NO\n 3.  JOIN\n 4.  WHERE\n 5.  GROUP BY\n 6.  AVG,SUM,... (聚合函数)\n 7.  HAVING\n 8.  SELECT\n 9.  DISTINCT\n 10. ORDER BY\n 11. LIMIT\n\n\n# SQL优化\n\n 1. 避免全表扫描，应先考虑 where 及 order by 涉及的列上建立索引\n 2. 避免 where语句 中的字段进行 null值 判断\n 3. 避免 where语句 中使用 != 或 < / > 操作符\n 4. 避免 where语句 使用 OR 连接条件\n 5. 谨慎使用 IN / NOT IN 进行查询，连续数字可使用 BETWEEN 范围查询\n\n\n# 完整性\n\n保证了数据的有效性和准确性，以防止数据表中插入错误的数据\n\n约束条件             说明\nPRIMARY KEY      主键约束，用于唯一标识对应的记录\nFOREIGN KEY      外键约束\nNOT NULL         非空约束\nUNIQUE [KEY]     唯一性约束\nDEFAULT          默认值约束，用于设置字段的默认值\nAUTO_INCREMENT   自动增长\nCHECK            约束取值范围\nUNSIGNED         无符号约束\n\n注意： 多个约束需要空格分隔\n\n\n# 实体完整性\n\n# 单字段主键\n\n每表只有一个主键，唯一性，不能NULL，可创建联合主键 ==字段名 数据类型 PRIMARY KEY[(字段名1,字段名2,···字段名n)];== ==ALTER TABLE student ADD PRIMARY KEY[(字段名1,字段名2,···字段名n)]==\n\n# 唯一约束\n\n数据不能重复，只能有一次为空 ==字段名 数据类型 UNIQUE;==\n\n# 字段自动增加\n\n在数据表中，若想为表中插入的新记录自动生成唯一的 ID,可以使用自增约束来实现 ==字段名 数据类型 AUTO_INCREMENT;==\n\n\n# 域完整性\n\n# 数据类型\n\n# 非空约束\n\n字段的值不能为NULL(空) ==字段名 数据类型 NOT NULL;==\n\n# 默认约束\n\n新添数据时，如果未赋值，则自动插入默认值 ==字段名 数据类型 DEFAULT(默认值);==\n\n# 无符号约束\n\n==字段名 数据类型 UNSIGNED;==\n\n# 约束范围\n\n==字段名 数据类型 CHECK (字段值>0 and 字段值<=100);==\n\n\n# 引用完整性\n\n# 外键约束\n\n外键是指引用另一个表中的一个字段或多个字段。建立、加强两表数据之间的链接\n\n创建表时 定义外键：\n\n# 从表\nCREATE TABLE 表名(\n   字段名1 数据类型 [完整性约束条件],\n   字段名2 数据类型 [完整性约束条件],\n   ·······\n   FOREIGN KEY (外键字段) REFERENCES 主表( 主表的 主键 / 唯一 字段 )\n);\n\n\n创建表后 定义外键： ==ALTER TABLE 从表 ADD CONSTRAINT [自定义外键名] FOREIGN KEY(从表 外键字段) REFERENCES 主表( 主表的 主键 / 唯一 字段 );==\n\n外键查询 （查询表详细 可查询表的外键）\n\n==SHOW CREATE TABLE 表名;==\n\n外键删除\n\n根据逻辑的需求，需要解除两个表之间的关联关系时，就需要删除外键约束 ==ALTER TABLE 表名 DROP FOREIGN KEY 外键名;==\n\n注意：\n\n 1. 主表是被外键引用的字段，且该字段有 主键约束/唯一性约束\n 2. 被引用的是 主表，引用 的是 从表，两表是主从关系\n 3. 引入外键后，从表 外键字段 只能插入主表被引用的字段值\n 4. 如果想删除 主表 一条记录，则必须删除完 与主表相同外键值(对象是删除的记录)的从表外键字段记录(删除外键字段值与主表相同的值) ，主表才能进行删除记录，确保数据的完整性\n 5. 建立外键的表必须是InnoDB型不能是临时表。因为MySQL中只有InnoDB型的表才支持外键\n 6. 定义外键名时，不能加引号。如: 'FK_ ID' 或\" FK_ID \"都是错误的 ，\n 7. 自定义外键名 用于删除外键约束时使用，也可不设置，一般建议“_fk”为结尾\n\n\n# 索引\n\n索引的目的在于提高查询效率，与我们查字典所用的目录是一个道理\n\n优点：\n\n * 提高查询效率\n * 降低CPU使用率\n\n缺点：\n\n * 索引本身很大，存储在 内存/硬盘 中\n * 索引会降低 增删改 的效率\n\n索引分类：\n\n * 单列索引\n * 唯一索引\n * 联合索引\n * 主键索引\n\n> 主键和唯一的区别：主键不能为null，而唯一可以\n\n\n# 索引创建\n\n建表时创建索引：\n\nCREATE TABLE 表名(\n\t字段名1 数据类型 [完整性约束条件]，\n\t字段名2 数据类型 [完整性约束条件]，\n     ·····\n\t字段名n 数据类型\n[UNIQUE | FULLTEXT | SPATIAL] INDEX | KEY\n\t[索引名] (字段名1 [长度]) [ASC | DESC])\n)[存储引擎];\n\n\nUNIQUE： 可选参数，表示唯一性约束 FULLTEXT：可选参数，表示全文约束 SPATIAL： 可选参数，表示空间约束 INDEX 和 KEY：用来表示字段的索引，二者选一即可 索引名：可选参数，表示创建的索引的名称 字段名1：指定索引对应字段的名称 长度：可选参数，用于表示索引的长度 ASC 和 DESC：可选参数，其中，ASC表示升序排列，DESC表示降序排列\n\n# 单列索引 (NORMAL)\n\n在表中单个字段上创建索引，它可以是普通索引、唯一索引或者全文素引， 只要保证该索引只对应表中一个字段即可\n\n创建代码：\n\n==CREATE INDEX 索引名 ON 表名 (字段名1[,字段名2...]);==\n\n==ALTER TABLE 表名 ADD INDEX 索引名 (字段名1[,字段名2...]);==\n\n> 以上添加代码一定一定要添加括号\n\n联合索引说明：\n\n单列索引多个字段，称为联合索引\n\n触发联合索引的条件有：\n\n> 假如索引添加形式为：==ALTER TABLE user ADD INDEX test (name,age)==\n\n * **组合约束查询 ** AND (OR查询不会触发索引) ==... WHERE name= '张三' AND age=12==\n * 单独约束查询 左边第一个字段会触发索引（右边的字段不会触发 ==WHERE name='张三'==\n\n# 唯一索引 (UNIQUE )\n\n使字段的值必须是唯一的（允许null，但只能允许一个空\n\n==CREATE UNIQUE INDEX 索引名 ON 表名 (字段名);==\n\n==ALTER TABLE 表名 ADD UNIQUE INDEX 索引名 (字段名);==\n\n# 全文索引 (FULLTEXT)\n\n只能创建在CHAR、VARCHAR或TEXT类型的字段上， 该索引只有MyISAM存储引擎支持\n\n==CREATE FULLTEXT INDEX 索引名 ON 表名 (字段名);==\n\n==ALTER TABLE 表名 ADD FULLTEXT INDEX 索引名 (字段名);== 注意： 后面需存储引擎(ENGINE =MyISAM)\n\n# 空间索引 (SPATIAL)\n\n只能创建在空间数据类型的字段上。MySQL中的空间数据类型有4种,分别是LGEOMETRY、POINT、 LINESTRING、POLYGON\n\n该索引只有MyISAM存储引擎支持\n\n==CREATE SPATIAL INDEX 索引名 ON 表名 (字段名);==\n\n==ALTER TABLE 表名 ADD SPATIAL INDEX 索引名 (字段名);==\n\n注意: 后面需存储引擎(ENGINE =MyISAM)\n\n\n# 索引删除\n\n==ALTER TABLE 表名 DROP INDEX 索引名;==\n\n==DROP INDEX 索引名 ON 表名;==\n\n\n# 函数\n\n\n# 数学函数\n\n函数名称                   作用\nABS(x)                 返回x的绝对值\nSQRT(x)                返回x的非负2次方根\nMOD(x , y)             返回x被y除后的余数\nCEILING(x) / CEIL(x)   返回 不小于x的最大整数 (前提x有小数)\nFLOOR(x)               返回 不大于x的最小整数 (前提x有小数)\nROUND(x , y)           对 x 四舍五入 操作，小数保留 y位\nTRUNCATE(x , y)        对 x 只舍不入 操作，小数保留 y位\nSIGN(x)                返回 x 符号 ( -1 / 0 / 1 )\n                       x为数值，则判断 正或负的值 ；x为其他类型，则返回0\n\n\n# 字符串函数\n\n函数名称                      作用\nLENGTH(str)               返回 字符串的长度\nCONCAT(s1 , s2 , .....)   返回 一个/多个字符串 连接的新字符串\nTRIM(str)                 删除字符串两侧的空格\nREPLACE(str , s1 , s2)    使用字符串s2替换字符串str中所有的字符串s1\nSUBSTRING(tr , n , len)   返回字符串st的子串，起始位置为n,长度为len\nREVERSE(str)              返回 字符串顺序反转\nLOCATE(s1 , str)          返回 s1 在 str 中的起始位置\nUPPER(str)                将 所有 小写 转换为 大写\nLOWER(str)                将 所有 大写 转换为 小写\nFORMAT(str,format)        将 字符串 进行数据格式化\n\n\n# 日期与时间的函数\n\n函数名称                                    作用\nCURDATE()                               获取 系统当前 日期\nCURTIME()                               获取 系统当前 时间\nSYSDATE()                               获取 当前系统 日期和时间\nDATE_ADD(now() , INTERVAL num {时间单位})   指定过去或未来时间点(num是对现在的时间进行相加)\nDATEDIFF(d1 , d2)                       计算 两时间 间隔的天数(从0000.1.1开始 n 天后的日期)\nFROM_DAYS(day)                          计算 时间 得出日期 (从0000.1.1开始 n 天后的日期)\nYEAR(d)                                 获取 日期年份\nMONTH(d)                                获取 日期月份\nDAY(d)                                  获取 日期 日\nDATE_FORMAT(date , format)              日期格式化\n                                        format ：'%m-%d-%Y'\n\n点击了解更多日期&时间函数了解\n\n\n# 条件判断函数\n\n函数名称                                                         作用\nIF(expr , v1 , v2)                                           如果expr表达式为true返回v1,否则返回v2\nIFNULL(v1 , v2)                                              如果v1不为NULL返回v1,否则返回v2\nCASE expr WHEN v1 THEN r1 [WHEN v2 THEN r2......] [ELSE m]   如果expr值等于v1、v2等,则返回对应位置THEN后面的结果，否则返回ELSE后的结果m\nEND\n\n\n# 加密函数\n\n函数名称                    作用\nMD5(str)                对字符串 str 进行MD5加密\nENCODE(str , pwd stu)   使用pwd作为密码加密字符串str\nDECODE(str , pwd str)   使用pwd作为密码解密字符串str\n\n\n# 事务\n\n事务指逻辑上的一组操作，组成这组操作的各个单元，要不全部成功，就全部不成功，同一个事务的操作具备同步优点\n\nSET AUTOCOMMIT = 0;\nSTART TRANSACTION; |  BEGIN;\n···\n····\nROLLBACK;\nCOMMIT; \n\n\nSET AUTOCOMMIT： 自动事务提交开关（0关闭；1开启） START TRANSACTION | BEGIN： 开启事务(处于事务中，不会影响数据库数据) ROLLBACK： 回滚事务(取消事务，前提是事务未提交前回滚) COMMIT ： 事务提交(事务生效后会立即影响数据库数据)\n\n\n# 事务ACID特性\n\n原子性(Atomicity) 指事务是一个不可分割的工作单位，事务中的操作要么执行成功，要么执行失败\n\n一致性(Consistency) 事务前后数据的完整性必须保持一致(数据库的完整性：如果数据库在某个时间点下，所有的数据都符合所有的约束，则称数据库为符合完整性的状态)\n\n隔离性(Isolation) 指多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间数据要相互隔离\n\n持久性(Durability) 指一个事务一旦被提交，数据库中的数据改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响\n\n\n# 事务安全问题\n\n脏读： 两事务 某一事务读取到另一个事务修改且未提交的数据\n\n不可重复读： 某一事务多次读取同一条记录的过程，读取的结果不相同过程数据有更改，读取到另一个事务已经提交的数据\n\n虚读(幻读)： 某一事务多次查询数据，由于其他事务 新增 或 删除 记录造成多次查询出的记录条数不同\n\n\n# 事务隔离级别\n\n防止不同隔离性的问题\n\n隔离类型                   脏读   不可重复读   幻读\n未提交 READ UNCOMMITTED   允许   允许      允许\n已读提交 READ COMMITTED    禁止   允许      允许\n可重复读 REPEATABLE READ   禁止   禁止      可能\n顺序读 SERIALIZABLE       禁止   禁止      禁止\n\n一般默认 可重复读、 已读提交\n\n修改隔离级别 ==SET  [SESSION | GLOBAL]  TRANSACTION  ISOLATION   LEVEL 隔离类型;== SESSION： 当前会话 GLOBAL： 全局\n\n查询隔离级别 ==SELECT @@TX_ISOLATION;== (MySQL版本8前) ==SELECT @@TRANSACTION_ISOLATION;== (MySQL版本8后)\n\n# 未提交 (READ UNCOMMITTED)\n\n读未提交，该隔离级别允许脏读取，其隔离级别是最低的\n\n时间(T)   事务A         事务B\nT1      开始事务        开始事务\nT2      ==          查余额(500元)\nT3      ==          取300元\nT4      查余额(200元)   ==\nT5      ==          滚动事务\nT6      存800元       ==\nT7      提交事务        ==\nT8                  取100元\nT9                  提提交事务\n\n最后余额剩1200元。T4 A脏读B修改的数据，T5 B回滚(撤回T5前的所有操作)，最后B只提取100元！\n\n# 已读提交 (READ COMMITTED)\n\n读已提交是不同的事务执行的时候 只能获取 到已经提交的数据\n\n时间(T)   事务A         事务B\nT1      开始事务        开始事务\nT2      ==          查余额(500元)\nT3      查余额(500元)   ==\nT4      ==          取500元\nT5      查余额(500元)   ==\nT6      ==          提交事务\nT7      查余额(0)      \nT8      提交事务        \n\nA只能读取 事务提交后的数据！！\n\n# 可重复读 (REPEATABLE READ)\n\n保证在事务处理过程中，多次读取同一个数据时，该数据的值和事务开始时刻是一致的\n\n时间(T)   事务A             事务B\nT1      开始事务            \nT2      查所有数据           开始事务\nT3      ==              插入一条数据\nT4      ==              提交事务\nT5      查所有数据(和T2一样)    \nT6      修改范围数据          \nT7      查所有数据(多了一条数据)   \nT8      提交事务            \n\n事务A 的 T2 查询数据 与 T5查询数据 是一样的 ，确认数据无误后 对表数据值修改，紧接查询事务多出了一条数据！！（作为这一前提 事务B 插入数据提交事务\n\n> 事务B未提交 ，事务A 对数据进行更改，则不会显示，除非 事务B提交\n\n# 顺序读 (SERIALIZABLE)\n\n最严格的事务隔离级别。事务以排队形式进行执行。某一事务对数据进行修改必须等另一个 提交 或 回滚 ，才可以进行数据修改！！\n\n\n# 隔离级别锁的情况\n\n读未提交(RU)： 有行级的锁，没有间隙锁。与RC的区别是能够查询到未提交的数据 读已提交(RC)： 有行级的锁，没有间隙锁，读不到没有提交的数据 可重复读(RR)： 有行级的锁，有间隙锁，每读取的数据都一样，且没有幻读的情况 序列化(S)： 有行级锁，也有间隙锁，读表的时候，就已经上锁了",normalizedContent:"# mysql\n\n\n# 安装\n\n点击官方链接下载\n\n配置环境\n\n在mysql根目录下的 bin文件 在 变量 path 增添 。如\n\nd:\\mysql\\mysql-8.0.22-winx64\\bin\n\n\n配置文件\n\n在mysql根目录下的新建 my.ini文件 和 data文件夹 , 配置参数\n\n[mysql]\n# 设置mysql客户端默认字符集\ndefault-character-set=utf8\n[mysqld] \n# 设置3306端口\nport = 3306 \n# 设置mysql根目录\nbasedir=d:\\mysql\\mysql-8.0.22-winx64\n# 设置mysql数据库数据存放目录\ndatadir=d:\\mysql\\mysql-8.0.22-winx64\\data \n# 允许最大连接数\nmax_connections=200 \n# 服务端使用的字符集默认为utf8\ncharacter-set-server=utf8 \n# 创建新表时将使用的默认存储引擎\ndefault-storage-engine=innodb\n# 设置时间戳\nexplicit_defaults_for_timestamp=true\n\n\n安装mysql\n\n初始化数据库 在mysql的根目录 bin文件夹 里 ，管理员身份打开cmd执行指令\n\nmysqld --initialize-insecure --user=mysql\n\n\n查看是否安装 然后安装执行，cmd执行指令\n\nmysqld install\n\n\n如果未提示成功，请用管理员身份打开重新执行cmd执行指令\n\n启动mysql服务。cmd执行指令\n\nnet start mysql\n\n\n也可以在 控制面板 打开服务 进行启动 mysql服务\n\n进入myslq，无密码执行，cmd执行指令\n\nmysql -uroot -p\n\n\n> ps：如果本地ip访问不到，需要重新启动服务，在cmd 进入 bin文件夹 进行启动服务\n\n\n# 卸载\n\n 1. 管理员运行cmd关闭 mysql服务，cmd执行指令\n\nnet stop mysql8\n\n\n 2. 删除mysql服务\n\nsc delete mysql8 \n或者 \nmysql remove mysql8\n\n\n 3. 删除mysqldb目录文件(安装mysql时my.ini指定的目录)\n\n\n# 数据类型\n\n\n# 整型数据\n\n整型数据        字节数   无符号的取值范围                 有符号的取值范围\ntinyint     1     0~225                    -125~127\nsmallint    2     0-65535                  -32768~32768\nmediumint   3     0~16777215               ···\nint         4     0-4294967295             ···\nbigint      8     0~18446744073709551615   \n\n\n# 浮点型\n\n浮点型 数据             字节数   说明\nfloat[(m,d)]       4     m指定显示长度，d指定小数位数，浮点\ndouble[(m,d)]      8     m指定显示长度，d指定小数位数，浮点\n定点数型数据             -     -\ndecimal(()m , 2)   m+2   定点数，存储 高精度数据\n\n\n# 日期 时间类型\n\n数据类型             字节数   取值范围                                      日期格式                  零值\nyear             1     1901~2155                                 yyyy                  0000\ndate             4     1000-01-01-9999-12-3                      yyyy-mm-dd            0000-00-00\ntime             3     -838:59:59-838:59:59                      hh:mm:ss              00:00:00\ndatetime         8     11                                        yyyy-mm-dd hh:mm:ss   0000-00-00 00:00:00\ntimestamp(时间戳)   4     1970-01-01 00:00:01~2038-01-19 03:14:07   yyyy-mm-dd hh:mm:ss   0000-00-00 00:00:00\n\n\n# 字符串型\n\n字符串类型(单位：字节)        字节状态   优点\nchar((int)max)      固定     查询快\nvarchar((int)max)   动态     省空间\n\n\n# 二进制数据类型\n\n二进制数据类型(单位：长度)        长度状态\nbinary((int)max)      固定\nvarbinary((int)max)   动态\n\nbinary类型的长度是固定的，如果长度不足最大长度,后面用“0”对齐，直到指定长度。\n\n\n# 大文本数据类型\n\n大文本数据类型      存储范围(单位：字节)\ntinytext     0~255字节\ntext         0~65535字节\nmediumtext   0~16777215字节\nlongtext     0~4294967295字节\n\n\n# 大数据二进制类型\n\n特殊二进制类型      存储范围(单位：字节)\ntinyblob     0~255字节\nblob         0-65535字节\nmediumblob   0~16777215字节\nlongblob     0-4294967295字节\n\n\n# 枚举型\n\nenum枚举型，单选项\n\nenum('值1','值2'···'值n')\n\n\n\n# 多选项\n\nset('值1','值2'···'值n')\n\n\n\n# ddl 库操作\n\nddl (data definition language)：数据定义语言，操作增删改查的操作\n\n**操作关键字 : ** create , drop , alter , show , use\n\n\n# 创建数据库\n\nsql语句                                                     说明\n==create database 库名;==                                   创建库\n==create database if not exists 库名;==                     判断不存在，则创建\n==create database 库名 character set 编码方式;==                指定编码创建\n==create database 库名 character set 编码方式 collate 排序规则;==   指定编码和排序规则创建\n\n> create database ：创建数据库 if not exists ：检查是否已存在的状态 character set：设置编码方式 collate ：排序规则\n\n\n# 查看数据库\n\n查看当前数据库： ==show databases;==\n\n查看创建的库： ==show create database 库名;==\n\n查看当前所选的数据库： ==select database();==\n\n\n# 修改数据库\n\nsql语句                                                    说明\n==alter database 库名;==                                   修改库\n==alter database 库名 character set 编码方式;==                指定编码更改\n==alter database 库名 character set 编码方式 collate 排序规则;==   指定编码和排序规则更改\n\n> alter database ：修改数据库 if not exists ：检查是否已存在的状态 character set ：设置编码方式 collate ：排序规则\n\n\n# 删除数据库\n\n==drop database 库名;==\n\n\n# 选择数据库\n\n==use 库名;==\n\n\n# ddl 表操作\n\nddl (data definition language):数据定义语言，定义数据库对象:库、表、列等\n\n**操作关键字 : ** create , drop , alter , show , use\n\n\n# 创建表\n\ncreate table 表名(\n   字段名1 数据类型 [完整性约束条件] [comment '注释内容'],\n   字段名2 数据类型 [完整性约束条件] [comment '注释内容'],\n   ·······\n   字段名n 数据类型 [完整性约束条件] [comment '注释内容'],\n   [完整性约束条件](字段1,字段2,·····,字段n)\n)[编码集设置];\n\n\n> **编码集设置 : ** character set 字符集名 [校对规则] **校对规则 : ** collate 校对名\n\n快速创建拷贝表\n\ncreate table 表名 as select * from 拷贝表\n\n\n> ps : as 后面 是拷贝制定查询的数据\n\n\n# 查看表\n\n查看指定表字段结构 ==desc 表名;==\n\n查看当前数据库所有表 ==show tables;==\n\n查看表的详细结构 ==show create table 表名;==\n\n\n# 修改表\n\n修改表名\n\n==rename table 表名 to 新表名;== ==alter table 表名 rename 新表名;==\n\n增加字段\n\n==alter table 表名 add 字段名 数据类型;==\n\n字段 修改 与 顺序\n\nalter table 表名 modify 字段名 数据类型 [更改字段循序 | 完整性约束条件] [comment '内容'];\n\n\n> 更改字段循序 : first | after 字段名2\n> \n> first：指定字段为表的第一个 after：指定字段插入字段2的后面\n\n修改字段名\n\n==alter table 表名 change 字段名 新字段名 新字段类型;==\n\n修改表字符集\n\n==alter table 表名 character set 字符集类型;==\n\n删除字段\n\n==alter table 表名 drop 字段名;==\n\n\n# 删除表\n\n==drop table 表名;==\n\n\n# dml 数据操作\n\ndml (data manipulation language):数据操作语言，定义数据库记录(数据)增删改 的操作\n\n**操作关键字 : ** insert , updata , delect\n\n\n# 插入数据\n\n一条数据添加 ==insert into 表名 [(字段名1 [，字段名2. . .])] values(值1 [,值2. . .]);== 多条数据添加 ==insert into 表名 [(字段名)] values (字段值1),(字段值2)...;==\n\n注意：\n\n * 插入字段与它的数据类型位置是一一对应的\n * 数据类型对应的值，字段值是非数值，则两侧必须添加单引号\n * null设置为空\n * 数据的大小应在字段的数据类型规定范围内\n * 如果要插入所有字段数据时可以省写字段，但必须按表中字段顺序写值\n * 尽可能避免字段数据值写入的是 null\n\n\n# 更改数据\n\n更改单表数据 ==update 表名 set 字段名1 = 字段值1 [,字段名2 = 值2..] [where 条件表达式];== 更改多表数据 ==update 表名1 , 表名2  set {修改字段值，可跨表修改} [where 条件表达式];==\n\n注意：\n\n * 逻辑运算符有： and(并且)、or(或者)、not(取非)\n * 如果更改字段无条件表达式，则指定全部该字段的值一致\n\n\n# 删除数据\n\n==delete from 表名 [where 条件表达式];== ==truncate table 表名;== 多表删除 ==delete {表名1,表名2...} from {表名1,表名2...} [where 条件表达式];==\n\n注意：\n\n * 如果无条件表达式，则删除全部数据\n * delete删除可找回\n * truncate删除不可找回，类似格式化数据，执行快\n * 不能删除某列的值(可修改数据值置null)\n * 多表删除 建议where过滤他们字段的关系\n * 多表中的每张表需要逗号分隔\n\n\n# dcl 安全访问\n\ndcl (data control language)︰数据控制语言，用来定义访问权限和安全级别\n\n操作关键字： grant , revoke\n\n\n# 创建用户\n\n==create user 用户名@指定ip identified by 密码;== ==create user 用户名@'%' identified by 密码;==\n\n指定ip / 任意ip 可登录\n\n\n# 授权用户\n\n==grant 权限1[,权限2...权限n] on 库名.* to 用户名@指定ip;== ==grant all on *.* to 用户名@指定ip;==\n\n指定权限 / 所有权限 用户授权 (指定权限自行查询)\n\n\n# 查询权限\n\n==show grants for 用户名@指定ip;== ==show grants for 用户名@‘%’;==\n\n查询指定 / 查询所有 ip的权限情况\n\n\n# 撤销权限\n\n==revoke 权限1[,权限2...权限n] on 库名.* from 用户名@指定ip;==\n\n\n# 删除用户\n\n==drop user 用户名@指定ip==\n\n\n# 权限刷新\n\n==flush privileges;==\n\n> 修改后需要刷新生效权限\n\n\n# dql 数据查询\n\ndql(data query language)：数据查询语言，用来查询记录(数据)查询 数据库执行dql语句不会对数据进行改变，而是让数据库发送结果集给客户端 查询返回的结果集是一张虚拟表\n\n操作关键字： select\n\nselect的语法结构：\n\nselect (* | {字段名1 [别名][,字段名2[别名]····,字段名n[别名]]} ) from 表名 [可选参数];\n\n\nselect * from 表名;\n\n\n> 可选参数：\n> \n>  * [where 条件表达式];\n>  * [group by 字段名 [having 条件表达式2]] ;\n>  * [order by 字段名 [asc | desc]];\n>  * [limit [offset] (int)记录数];\n\n * 别名：代替字段名\n * **distinct：**过滤表字段中重复的值(数据)，如果指定是多个字段，而且指定的字段值相同，则过滤重复的值！！！\n * **where：**指定查询条件\n * **group by：**将查询结果按指定字段进行分组\n   * **having：**对分组后的结果进行过滤\n * **order by：**将查询结果按指定字段进行排序，排列方式有参数asc(升序)、desc(降序)控制，默认为asc(升序)\n * **limit：**限制查询结果的数量，后面有可有两个参数\n   * **offset：**表示偏移量，如果偏移量为0则从第一条开始,。不指定参数1，其默认值为0。\n   * **记录数：**表示返回查询记录的条数\n\n\n# 普通查询\n\n# 条件查询 (where)\n\n··· where (条件表达式);\n\n# 查询 age大于等于25 \nselect * from stu where age>=25;\n# 查询 age大于等于25 指定显示 sname\nselect sname from stu where age>=25;\n# 查询 指定gender值非male\nselect * from stu where gender!='male';\nselect * from stu where gender<>'male';\nselect * from stu where not gender='male';\n\n\n# 指定查询 (in)\n\n查指定字段\n\n··· where 字段名 [not] in (值1，值2，···);\n\n# 查询 指定sid\nselect * from stu where sid in ('s_1011' , 's_1004');\n# 查询 指定sid \nselect * from stu where sid not in ('s_1011' , 's_1004');\n\n\n# 范围查询 (between and)\n\n查指定字段的范围值\n\n··· where 字段名 [not] between (int)值1 and (int)值2;\n\n# 查询 指定age 12 - 28的范围\nselect * from stu where age between 12 and 28;\n# 查询 指定age 非12 - 28的范围\nselect * from stu where age not between 12 and 28;\n\n\n查询字段名的值1和值2的范围，前提2值必须大于1值\n\n# 空值查询 (null)\n\n查字段null值\n\n··· where 字段名 is [not] null;\n\n# 查询 age为空的\nselect * from stu where age is null;\n# 查询 gender不为空的\nselect * from stu where gender is not null;\n\n\n# 过滤查询 (distinct )\n\n过滤重复字段\n\nselect distinct * | {字段1,字段2...字段n} from 表名 [···];\n\n# 查询表中不重复的字段\nselect distinct * from stu;\n\n\n# 模糊查询 (like)\n\n寻找匹配的字符串\n\n··· where 字段名 [not] like '匹配字符串%_';\n\n# 查询 sname 前缀有字符 l \nselect * from stu where sname like 'l%';\n# 查询 sname 第5个字符为 s \nselect * from stu where sname like '_____s%';\n\n\n注意：\n\n> % 任意0 - n个字符 _ 一个字符，通配符(未知数) \\ 进行转义 \\% 为 %\n\n# 多条件查询 (and)\n\n(交集)连接两个或者多个查询条件\n\n··· where 条件表达式1 [and 条件表达式2 [··· and 条件表达式n]];\n\n#查询 age>16 && age<28\nselect * from stu where age>16 and age<28;\n#查询 age>16 && age<28 且不能有 25\nselect * from stu where age>16 and age<28 and age != 25;\n\n\n# 多条件查询 (or)\n\n(并集)记录满足任意一个条件即被查出\n\n··· where 条件表达式1 [or 条件表达式2 [··· or 条件表达式n]];\n\n# 查询 age<16 || age>28\nselect * from stu where age<16 or age>28;\n# 查询 age<16 || age>28 且不能有 5\nselect * from stu where  age != 5 and age<16 or age>28;\n\n\nor和and一起用的情况： and的优先级高于or，因此当两者在一起使用时，应该先运算and两边的条件表达式，再运算or两边的条件表达式\n\n\n# 高级查询\n\n# 聚合函数\n\n# 记数函数 (count)\n\n统计不为null的记录条数\n\nselect count((*) | (字段名)) \nfrom 表名 [···];\n\n# 查询 emp2表 总记录数\nselect count(*) from emp2 ;\n# 查询 emp2表 comm记录数\nselect count(comm) from emp2 ;\n\n\n# 求和函数 (sum)\n\n求出表中某个字段所有值的总和\n\nselect sum(字段名1)[,sum(字段名2)...,sum(字段名n)] \nfrom 表名 [···];\n\n# 查询 emp2表 sal字段总和 \nselect sum(sal) from emp2;\n# 查询 emp2表 sal+comm字段 总和(ifnull(comm , 0) 如果字段值为null 则至为0)\nselect sum(sal+ ifnull(comm , 0) ) from emp2;\n\n\n# 平均值函数 (avg)\n\n求出某个字段所有值的平均值\n\nselect avg(字段名1)[,avg(字段名2)...,avg(字段名n)] \nfrom 表名 [···];\n\n# 查询 emp2表 sal字段平均值\nselect avg(sal) from emp2;\n\n\n# 最大值函数 (max)\n\n用于求出某个字段的最大值，语法格式:\n\nselect max(字段名1)[,max(字段名2)...,max(字段名n)] \nfrom 表名 [···];\n\n# 查询 emp2表 mgr字段最大值\nselect max(mgr) from emp2;\n\n\n# 最小值函数 (min)\n\n用于求出某个字段的最小值，语法格式:\n\nselect min(字段名1)[,min(字段名2)...,min(字段名n)] \nfrom 表名 [···];\n\n# 查询 emp2表 mgr字段最小值\nselect min(mgr) from emp2;\n\n\n# 顺序查询 (order by)\n\n对查询结果进行排序，语法格式:\n\nselect * | {字段1,字段2...字段n} from 表名 \norder by 字段名1 [asc | desc] [,字段名2 [asc| desc]...,字段名n [asc | desc]];\n\n# 查询 排序 emp2 表的 mgr(降序)\nselect * from emp2 order by mgr desc;\n# 查询 排序 emp2表 的 先排序mar ，相同值的情况排序sal (默认升序)\nselect * from emp2 order by mgr , sal ;\n\n\norder by：指定字段进行排序 select：指定查询的字段 asc升序(默认)、desc降序\n\n注意：指定字段升序排列时，某条字段值为null,则这条记录会在第一条显示，因null值被认为是最小值\n\n# 分组查询 (group by)\n\n对字段值进行分组查询\n\nselect 字段名1 | [···] from 表名\ngroup by 字段名1,字段2,···[having 条件表达式 | ···];\n\n# 查询 emp2表 以daptno字段分组 进行sal求和 \nselect deptno , sum(sal) from emp2 group by deptno;\n# 查询 emp2表 以daptno字段分组 每个dapthon分组的记录数 并排序\nselect deptno , count(*) from emp2 group by deptno order by deptno;\n# 查询 emp2表 以daptno字段分组 deptno值为30 过滤\nselect deptno , sum(sal) from emp2 group by deptno having deptno != 30;\n# 查询 emp2表 以daptno字段分组 mgr值小于7800 过滤\nselect deptno , count(*) from emp2 where mgr>7800 group by deptno;\n\n\n注意：\n\n 1. group by后面的字段 是指定字段进行分组\n 2. 聚合函数一起使用\n 3. 查询过滤使用 having 并非 where\n 4. having不能单独出现，只能存在group by后面\n 5. 非指定字段分组不能显示字段 如：(指定字段分组是deptno字段，但不能显示empno字段) select empno , sum(sal) from emp2 group by deptno;\n 6. 指定分组的字段可进行排序\n\nwhere和having区别\n\nwhere语句：分组前进行过滤,不能使用聚合函数 having语句：分组后进行过滤，可使用聚合函数\n\n# 限制查询 (limit)\n\n限制查询结果的数量\n\nselect 字段名1[,字段名2,...字段n] from 表名 \nlimit [(int)偏移量，](int)显示数;\n\n# 查询 emp2表 sal最小5个\nselect * from emp2 order by sal limit 0 , 5;\n# 查询 emp2表 sal最大5个\nselect * from emp2 order by sal desc limit 0 , 5;\n\n\n批量分页查询的情况\n\n如果有大量数据比如：10页，每页有10条 ，共有100条！ 第一页0，第二页10，第三页20····第九页90\n\npagelndex 页码数、pagesize 每页显示的条数\n\n==limit (pageindex-1)*pagesize , pagesize;==\n\n\n# 别名\n\n在查询数据时，可以为表和字段取别名，这个别名可以代替其指定的表和字段。\n\n# 表别名\n\n可以为表取一个别名,用这个别名来代替表的名称。别名格式:\n\nselect (* | 字段) from 表名 别名 [...];\n\n\nas:用于指定表名的别名,它可以省略不写。\n\n# 字段别名\n\n为字段取一个别名,用这个别名来代替表的名称。别名格式:\n\nselect (* | 字段名1 [别名][,字段名2[别名]····,字段名n[别名]]) from 表名 [...];\n# 或者：\nselect (* | 字段名1 [as 别名][,字段名2[as 别名]····,字段名n[as 别名]]) from 表名 [...];\n\n\n\n# 多表关系\n\n多对一 在多对一的表关系中，应将外键建在多的一方\n\n多对多 为了实现数据表多对多的关系，需要定义第三方中间表来保存两个关系表的外键\n\n一对一 一对一的对应关系中，需要分清主从关系，通常在从表中建立外键\n\n表创建及测试调用例子 复制导入 sql脚本导入\n\nset names utf8mb4;\nset foreign_key_checks = 0;\n\n-- ----------------------------\n-- table structure for category\n-- ----------------------------\ndrop table if exists `category`;\ncreate table `category`  (\n  `cid` varchar(32) character set utf8 collate utf8_general_ci not null,\n  `cname` varchar(100) character set utf8 collate utf8_general_ci null default null,\n  primary key (`cid`) using btree\n) engine = innodb character set = utf8 collate = utf8_general_ci row_format = dynamic;\n\n-- ----------------------------\n-- records of category\n-- ----------------------------\ninsert into `category` values ('c001', '电器');\ninsert into `category` values ('c002', '服饰');\ninsert into `category` values ('c003', '化妆品');\ninsert into `category` values ('c004', '书籍');\n\n-- ----------------------------\n-- table structure for class\n-- ----------------------------\ndrop table if exists `class`;\ncreate table `class`  (\n  `classid` int(0) not null auto_increment,\n  `classname` varchar(20) character set utf8 collate utf8_general_ci null default null,\n  primary key (`classid`) using btree\n) engine = innodb auto_increment = 5 character set = utf8 collate = utf8_general_ci row_format = dynamic;\n\n-- ----------------------------\n-- records of class\n-- ----------------------------\ninsert into `class` values (1, '红龙班');\ninsert into `class` values (2, '卫冕班');\ninsert into `class` values (3, '神州班');\ninsert into `class` values (4, '航天班');\n\n-- ----------------------------\n-- table structure for orderitem\n-- ----------------------------\ndrop table if exists `orderitem`;\ncreate table `orderitem`  (\n  `oid` varchar(50) character set utf8 collate utf8_general_ci null default null,\n  `pid` varchar(50) character set utf8 collate utf8_general_ci null default null\n) engine = innodb character set = utf8 collate = utf8_general_ci row_format = dynamic;\n\n-- ----------------------------\n-- records of orderitem\n-- ----------------------------\n\n-- ----------------------------\n-- table structure for orders\n-- ----------------------------\ndrop table if exists `orders`;\ncreate table `orders`  (\n  `oid` varchar(32) character set utf8 collate utf8_general_ci not null,\n  `totalprice` double null default null,\n  `uid` int(0) null default null,\n  primary key (`oid`) using btree\n) engine = innodb character set = utf8 collate = utf8_general_ci row_format = dynamic;\n\n-- ----------------------------\n-- records of orders\n-- ----------------------------\n\n-- ----------------------------\n-- table structure for products\n-- ----------------------------\ndrop table if exists `products`;\ncreate table `products`  (\n  `pid` varchar(32) character set utf8 collate utf8_general_ci not null,\n  `name` varchar(40) character set utf8 collate utf8_general_ci null default null,\n  `price` double null default null,\n  `category_id` varchar(32) character set utf8 collate utf8_general_ci null default null,\n  primary key (`pid`) using btree\n) engine = innodb character set = utf8 collate = utf8_general_ci row_format = dynamic;\n\n-- ----------------------------\n-- records of products\n-- ----------------------------\ninsert into `products` values ('p001', '联想', 5000, 'c001');\ninsert into `products` values ('p002', '海尔', 3000, 'c001');\ninsert into `products` values ('p003', '雷神', 5000, 'c001');\ninsert into `products` values ('p004', 'jackjones', 800, 'c002');\ninsert into `products` values ('p005', '真维斯', 200, 'c002');\ninsert into `products` values ('p006', '花花公子', 440, 'c002');\ninsert into `products` values ('p007', '劲霸', 2000, 'c002');\ninsert into `products` values ('p008', '香奈儿', 800, 'c003');\ninsert into `products` values ('p009', '相宜本草', 200, 'c003');\ninsert into `products` values ('p010', '梅明子', 200, null);\n\n-- ----------------------------\n-- table structure for scores\n-- ----------------------------\ndrop table if exists `scores`;\ncreate table `scores`  (\n  `sid` int(0) not null auto_increment,\n  `score` int(0) null default null,\n  `subjectid` int(0) null default null,\n  `studentid` int(0) null default null,\n  primary key (`sid`) using btree\n) engine = innodb auto_increment = 13 character set = utf8 collate = utf8_general_ci row_format = dynamic;\n\n-- ----------------------------\n-- records of scores\n-- ----------------------------\ninsert into `scores` values (1, 43, 1, 1);\ninsert into `scores` values (2, 100, 2, 1);\ninsert into `scores` values (3, 54, 3, 1);\ninsert into `scores` values (4, 34, 1, 2);\ninsert into `scores` values (5, 52, 2, 2);\ninsert into `scores` values (6, 32, 3, 2);\ninsert into `scores` values (7, 41, 1, 3);\ninsert into `scores` values (8, 86, 3, 3);\ninsert into `scores` values (9, 98, 2, 3);\ninsert into `scores` values (10, 78, 3, 4);\ninsert into `scores` values (11, 76, 2, 4);\ninsert into `scores` values (12, 54, 1, 4);\n\n-- ----------------------------\n-- table structure for student\n-- ----------------------------\ndrop table if exists `student`;\ncreate table `student`  (\n  `studentid` int(0) not null auto_increment,\n  `studentname` varchar(10) character set utf8 collate utf8_general_ci null default null,\n  `password` varchar(10) character set utf8 collate utf8_general_ci null default null,\n  `sex` char(1) character set utf8 collate utf8_general_ci null default null,\n  `classid` int(0) null default null,\n  `test` int(0) null default null,\n  primary key (`studentid`) using btree\n) engine = innodb auto_increment = 10 character set = utf8 collate = utf8_general_ci row_format = dynamic;\n\n-- ----------------------------\n-- records of student\n-- ----------------------------\ninsert into `student` values (1, '黑猫', '111111', '女', 1, 10);\ninsert into `student` values (2, '大鲸', '2222', '男', 3, 20);\ninsert into `student` values (3, '白兔', '3333', '女', 3, 30);\ninsert into `student` values (4, '柏竹', '4444', '男', null, 40);\ninsert into `student` values (5, '棕熊', '5555', '男', 5, 50);\ninsert into `student` values (6, '智乃', '6666', '女', 3, 60);\ninsert into `student` values (7, '蕾姆', '7777', '女', 2, 70);\ninsert into `student` values (8, '艾米', '8888', '女', 1, 80);\ninsert into `student` values (9, '纱雾', '9999', '女', 2, 90);\n\n-- ----------------------------\n-- table structure for subject\n-- ----------------------------\ndrop table if exists `subject`;\ncreate table `subject`  (\n  `subjectid` int(0) not null auto_increment,\n  `subjectname` varchar(10) character set utf8 collate utf8_general_ci null default null,\n  primary key (`subjectid`) using btree\n) engine = innodb auto_increment = 5 character set = utf8 collate = utf8_general_ci row_format = dynamic;\n\n-- ----------------------------\n-- records of subject\n-- ----------------------------\ninsert into `subject` values (1, 'java');\ninsert into `subject` values (2, 'mysql');\ninsert into `subject` values (3, 'html');\n\n-- ----------------------------\n-- table structure for users\n-- ----------------------------\ndrop table if exists `users`;\ncreate table `users`  (\n  `userid` int(0) null default null,\n  `username` varchar(20) character set utf8 collate utf8_general_ci null default null,\n  `upass` varchar(20) character set utf8 collate utf8_general_ci null default null\n) engine = innodb character set = utf8 collate = utf8_general_ci row_format = dynamic;\n\n-- ----------------------------\n-- records of users\n-- ----------------------------\n\nset foreign_key_checks = 1;\n\n\n# 连接查询(cross join)\n\n交叉连接又称 笛卡尔积 ，返回结果的是 被连接的两个表中所有字段行乘积\n\nselect {* | 查询字段} from 表1 cross join 表2 [where 条件表达式];\n# 或者(简写)\nselect {* | 查询字段} from 表1,表2 [where 条件表达式];\n\n# 将学生与班级交叉查询\nselect * from student cross join class;\n\n\n# 自然连接(natural join)\n\n特殊的等值连接，前提两表字段属性必须相同，且字段名也要相同，无须添加连接条件，得出的结果是消除重复的字段\n\nselect {* | 查询字段} from 表1 natural join 表2;\n\n# 查询学生所在的班级\nselect * from student natural join class;\n\n\n# 合并结果集 (union)\n\n连接查询的过程中，通过添加过滤条件来限制查询结果，使查询结果更加精确(all去除重复的记录)\n\n应用场景：\n\n * 查询列数类型一致可合并！！！\n * 查询两表相同列数类型进行合并结果\n\nselect {* | 查询字段} from 表1 union [all]\nselect {* | 查询字段} from 表2;\n\n# 合并两表数据\nselect studentid,studentname from student union \nselect subjectid,subjectname from subject;\n\n\n注意： 合并前提必须将两表的列数和类型一致\n\n# 内连接 (inner join)\n\n内连接使用 比较运算符，对两表中指定字段值进行比较，列出与连接条件匹配的数据行 ，字段值符合匹配的进行连接，组合成新的记录(无视不匹配的字段)\n\n# \nselect  {* | 查询字段}  from  表1  inner  join  表2  on  {表1.关系字段 = 表2.关系字段 | where 条件表达式} ;\n# 或者 sql92写法\nselect {* | 查询字段}  from  表1,表2  where  表1.关系字段 = 表2.关系字段;\n# 或者 sql99写法\nselect {* | 查询字段} from 表1 join 表2 on 表1.关系字段 = 表2.关系字段 where 约束;\n\n# 查询 与班关联的学生(已经分配班级的学生)\nselect * from student join class on student.classid = class.classid;\n\n# 查询花子所有成绩\nselect subjectname,score \nfrom\n\tscores , subject , student \nwhere\n\tscores.subjectid = subject.subjectid \n\tand scores.studentid = student.studentid \n\tand student.studentname = '花儿';\n\n# 查询 所有科目的平均值\nselect subjectname , avg( score ) \nfrom\n\tscores join subject \n\ton scores.subjectid = subject.subjectid \ngroup by\n\tsubjectname;\n\n\n# 外连接 (outer join)\n\n外连接 弥补了内连接查询不匹配的条件，查出不满足条件的可能 外连接包括： 左连接 / 右连接\n\n左连接 指定左表的所有记录，所有满足连接条件的记录。如果左表的某条记录在右表中不存在，则在右表中显示为空值\n\n主表 为左边，从表 为右边\n\n右连接 右连接与左连接正好相反\n\n主表 为右边，从表 为左边\n\n# 可将 {left|right} outer join 进行缩写为 {left|right} join\nselect {*|查询字段} from 主表 {left|right} join 从表 on 主表.字段 = 从表.字段;\n# 左外连接\nselect {*|查询字段} from 主表 left join 从表 on 主表.字段 = 从表.字段;\n# 右外连接\nselect {*|查询字段} from 主表 right join 从表 on 主表.字段 = 从表.字段;\n\n# 左外查询\nselect * from\n\tstudent left join class \n\ton student.classid = class.classid;\n# 右外查询\nselect * from\n\tstudent right join class \n\ton student.classid = class.classid;\n\n\n注意： 主表会显示所有字段，空值或不匹配条件的字段均可查询！！！\n\n# 子查询\n\n子查询是指一个查询语句 嵌套在另一个 查询语句内部的查询 在执行查询语句时，首先会执行子查询中的语句，然后将返回的结果作为外层查询的过滤条件，子查询必须返回是一个字段数据\n\n# where中子查询\n\n常用于聚合函数的子查询 比较 约束（子查询只能单条结果）\n\nselect * from 表 where ...(子查询)\n\n# 查询和 智乃 同班的学生\nselect studentname from student where classid = (\n\tselect classid from student where studentname = \"智乃\"\n);\n\n\n# from中子查询\n\n将子查询的临时表当做一个表进行应用 （子查询能多条结果）\n\nselect * from (子查询) 别名 where ...\n\n# 查出每个同学所有科目的平均分数\nselect studentname,c.avg from (\n\tselect sid,avg(score) avg from scores group by sid\n)c join student s on c.sid = s.studentid\n\n\nps : 使用临时表需要手动指定表名\n\n# select中子查询\n\n将结果进行展示，在 两表有字段关联约束进行查询使用（子查询只能单条结果）\n\nselect (子查询),... from 表\n\n\n\n\n# in\n\n内层查询语句仅仅返回一个数据字段，数据字段中的值将供外层查询语句进行比较操作\n\nselect {* | 查询字段} from 表名1 where 字段 [not] in(select 字段 from 表名2 where 条件表达式);\n\n# 查询 三班有多少女生\nselect studentname from student where classid in(\n    select classid from class where classid = 3\n)and sex = '女';\n# 查询 与‘智乃’同一个班的学生\nselect studentname from\tstudent where classid in( \n    select classid from student where studentname = '智乃' \n);\n\n\n注意： in 后面子查询返回结果要和in前的字段匹配\n\n# exists\n\n参数可以是任意一个子查询， 这个子查询的作用相当于测试，返回 布尔值 , 如果 true 外层查询才会执行\n\nselect  {* | 查询字段}  from  表名1  where  [not]  exists  (select  字段  from  表名2  where  条件表达式);\n\n# 测试 两表关系(匹配显示，不匹配不显示)\nselect\n\tstudentid,\n\tstudentname \nfrom student where\n\texists ( select * from class where class.classid = student.classid );\n\n\n# any\n\n满足任意一个条件，子查询返回的字段列表进行比较，将不匹配的过滤\n\nselect * from 表名 where [not] 字段 {比较运算符} any(select 字段 from 表名);\n\n# 查询 已经分配班级的学生\nselect classid,studentname from student \nwhere\n\tclassid = any(select classid from class);\n#或 (结果一样)\nselect classid,studentname from student \nwhere\n\tclassid in( select classid from class);\n\n\n# all\n\n子查询返回的字段列表结果需同时满足所有内层查询条件，否则查询为空\n\nselect * from 表名 where [not] 字段 {比较运算符} all(select 字段 from 表名);\n \n# 查询 test 高于蕾姆的同学\nselect studentname,test from student \nwhere \n\ttest > all(select test from student where studentname = '蕾姆');\t\n# 查询 匹配错班级的同学(数据错乱)\nselect classid,studentname from student \nwhere\n\tclassid > all(select classid from class);\n#或 (结果一样)\nselect classid,studentname from student \nwhere\n\tclassid not in( select classid from class);\n\n\n# 比较运算符\n\nany 和 all 都用到比较运算符，但还可以使用其他运算符\n\nselect * from 表名 where [not] 字段 {比较运算符} (select 字段 from 表名)\n\n\n\n# 查新执行顺序\n\n书写顺序：\n\nselect distinct ... from ... join ... on ... where ... \n\tgroup by ... having ... order by ... desc limit ...\n\n\n执行顺序：\n\n 1.  from\n 2.  no\n 3.  join\n 4.  where\n 5.  group by\n 6.  avg,sum,... (聚合函数)\n 7.  having\n 8.  select\n 9.  distinct\n 10. order by\n 11. limit\n\n\n# sql优化\n\n 1. 避免全表扫描，应先考虑 where 及 order by 涉及的列上建立索引\n 2. 避免 where语句 中的字段进行 null值 判断\n 3. 避免 where语句 中使用 != 或 < / > 操作符\n 4. 避免 where语句 使用 or 连接条件\n 5. 谨慎使用 in / not in 进行查询，连续数字可使用 between 范围查询\n\n\n# 完整性\n\n保证了数据的有效性和准确性，以防止数据表中插入错误的数据\n\n约束条件             说明\nprimary key      主键约束，用于唯一标识对应的记录\nforeign key      外键约束\nnot null         非空约束\nunique [key]     唯一性约束\ndefault          默认值约束，用于设置字段的默认值\nauto_increment   自动增长\ncheck            约束取值范围\nunsigned         无符号约束\n\n注意： 多个约束需要空格分隔\n\n\n# 实体完整性\n\n# 单字段主键\n\n每表只有一个主键，唯一性，不能null，可创建联合主键 ==字段名 数据类型 primary key[(字段名1,字段名2,···字段名n)];== ==alter table student add primary key[(字段名1,字段名2,···字段名n)]==\n\n# 唯一约束\n\n数据不能重复，只能有一次为空 ==字段名 数据类型 unique;==\n\n# 字段自动增加\n\n在数据表中，若想为表中插入的新记录自动生成唯一的 id,可以使用自增约束来实现 ==字段名 数据类型 auto_increment;==\n\n\n# 域完整性\n\n# 数据类型\n\n# 非空约束\n\n字段的值不能为null(空) ==字段名 数据类型 not null;==\n\n# 默认约束\n\n新添数据时，如果未赋值，则自动插入默认值 ==字段名 数据类型 default(默认值);==\n\n# 无符号约束\n\n==字段名 数据类型 unsigned;==\n\n# 约束范围\n\n==字段名 数据类型 check (字段值>0 and 字段值<=100);==\n\n\n# 引用完整性\n\n# 外键约束\n\n外键是指引用另一个表中的一个字段或多个字段。建立、加强两表数据之间的链接\n\n创建表时 定义外键：\n\n# 从表\ncreate table 表名(\n   字段名1 数据类型 [完整性约束条件],\n   字段名2 数据类型 [完整性约束条件],\n   ·······\n   foreign key (外键字段) references 主表( 主表的 主键 / 唯一 字段 )\n);\n\n\n创建表后 定义外键： ==alter table 从表 add constraint [自定义外键名] foreign key(从表 外键字段) references 主表( 主表的 主键 / 唯一 字段 );==\n\n外键查询 （查询表详细 可查询表的外键）\n\n==show create table 表名;==\n\n外键删除\n\n根据逻辑的需求，需要解除两个表之间的关联关系时，就需要删除外键约束 ==alter table 表名 drop foreign key 外键名;==\n\n注意：\n\n 1. 主表是被外键引用的字段，且该字段有 主键约束/唯一性约束\n 2. 被引用的是 主表，引用 的是 从表，两表是主从关系\n 3. 引入外键后，从表 外键字段 只能插入主表被引用的字段值\n 4. 如果想删除 主表 一条记录，则必须删除完 与主表相同外键值(对象是删除的记录)的从表外键字段记录(删除外键字段值与主表相同的值) ，主表才能进行删除记录，确保数据的完整性\n 5. 建立外键的表必须是innodb型不能是临时表。因为mysql中只有innodb型的表才支持外键\n 6. 定义外键名时，不能加引号。如: 'fk_ id' 或\" fk_id \"都是错误的 ，\n 7. 自定义外键名 用于删除外键约束时使用，也可不设置，一般建议“_fk”为结尾\n\n\n# 索引\n\n索引的目的在于提高查询效率，与我们查字典所用的目录是一个道理\n\n优点：\n\n * 提高查询效率\n * 降低cpu使用率\n\n缺点：\n\n * 索引本身很大，存储在 内存/硬盘 中\n * 索引会降低 增删改 的效率\n\n索引分类：\n\n * 单列索引\n * 唯一索引\n * 联合索引\n * 主键索引\n\n> 主键和唯一的区别：主键不能为null，而唯一可以\n\n\n# 索引创建\n\n建表时创建索引：\n\ncreate table 表名(\n\t字段名1 数据类型 [完整性约束条件]，\n\t字段名2 数据类型 [完整性约束条件]，\n     ·····\n\t字段名n 数据类型\n[unique | fulltext | spatial] index | key\n\t[索引名] (字段名1 [长度]) [asc | desc])\n)[存储引擎];\n\n\nunique： 可选参数，表示唯一性约束 fulltext：可选参数，表示全文约束 spatial： 可选参数，表示空间约束 index 和 key：用来表示字段的索引，二者选一即可 索引名：可选参数，表示创建的索引的名称 字段名1：指定索引对应字段的名称 长度：可选参数，用于表示索引的长度 asc 和 desc：可选参数，其中，asc表示升序排列，desc表示降序排列\n\n# 单列索引 (normal)\n\n在表中单个字段上创建索引，它可以是普通索引、唯一索引或者全文素引， 只要保证该索引只对应表中一个字段即可\n\n创建代码：\n\n==create index 索引名 on 表名 (字段名1[,字段名2...]);==\n\n==alter table 表名 add index 索引名 (字段名1[,字段名2...]);==\n\n> 以上添加代码一定一定要添加括号\n\n联合索引说明：\n\n单列索引多个字段，称为联合索引\n\n触发联合索引的条件有：\n\n> 假如索引添加形式为：==alter table user add index test (name,age)==\n\n * **组合约束查询 ** and (or查询不会触发索引) ==... where name= '张三' and age=12==\n * 单独约束查询 左边第一个字段会触发索引（右边的字段不会触发 ==where name='张三'==\n\n# 唯一索引 (unique )\n\n使字段的值必须是唯一的（允许null，但只能允许一个空\n\n==create unique index 索引名 on 表名 (字段名);==\n\n==alter table 表名 add unique index 索引名 (字段名);==\n\n# 全文索引 (fulltext)\n\n只能创建在char、varchar或text类型的字段上， 该索引只有myisam存储引擎支持\n\n==create fulltext index 索引名 on 表名 (字段名);==\n\n==alter table 表名 add fulltext index 索引名 (字段名);== 注意： 后面需存储引擎(engine =myisam)\n\n# 空间索引 (spatial)\n\n只能创建在空间数据类型的字段上。mysql中的空间数据类型有4种,分别是lgeometry、point、 linestring、polygon\n\n该索引只有myisam存储引擎支持\n\n==create spatial index 索引名 on 表名 (字段名);==\n\n==alter table 表名 add spatial index 索引名 (字段名);==\n\n注意: 后面需存储引擎(engine =myisam)\n\n\n# 索引删除\n\n==alter table 表名 drop index 索引名;==\n\n==drop index 索引名 on 表名;==\n\n\n# 函数\n\n\n# 数学函数\n\n函数名称                   作用\nabs(x)                 返回x的绝对值\nsqrt(x)                返回x的非负2次方根\nmod(x , y)             返回x被y除后的余数\nceiling(x) / ceil(x)   返回 不小于x的最大整数 (前提x有小数)\nfloor(x)               返回 不大于x的最小整数 (前提x有小数)\nround(x , y)           对 x 四舍五入 操作，小数保留 y位\ntruncate(x , y)        对 x 只舍不入 操作，小数保留 y位\nsign(x)                返回 x 符号 ( -1 / 0 / 1 )\n                       x为数值，则判断 正或负的值 ；x为其他类型，则返回0\n\n\n# 字符串函数\n\n函数名称                      作用\nlength(str)               返回 字符串的长度\nconcat(s1 , s2 , .....)   返回 一个/多个字符串 连接的新字符串\ntrim(str)                 删除字符串两侧的空格\nreplace(str , s1 , s2)    使用字符串s2替换字符串str中所有的字符串s1\nsubstring(tr , n , len)   返回字符串st的子串，起始位置为n,长度为len\nreverse(str)              返回 字符串顺序反转\nlocate(s1 , str)          返回 s1 在 str 中的起始位置\nupper(str)                将 所有 小写 转换为 大写\nlower(str)                将 所有 大写 转换为 小写\nformat(str,format)        将 字符串 进行数据格式化\n\n\n# 日期与时间的函数\n\n函数名称                                    作用\ncurdate()                               获取 系统当前 日期\ncurtime()                               获取 系统当前 时间\nsysdate()                               获取 当前系统 日期和时间\ndate_add(now() , interval num {时间单位})   指定过去或未来时间点(num是对现在的时间进行相加)\ndatediff(d1 , d2)                       计算 两时间 间隔的天数(从0000.1.1开始 n 天后的日期)\nfrom_days(day)                          计算 时间 得出日期 (从0000.1.1开始 n 天后的日期)\nyear(d)                                 获取 日期年份\nmonth(d)                                获取 日期月份\nday(d)                                  获取 日期 日\ndate_format(date , format)              日期格式化\n                                        format ：'%m-%d-%y'\n\n点击了解更多日期&时间函数了解\n\n\n# 条件判断函数\n\n函数名称                                                         作用\nif(expr , v1 , v2)                                           如果expr表达式为true返回v1,否则返回v2\nifnull(v1 , v2)                                              如果v1不为null返回v1,否则返回v2\ncase expr when v1 then r1 [when v2 then r2......] [else m]   如果expr值等于v1、v2等,则返回对应位置then后面的结果，否则返回else后的结果m\nend\n\n\n# 加密函数\n\n函数名称                    作用\nmd5(str)                对字符串 str 进行md5加密\nencode(str , pwd stu)   使用pwd作为密码加密字符串str\ndecode(str , pwd str)   使用pwd作为密码解密字符串str\n\n\n# 事务\n\n事务指逻辑上的一组操作，组成这组操作的各个单元，要不全部成功，就全部不成功，同一个事务的操作具备同步优点\n\nset autocommit = 0;\nstart transaction; |  begin;\n···\n····\nrollback;\ncommit; \n\n\nset autocommit： 自动事务提交开关（0关闭；1开启） start transaction | begin： 开启事务(处于事务中，不会影响数据库数据) rollback： 回滚事务(取消事务，前提是事务未提交前回滚) commit ： 事务提交(事务生效后会立即影响数据库数据)\n\n\n# 事务acid特性\n\n原子性(atomicity) 指事务是一个不可分割的工作单位，事务中的操作要么执行成功，要么执行失败\n\n一致性(consistency) 事务前后数据的完整性必须保持一致(数据库的完整性：如果数据库在某个时间点下，所有的数据都符合所有的约束，则称数据库为符合完整性的状态)\n\n隔离性(isolation) 指多个用户并发访问数据库时，一个用户的事务不能被其它用户的事务所干扰，多个并发事务之间数据要相互隔离\n\n持久性(durability) 指一个事务一旦被提交，数据库中的数据改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响\n\n\n# 事务安全问题\n\n脏读： 两事务 某一事务读取到另一个事务修改且未提交的数据\n\n不可重复读： 某一事务多次读取同一条记录的过程，读取的结果不相同过程数据有更改，读取到另一个事务已经提交的数据\n\n虚读(幻读)： 某一事务多次查询数据，由于其他事务 新增 或 删除 记录造成多次查询出的记录条数不同\n\n\n# 事务隔离级别\n\n防止不同隔离性的问题\n\n隔离类型                   脏读   不可重复读   幻读\n未提交 read uncommitted   允许   允许      允许\n已读提交 read committed    禁止   允许      允许\n可重复读 repeatable read   禁止   禁止      可能\n顺序读 serializable       禁止   禁止      禁止\n\n一般默认 可重复读、 已读提交\n\n修改隔离级别 ==set  [session | global]  transaction  isolation   level 隔离类型;== session： 当前会话 global： 全局\n\n查询隔离级别 ==select @@tx_isolation;== (mysql版本8前) ==select @@transaction_isolation;== (mysql版本8后)\n\n# 未提交 (read uncommitted)\n\n读未提交，该隔离级别允许脏读取，其隔离级别是最低的\n\n时间(t)   事务a         事务b\nt1      开始事务        开始事务\nt2      ==          查余额(500元)\nt3      ==          取300元\nt4      查余额(200元)   ==\nt5      ==          滚动事务\nt6      存800元       ==\nt7      提交事务        ==\nt8                  取100元\nt9                  提提交事务\n\n最后余额剩1200元。t4 a脏读b修改的数据，t5 b回滚(撤回t5前的所有操作)，最后b只提取100元！\n\n# 已读提交 (read committed)\n\n读已提交是不同的事务执行的时候 只能获取 到已经提交的数据\n\n时间(t)   事务a         事务b\nt1      开始事务        开始事务\nt2      ==          查余额(500元)\nt3      查余额(500元)   ==\nt4      ==          取500元\nt5      查余额(500元)   ==\nt6      ==          提交事务\nt7      查余额(0)      \nt8      提交事务        \n\na只能读取 事务提交后的数据！！\n\n# 可重复读 (repeatable read)\n\n保证在事务处理过程中，多次读取同一个数据时，该数据的值和事务开始时刻是一致的\n\n时间(t)   事务a             事务b\nt1      开始事务            \nt2      查所有数据           开始事务\nt3      ==              插入一条数据\nt4      ==              提交事务\nt5      查所有数据(和t2一样)    \nt6      修改范围数据          \nt7      查所有数据(多了一条数据)   \nt8      提交事务            \n\n事务a 的 t2 查询数据 与 t5查询数据 是一样的 ，确认数据无误后 对表数据值修改，紧接查询事务多出了一条数据！！（作为这一前提 事务b 插入数据提交事务\n\n> 事务b未提交 ，事务a 对数据进行更改，则不会显示，除非 事务b提交\n\n# 顺序读 (serializable)\n\n最严格的事务隔离级别。事务以排队形式进行执行。某一事务对数据进行修改必须等另一个 提交 或 回滚 ，才可以进行数据修改！！\n\n\n# 隔离级别锁的情况\n\n读未提交(ru)： 有行级的锁，没有间隙锁。与rc的区别是能够查询到未提交的数据 读已提交(rc)： 有行级的锁，没有间隙锁，读不到没有提交的数据 可重复读(rr)： 有行级的锁，有间隙锁，每读取的数据都一样，且没有幻读的情况 序列化(s)： 有行级锁，也有间隙锁，读表的时候，就已经上锁了",charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"SpringBoot",frontmatter:{title:"SpringBoot",author:"柏竹",permalink:"/backend/40kn39",date:"2020-02-18T00:00:00.000Z",categories:["后端","框架"],tags:[null]},regularPath:"/01.%E5%90%8E%E7%AB%AF/04.%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF/04.SpringBoot%20.html",relativePath:"01.后端/04.框架技术/04.SpringBoot .md",key:"v-27ebad24",path:"/backend/40kn39/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:17},{level:2,title:"首次应用",slug:"首次应用",normalizedTitle:"首次应用",charIndex:206},{level:3,title:"Spring Boot无xml应用Web项目",slug:"spring-boot无xml应用web项目",normalizedTitle:"spring boot无xml应用web项目",charIndex:215},{level:3,title:"Spring Boot启动器应用Web项目",slug:"spring-boot启动器应用web项目",normalizedTitle:"spring boot启动器应用web项目",charIndex:5240},{level:2,title:"数据配置",slug:"数据配置",normalizedTitle:"数据配置",charIndex:7291},{level:3,title:"Bean配置",slug:"bean配置",normalizedTitle:"bean配置",charIndex:7830},{level:3,title:"Controller配置",slug:"controller配置",normalizedTitle:"controller配置",charIndex:10720},{level:3,title:"自动注入配置",slug:"自动注入配置",normalizedTitle:"自动注入配置",charIndex:13221},{level:4,title:"@ConfigurationProperties",slug:"configurationproperties",normalizedTitle:"@configurationproperties",charIndex:7478},{level:4,title:"定义在类上",slug:"定义在类上",normalizedTitle:"定义在类上",charIndex:13343},{level:4,title:"定义在方法上",slug:"定义在方法上",normalizedTitle:"定义在方法上",charIndex:13753},{level:4,title:"@EnableConfigurationProperties",slug:"enableconfigurationproperties",normalizedTitle:"@enableconfigurationproperties",charIndex:7549},{level:3,title:"配置文件",slug:"配置文件",normalizedTitle:"配置文件",charIndex:2157},{level:3,title:"Session集群共享",slug:"session集群共享",normalizedTitle:"session集群共享",charIndex:20121},{level:3,title:"计划任务",slug:"计划任务",normalizedTitle:"计划任务",charIndex:20452},{level:3,title:"热部署",slug:"热部署",normalizedTitle:"热部署",charIndex:20593},{level:3,title:"日志",slug:"日志",normalizedTitle:"日志",charIndex:21539},{level:4,title:"日志级别",slug:"日志级别",normalizedTitle:"日志级别",charIndex:21988},{level:4,title:"日志配置",slug:"日志配置",normalizedTitle:"日志配置",charIndex:22633},{level:2,title:"框架整合",slug:"框架整合",normalizedTitle:"框架整合",charIndex:23435},{level:3,title:"SpringMVC 整合",slug:"springmvc-整合",normalizedTitle:"springmvc 整合",charIndex:23501},{level:4,title:"修改端口",slug:"修改端口",normalizedTitle:"修改端口",charIndex:24070},{level:4,title:"静态资源加载",slug:"静态资源加载",normalizedTitle:"静态资源加载",charIndex:24078},{level:4,title:"文件上传",slug:"文件上传",normalizedTitle:"文件上传",charIndex:25459},{level:4,title:"拦截器",slug:"拦截器",normalizedTitle:"拦截器",charIndex:23792},{level:4,title:"虚实映射重定向",slug:"虚实映射重定向",normalizedTitle:"虚实映射重定向",charIndex:23960},{level:4,title:"跨域",slug:"跨域",normalizedTitle:"跨域",charIndex:24037},{level:4,title:"简单请求",slug:"简单请求",normalizedTitle:"简单请求",charIndex:29083},{level:4,title:"非简单请求",slug:"非简单请求",normalizedTitle:"非简单请求",charIndex:29090},{level:4,title:"SpringBoot解决方案",slug:"springboot解决方案",normalizedTitle:"springboot解决方案",charIndex:30199},{level:4,title:"url图片",slug:"url图片",normalizedTitle:"url图片",charIndex:31284},{level:3,title:"JDBC 整合",slug:"jdbc-整合",normalizedTitle:"jdbc 整合",charIndex:31774},{level:3,title:"MyBatis 整合",slug:"mybatis-整合",normalizedTitle:"mybatis 整合",charIndex:34252},{level:3,title:"tk-MyBatis 整合",slug:"tk-mybatis-整合",normalizedTitle:"tk-mybatis 整合",charIndex:37555},{level:4,title:"应用实现",slug:"应用实现",normalizedTitle:"应用实现",charIndex:39732},{level:4,title:"自定义映射文件查询",slug:"自定义映射文件查询",normalizedTitle:"自定义映射文件查询",charIndex:43895},{level:3,title:"视图框架整合",slug:"视图框架整合",normalizedTitle:"视图框架整合",charIndex:45584},{level:4,title:"表达式",slug:"表达式",normalizedTitle:"表达式",charIndex:45823},{level:5,title:"变量表达式",slug:"变量表达式",normalizedTitle:"变量表达式",charIndex:45847},{level:5,title:"选择表达式",slug:"选择表达式",normalizedTitle:"选择表达式",charIndex:45862},{level:5,title:"URL表达式",slug:"url表达式",normalizedTitle:"url表达式",charIndex:45877},{level:4,title:"th属性",slug:"th属性",normalizedTitle:"th属性",charIndex:46904},{level:4,title:"内置对象",slug:"内置对象",normalizedTitle:"内置对象",charIndex:50815},{level:4,title:"首次应用",slug:"首次应用-2",normalizedTitle:"首次应用",charIndex:206},{level:3,title:"Shiro整合",slug:"shiro整合",normalizedTitle:"shiro整合",charIndex:54429},{level:3,title:"MyBatis Plus整合",slug:"mybatis-plus整合",normalizedTitle:"mybatis plus整合",charIndex:59883},{level:4,title:"首次应用",slug:"首次应用-3",normalizedTitle:"首次应用",charIndex:206},{level:4,title:"注解配置",slug:"注解配置",normalizedTitle:"注解配置",charIndex:7313},{level:4,title:"内置 CRUD",slug:"内置-crud",normalizedTitle:"内置 crud",charIndex:62553},{level:5,title:"新增",slug:"新增",normalizedTitle:"新增",charIndex:29394},{level:5,title:"删除",slug:"删除",normalizedTitle:"删除",charIndex:13913},{level:5,title:"更改",slug:"更改",normalizedTitle:"更改",charIndex:8215},{level:5,title:"查询",slug:"查询",normalizedTitle:"查询",charIndex:38187},{level:4,title:"自定义 SQL",slug:"自定义-sql",normalizedTitle:"自定义 sql",charIndex:69611},{level:5,title:"条件构造器",slug:"条件构造器",normalizedTitle:"条件构造器",charIndex:69888},{level:5,title:"传参操作",slug:"传参操作",normalizedTitle:"传参操作",charIndex:71059},{level:4,title:"多表查询",slug:"多表查询",normalizedTitle:"多表查询",charIndex:72004},{level:4,title:"分页插件",slug:"分页插件",normalizedTitle:"分页插件",charIndex:60089},{level:5,title:"内置分页",slug:"内置分页",normalizedTitle:"内置分页",charIndex:74642},{level:5,title:"xml分页",slug:"xml分页",normalizedTitle:"xml分页",charIndex:76735},{level:5,title:"pagehelper分页",slug:"pagehelper分页",normalizedTitle:"pagehelper分页",charIndex:78972},{level:4,title:"反向工程",slug:"反向工程",normalizedTitle:"反向工程",charIndex:83218},{level:5,title:"3.5.1之前",slug:"_3-5-1之前",normalizedTitle:"3.5.1之前",charIndex:83277},{level:5,title:"3.5.1之后",slug:"_3-5-1之后",normalizedTitle:"3.5.1之后",charIndex:91353},{level:3,title:"JSON整合",slug:"json整合",normalizedTitle:"json整合",charIndex:95917},{level:4,title:"对象>JSON",slug:"对象-json",normalizedTitle:"对象&gt;json",charIndex:null},{level:4,title:"JSON>对象",slug:"json-对象",normalizedTitle:"json&gt;对象",charIndex:null},{level:4,title:"自定义工具类",slug:"自定义工具类",normalizedTitle:"自定义工具类",charIndex:96468},{level:2,title:"部署",slug:"部署",normalizedTitle:"部署",charIndex:20594},{level:3,title:"Jar打包",slug:"jar打包",normalizedTitle:"jar打包",charIndex:100579},{level:3,title:"Docker打包/群辉挂载",slug:"docker打包-群辉挂载",normalizedTitle:"docker打包/群辉挂载",charIndex:101063},{level:3,title:"SSL域名认证",slug:"ssl域名认证",normalizedTitle:"ssl域名认证",charIndex:101817},{level:3,title:"SSH",slug:"ssh",normalizedTitle:"ssh",charIndex:102236}],headersStr:"概述 首次应用 Spring Boot无xml应用Web项目 Spring Boot启动器应用Web项目 数据配置 Bean配置 Controller配置 自动注入配置 @ConfigurationProperties 定义在类上 定义在方法上 @EnableConfigurationProperties 配置文件 Session集群共享 计划任务 热部署 日志 日志级别 日志配置 框架整合 SpringMVC 整合 修改端口 静态资源加载 文件上传 拦截器 虚实映射重定向 跨域 简单请求 非简单请求 SpringBoot解决方案 url图片 JDBC 整合 MyBatis 整合 tk-MyBatis 整合 应用实现 自定义映射文件查询 视图框架整合 表达式 变量表达式 选择表达式 URL表达式 th属性 内置对象 首次应用 Shiro整合 MyBatis Plus整合 首次应用 注解配置 内置 CRUD 新增 删除 更改 查询 自定义 SQL 条件构造器 传参操作 多表查询 分页插件 内置分页 xml分页 pagehelper分页 反向工程 3.5.1之前 3.5.1之后 JSON整合 对象>JSON JSON>对象 自定义工具类 部署 Jar打包 Docker打包/群辉挂载 SSL域名认证 SSH",content:'# SpringBoot\n\n\n# 概述\n\nSpring Boot 是 Spring 快速开发的脚手架，Spring Boot 大大优化了 Spring的 ==复杂配置== 和 ==依赖配置版本== 问题\n\n特点\n\n 1. 独立运行 Spring项目\n 2. 内嵌 tomcat 和 jetty 容器 , 无需打包war文件\n 3. 简化 maven配置\n 4. 无 代码生成/xml配置\n 5. ...\n\n\n# 首次应用\n\n\n# Spring Boot无xml应用Web项目\n\n模拟原生的Servlet搭建Web\n\n> 该配置方式学习了解即可，并非针对学习！！\n\n 1. 创建 Maven无骨架项目 IDEA创建Maven项目 （无骨架Java项目）\n\n 2. pom.xml 引入 SpringBoot相关依赖\n    \n    <packaging>war</packaging>\n    \x3c!-- 集中定义依赖版本号 --\x3e\n    <properties>\n        <spring.version>5.1.2.RELEASE</spring.version>\n        <pagehelper.version>4.2.1</pagehelper.version>\n    </properties>\n    \n    <dependencies>\n    \n        \x3c!-- Spring --\x3e\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-beans</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-webmvc</artifactId>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupId>javax.servlet</groupId>\n            <artifactId>javax.servlet-api</artifactId>\n            <version>4.0.1</version>\n            <scope>provided</scope>\n        </dependency>\n        \x3c!-- jstl --\x3e\n        <dependency>\n            <groupId>javax.servlet</groupId>\n            <artifactId>jstl</artifactId>\n            <version>1.2</version>\n        </dependency>\n    </dependencies>\n    \n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.7.0</version>\n                <configuration>\n                    <source>1.8</source>\n                    <target>1.8</target>\n                    <encoding>UTF-8</encoding>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n    \n\n 3. 建立 模拟web.xml配置 的Java程序类 WebInit类\n    \n    web.xml文件配置 (比对示例的配置文件\n    \n    <servlet>\n        <servlet-name>dispatcherServlet</servlet-name>\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n            <param-value>classpath*:springmvc.xml</param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>dispatcherServlet</servlet-name>\n        <url-pattern>/</url-pattern>\n    </servlet-mapping>\n    \n    \n    Java程序配置 （应用代码\n    \n    public class WebInit implements WebApplicationInitializer {\n        // 初始化配置\n        @Override\n        public void onStartup(ServletContext servletContext) throws ServletException {\n            // 指定 spring配置类\n            AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext();\n            context.register(SpringMVCConfig.class);\n    \n            // 添加Serlvet并指定映射\n            ServletRegistration.Dynamic springmvc =\n                    servletContext.addServlet("springmvc",new DispatcherServlet(context));\n            springmvc.addMapping("/");\n            springmvc.setLoadOnStartup(1);\n        }\n    }\n    \n    \n    > SpringMVCConfig类 需要指定加载的 SpringMVC配置的类，在下面\n\n 4. 创建 SpringMVC配置类\n    \n    web.xml文件配置 (比对示例的配置文件\n    \n    <mvc:annotation-driven />\n    <context:component-scan base-package="com.sans"/>\n    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">\n    \t<property name="prefix" value="/html/"/>\n    \t<property name="suffix" value=".html"/>\n    </bean>\n    \n    \n    Java程序配置 （应用代码\n    \n    @Configuration\n    @ComponentScan("com.sans")\n    @EnableWebMvc\n    public class SpringMVCConfig implements WebMvcConfigurer {\n    // 组件注解加载 xml：<mvc:default-servlet-handler/>\n    @Override\n    public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) {\n        configurer.enable();\n    }\n    \n    @Bean\n    public ViewResolver viewResolver() {\n        InternalResourceViewResolver viewResolver = new InternalResourceViewResolver();\n        viewResolver.setPrefix("/html/");\n        viewResolver.setSuffix(".html");\n        return viewResolver;\n    }\n    \n\n 5. 创建 Controller\n    \n    package com.controller;\n    \n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.web.bind.annotation.GetMapping;\n    import org.springframework.web.bind.annotation.RestController;\n    \n    import javax.sql.DataSource;\n    \n    @Controller\n    public class HelloController {\n        @RequestMapping("/hello")\n        public String hello() {\n            return "test";\n        }\n    }\n    \n\n 6. 在Web项目访问 html/test.html文件 访问即可\n\n项目结构\n\n  .\n  |\n  ├── src\n  |    ├── main\n  |\t   |\t├── java\n  |\t   |\t|\t  └── com\n  |\t   |    |   \t   ├── controller\n  |    |    |          |      └── HelloController.java\n  |    |    |          └── config\n  |    |    |                 ├── SpringMVCConfig.java\n  |    |    |                 └── WebInit.java\n  |\t   |\t└──\tresources\n  |\t  test\n  └── pom.xml\n\n\n\n# Spring Boot启动器应用Web项目\n\n 1. 创建 Maven无骨架项目 IDEA创建Maven项目 （无骨架Java项目）\n\n 2. pom.xml 引入 SpringBoot相关依赖\n    \n    <project>\n        ...\n        \x3c!--父工程坐标\n            web相关应用无需配置再配置版本号(解决版本冲突问题)\n        --\x3e\n        <parent>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-parent</artifactId>\n            <version>2.0.0.RELEASE</version>\n        </parent>\n      \n        <dependencies>\n            \x3c!--当中包含 tomcat、SpringMVC、...（有关web应用，自动配置）--\x3e\n            <dependency>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-starter-web</artifactId>\n            </dependency>\n        </dependencies>\n    ...\n    </project>\n    \n\n 3. 创建 Application启动器类 全限定名 com.Application\n    \n    package com;\n    \n    import org.springframework.boot.SpringApplication;\n    import org.springframework.boot.autoconfigure.SpringBootApplication;\n    \n    // @SpringBootApplication启动类\n    @SpringBootApplication\n    public class Application {\n        \n        public static void main(String[] args) {\n            SpringApplication.run(Application.class , args);\n        }\n    \n    }\n    \n\n 4. 创建 HelloController控制器类 全限定名 com.controller.Application (为了方便看出构架结构)\n    \n    package com.controller;\n    \n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.web.bind.annotation.GetMapping;\n    import org.springframework.web.bind.annotation.RestController;\n    \n    import javax.sql.DataSource;\n    \n    @RestController\n    public class HelloController {\n        \n        @GetMapping("/hello")\n        public String hello() {\n            return "hello , Spring Boot...";\n        }\n        \n    }\n    \n\n 5. 启动类启用Main方法，再浏览器访问：http://localhost:8080/hello （页面返回有信息表示成功！）\n    \n    \n\n项目结构\n\n  .\n  |\n  ├── src\n  |    ├── main\n  |\t   |\t├── java\n  |\t   |\t|\t  └── com\n  |\t   |    |   \t   ├── controller\n  |    |    |          |        └── HelloController.java\n  |\t   |    | \t\t   └── Application.java\n  |\t   |\t└──\tresources\n  |\t  test\n  └── pom.xml\n\n\n\n# 数据配置\n\nSpring Boot应用的是全注解配置（Java程序配置\n\n常用注解：\n\n * @Configuration 声明在类上，作为配置类（代替xml文件）\n\n * @Bean 声明在方法上，将方法返回值导入Bean容器（代替 标签）\n\n * @value 属性注入（需要属性文件进行搭配应用）\n\n * @PropertySource 引入读取外部属性文件\n\n * @ConfigurationProperties 引入读取外部属性文件，自动注入 成员变量（需要指定前缀 、Properties文件\n\n * @EnableConfigurationProperties\n   \n   自动注入 @ConfigurationProperties类\n\n * @RequestMapping 负责URL路由映射 , 可以添加映射规则(请求类型/响应体/请求头/...)\n\n * @RestController 响应的对象都会转换为JSON格式\n\n * @Component 把类对象实例化到 Bean容器 (类似于\n\n * @PostConstruct 方法 在配置类 执行的构造函数 和自动注入 后执行初始化的方法(类似servlet的init()方法)\n\n * \n\n\n# Bean配置\n\n通过 Spring Boot 还原 Spring配置连接池 的操作\n\nSpring 原配置\n\n\x3c!-- 配置连接池 --\x3e\n<bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"\ninit-method="init" destroy-method="close">\n\t<property name="url" value="${jdbc.url}" />\n\t<property name="username" value="${jdbc.username}" />\n\t<property name="password" value="${jdbc.password}" />\n</bean>\n\n\nSpring Boot配置\n\n 1. 在以上篇章 首次应用的代码 基础上进行更改\n\n 2. pom.xml 引入 Druid连接池依赖\n    \n    <dependency>\n    \t<groupId>com.alibaba</groupId>\n    \t<artifactId>druid</artifactId>\n    \t<version>1.1.10</version>\n    </dependency>\n    \n\n 3. 创建 jdbc.properties文件 到 resources资源中\n    \n    jdbc.driverClassName=com.mysql.jdbc.Driver\n    jdbc.url=jdbc:mysql://127.0.0.1:3306/test\n    jdbc.username=root\n    jdbc.password=root\n    \n\n 4. 创建 JdbcConfig配置类\n    \n    package com.config;\n    \n    import com.alibaba.druid.pool.DruidDataSource;\n    import org.springframework.beans.factory.annotation.Value;\n    import org.springframework.boot.context.properties.EnableConfigurationProperties;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.context.annotation.PropertySource;\n    \n    import javax.sql.DataSource;\n    \n    //配置类\n    @Configuration\n    //读取数据文件\n    @PropertySource("classpath:jdbc.properties")\n    public class JdbcConfig {\n    \n        /** 属性\n         * 注入属性\n         */\n        @Value("${jdbc.driverClassName}")\n        String driverClassName;\n        @Value("${jdbc.url}")\n        String url;\n        @Value("${jdbc.username}")\n        String username;\n        @Value("${jdbc.password}")\n        String password;\n    \n        /** 对象\n         *  声明的Bean方法返回值会加入到Spring容器中\n         *  说明：\n         *      - 注解方法 Bean对象\n         *      - 默认对象名id(Bean的ID) 与 方法名 一致\n         *      - 自定义Bean对象名，可在注解 @Bean("自定义名称"),指定新对象\n         */\n        @Bean\n        public DataSource dataSource() {\n            DruidDataSource dataSource = new DruidDataSource();\n            dataSource.setDriverClassName(driverClassName);\n            dataSource.setUrl(url);\n            dataSource.setUsername(username);\n            dataSource.setPassword(password);\n            return dataSource;\n        }\n    \n    }\n    \n\n 5. 在 HelloController控制类 自动注入测试\n    \n    package com.controller;\n    \n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.web.bind.annotation.GetMapping;\n    import org.springframework.web.bind.annotation.RestController;\n    \n    import javax.sql.DataSource;\n    \n    @RestController\n    public class HelloController {\n        \n        // 该注解自动匹配名称进行指定注入\n        @Autowired\n        private DataSource dataSource;\n    \n        @GetMapping("/hello")\n        public String hello() {\n            return "hello , Spring Boot..." + dataSource;\n        }\n        \n    }\n    \n\n 6. 启用Main方法调试测试。可利用断点进行查看配置连接池的参数传递情况\n\n\n# Controller配置\n\nController配置中 Spring提供有以下两种注解进行应用\n\n * @Controller 请求包含有 页面和数据\n * @RestController 请求只有 数据\n\n> 一般情况下使用的 @RestController 居多 , 前后端分离嘛 . @Controller 则需要搭配模板引擎进行应用\n\n参数传递 直接上代码 , 详细了解进入 SpringMVC参数传递篇\n\n@RestController\npublic class ParamsController {\n\n    // http://localhost:8080/getTest1\n    @RequestMapping(value = "getTest1", method = RequestMethod.GET)\n    public String getTest1() {\n        return "GET请求1";\n    }\n\n    // http://localhost:8080/getTest2?nickname=zs&phone=123\n    @RequestMapping(value = "getTest2", method = RequestMethod.GET)\n    public String getTest2(String nickname, String phone) {\n        System.out.println("nickname = " + nickname);\n        System.out.println("phone = " + phone);\n        return "GET请求2";\n    }\n\n    // http://localhost:8080/getTest3?name=zs\n    @RequestMapping(value = "getTest3", method = RequestMethod.GET)\n    public String getTest3(@RequestParam("name") String nickname) {\n        System.out.println("nickname = " + nickname);\n        return "GET请求3";\n    }\n\n    // http://localhost:8080/postTest1\n    @RequestMapping(value = "/postTest1", method = RequestMethod.POST)\n    public String postTest1() {\n        return "POST请求1";\n    }\n\n    // http://localhost:8080/postTest2\n    /*\n    * application/x-www-form-urlencoded : {\n    *   username:zs,\n    *   password:123\n    * }\n     * */\n    @RequestMapping(value = "/postTest2", method = RequestMethod.POST)\n    public String postTest2(String username, String password) {\n        System.out.println("username = " + username);\n        System.out.println("password = " + password);\n        return "POST请求2";\n    }\n\n    // http://localhost:8080/postTest3\n    /*\n     * application/x-www-form-urlencoded : {\n     *   username:zs,\n     *   password:123\n     * }\n     * */\n    @RequestMapping(value = "/postTest3", method = RequestMethod.POST)\n    public String postTest3(MyUser user) {\n        System.out.println(user);\n        return "POST请求3";\n    }\n\n    // http://localhost:8080/postTest4\n    /*\n       application/json : {\n         "username":"zs",\n         "password":"123"\n       }\n     */\n    @RequestMapping(value = "/postTest4", method = RequestMethod.POST)\n    public String postTest4(@RequestBody MyUser user) {\n        System.out.println(user);\n        return "POST请求4";\n    }\n\n    // http://localhost:8080/test/xxx...\n    @GetMapping("/test/**")\n    public String test() {\n        return "通配符请求";\n    }\n}\n\n\n通配符\n\n * * : 任意单词\n * ** : 任意路径\n * ? : 任意单个字符\n\n> 通常使用的 * 较多 , 比如指定未知文件名的文件等等...\n\n\n# 自动注入配置\n\nSpringBoot注解配置 正是优化 Spring注解配置 的存在。虽然以上spring注解配置可行，但配置依旧有些许繁琐。\n\n# @ConfigurationProperties\n\n该注解有两种实现方式 类/方法 上\n\n# 定义在类上\n\n将 类的成员变量 与 配置文件key值 进行匹配赋予值，赋予值的前提需要指定 配置文件的前缀字符串prefix\n\n例如：\n\njdbc.driver.username=root\njdbc.driver.password=root\n\n\n@ConfigurationProperties(prefix = "jdbc.driver")\npublic class JdbcProperties {\n    private String driverClassName;\n    private String url;\n    private String username;\n    private String password;\n    // settre/gettre 方法省略 （一定一定不能少写\n}\n\n\n> 应用需要搭配 @EnableConfigurationProperties注解 进行使用\n\n# 定义在方法上\n\nBean方法 返回直接声明使用，这一过程无需@EnableConfigurationProperties注解 进行读取类对象应用\n\n> 应用前提： 注入的对象必须有 set方法\n\n// 声明要注入属性前缀，SpringBoot会自动把相关属性通过set方法进行注入到dataSource中\n// 应用前提删除 JdbcProperties属性读取类 已经使用 属性的前缀值 进行读取\n@Bean\n@ConfigurationProperties (prefix = "jdbc")\npublic DataSource dataSource() {\n    return new DruidDataSource();\n}\n\n\n# @EnableConfigurationProperties\n\n用于声明指定获取存储参数的对象，参数 value 其值为 指定某个存储参数的类\n\n自动注入方式：\n\n 1. @Autowired注入\n 2. 声明有@Bean的方法参数注入\n\n以下示例以连接池的配置进行测试\n\n 1. 创建 JdbcProperties属性读取类 ，全限定名 com.config.JdbcProperties\n    \n    package com.config;\n    \n    import org.springframework.boot.context.properties.ConfigurationProperties;\n    \n    /** 属性读取类\n     * @ConfigurationProperties （属性配置）\n     *      prefix = "jdbc" , 配置数据的前缀为jdbc的值 (它只会读取前缀为jdbc的值)\n     */\n    @ConfigurationProperties(prefix = "jdbc")\n    public class JdbcProperties {\n    \n        private String driverClassName;\n        private String username;\n        private String password;\n        private String url;\n        \n        // set 和 get \n        ...\n    }\n    \n\n 2. JdbcConfig配置类 ，全限定名 com.config.JdbcConfig\n    \n    package com.config;\n    \n    import com.alibaba.druid.pool.DruidDataSource;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.boot.context.properties.EnableConfigurationProperties;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    \n    import javax.sql.DataSource;\n    \n    // 定义 配置类\n    @Configuration\n    // 定义 加载配置文件\n    @PropertySource("classpath:jdbc.properties")\n    // 定义 启动加载实体\n    @EnableConfigurationProperties(JdbcProperties.class)\n    public class JdbcConfig {\n    \n        /** 方式1 （成员变量注入\n         *  步骤：\n         *    1. 加载配置文件 @PropertySource("classpath:jdbc.properties")\n         *    2. 成员变量赋予值 @Value()\n         */\n        @Value("${jdbc.driverClassName}")\n        private String driverClassName;\n        @Value("${jdbc.url}")\n        private String url;\n        @Value("${jdbc.username}")\n        private String username;\n        @Value("${jdbc.password}")\n        private String password;\n    \n        @Bean\n        public DataSource dataSource01() {\n            DruidDataSource dataSource = new DruidDataSource();\n            dataSource.setDriverClassName(driverClassName);\n            dataSource.setUrl(url);\n            dataSource.setUsername(username);\n            dataSource.setPassword(password);\n            return dataSource;\n        }\n    \n        /** 方式2 （实体对象注入\n         *  步骤：\n         *    1. 创建承载的实体 JdbcProperties对应前缀属性指定填充。通过 @ConfigurationProperties注解实现参数填充\n         *    2. 加载配置文件 @PropertySource("classpath:jdbc.properties")\n         *    3. 启动指定实体类的自动注入 @EnableConfigurationProperties(JdbcProperties.class)\n         *    4. 承载实体对象自动注入 @Autowired\n         */\n        @Autowired\n        private JdbcProperties jdbcProperties;\n    \n        @Bean\n        public DataSource dataSource02() {\n            DruidDataSource dataSource = new DruidDataSource();\n            dataSource.setDriverClassName(jdbcProperties.getDriverClassName());\n            dataSource.setUrl(jdbcProperties.getUrl());\n            dataSource.setUsername(jdbcProperties.getUsername());\n            dataSource.setPassword(jdbcProperties.getPassword());\n            return dataSource;\n        }\n    \n        /** 方式3 （方法参数注入\n         *  步骤：\n         *    1. 创建承载的实体 JdbcProperties对应前缀属性指定填充。通过 @ConfigurationProperties注解实现参数填充\n         *    2. 加载配置文件 @PropertySource("classpath:jdbc.properties")\n         *    3. 注解加载配置文件 @EnableConfigurationProperties(JdbcProperties.class)\n         *    4. 方法参数直接应用\n         */\n        @Bean\n        public DataSource dataSource03(JdbcProperties jdbc) {\n            DruidDataSource dataSource = new DruidDataSource();\n            dataSource.setDriverClassName(jdbc.getDriverClassName());\n            dataSource.setUrl(jdbc.getUrl());\n            dataSource.setUsername(jdbc.getUsername());\n            dataSource.setPassword(jdbc.getPassword());\n            return dataSource;\n        }\n        \n        /** 方式4 （@ConfigurationProperties注入\n         *  创建承载的实体 JdbcProperties对应前缀属性指定填充。通过 @ConfigurationProperties注解实现 数据直接填充\n         */\n        @Bean\n        @ConfigurationProperties(prefix = "jdbc.driver")\n        public DataSource dataSource04() {\n            return new DruidDataSource();\n        }\n    \n    }\n    \n\n 3. Controller层。自动注入，断点测试\n    \n    @RestController\n    public class HelloContoller {\n    \n        // Bean配置注入\n        @Autowired\n        private DataSource dataSource01;\n        // @EnableConfigurationProperties 注解注入\n        @Autowired\n        private DataSource dataSource02;\n        // @EnableConfigurationProperties 方法参数注入\n        @Autowired\n        private DataSource dataSource03;\n        // @ConfigurationProperties注入\n        @Autowired\n        private DataSource dataSource04;\n    \n        /**\n         *  运行时 断点查看 成员变量\n         */\n        @GetMapping("/hello")\n        public String hello() {\n            return "hello";\n        }\n    \n    }\n    \n\n 4. 启用Main方法调试测试\n\n\n# 配置文件\n\nSpringBoot 在启动时会将 resources 目录下的 application.properties 或 apllication.yml 文件 作为其默认配置文件（它们可以包含多个文件）\n\n.properties 和 .yml 的区别\n\n * 配置结构：.properties 线性结构 ；.yml 树状结构\n * 分割方式：.properties 以 . 进行分割；.yml 以 : 进行分割\n\n.properties配置文件\n\n# properties格式\nenvironments.dev.url=http://dev.bar.com\nenvironments.dev.name=Developer Setup\nenvironments.prod.url=http://foo.bar.com\nenvironments.prod.name=My Cool App\nmy.servers[0]=dev.bar.com\nmy.servers[1]=foo.bar.com\n\n\n.yml配置文件\n\n# YAML格式\nenvironments:\n\tdev:\n\t\turl: http://dev.bar.com\n\t\tname: Developer Setup\n\tprod:\n\t\turl: http://foo.bar.com\n\t\tname: My Cool App\nmy:\n\tservers:\n\t\t- dev.bar.com\n\t\t- foo.bar.com\n\n\n优先级\n\n目录的配置文件都会被加载，且顺序就是它们的优先级依次降低\n\n 1. file：./config/\n 2. file：./config/*/\n 3. file：./\n 4. classpath：/config/\n 5. classpath：/\n\n相同位置的 application.properties 和 application.yml ，而application.properties 更优先加载\n\n> file： 指当前项目根目录\n> \n> **classpath：**指当前项目的类路径，即 resources 目录\n\n多个配置文件存在的时候且它们有相同的配置内容情况下，SpringBoot会根据优先级进行覆盖低级的配置，形成互补配置：\n\n * 存在相同配置内容，高级覆盖低级的配置内容\n * 存在不同的配置内容，所有配置内容都读取\n\n示例：\n\n在以上的基础进行测试\n\n\n\napplication.yml文件\n\n# 类路径下的 config 目录下\n# 端口号为8090\n# 上下文路径为 /test2\nserver:\n    port: 8090\n    servlet:\n        context-path: /test2\n#...\n\n\napplication.properties文件\n\nserver.port=8080\nserver.servlet.path=/test1\n#...\n\n\n启动 SpringBoot，控制信息：\n\n\n\n通过浏览器访问测试\n\n\n\n> 出现以上字样，因本地 test1、test2没有对应的资源\n\n\n# Session集群共享\n\nSpringBoot默认情况下存Session到本机中 , 多台服务器不会共享Session\n\n**解决方案 : **\n\nSpring-Session 和 Redis 整合\n\n 1. 引入 redis 和 spring-session redis jar包\n 2. 配好 redis连接 和 Session存储方式\n\n# redis 配置\nspring:\n    redis:\n        port: 6379\n        host: localhost\n        database: 0\n    session:\n    \tstore-type: redis\n\n\n> Session的读取会通过Redis进行的\n\n\n# 计划任务\n\n@EnableScheduling 在配置类上使用，开启计划任务的支持\n\n 1. @EnableScheduling定义指定启动类 application上\n 2. @Scheduled定义指定方法 预定执行(运行频率/运行周期等配置...)\n 3. 运行即可\n\n\n# 热部署\n\n在实际开发中会频繁的修改后台类文件 , 而且每次修改都需要重新进行编译运行 , 因此非常的麻烦 .\n\nSpring Boot 提供了 devtools组件 , 热部署正是解决了该问题 , devtools会监听 , classpath下的文件变动 , 触发 Restart类加载器加载该类 , 实现文件和配置热部署功能\n\n热部署应用\n\n 1. pon.xml\n    \n    \x3c!-- 热部署 --\x3e\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-devtools</artifactId>\n        <optional>true</optional>\n    </dependency>\n    \n\n 2. application.properties\n    \n    # 热部署\n    # 启动 热部署\n    spring.devtools.restart.enabled=true\n    # 重启目录\n    spring.devtools.restart.additional-paths=src/main/java\n    # classpath目录 修改修改不重启\n    spring.devtools.restart.exclude=static/**\n    \n\n 3. 设置启动自动构建项目 设置 -> 搜索Conpile(编辑器) -> 勾选Build project automatically(启动自动构建项目)\n\n 4. 设置运行时执行刷新 ==Ctrl+Shift+Alt+/== -> 进入Registry(注册表) -> 启动compiler.automake.allow.when.app.running(运行时执行)\n    \n    PS : 如果 4步骤没有该选项 , 则操作一下步骤 : 设置 -> Advansed Settings(高级设置) -> 勾选Allow auto-make(运行时执行)\n\n> 做完以上配置 , 可以在类中边修改边测试代码啦\n\n\n# 日志\n\nSpringBoot 选用 SLF4j 和 logback (大厂建议: SLF4j)\n\nSLF4j官方文档 :\n\n * https://springdoc.cn/spring-boot/features#features.logging\n * https://www.slf4j.org/manual.html\n * https://www.slf4j.org/apidocs/index.html\n\n简单日志示例 :\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class HelloWorld {\n\n  public static void main(String[] args) {\n    Logger logger = LoggerFactory.getLogger(HelloWorld.class);\n    logger.info("Hello World");\n  }\n}\n\n\n# 日志级别\n\ntrace < debug < info < warn < error\n\ninfo后面的才可打印至控制台\n\n常用 trace/debug/info 三种日志输出\n\nimport org.junit.jupiter.api.Test;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.boot.test.context.SpringBootTest;\n\n@SpringBootTest\npublic class LogingApplicationTests {\n\n    // 记录器\n    Logger logger = LoggerFactory.getLogger(getClass());\n\n    @Test\n    public void contextLoads(){\n        // 日志级别\n        // trace < debug < info < warn < error\n        logger.trace("trace日志");\n        logger.debug("debug日志");\n        logger.info("info日志");\n        logger.warn("warn日志");\n        logger.error("error日志");\n    }\n\n}\n\n\n# 日志配置\n\n只需在 applicaton.properties文件 配置即可\n\n配置K                         值V                  说明\nlogging.level.com.atguigu   (Boolean) true      控制台打印级别限制解除\nlogging.file.name           (String) my.log     输出日志到 指定文件(my.log)\nlogging.file.path           (String) /var/log   输出日志到 指定目录的指定文件(my.log)\nlogging.pattern.console     (String)            在控制台输出日志格式\nlogging.pattern.file        (String)            指定文件中日志输出格式\n\n> 注意 :\n> \n>  * 如果定义 loggin.path路径没有指定文件 , 则会在默认系统根路生成日志文件\n>  * 默认格式 : 日期 - 时间 - 日志级别 - 线程id - 线程名称 - 全类名 - 消息\n\n配置日志格式 :\n\n日志格式          说明\n%d            日期时间\n%thread       线程名\n%-5level      级别显示字符宽度\n%logger{50}   日志名最长50 , 否则分割\n%msg          日志消息\n%n            换行\n\n全格式 : ==%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n==\n\n个人应用格式 : ==%d{MM-dd HH:mm} %-5level %msg%n==\n\n\n# 框架整合\n\nSpringBoot 抛弃了传统 xml 配置文件，以Java程序的形式进行配置。因此其他配置整合需要应用说明\n\n\n# SpringMVC 整合\n\nSpringBoot 对 SpringMVC 的一些自动配置可以满足大部分需求，但也可以自定义配置类 并实现org.springframework.web.servlet.config.annotation.WebMvcConfigurer接口 进行配置\n\n接口提供方法\n\n返回     方法                                                          说明\nvoid   ==addInterceptors(InterceptorRegistry registry)==           添加 拦截器，对请求进行拦截处理\nvoid   ==addResourceHandlers(ResourceHandlerRegistry registry)==   添加 或 修改静态资源\nvoid   ==addViewControllers(ViewControllerRegistry registry)==     无业务逻辑跳转（虚实映射重定向\nvoid   ==addCorsMappings(CorsRegistry registry)==                  解决跨域问题\n\n以下 SpringMVC配置问题 主要解决：\n\n * 修改端口\n * 静态资源加载\n * 拦截器配置\n * 虚实映射重定向\n * 跨域\n\n# 修改端口\n\n在SpringBoot的 全局属性(application.properties文件) 进行以下配置端口：\n\n# 映射端口\nserver.port=80 \n\n\n# 静态资源加载\n\nSpring Boot 中 org.springframework.boot.autoconfigure.web.ResourceProperties类 ，已经定义了静态资源的默认路径 ：（以下路径创建对应的目录即可直接访问\n\nprivate static final String[] CLASSPATH_RESOURCE_LOCATIONS = {\n\t\t\t"classpath:/META-INF/resources/", "classpath:/resources/",\n\t\t\t"classpath:/static/", "classpath:/public/" };\n\n\n * ==classpath:/META-INF/resources/==\n * ==classpath:/resources/==\n * ==classpath:/static/==\n * ==classpath:/public==\n\n> classpath:/ 指定的目录是指 缓存中加载的类路径classes\n\n> 以上目录可以在项目中直接访问到指定根目录。如果自定义的资源路径则需要指定确定路径，例如：\n> \n> 项目默认的路径 : 测试访问 static/1.jpg ==localhost:8080/1.jpg==\n\n自定义静态资源路径\n\n 1. 重写方法映射 在SpringMVC的配置类中 重写 addResourceHandlers()方法 以下代码：\n    \n    @Override\n    public void addResourceHandlers(ResourceHandlerRegistry registry) {\n        // 类似于 SpringMVC配置\n        // <mvc:resources mapping="/test/**" location="/test/"/>\n     \tregistry.addResourceHandler("/test/**").addResourceLocations("classpath:/test/");\n    }\n    \n    \n    > 如果指定实体本机文件则： ==registry.addResourceHandler("/pic/**").addResourceLocations("file:"+"D:/uploadFiles/");==\n\n 2. 修改配置文件 修改 application.properties更改规则\n    \n    # 过滤规则\n    spring.mvc.static-path-pattern=/static/**\n    # 静态资源位置\n    spring.web.resources.static-locations=classpath:/static/\n    \n    \n    > 以上是默认配置 , 可手写覆盖 , 覆盖后原有的会失效\n\n# 文件上传\n\n表单默认应用 enctype="application/x-www-form-urlencoded" , 需要改成 enctype="multipart/form-data" 进行上传文件\n\n修改默认大小限制\n\n默认每个1M , 配置修改\n\n# 单个文件最大\nspring.servlet.multipart.max-file-size=10MB\n# 单次请求最大\nspring.servlet.multipart.max-request-size=10M\n\n\n应用\n\n@RestController\npublic class FileUploadController {\n    @PostMapping("/upload")\n    public String up(String nickname, MultipartFile photo , HttpServletRequest request) throws IOException {\n        System.out.println("nickname = " + nickname);\n\n        // 图片信息\n        System.out.println("图片原始名称: "+photo.getOriginalFilename());\n        System.out.println("图片类型: "+photo.getContentType());\n\n        String path = request.getServletContext().getRealPath("/upload/");\n        System.out.println("path = " + path);\n\n        // 存储\n        saveFile(photo,path);\n        return "上传完毕";\n    }\n\n    // 存储\n    private void saveFile(MultipartFile photo, String path) throws IOException {\n\n        File dir = new File(path);\n        // 目录空则创建\n        if (!dir.exists()) {\n            dir.mkdir();\n        }\n        File file = new File(path + photo.getOriginalFilename());\n        photo.transferTo(file);\n    }\n}\n\n\n# 拦截器\n\n拦截器需要自行配置 。 SpringMVC拦截器类配置了解\n\nSpring Boot 定义了 HandlerInterceptor接口 , 该接口实现了自定义拦截器的功能 , 可以重写以下三个过程方法进行 :\n\n 1. 请求前 ==preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)==\n    \n    参数：handler 被拦截的控制器对象（MyController） 返回：是否允许放行，false拦截\n\n 2. 请求处理后 ==postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)==\n    \n    参数：handler 被拦截的控制器对象 ；modelAndView 控制器方法的返回值\n\n 3. 请求最后 ==afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)== 参数：handler 被拦截的控制器对象 ；ex 控制器方法异常\n\n\n\n应用\n\n 1. 创建 MyInterceptor自定义拦截器类 （模拟日志形式进行输出）\n    \n    public class MyInterceptor implements HandlerInterceptor {\n    \n        private Logger logger = LoggerFactory.getLogger(LoginInterceptor.class);\n        \n        @Override\n        public boolean preHandle(HttpServletRequest request , HttpServletResponse response , Object handler) {\n            logger.debug("处理器执行前执行!");\n            return true;\n        }\n        \n        @Override\n        public void postHandle(HttpServletRequest request , HttpServletResponse response , Object handler , ModelAndView modelAndView) throws Exception {\n            logger.debug("处理器执行后执行!");\n        }\n        \n        @Override\n        public void afterCompletion(HttpServletRequest request , HttpServletResponse response , Object handler , Exception ex) throws Exception {\n            logger.debug("跳转后执行！");\n        }\n        \n    }\n    \n\n 2. 在SpringMVC的配置类中 重写 addInterceptors方法 添加自定义拦截器 应用前提需要将 自定义拦截类 添加到Spring容器中进行指定注入\n    \n    @Configuration\n    public class SpringMVCConfig implements WebMvcConfigurer {\n    \t@Override\n    \tpublic void addInterceptors(InterceptorRegistry registry) {\n    \t\t// 通过registry来注册拦截器，通过addPathPatterns来添加拦截路径 (不加则拦截所有)\n    \t\tregistry.addInterceptor(new MyInterceptor()).addPathPatterns("/user/**");\n    \t}\n    }\n    \n\n 3. 在 全局属性(application.properties文件) 进行添加属性（此时在控制器是看不到日志的输出） 因 记录打印 级别 : debug ，日志打印 级别 ：info\n    \n    # 设置 com.*包 的日志级别为debug \n    logging.level.com.*=debug\n    \n\n 4. 启用Main方法调试测试，浏览器访问有效路径，看见控制台打印日志信息表示完成！！！\n\n# 虚实映射重定向\n\n主要意图是把 访问的URI 转换至 自定义URI ，达到重定向效果 实现需要在 SpringMVC的配置类中 重写 addViewControllers()方法 以下代码：\n\n@Override\npublic void addViewControllers(ViewControllerRegistry registry) {\n    registry.addViewController("/").setViewName("login.html");\n    registry.setOrder(Ordered.HIGHEST_PRECEDENCE);\n}\n\n\n> 首次访问重定向值登录页面，且设置最高优先级\n\n# 跨域\n\nCORS 是种 跨域资源共享的技术标准 , 为了更好的解决前端跨域请求 , CORS请求分为 简单请求 / 非简单请求 分别对跨域提供支持\n\n跨域 : 当一个请求 url 的 协议/域名/端口 三者任意一个 与 当前页面url不同 称为 跨域\n\n# 简单请求\n\n请求方法 : GET / POST / HEAD 未自定义的请求头 : Accept / Accept-Language / Content--Language / Last-Event--lD / Content-Type Content-Type 的值只有以下三种 : text/plain , multipart/form-data , application/x-www-form-urlencode\n\n前端发出请求时 : CORS的策略在请求头新增了个 Origin字段(url) , 用于告诉服务器来自哪里\n\n后端收到请求后 :\n\n可以根据 Origin字段 判断是否允许请求访问 , 如果允许 会在HTTP头信息添加 Access-Control-Allow-Origin字段(应用端口)\n\n# 非简单请求\n\n非简单请求时 浏览器会在真实请求发出前增加一次OPTION请求 称为预检请求\n\n预检请求将真实请求的信息 , 包括请求方法/自定义头字段/源信息 添加到HTTP头信息字段中 , 询问服务器是否允许这样的操作\n\n前端发出请求 :\n\nOPTIONS /test HTTP/1.1\nOrigin: http://www.test.com\nAccess-Control-Request-Method: GET\n# 请求的自定义头字段\nAccess-Control-Request-Headers: X-Custom-Header\nHost: www.test.com\n\n\n后端收到请求后 : 会对 Origin / Access-Control-Request-Method / Access-Control-Request-Headers 字段进行验证 , 后端请求允许通过后会返回\n\n# 真实请求 请求允许 来源url/方法/头信息\nAccess-Control-Allow-Origin: http://www.test.com\nAccess-Control-Allow-Methods: GET,POST,PUT,DELETE\nAccess-Control-Allow-Headers: X-Custom-Header\n# 允许 用户 发送/处理 cookie\nAccess-Control-Allow-Credentials: true\n# 允许 请求有效期 毫秒\nAccess-Control-Max-Age: 1728000\n\n\n# SpringBoot解决方案\n\n解决跨域问题需要在 SpringMVC的配置类中 重写 addCorsMappings()方法 以下代码：\n\nspringboot 2.4.0版本前 :\n\n@Override\npublic void addCorsMappings(CorsRegistry registry) {\n    // 允许访问的路径\n        registry.addMapping("/**")\n                // 是否发送 cookie\n                .allowCredentials(true)\n                // 允许 跨域访问的源\n                .allowedOrigins("*")\n                // 允许 接收的请求类型\n                .allowedMethods("POST","GET")\n                // 允许 头部设置\n                .allowedHeaders("*")\n                // 允许 有效期\n                .maxAge(1800);\n}\n\n\nspringboot 2.4.0版本后 :\n方法名更变为 : allowedOrigins => allowedOriginPatterns\n\n@Override\npublic void addCorsMappings(CorsRegistry registry) {\n    // 允许访问的路径\n    registry.addMapping("/**")\n            // 是否发送 cookie\n            .allowCredentials(true)\n            // 允许 跨域访问的源\n            .allowedOriginPatterns("*")\n            // 允许 接收的请求类型\n            .allowedMethods("POST","GET")\n            // 允许 头部设置\n            .allowedHeaders("*")\n            // 允许 有效期\n            .maxAge(1800);\n}\n\n\n方案2 : 在启动器类加上注解 @CrossOrigin . 也可实现跨域功能 (PS注意版本问题)\n\n# url图片\n\n@Controller\n@RequestMapping(value = "/image")\npublic class ImageController {\n    @RequestMapping(value = "/get",produces = MediaType.IMAGE_JPEG_VALUE)\n    @ResponseBody\n    public byte[] getImage() throws IOException {\n        File file = new File("D:/test.jpg");\n        FileInputStream inputStream = new FileInputStream(file);\n        byte[] bytes = new byte[inputStream.available()];\n        inputStream.read(bytes, 0, inputStream.available());\n        return bytes;\n    }\n}\n\n\n\n# JDBC 整合\n\nSpringBoot 中默认自动配置有 HikariCP连接池（HikariCP连接池是目前最快的连接池）\n\n 1. 引入依赖 pom.xml文件\n    \n    \x3c!--jdbc--\x3e\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-jdbc</artifactId>\n    </dependency>\n    \x3c!--测试--\x3e\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n    </dependency>\n    \x3c!--mysql--\x3e\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <version>5.1.46</version>\n    </dependency>\n    \n    \n    > 连接数据库 mysql的依赖 ，需要添加依赖 和 自行配置版本号。因 该依赖并非是 SpringBoot的相关组件\n\n 2. 在SpringBoot的 全局属性(application.properties文件) 添加参数\n    \n    # 连接四大参数\n    spring.datasource.url=jdbc:mysql://localhost:3306/库名\n    spring.datasource.username=root\n    spring.datasource.password=root\n    # 可省略，SpringBoot自动推断\n    #spring.datasource.driverClassName=com.mysql.jdbc.Driver\n    #spring.datasource.hikari.idle-timeout=60000\n    #spring.datasource.hikari.maximum-pool-size=30\n    #spring.datasource.hikari.minimum-idle=10\n    \n\n 3. 创建 User实体类 （指定库中的表列属性信息）\n    \n    public class User implements Serializable {\n        \n        private Long id;\n        // 用户名\n        private String userName;\n        // 密码\n        private String password;\n        // 姓名\n        private String name;\n        // 年龄\n        private Integer age;\n        // 性别，1男性，2女性\n        private Integer sex;\n        // 出生日期\n        private Date birthday;\n        \n        //省略 get 、 set 和 toString\n    }\n    \n    \n    > 表列名 和 类属性名 一致，在这一说法的前提它们支持 驼峰命名 和 下划线命名 如： (库列名) user_name -> (类属性名)userName\n\n 4. 创建 JdbcDao操作类\n    \n    @Repository\n    public class JdbcDao {\n        \n        @Autowired\n        private JdbcTemplate jdbcTemplate;\n        \n        public List<User> findAll() {\n            // BeanPropertyRowMapper : 可将同名的字段赋值给属性 （支持驼峰、下划线）\n            return jdbcTemplate.query("select * from tb_user" ,\n                    new BeanPropertyRowMapper<>(User.class));\n        }\n        \n    }\n    \n\n 5. 测试\n    \n    @RunWith(SpringRunner.class)\n    @SpringBootTest\n    public class JdbcDaoTest extends TestCase {\n        \n        @Autowired\n        private JdbcDao jdbcDao;\n        \n        @Test\n        public void testFindAll() {\n            System.out.println("jdbcDao : " + jdbcDao);\n            \n            for (User user : jdbcDao.findAll()) {\n                System.out.println(user);\n            }\n        }\n        \n    }\n    \n\n\n# MyBatis 整合\n\n 1. 引入依赖 pom.xml文件\n    \n    \x3c!--mybatis --\x3e\n    <dependency>\n        <groupId>org.mybatis.spring.boot</groupId>\n        <artifactId>mybatis-spring-boot-starter</artifactId>\n        <version>1.3.2</version>\n    </dependency>\n    \x3c!--测试--\x3e\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-test</artifactId>\n    </dependency>\n    \n\n 2. 在SpringBoot的 全局属性(application.properties文件) 添加参数\n    \n    # mybatis 别名扫描\n    mybatis.type-aliases-package=com.pojo\n    # mapper.xml文件位置 (使用在有映射的前提)\n    mybatis.mapper-locations=classpath:mappers/*.xml\n    \n\n 3. 创建 User实体类 （指定库中的表列属性信息）\n    \n    package com.pojo;\n    \n    import javax.persistence.*;\n    import java.io.Serializable;\n    import java.util.Date;\n    \n    public class User implements Serializable {\n        \n        private Long id;\n        // 用户名\n        private String userName;\n        // 密码\n        private String password;\n        // 姓名\n        private String name;\n        // 年龄\n        private Integer age;\n        // 性别，1男性，2女性\n        private Integer sex;\n        // 出生日期\n        private Date birthday;\n        \n        //省略 get 、 set 和 toString\n    }\n    \n    \n    > 表列名 和 类属性名 一致，MyBatis不支持 驼峰、下划线 命名方式\n\n 4. 创建 UserMapping接口 ，全限定名 com.mapping.UserMapping\n    \n    package com.dao;\n    \n    import com.pojo.User;\n    import java.util.List;\n    \n    public interface UserMapping {\n        List<User> findAll();\n    }\n    \n\n 5. 创建 UserMapping.xml映射文件\n    \n    <?xml version="1.0" encoding="UTF-8"?>\n    <!DOCTYPE mapper\n            PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n            "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n    <mapper namespace="com.mapping.UserMapping">\n    \n        <select id="findAll" resultType="user">\n            select * from tb_user\n        </select>\n    \n    </mapper>\n    \n\n 6. Mapper映射加载 。加载方式有两种\n    \n    1. 使用 @Mapping注解 在 UserMapping接口 添加 @Mapper注解 进行识别\n       \n       @Mapper\n       public interface UserMapper {\n           ....\n       }\n       \n    \n    2. 使用 @MapperScan注解 扫描的包 在 @SpringBootApplication注解下的启动类，添加@MapperScan注解 value参数为 扫描的包路径\n       \n       package com;\n       import org.mybatis.spring.annotation.MapperScan;\n       import org.springframework.boot.SpringApplication;\n       import org.springframework.boot.autoconfigure.SpringBootApplication;\n       \n       // 启动类\n       @SpringBootApplication\n       @MapperScan("com.mapping")\n       public class Application {\n           public static void main(String[] args) {\n               SpringApplication.run(Application.class , args);\n           }\n       }\n       \n\n 7. 测试\n    \n    package com.dao;\n    \n    import junit.framework.TestCase;\n    import org.junit.Test;\n    import org.junit.runner.RunWith;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.boot.test.context.SpringBootTest;\n    import org.springframework.test.context.junit4.SpringRunner;\n    \n    @RunWith(SpringRunner.class)\n    @SpringBootTest\n    public class UserDaoTest extends TestCase {\n        \n        @Autowired\n        private UserMapping userMapping;\n        \n        @Test\n        public void findAll() {\n             for (User user : userMapping.findAll()) {\n                System.out.println(user);\n            }\n        }\n    }\n    \n\n\n# tk-MyBatis 整合\n\n由于MyBatis的使用会出现一些功能上的问题，和大量的xml文件。当库表结构进行改动，则实体和xml文件都需要重新更改。因此为了避免以上情况 ，应用 tk-MyBatis框架\n\n使用前注意事项：\n\n * tk-MyBatis依赖引入 后就无需再引入MyBatis依赖\n * 支持 驼峰、下划线 命名方式，需要手动纠正\n * 实体类中 主键一定要映射 @GeneratedValue注解 映射主键策略（该字段自增、...等其他索引约束）\n * 类与表不匹配的情况，使用 jpa注解 纠正（名相同无需添加注解）\n   1. 类名 ≠ 表名 ，在类上添加 @Table注解 name参数为 纠正的表名\n   2. 属性名 ≠ 字段名，在属性上添加 @Column注解 name参数为 纠正的字段名\n * 如果 前面有导入 MyBatis构件的类 ，需要更改为 tk-mybatis构件的类\n * 接口一旦继承了 tk.mybatis.mapper.common.Mapper接口 就可实现以下Mapper通用方法\n\nMapper通用方法\n\n返回        方法                                                             说明\nList<T>   select(T record)                                               查询 根据实体类属性值进行查询\nT         selectByPrimaryKey(Object key)                                 查询 根据主键进行查询\nList<T>   selectAll()                                                    查询 所有结果\nT         selectOne(T record)                                            查询 根据实体类属性值进行查询，只能返回一个，多个则异常\nint       selectCount(T record)                                          查询 表中的总条数\nint       insert(T record)                                               插入 一个实体类 ，null属性值也会保存，而不是库中的默认值\nint       insertSelective(T record)                                      插入 一个实体类 ，null属性值不会保存，而应用库中的默认值\nint       updateByPrimaryKey(T record)                                   更新 根据主键更新所有字段，null属性值也会被更新\nint       updateByPrimaryKeySelective(T record)                          更新 根据主键更新字段，null属性值不会被更新\nint       delete(T record)                                               删除 根据实体类属性值进行条件删除\nint       deleteByPrimaryKey(Object key)                                 删除 根据主键进行删除\nList<T>   selectByExample(Object example)                                查询 根据Example条件进行查询\nint       selectByExample(Object example)                                查询 根据Example条件进行查询总条数\nint       updateByExample(@Param("record") T record, @Param("example")   更新 根据Example条件进行更新为 record实体类 全部属性，null属性值也会被更新\n          Object example)\nint       updateByExampleSelective(@Param("record") T record,            更新 根据Example条件进行更新为 record实体类 全部属性，null属性值不会被更新\n          @Param("example") Object example)\nint       deleteByExample(Object example)                                删除 根据Example条件进行删除\n\n# 应用实现\n\n以下应用实例：\n\n数据库展示\n\ntb_user表 （其他数据自行引入）\n\n字段名         类型        主键\nid          bigint    T\nuser_name   varchar   F\npassword    varchar   F\nname        varchar   F\nage         int       F\nsex         int       F\nbirthday    date      F\n\n 1. 引入依赖 pom.xml\n    \n    <dependency>\n        <groupId>tk.mybatis</groupId>\n        <artifactId>mapper-spring-boot-starter</artifactId>\n        <version>2.0.2</version>\n    </dependency>\n    \n\n 2. 创建 User实体类 （指定库中的表列属性信息）\n    \n    package com.pojo;\n    \n    import javax.persistence.*;\n    import java.io.Serializable;\n    import java.util.Date;\n    \n    @Table(name = "tb_user")\n    public class User implements Serializable {\n        \n        //主键 ，主键策略为 自增\n        @Id\n        @GeneratedValue(strategy = GenerationType.IDENTITY)\n        private Long id;\n        // 用户名\n        @Column(name = "user_name")\n        private String userName;\n        // 密码\n        private String password;\n        // 姓名\n        private String name;\n        // 年龄\n        private Integer age;\n        // 性别，1男性，2女性\n        private Integer sex;\n        // 出生日期\n        private Date birthday;\n        \n        //省略 get 、 set 和 toString\n    }\n    \n\n 3. 创建 UserMapping接口 ，全限定名 com.mapping.UserMapping （继承接口即可实现Mapper通用方法）\n    \n    package com.mapping;\n    \n    import com.domain.User;\n    import tk.mybatis.mapper.common.Mapper;\n    \n    public interface UserMapping extends Mapper<User> {\n    }\n    \n    \n    > 不要忘记应用的是 tk.mybatis.mapper.common.Mapper接口 构件\n\n 4. 使用 @MapperScan注解 扫描的包 在 @SpringBootApplication注解下的启动类，添加@MapperScan注解 value参数为 扫描的包路径\n    \n    package com;\n    // import org.mybatis.spring.annotation.MapperScan;\n    import tk.mybatis.spring.annotation.MapperScan;\n    import org.springframework.boot.SpringApplication;\n    import org.springframework.boot.autoconfigure.SpringBootApplication;\n    \n    // 启动类\n    @SpringBootApplication\n    @MapperScan("com.mapping")\n    public class Application {\n        public static void main(String[] args) {\n            SpringApplication.run(Application.class , args);\n        }\n    }\n    \n    \n    > 不要忘记应用的是 tk.mybatis.mapper.common.Mapper接口 构件\n\n 5. 测试\n    \n    package com.mapping;\n    \n    import com.domain.User;\n    import junit.framework.TestCase;\n    import org.junit.Test;\n    import org.junit.runner.RunWith;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.boot.test.context.SpringBootTest;\n    import org.springframework.test.context.junit4.SpringRunner;\n    import tk.mybatis.mapper.entity.Example;\n    import java.util.List;\n    \n    @RunWith(SpringRunner.class)\n    @SpringBootTest\n    public class UserMappingTest extends TestCase {\n        \n        @Autowired\n        private UserMapping userMapping;\n        \n        //查所有\n        @Test\n        public void testFindAll() {\n            userMapping.selectAll().forEach(user -> {\n                System.out.println(user);\n            });\n        }\n        \n        //查id\n        @Test\n        public void testFindById() {\n            User user = userMapping.selectByPrimaryKey(5);\n            System.out.println("user : " + user);\n        }\n        \n        //插入\n        @Test\n        public void testInsert(){\n            User user = new User();\n            user.setUserName("lishi");\n            user.setName("李四");\n            user.setPassword("1");\n            user.setAge(21);\n            user.setSex(1);\n            int i = userMapping.insertSelective(user);\n            System.out.println("插入结果 : " + i);\n        }\n        \n        // Example条件查询\n        @Test\n        public void testFindByExample() {\n            Example example = new Example(User.class);\n            \n            // 展示1\n            // SQL：SELECT * FROM tb_user WHERE ( name like \'%张%\' )\n            example.createCriteria().andLike("name","%张%");\n            \n            // 展示2\n            // SQL：SELECT * FROM tb_user WHERE ( name like \'%张%\' and password = \'1\' )\n            // example.createCriteria().andLike("name","%张%").andEqualTo("password","1");\n            userMapping.selectByExample(example).forEach(user -> {\n                System.out.println(user);\n            });\n        }\n    }\n    \n\n# 自定义映射文件查询\n\n自定义映射文件用于进行复杂的SQL语句进行对库编辑\n\n应用前说明：\n\n * 应用后 驼峰、下划线 命名失效\n\n应用实现 在以上代码原有的基础上进行编辑！\n\n 1. 在SpringBoot的 全局属性(application.properties文件) 添加参数\n    \n    # mybatis 别名扫描\n    mybatis.type-aliases-package=com.pojo\n    # mapper.xml文件位置 (使用在有映射的前提)\n    mybatis.mapper-locations=classpath:mappers/*.xml\n    \n\n 2. 创建 UserMapper.xml文件 资源路径 resources/mappers/UserMapper.xml\n    \n    <?xml version="1.0" encoding="UTF-8"?>\n    <!DOCTYPE mapper\n            PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n            "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n    <mapper namespace="com.mapping.UserMapping">\n    \n        <select id="findByUser" resultType="user">\n            SELECT * FROM\n            tb_user\n            <where>\n                <if test="name != null">\n                    name like \'%${name}%\'\n                </if>\n                <if test="password != null">\n                    and password like \'%${password}%\'\n                </if>\n            </where>\n        </select>\n    \n    </mapper>\n    \n    \n    > 注意 mapper节点 映射指定的接口路径\n\n 3. 编辑 UserMapping接口 ，全限定名 com.mapping.UserMapping\n    \n    package com.mapping;\n    \n    import com.domain.User;\n    import tk.mybatis.mapper.common.Mapper;\n    import java.util.List;\n    \n    public interface UserMapping extends Mapper<User> {\n        // 自定义复杂sql方法\n        public List<User> findByUser(User user);\n    }\n    \n\n 4. 测试， 在 UserMappingTest测试类 中\n    \n    // 自定义方法\n    @Test\n    public void testfindByUser() {\n        \n        User user = new User();\n        user.setName("张");\n        // user.setPassword("1");g\n        userMapping.findByUser(user).forEach(u -> {\n            System.out.println(u);\n        });\n        \n    }\n    \n\n\n# 视图框架整合\n\nThymeleaf是用于 Web 和 独立环境 的Java模板引擎（类似于JSP）\n\nSpringBoot 为 Thymeleaf 提供一系列的默认配置，Thymeleaf依赖 一旦导入，项目会自动配置\n\n优点：\n\n * Thymeleaf 在有网络和无网络的环境下皆可运行，通过美工实现页面数据的动静结合 有网络则覆盖静态显示的内容数据 无网络则显示默认静态的内容数据\n * SpringBoot完美整合，springboot默认整合thymeleaf\n\n# 表达式\n\nThymeleaf有3表达式\n\n * 变量表达式${...}\n * 选择表达式*{...}\n * URL表达式@{...}\n\n# 变量表达式\n\n==${...}== 变量表达式可以直接过去域中的数据。接收方式和JSP一样，但使用呈现方式不一样\n\n示例：（后端响应变量 "good" : "Thymeleaf very Good!"）\n\n\x3c!--响应的变量 good的值为 “Thymeleaf very Good!” --\x3e\n<h5>表达式</h5>\n<span>${good}</span><br>\n<span th:text="${good}">你好 thymleaf</span><br>\n<span>${good}</span><br>\n\n\x3c!-- 结果预览\n表达式\n${good}\nThymeleaf very Good!\n${good}\n--\x3e\n\n\n# 选择表达式\n\n==*{...}== 选择表达式 也称 星号表达式，不过这一操作需要预先通过选择一个对象进行充当上下文容器的变量执行\n\n示例：（后端响应变量 {"cat" : "猫","dog" : "狗"}）\n\n<div th:object="${pet}">\n    <span th:text="*{dog}"></span> <br>\n    <span th:text="*{cat}"></span> <br>\n</div>\n\n\x3c!-- 浏览器预览结果\n狗\n猫\n--\x3e\n\n\n# URL表达式\n\nURL表达式 是把一个有效的信息 添加到URL，也是URL重写\n\n重写形式有3种：\n\n * url表达式\n * 文本替换\n * 字符串拼接\n\n\x3c!-- url表达式 （无参\n\t结果：href="main.html" \n--\x3e\n<a th:href="@{/main}">\n\n\x3c!-- url表达式（有参\n\t后端响应：{user.id : 1,user.name : "张三"}\n\t结果：href="/del?id=1&name=张三" \n--\x3e\n<a th:href="@{/del(id=*{id},name=${user.name})}">删除</a>\n    \n\x3c!-- 文本替换\n\t结果：href="/update/1" \n--\x3e\n<a th:href="@{|/update/*{id}|}">修改</a>\n\n\x3c!-- 字符串拼接\n\t 结果：href="/approve/1" \n--\x3e\n<a th:href="\'/approve/\'+*{id}">审核</a>\n\n\n# th属性\n\n关键字           功能介绍                     案例\nth:id         替换id                     <input th:id="\'xxx\' + ${collect.id}"/>\nth:text       文本替换                     <p th:text="${user.name}">张三</p>\nth:utext      支持html的文本替换              <p th:utext="${htmlContent}">content</p>\nth:object     替换对象                     <div th:object="${user}">\nth:value      属性赋值                     <input th:value="${user.id}"/>\nth:with       变量赋值运算                   <div th:with="isEven=${prodStat.count}%2==0"></div>\nth:style      设置样式                     th:style="\'display:\' + @{(${sitrue} ? \'none\' :\n                                       \'inline-block\')} + \'\'"\nth:onclick    点击事件                     th:onclick="\'getCollect()\'"\nth:each       属性赋值                     <tr th:each="user,userStat:${users}"/>\nth:if         判断条件                     <a th:if="${userId == collect.userId}" >\nth:unless     和th:if判断相反               <a th:href="@{/login}" th:unless=${session.user !=\n                                       null}>Login</a>\nth:href       链接地址                     <a th:href="@{/login}" th:unless=${session.user !=\n                                       null}>Login</a> />\nth:switch     多选择 配合th:case 使用         <div th:switch="${user.role}">\nth:case       th:switch的一个分支           <p th:case="\'admin\'">User is an administrator</p>\nth:fragment   布局标签，定义一个代码片段，方便其它地方引用   <div th:fragment="alert">\nth:include    布局标签，替换内容到引入的文件          <head th:include="layout :: htmlhead"\n                                       th:with="title=\'xx\'"></head> />\nth:replace    布局标签，替换整个标签到引入的文件        <div th:replace="fragments/header :: title"></div>\nth:selected   selected选择框 选中           th:selected="(${xxx.id} == ${configObj.dd})"\nth:src        图片类地址引入                  <img class="img-responsive" alt="App Logo"\n                                       th:src="@{/img/logo.png}" />\nth:inline     定义js脚本可以使用变量             <script type="text/javascript" th:inline="javascript">\nth:action     表单提交的地址                  <form action="subscribe.html" th:action="@{/subscribe}">\nth:remove     删除某个属性                   <tr th:remove="all">\n                                       1. all: 删除所有\n                                       2. body: 不删本身, 删除其所有的子标签\n                                       3. tag: 删除本身，但不删除它的子标签\n                                       4. all-but-first: 仅保留第一个子标签，其他删除\n                                       5. none: 什么也不做\nth:attr       设置标签属性，多个属性可以用逗号分隔       <img th:attr="src=@{/image/aa.jpg},title=#{logo}"/>\n                                       一般比较少使用（难以阅读\n\n常用th属性 示例：\n\n条件判断 th:if/th:unless 判断属性是否成立，如果成立则显示\n\n\x3c!-- 响应：{"numbers":[1,2,3]} --\x3e\n<a th:if="${numbers.length > 0}">测试1</a><br>\n<a th:if="${numbers.length <= 0}">测试2</a><br>\n<a th:unless="${numbers.length <= 0}">测试3</a><br>\n\n\x3c!-- 预览结果\n测试1\n\n测试3\n--\x3e\n\n\nfor循环 th:each\n\n组成拆解：==...==\n\nstatus状态对象的属性：\n\n类型        STATUS属性   说明\nint       index      迭代当前对象（从0开始）\nint       count      迭代当前对象（从1开始）\nint       size       被迭代的对象大小\n-         current    当前迭代变量\nboolean   even       当前迭代值 是否为 偶数\nboolean   odd        当前迭代值 是否为 奇数\nboolean   first      当前迭代值 是否为 第一个\nboolean   last       当前迭代值 是否为 最后一个\n\n\x3c!-- \n\t响应："users":[{\n\t\t\t"id":"1",\n\t\t\t"name":"张三",\n\t\t\t"userName":"zhangsan",\n\t\t\t"age":"23",\n\t\t\t"sex":1,\n\t\t\t"birthday":"1980-02-30"\n\t\t},...]\n--\x3e\n<tr th:each="user ,status : ${users}" th:object="${user}">\n    <td th:text="${status.count}">1</td>\n    <td th:text="*{id}">233</td>\n    <td data-th-text="*{name}">张三</td>\n    <td th:text="${user.userName}">zhangsan</td>\n    <td th:text="${user.age}">20</td>\n    <td th:text="${user.sex} == 1 ? \'男\': \'女\'">男</td>\n    <td th:text="${user.birthday}">1980-02-30</td>\n    <td>\n        \x3c!--不同参数 形式--\x3e\n        <a th:href="@{/del(id=*{id},name=${user.name})}">删除</a>\n        \x3c!--文本替换 形式--\x3e\n        <a th:href="@{|/update/*{id}|}">修改</a>\n        \x3c!--字符串拼接 形式--\x3e\n        <a th:href="\'/approve/\'+*{id}">审核</a>\n    </td>\n</tr>\n\n\n# 内置对象\n\nThymeleaf提供了一系列Utiliy对象，可直接通过#进行访问：\n\n * strings： 字符串工具对象，常用方法有：equals、equalsIgnoreCase、length、trim、toUpperCase、toLowerCase、indexOf、substring、replace、startsWith、endsWith，contains 和 containsIgnoreCase 等\n * numbers： 数字工具对象，常用的方法有：formatDecimal 等\n * bools： 布尔工具对象，常用的方法有：isTrue 和 isFalse 等\n * arrays： 数组工具对象，常用的方法有：toArray、length、isEmpty、contains 和 containsAll 等；\n * lists/sets： List/Set 集合工具对象，常用的方法有：toList、size、isEmpty、contains、containsAll 和 sort 等\n * maps： Map 集合工具对象，常用的方法有：size、isEmpty、containsKey 和 containsValue 等\n * dates： 日期工具对象，常用的方法有：format、year、month、hour 和 createNow 等\n\n<h4>dates</h4>\n<p th:text="${#dates.createNow()}">获取当前日期</p>\n<p th:text="${#dates.format(#dates.createNow())}">日期格式化</p>\n<p th:text="${#dates.format(#dates.createNow(),\'yyyy-MM-dd HH:mm:ss\')}">日期自定义格式化</p>\n\x3c!-- 预览结果\ndates\nMon Sep 20 14:57:12 CST 2021\n2021年9月20日 下午02时57分12秒\n2021-09-20 14:57:12\n--\x3e\n\n\x3c!-- 响应："good":"Thymeleaf very Good!"--\x3e\n<h4>strings</h4>\n<p th:text="${#strings.substring(good, 6, 9)}">截取字符串</p>\n<p th:text="${#strings.length(good)}">获得长度</p>\n<p th:text="${#strings.randomAlphanumeric(6)}">随机字符串</p>\n<p th:text="${#strings.equals(good, \'hello\')}">比较</p>\n\x3c!--  预览结果\neaf\n20\nNI5QPI\nfalse\n--\x3e\n\n\n更多了解：Thymeleaf （19 Appendix B: Expression Utility Objects）\n\n# 首次应用\n\n前提说明：\n\n * 在 .html文件 需要添加以下的命名空间（否则无法识别 th属性标签 == .... ==\n\n * 后端的 资源文件 需要存放指定目录 classpath:/templates/*\n   \n   默认前缀： templates/ 默认后缀： .html\n   \n   \n\n * 测试优化。在修改页面的时，由于缓存并非立即呈现效果，因此可通过添加以下全参关闭缓存\n   \n   # 开发阶段关闭 thymeleaf的模板缓存\n   spring.thymeleaf.cache=false\n   \n\n应用步骤：\n\n 1. 引入依赖\n    \n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-thymeleaf</artifactId>\n    </dependency>\n    \n\n 2. 创建前端文件。路径：==templates/ThymeleafView.html==\n    \n    <!DOCTYPE html>\n    <html lang="en" xmlns:th="http://www.w3.org/1999/xhtml">\n    <head>\n        <meta charset="UTF-8">\n        <title>Title</title>\n    </head>\n    <body>\n        <ul>\n            <li th:each="user,userStat : ${userList}" th:object="${user}">\n                <span th:text="*{id}"></span> ==\n                <span th:text="*{name}"></span> ==\n                <span th:text="${user.age}"></span>\n            </li>\n        </ul>\n    </body>\n    </html>\n    \n\n 3. 封装 User实体类\n    \n    public class User {\n        String id;\n        String name;\n        int age;\n        \n        // 构造全参/无参 、set 、get方法省略。。。\n    }\n    \n\n 4. 编辑 Controller控制器\n    \n    @Controller\n    public class HelloController {\n    \n        @GetMapping("/findAll")\n        public ModelAndView findAll() {\n            ModelAndView view = new ModelAndView();\n    \n            List<User> list = new ArrayList<User>(){{\n                add(new User("2","张三",33));\n                add(new User("3","李四",34));\n                add(new User("4","王五",35));\n                add(new User("5","赵六",36));\n            }};\n    \n            view.addObject("userList",list);\n            view.setViewName("ThymeleafView");\n            return view;\n        }\n    }\n    \n\n 5. 启动直接访问即可，结果示例\n    \n    <body>\n        <ul>\n            <li>\n                <span>2</span> ==\n                <span>张三</span> ==\n                <span>33</span>\n            </li>\n            <li>\n                <span>3</span> ==\n                <span>李四</span> ==\n                <span>34</span>\n            </li>\n            <li>\n                <span>4</span> ==\n                <span>王五</span> ==\n                <span>35</span>\n            </li>\n            <li>\n                <span>5</span> ==\n                <span>赵六</span> ==\n                <span>36</span>\n            </li>\n        </ul>\n    </body>\n    \n\n\n# Shiro整合\n\nShiro是开源的安全框架，可以完全处理身份验证，授权，会话加密等\n\n这里只讲解 SpringBoot 整合 Shrio，进一步了解，进入Shiro文章进行深入学习\n\n应用步骤：\n\n 1. 引入依赖\n    \n    \x3c!-- Shiro --\x3e\n    <dependency>\n        <groupId>org.apache.shiro</groupId>\n        <artifactId>shiro-spring-boot-web-starter</artifactId>\n        <version>1.4.0-RC2</version>\n    </dependency>\n    \n\n 2. 创建配置类 ShiroConfig\n    \n    @Configuration\n    @Component\n    public class ShiroConfig {\n    \n        @Bean\n        public ShiroFilterFactoryBean shiroFilterFactoryBean(org.apache.shiro.mgt.SecurityManager securityManager) {\n    \n            ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean();\n            shiroFilterFactoryBean.setSecurityManager(securityManager);\n    \n            // 定义默认路径\n            shiroFilterFactoryBean.setLoginUrl("/dologin");\n            shiroFilterFactoryBean.setSuccessUrl("/index");\n            shiroFilterFactoryBean.setUnauthorizedUrl("/refuse.html");\n    \n            // 过滤器链\n            LinkedHashMap<String, String> filterChainDefinitionMap = new LinkedHashMap<>();\n            filterChainDefinitionMap.put("/", "anon");\n            filterChainDefinitionMap.put("/static/css/**", "anon");\n            filterChainDefinitionMap.put("/static/js/**", "anon");\n            filterChainDefinitionMap.put("/static/images/**", "anon");\n            filterChainDefinitionMap.put("/static/register", "anon");\n            filterChainDefinitionMap.put("/toRegister", "anon");\n            filterChainDefinitionMap.put("/login.html", "anon");\n            filterChainDefinitionMap.put("/logout", "logout");\n            filterChainDefinitionMap.put("/**", "authc");\n    \n            // 配置过滤器\n            shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap);\n    \n            // 自定义过滤器\n            // Map<String, Filter> filters = new HashMap<>();\n            // filters.put("authc", new CustomFormAuthenticationFilter());\n            // shiroFilterFactoryBean.setFilters(filters);\n    \n            return shiroFilterFactoryBean;\n        }\n    \n        @Bean\n        public ShiroFilterChainDefinition shiroFilterChainDefinition() {\n            DefaultShiroFilterChainDefinition chainDefinition = new DefaultShiroFilterChainDefinition();\n    \n            // logged in users with the \'admin\' role\n            //chainDefinition.addPathDefinition("/admin/**", "authc, roles[admin]");\n    \n            // logged in users with the \'document:read\' permission\n            //chainDefinition.addPathDefinition("/docs/**", "authc, perms[document:read]");\n    \n            // all other paths require a logged in user\n            //chainDefinition.addPathDefinition("/logout", "logout");\n            //chainDefinition.addPathDefinition("/**", "authc");\n            return chainDefinition;\n        }\n    \n        @Bean\n        public DefaultWebSecurityManager securityManager(Realm realm) {\n            DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager();\n            securityManager.setRealm(realm);\n    //       securityManager.setRememberMeManager(rememberMeManager());\n    //       securityManager.setCacheManager(getEhCacheManager());\n    //       securityManager.setSessionManager(sessionManager());\n            return securityManager;\n        }\n    \n        @Bean\n        public Realm shiroRealm() {\n            return new ShiroRealm();\n        }\n    \n    //    /**\n    //     * 密码校验规则HashedCredentialsMatcher\n    //     * 这个类是为了对密码进行编码的 ,\n    //     * 防止密码在数据库里明码保存 , 当然在登陆认证的时候 ,\n    //     * 这个类也负责对form里输入的密码进行编码\n    //     * 处理认证匹配处理器：如果自定义需要实现继承HashedCredentialsMatcher\n    //     */\n    //    @Bean("hashedCredentialsMatcher")\n    //    public HashedCredentialsMatcher hashedCredentialsMatcher() {\n    //        HashedCredentialsMatcher credentialsMatcher = new HashedCredentialsMatcher();\n    //        //指定加密方式为MD5\n    //        credentialsMatcher.setHashAlgorithmName("MD5");\n    //        //加密次数\n    //        credentialsMatcher.setHashIterations(1024);\n    //        credentialsMatcher.setStoredCredentialsHexEncoded(true);\n    //        return credentialsMatcher;\n    //    }\n    \n    \n    //    @Bean("authRealm")\n    //    @DependsOn("lifecycleBeanPostProcessor")//可选\n    //    public AuthRealm authRealm(@Qualifier("hashedCredentialsMatcher") HashedCredentialsMatcher matcher) {\n    //        AuthRealm authRealm = new AuthRealm();\n    //        authRealm.setAuthorizationCachingEnabled(false);\n    //        authRealm.setCredentialsMatcher(matcher);\n    //        return authRealm;\n    //    }\n    }\n    \n\n 3. 创建领域\n    \n    public class ShiroRealm extends AuthorizingRealm {\n    \n        @Autowired\n        private AuctionuserService auctionuserService;\n    \n        @Override\n        protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n            return null;\n        }\n    \n        /**\n         * 身份验证\n         * @param token 包含用户主体和凭据的身份验证令牌。\n         * @return\n         * @throws AuthenticationException\n         */\n        @Override\n        protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n            String username = (String) token.getPrincipal();\n            Auctionuser user = auctionuserService.findUserByName(username);\n            if (user == null) return null;\n            return new SimpleAuthenticationInfo(user, user.getUserPassword(),"ShiroRealm");\n        }\n    }\n    \n\n 4. 三个步骤即可实现引入Shiro（如果需要其他功能可以在配置类中进行添加！）\n\n\n# MyBatis Plus整合\n\nMyBatis Plus是MyBatis的增强工具，在MyBatis的基础上做了增强不改变的开发实现，从而提高效率。\n\n官方文档：https://baomidou.com/pages/24112f/\n\n特点：\n\n * 无侵入。只做增强不做改变\n * 消耗小。启动只注入CURD\n * 增强CRUD操作。内置通用Mapper\n * 内置代码生成器。采用Maven插件生成映射\n * 分页插件多功能。支持多种数据库\n * 内置全局拦截器。可分析增删改过程进行阻断\n\n# 首次应用\n\n应用大致流程 :\n\n 1. 引入pon.xml依赖\n 2. 更改库数据相关配置\n 3. 启动器类 添加@MapperScan注解\n\n应用\n\n 1. 引入依赖 pom.xml\n    \n    \x3c!-- MyBatisPlus --\x3e\n    <dependency>\n        <groupId>com.baomidou</groupId>\n        <artifactId>mybatis-plus-boot-starter</artifactId>\n        <version>3.4.2</version>\n    </dependency>\n    \x3c!-- mysql驱动 --\x3e\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <version>5.1.48</version>\n    </dependency>\n    \x3c!-- 连接池 --\x3e\n    <dependency>\n        <groupId>com.alibaba</groupId>\n        <artifactId>druid-spring-boot-starter</artifactId>\n        <version>1.1.20</version>\n    </dependency>\n    \n\n 2. 配置文件 application\n    \n    # MyBatis\n    # 连接池\n    spring.datasource.type=com.alibaba.druid.pool.DruidDataSource\n    # 驱动\n    spring.datasource.driver-class-name=com.mysql.jdbc.Driver\n    # url/账号/密码\n    spring.datasource.url=jdbc:mysql://localhost:3306/test?useSSL=false\n    spring.datasource.username=root\n    spring.datasource.password=root\n    mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl\n    \n    \n    > 这里连接库的用户名和密码可以省略不写，或者随意设定\n\n 3. 创建 库数据 和 创建实体类 (省略\n\n 4. 创建 UserMapper接口\n    \n    @Mapper\n    public interface UserMapper extends BaseMapper<User> {}\n    \n    \n    > 继承实现Mapper通用方法\n\n 5. SpringBoot 启动类 添加注解 @MapperScan\n    \n    @SpringBootApplication\n    @MapperScan("com.mapper")\n    public class Application {\n        public static void main(String[] args) {\n            SpringApplication.run(Application.class , args);\n        }\n    }\n    \n    \n    > @MapperScan注解 扫描 Mapper文件夹 的包路径\n\n 6. 测试\n    \n    // 启动器Spring测试启动环境\n    @RunWith(SpringRunner.class)\n    // 启动类\n    @SpringBootTest(classes = Application.class)\n    public class UserMapperTest {\n        \n        @Autowired\n        private UserMapper userMapper;\n        \n        @Test\n        public void testFindByAll() {\n            \n            List<User> users = userMapper.selectList(null);\n            users.forEach(System.out::println);\n            // Assert.assertEquals(26 , users.size());\n        }\n    }\n    \n\n# 注解配置\n\n常用注解说明：\n\n注解            值               说明\n@TableName    value：纠正表名      表名注解\n@TableId      value：纠正主键字段名   主键注解\n              type：主键策略类型\n@TableField   value：纠正字段名     字段注解(非主键)\n              exist：是否为库字段\n              fill：默认值填充\n\n更多注解：https://baomidou.com/pages/223848/\n\n> PS : @TableId/@TableField 纠正后 set方法也需要修改 , 因 使用set注入 , 否则失效\n\n# 内置 CRUD\n\n官网说明 : 更多详细\n\n# 新增\n\n@Test\n    public void testInsert() {\n        Assert.assertTrue(userMapper.insert(new User().setName("张三").setAge(3)) > 0);\n        userMapper.selectList(null).forEach(System.out::println);\n    }\n    /*\n        User(id=1, name=Jone, age=18, email=test1@baomidou.com, phone=null)\n        User(id=2, name=Jack, age=20, email=test2@baomidou.com, phone=null)\n        User(id=3, name=Tom, age=28, email=test3@baomidou.com, phone=null)\n        User(id=4, name=Sandy, age=21, email=test4@baomidou.com, phone=null)\n        User(id=5, name=kaikeba, age=331, email=test4@baomidou.com, phone=null)\n        User(id=6, name=Billie, age=24, email=test5@baomidou.com, phone=null)\n        User(id=7, name=张三, age=3, email=null, phone=null)\n     */\n\n\n# 删除\n\n@Test\n    public void testDelById() {\n        Assert.assertTrue(userMapper.deleteById(3) > 0);\n        userMapper.selectList(null).forEach(System.out::println);\n    }\n    /*\n        User(id=1, name=Jone, age=18, email=test1@baomidou.com, phone=null)\n        User(id=2, name=Jack, age=20, email=test2@baomidou.com, phone=null)\n        User(id=4, name=Sandy, age=21, email=test4@baomidou.com, phone=null)\n        User(id=5, name=kaikeba, age=331, email=test4@baomidou.com, phone=null)\n        User(id=6, name=Billie, age=24, email=test5@baomidou.com, phone=null)\n     */\n    \n    @Test\n    public void testDeletes1() {\n        Assert.assertTrue(userMapper.delete(new QueryWrapper<User>().like("name","J")) > 0);\n        userMapper.selectList(null).forEach(System.out::println);\n    }\n    /*\n        User(id=3, name=Tom, age=28, email=test3@baomidou.com, phone=null)\n        User(id=4, name=Sandy, age=21, email=test4@baomidou.com, phone=null)\n        User(id=5, name=kaikeba, age=331, email=test4@baomidou.com, phone=null)\n        User(id=6, name=Billie, age=24, email=test5@baomidou.com, phone=null)\n     */\n    \n    @Test\n    public void testDeletes2() {\n        Assert.assertTrue(userMapper.delete(Wrappers.<User>query().like("name","J")) > 0);\n        userMapper.selectList(null).forEach(System.out::println);\n    }\n    /*\n        User(id=3, name=Tom, age=28, email=test3@baomidou.com, phone=null)\n        User(id=4, name=Sandy, age=21, email=test4@baomidou.com, phone=null)\n        User(id=5, name=kaikeba, age=331, email=test4@baomidou.com, phone=null)\n        User(id=6, name=Billie, age=24, email=test5@baomidou.com, phone=null)\n     */\n    \n    @Test\n    public void testDeletes3() {\n        Assert.assertTrue(userMapper.delete(Wrappers.<User>query().lambda().like(User::getName,"J")) > 0);\n        userMapper.selectList(null).forEach(System.out::println);\n    }\n    /*\n        User(id=3, name=Tom, age=28, email=test3@baomidou.com, phone=null)\n        User(id=4, name=Sandy, age=21, email=test4@baomidou.com, phone=null)\n        User(id=5, name=kaikeba, age=331, email=test4@baomidou.com, phone=null)\n        User(id=6, name=Billie, age=24, email=test5@baomidou.com, phone=null)\n    */\n    \n    @Test\n    public void testDeletes4() {\n        Assert.assertTrue(userMapper.delete(new QueryWrapper<User>().lambda().like(User::getName,"J")) > 0);\n        userMapper.selectList(null).forEach(System.out::println);\n    }\n    /*\n        User(id=3, name=Tom, age=28, email=test3@baomidou.com, phone=null)\n        User(id=4, name=Sandy, age=21, email=test4@baomidou.com, phone=null)\n        User(id=5, name=kaikeba, age=331, email=test4@baomidou.com, phone=null)\n        User(id=6, name=Billie, age=24, email=test5@baomidou.com, phone=null)\n    */\n\n\n# 更改\n\n@Test\n    public void testUpdateById() {\n        userMapper.updateById(new User().setId(3L).setName("先科"));\n        userMapper.selectList(null).forEach(System.out::println);\n    }\n    /*\n        User(id=1, name=Jone, age=18, email=test1@baomidou.com, phone=null)\n        User(id=2, name=Jack, age=20, email=test2@baomidou.com, phone=null)\n        User(id=3, name=先科, age=28, email=test3@baomidou.com, phone=null)\n        User(id=4, name=Sandy, age=21, email=test4@baomidou.com, phone=null)\n        User(id=5, name=kaikeba, age=331, email=test4@baomidou.com, phone=null)\n        User(id=6, name=Billie, age=24, email=test5@baomidou.com, phone=null)\n     */\n    \n    @Test\n    public void testUpdate1() {\n        userMapper.update(null, Wrappers.<User>update().set("name","kkkBbb").like("name","Tom"));\n        userMapper.selectList(null).forEach(System.out::println);\n    }\n    /*\n        User(id=1, name=Jone, age=18, email=test1@baomidou.com, phone=null)\n        User(id=2, name=Jack, age=20, email=test2@baomidou.com, phone=null)\n        User(id=3, name=先科, age=28, email=test3@baomidou.com, phone=null)\n        User(id=4, name=Sandy, age=21, email=test4@baomidou.com, phone=null)\n        User(id=5, name=kaikeba, age=331, email=test4@baomidou.com, phone=null)\n        User(id=6, name=Billie, age=24, email=test5@baomidou.com, phone=null)\n     */\n    \n    @Test\n    public void testUpdate2() {\n        userMapper.update(new User().setName("kkkBbb"), Wrappers.<User>update().like("name","Tom"));\n        userMapper.selectList(null).forEach(System.out::println);\n    }\n    /*\n        User(id=1, name=Jone, age=18, email=test1@baomidou.com, phone=null)\n        User(id=2, name=Jack, age=20, email=test2@baomidou.com, phone=null)\n        User(id=3, name=kkkBbb, age=28, email=test3@baomidou.com, phone=null)\n        User(id=4, name=Sandy, age=21, email=test4@baomidou.com, phone=null)\n        User(id=5, name=kaikeba, age=331, email=test4@baomidou.com, phone=null)\n        User(id=6, name=Billie, age=24, email=test5@baomidou.com, phone=null)\n     */\n\n\n# 查询\n\n@Test\n    public void testFindByBasic() {\n        System.out.println(userMapper.selectList(Wrappers.<User>query().eq("name","Jone")));\n    }\n    /*\n        [User(id=1, name=Jone, age=18, email=test1@baomidou.com, phone=null)]\n     */\n    \n    @Test\n    public void testFindProjection1() {\n        userMapper.selectList(new QueryWrapper<User>().select("id","name")).forEach(System.out::println);\n    }\n    /*\n        User(id=1, name=Jone, age=null, email=null, phone=null)\n        User(id=2, name=Jack, age=null, email=null, phone=null)\n        User(id=3, name=Tom, age=null, email=null, phone=null)\n        User(id=4, name=Sandy, age=null, email=null, phone=null)\n        User(id=5, name=kaikeba, age=null, email=null, phone=null)\n        User(id=6, name=Billie, age=null, email=null, phone=null)\n     */\n    \n    @Test\n    public void testFindProjection2() {\n        userMapper.selectList(new QueryWrapper<User>().select("id","name").like("name","J")).forEach(System.out::println);\n    }\n    /*\n        User(id=1, name=Jone, age=null, email=null, phone=null)\n        User(id=2, name=Jack, age=null, email=null, phone=null)\n     */\n    \n    @Test\n    public void testFindProjection3() {\n        userMapper.selectList(new QueryWrapper<User>().select("id","name").lambda().like(User::getName,"J")).forEach(System.out::println);\n    }\n    /*\n        User(id=1, name=Jone, age=null, email=null, phone=null)\n        User(id=2, name=Jack, age=null, email=null, phone=null)\n     */\n\n\n# 自定义 SQL\n\n自定义SQL是写在 Mapper接口的方法上 , 值直接写SQL语句\n\n注解        说明\n@Insert   插入\n@Update   更新\n@Delete   删除\n@Select   查询\n\nCRUD按照指定的规则编写SQL即可 , 如果需要传递参数 点击跳转\n\n@Mapper\npublic interface UserMapper extends BaseMapper<User> {\n    @Select("select * from users")\n    List<User> findAll();\n}\n\n\n# 条件构造器\n\n条件构造器主要作用在 SQL语句中添加Where条件 , 从而自动生成约束的SQL . 主要比较贴合 Hibernate 的使用方式\n\n条件构造器两大分类 : (它们的父类 AbstractWrapper抽象类)\n\n * **QueryWrapper **\n * UpdateWrapper\n\n> 以上有各自独有的属性详细自行官网查询 条件构造器更多详细\n\n应用 :\n\n// 最终Where约束语句 (默认全参存在)\n// select xxx from xxx where\n// \t\t(ex.del_flag=0 AND ex.examine_user_id=su.id AND su.office_id=so.id) and\n// \t\t(ex.type=?) and (su.name like \'%?%\') and (so.id=?);\n@Override\npublic List<ExamineDo> selectByCondition(Map<String, Object> map) {\n\n    QueryWrapper<ExamineDo> query = new QueryWrapper<>();\n\n    // 三表连接的 关键字段的 SQL约束代码\n    query.apply("ex.del_flag=0 AND ex.examine_user_id=su.id AND su.office_id=so.id");\n\n    /**\n     * SQL约束拼接参数说明：\n     *   参数1.判断该对象是否可行（指该属性数据是有效且不为空\n     *   参数2.指定比较的字段 字符串（一般指定的字符串\n     *   参数3.指定比较的数据 外面获取到的\n     */\n    query.eq(map.containsKey("type") && !ObjectUtils.isEmpty(map.get("type")),"ex.type",map.get("type"))\n            .like(map.containsKey("name") && !ObjectUtils.isEmpty(map.get("name")),"su.name",map.get("name"))\n            .eq(map.containsKey("officeId") && !ObjectUtils.isEmpty(map.get("officeId")),"so.id",map.get("officeId"));\n\t// Mapper传递对象即可\n    return baseMapper.selectByCondition(query);\n}\n\n\n# 传参操作\n\n手写SQL多多少少都会需要参数的传递 , 因此有以下三种方式进行传递参数 :\n\n 1. 实体类 根据实体的 属性 进行匹配信息\n 2. Map 根据Map哈希中的 K键 匹配 V值\n 3. @Param 根据 参数值 映射匹配\n 4. 条件构造器 只需添加一个对象即可自动生成 约束SQL 官方说明 : 条件构造器使用方式\n\n示例：\n\n// 实体类\n// 实体类包含的属性JSON展示 Users{id,name}\n@Select("SELECT su.*  " +\n        "FROM  " +\n        "sys_user su " +\n        "WHERE " +\n        "su.id= #{id} " +\n        "AND su.name= #{name} " )\nList<SysUser> findByid(Users user);\n\n// Map\n// map = {id:23,name:"张三"}\n@Select("SELECT su.*  " +\n        "FROM  " +\n        "sys_user su " +\n        "WHERE " +\n        "su.id= #{id} " +\n        "AND su.name= #{name} " )\nList<SysUser> findByid(Map<String,Object> map);\n\n// @Param\n@Select("SELECT su.*  " +\n        "FROM  " +\n        "sys_user su " +\n        "WHERE " +\n        "su.id= #{id} " )\nList<SysUser> findByid(@Param("id")Integer id);\n\n// 条件构造器\n@Select("select * from mysql_data ${ew.customSqlSegment}")\nList<MysqlData> getAll(@Param(Constants.WRAPPER) Wrapper wrapper);\n\n\n# 多表查询\n\n多个表查询难免会有些稍微复杂的SQL . 多表查询分为 一对多/一对一/多对多 三种类型\n\n注解         以往标签            说明\n@Result    <id>/<Result>   结果集封装 . 包含有以下属性 :\n                           - column : 数据表字段名称\n                           - property : 类中对应的属性名\n                           - one : 与@One搭配 , 进行一对一的映射\n                           - many : 与@Many搭配 , 进行一对多的映射\n@Results   <resultMap>     和@Result 使用 , 封装 一个/多个 结果集\n@One       <assocation>    一对一结果集封装 , 使用格式如下 :\n                           @Result(column="xx",property="xx",one=@One(select="xx",...))\n@Many      <collection>    一对多结果集封装 , 使用格式如下 :\n                           @Result(column="xx",property="xx",many=@Many(select="xx",...))\n\n> 注意 :\n> \n>  * 一旦使用了 @Results注解 封装的当前对象全部属性都要重新手写\n>  * 使用 @One/@Many 注解 , 一般情况使用 select属性值 指定全限定名类的方法(如: ById/...)\n\n应用\n\n主要编写核心部分 , 其他代码简单表示即可\n\nUser 用户实体\n\n类型       名称          表对应的字段      注解规则\nint      id          id          \nString   username    username    \nString   password    password    \nList     orderList   oid(提取二查)   @TableField(exist = false)\n\nOrder 订单实体\n\n类型       名称          表对应的字段      注解规则\nString   id          id          \nDate     ordertime   ordertime   \ndouble   total       total       \nUser     user        uid(提取二查)   @TableField(exist = false)\n\n一对多 一人有多个订单 UserMapper接口\n\n@Mapper\npublic interface UserMapper extends BaseMapper<User> {\n    // 查所用用户并且包含订单\n    @Select("select * from user")\n    @Results({\n            @Result(column = "id", property = "id"),\n            @Result(column = "username", property = "username"),\n            @Result(column = "password", property = "password"),\n            @Result(column = "id", property = "orderList",javaType = List.class,\n                    many = @Many(select = "com.sans.demoapplication.mapper.OrderMapper.findByUId"))\n    })\n    List<User> findAll();\n}\n\n\n> @Many注解中属性seelct的值 : 是指定路径类的方法\n\n多对多 每个订单必须有一个用户 OrderMapper接口\n\n@Mapper\npublic interface OrderMapper extends BaseMapper<Order> {\n\n    // 查所有\n    @Select("SELECT  id,ordertime,total,uid  FROM `order`")\n    @Results({\n            @Result(column = "id",property = "id"),\n            @Result(column = "ordertime",property = "ordertime"),\n            @Result(column = "total",property = "total"),\n            @Result(column = "uid", property = "user" ,javaType = User.class ,\n                    one = @One(select = "com.sans.demoapplication.mapper.UserMapper.selectById"))\n    })\n    List<Order> findAllOrder();\n\n    // 按uid 查订单\n    @Select("select id,ordertime,total from `order` where uid=#{uid}")\n    List<Order> findByUId(int uid);\n\n}\n\n\n> @One注解中属性seelct的值 : 是指定路径类的方法 (该类继承有 BaseMapper接口 里面有内置的CRUD)\n\n# 分页插件\n\n以下分页功能的实现 , 基于以上的基础进行实现\n\n分页应用方式有3种形式：\n\n * 内置分页\n * XML分页\n * PageHelper分页\n\n三种分页区别\n\n         内置分页    XML分页          PAGEHELPER分页\njar包引入   无       无              有\n配置       拦截器配置   全局配置 + 手写SQL   引入Bean\n分页信息     简略      自定义            详细\n复杂度      低       高              一般\n\n# 内置分页\n\n 1. 创建 mp配置类 MybatisPlusConfig.java ，全限定名类 : com.config.MybatisPlusConfig\n    \n    package com.config;\n    \n    import com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor;\n    import com.baomidou.mybatisplus.extension.plugins.pagination.optimize.JsqlParserCountOptimize;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    \n    @Configuration\n    public class MybatisPlusConfig {\n        \n        /**\n         * 分页插件\n         */\n        @Bean\n        public PaginationInterceptor paginationInterceptor() {\n            PaginationInterceptor paginationInterceptor = new PaginationInterceptor();\n            // 开启 count 的 join 优化,只针对 left join !!!\n            paginationInterceptor.setCountSqlParser(new JsqlParserCountOptimize(true));\n            return paginationInterceptor;\n        }\n        \n    }\n    \n\n 2. 测试\n    \n    @Autowired\n    private UserMapper mapper;\n    \n    //····\n    \n    @Test\n    public void testSelectPage() {\n        \n        Page<User> page = new Page<>(2, 3);\n        Page<User> result = mapper.selectPage(page, Wrappers.<User>query());\n    \n        result.getRecords().forEach(System.out :: println);\n        System.out.println("总数：" + result.getTotal());\n        System.out.println("总页数：" + result.getPages());\n        System.out.println("每行数：" + result.getSize());\n    \n        /**\n         * 验证分页信息\n         *      1. 总数 > 3\n         *      2. 页总数 = 3\n          */\n        assertThat(result.getTotal()).isGreaterThan(3);\n        assertThat(result.getRecords().size()).isEqualTo(3);\n        \n    }\n    \n    /*\n    \n    User(id=4, name=Jack, age=20, email=test2@baomidou.com)\n    User(id=5, name=Jack, age=20, email=test2@baomidou.com)\n    User(id=6, name=Jack, age=20, email=test2@baomidou.com)\n    总数：17\n    总页数：6\n    每行数：3\n    \n    */\n    \n\n# xml分页\n\n 1. 添加属性 ，全局配置文件 application.yml\n    \n    mybatis-plus :\n      type-aliases-package : com.pojo.User\n      mapper-locations: classpath:/mapper/*.xml\n    \n\n 2. 映射类添加方法 UserMapper.java\n    \n    @Mapper\n    public interface UserMapper extends BaseMapper<User> {\n        \n        /**\n         * 用户列表分页查询 （xml）\n         * Param()注解：替换了原旧名称进行应用参数属性 如 p.属性、c.属性\n         * @param page 分页对象\n         * @param conditioin 约束查询数据\n         * @return\n         */\n        public Page<User> selectUserByPage(@Param ("p") IPage<User> page, @Param("c") User conditioin);\n    }\n    \n\n 3. 创建映射文件 UserMapper.xml ，路径 resources/mapper/UserMapper.xml\n    \n    <?xml version="1.0" encoding="UTF-8"?>\n    <!DOCTYPE mapper\n            PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n            "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n    <mapper namespace="com.mapper.UserMapper">\n    \n        <sql id="selectSql">\n            SELECT `user`.id,`user`.name,`user`.age,`user`.email\n            FROM user\n        </sql>\n    \n        <select id="selectUserByPage" resultType="user">\n            <include refid="selectSql"></include>\n            <where>\n                <if test="c.age !=null">\n                    age = #{c.age}\n                </if>\n                <if test="c.email !=null">\n                    and email like \'%${c.email}%\'\n                </if>\n            </where>\n        </select>\n    \n    </mapper>\n    \n    \n    > 注意： namespace 属性指定的值是 实现的接口\n\n 4. 测试\n    \n    //xml分页\n    @Test\n    public void testSelectUserByPage() {\n        Page<User> page = new Page<>(1,2);\n    \n        User u = new User();\n        u.setAge(20);\n        u.setEmail("test2");\n        \n        Page<User> pr = mapper.selectUserByPage(page , u);\n        \n        \n        System.out.println("总数：" + pr.getTotal());\n        System.out.println("总页数：" + pr.getPages());\n        System.out.println("每行数：" + pr.getSize());\n        System.out.println("===========");\n        pr.getRecords().forEach(System.out::println);\n    }\n    \n    /*\n    \n    总数：13\n    总页数：7\n    每行数：2\n    ===========\n    User(id=2, name=Jack, age=20, email=test2@baomidou.com)\n    User(id=3, name=Jack, age=20, email=test2@baomidou.com)\n    \n    */\n    \n    \n    > 注意： 约束条件查询结果条数 必须要 大于 分页每页数\n\n# pagehelper分页\n\n 1. 引入独有依赖 pom.xml\n    \n    \x3c!--pagehelper分页--\x3e\n    <dependency>\n        <groupId>com.github.pagehelper</groupId>\n        <artifactId>pagehelper</artifactId>\n        <version>5.1.11</version>\n    </dependency>\n    \n\n 2. 编辑 mp配置类 MybatisPlusConfig.java ，全限定名：com.config.MybatisPlusConfig\n    \n    package com.config;\n    \n    import com.baomidou.mybatisplus.extension.plugins.PaginationInterceptor;\n    import com.baomidou.mybatisplus.extension.plugins.pagination.optimize.JsqlParserCountOptimize;\n    import com.github.pagehelper.PageInterceptor;\n    import org.mybatis.spring.annotation.MapperScan;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    \n    @Configuration\n    @MapperScan("com.mapper")\n    public class MybatisPlusConfig {\n        \n        //···\n        \n        /**\n         * pagehelper的分页插件\n         */\n        @Bean\n        public PageInterceptor pageInterceptor() {\n            return new PageInterceptor();\n        }\n        \n    }\n    \n\n 3. 映射类添加方法 UserMapper.java （可选测试）\n    \n    package com.mapper;\n    \n    import com.baomidou.mybatisplus.core.mapper.BaseMapper;\n    import com.baomidou.mybatisplus.core.metadata.IPage;\n    import com.baomidou.mybatisplus.extension.plugins.pagination.Page;\n    import com.sans.pojo.User;\n    import org.apache.ibatis.annotations.Mapper;\n    import org.apache.ibatis.annotations.Param;\n    \n    import java.util.List;\n    \n    @Mapper\n    public interface UserMapper extends BaseMapper<User> {\n        \n        //···\n        \n        /**\n         * 用户列表分页查询 （pagehelper）\n         * @param conditioin 约束查询数据\n         * @return\n         */\n        public List<User> selectUserByPage2(User conditioin);\n        \n    }\n    \n\n 4. 编辑映射文件 UserMapper.xml ，路径 resources/mapper/UserMapper.xml（可选测试）\n    \n    <?xml version="1.0" encoding="UTF-8"?>\n    <!DOCTYPE mapper\n            PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n            "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n    <mapper namespace="com.sans.mapper.UserMapper">\n    \n        <sql id="selectSql">\n            SELECT `user`.id,`user`.name,`user`.age,`user`.email\n            FROM user\n        </sql>\n    \n        \x3c!-- ····· --\x3e\n    \n        \x3c!-- pagehelper 映射分页查询--\x3e\n        <select id="selectUserByPage2" resultType="user">\n            <include refid="selectSql"></include>\n            <where>\n                <if test="age !=null">\n                    age = #{age}\n                </if>\n                <if test="email !=null">\n                    and email like \'%${email}%\'\n                </if>\n            </where>\n        </select>\n    \n    </mapper>\n    \n\n 5. 测试\n    \n    // pagehelper分页\n    @Test\n    public void testSelectUserByPage2() {\n    \n        User u = new User();\n        u.setAge(20);\n        u.setEmail("test2");\n        PageInfo<User> page = PageHelper.startPage(1,2).doSelectPageInfo(() ->{\n            // 方法选择测试 (他们测试结果一致)\n            // 1. 自定义xml\n            mapper.selectUserByPage2(u);\n            // 2. mp 内置方法\n            // mapper.selectList(Wrappers.<User>query().eq("age",20).like("email","test2"));\n        });\n    \n        page.getList().forEach(System.out :: println);\n    \n        System.out.println("===========");\n    \n        System.out.println("总行数=" + page.getTotal());\n        System.out.println("总页数=" + page.getPages());\n        System.out.println("每页行数=" + page.getPageSize());\n    \n        System.out.println("当前页=" + page.getPageNum());\n        System.out.println("起始行数=" + page.getStartRow());\n    \n        System.out.println("是第一页=" + page.isIsFirstPage());\n        System.out.println("是最后页=" + page.isIsLastPage());\n    \n        System.out.println("还有下一页=" + page.isHasNextPage());\n        System.out.println("还有上一页=" + page.isHasPreviousPage());\n    \n        System.out.println("页码列表" + Arrays.toString(page.getNavigatepageNums()));\n    }\n    \n    /*\n    \n    User(id=2, name=Jack, age=20, email=test2@baomidou.com)\n    User(id=3, name=Jack, age=20, email=test2@baomidou.com)\n    ===========\n    总行数=13\n    总页数=7\n    每页行数=2\n    当前页=1\n    起始行数=1\n    是第一页=true\n    是最后页=false\n    还有下一页=true\n    还有上一页=false\n    页码列表[1, 2, 3, 4, 5, 6, 7]\n    \n    */\n    \n\n官方文档：MyBatis-Plus (baomidou.com)\n\n# 反向工程\n\n官方在 3.5.1 以上和以下 分别 生成方式都不一样，因此做了两个示例\n\n工程配置文档：添加跳转\n\n# 3.5.1之前\n\n步骤：\n\n 1. 引入必要jar freemarker模板、lombok简化实体、mybatis-plus-generator生成核心\n    \n    <dependency>\n        <groupId>org.freemarker</groupId>\n        <artifactId>freemarker</artifactId>\n        <version>2.3.31</version>\n    </dependency>\n    <dependency>\n        <groupId>org.projectlombok</groupId>\n        <artifactId>lombok</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>com.baomidou</groupId>\n        <artifactId>mybatis-plus-generator</artifactId>\n        <version>3.4.1</version>\n    </dependency>\n    \n    \n    > 生成后可以直接删除 freemarker模板、mybatis-plus-generator生成核心\n\n 2. 反向工程启动类\n    \n    必要提示说明：\n    \n    * 数据源配置\n    * 作者\n    * 生成路径\n    * 模组名（启动输入\n    * 表名（启动输入\n    \n    import com.baomidou.mybatisplus.annotation.FieldFill;\n    import com.baomidou.mybatisplus.annotation.IdType;\n    import com.baomidou.mybatisplus.core.exceptions.MybatisPlusException;\n    import com.baomidou.mybatisplus.core.toolkit.StringPool;\n    import com.baomidou.mybatisplus.core.toolkit.StringUtils;\n    import com.baomidou.mybatisplus.generator.AutoGenerator;\n    import com.baomidou.mybatisplus.generator.InjectionConfig;\n    import com.baomidou.mybatisplus.generator.config.*;\n    import com.baomidou.mybatisplus.generator.config.po.TableFill;\n    import com.baomidou.mybatisplus.generator.config.po.TableInfo;\n    import com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;\n    import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;\n    \n    import java.util.ArrayList;\n    import java.util.List;\n    import java.util.Scanner;\n    \n    public class MysqlGenerator {\n    \n        /**\n         * <p>\n         * 读取控制台内容\n         * </p>\n         */\n        public static String scanner(String tip) {\n            Scanner scanner = new Scanner(System.in);\n            StringBuilder help = new StringBuilder();\n            help.append("请输入" + tip + "：");\n            System.out.println(help.toString());\n            if (scanner.hasNext()) {\n                String ipt = scanner.next();\n                if (StringUtils.isNotBlank(ipt)) {\n                    return ipt;\n                }\n            }\n            throw new MybatisPlusException("请输入正确的" + tip + "！");\n        }\n    \n        public static void main(String[] args) {\n            // 代码生成器\n            AutoGenerator mpg = new AutoGenerator();\n    \n            // 全局配置\n            GlobalConfig gc = new GlobalConfig();\n            String projectPath = System.getProperty("user.dir");\n            /*\n            指定工程名称\n            指定作者\n            *  */\n            gc.setOutputDir(projectPath + "/NewsSys/src/main/java");\n            gc.setAuthor("sasn");\n            gc.setOpen(false);\n            gc.setIdType(IdType.AUTO);//设置全局id自增\n            gc.setBaseResultMap(true);//设置生成BaseResultMap\n            // gc.setSwagger2(true); 实体属性 Swagger2 注解\n            mpg.setGlobalConfig(gc);\n    \n            // 数据源配置\n            /* 写自己的连接源 */\n            DataSourceConfig dsc = new DataSourceConfig();\n            dsc.setUrl("jdbc:mysql://localhost:3306/test?serverTimezone=UTC");\n            // dsc.setSchemaName("public");\n            dsc.setDriverName("com.mysql.jdbc.Driver");\n            dsc.setUsername("root");\n            dsc.setPassword("root");\n            \n            // 库数据 和 实体数据字段手动匹配配置\n            dsc.setTypeConvert(new MySqlTypeConvert() {\n                @Override\n                public IColumnType processTypeConvert(@org.jetbrains.annotations.NotNull GlobalConfig globalConfig,\n                                                      @org.jetbrains.annotations.NotNull String fieldType) {\n                    // 比较库字段类型\n                    if ("datetime".equals(fieldType)) {\n                        // 满足则返回需要对应的实体类型\n                        return DbColumnType.DATE;\n                    }\n                    if ("float".equals(fieldType)) {\n                        return DbColumnType.BASE_DOUBLE;\n                    }\n                    switch (fieldType) {\n                        case "text" :\n                        case "mediumtext" :\n                            return DbColumnType.STRING;\n                        default:\n                            break;\n                    }\n                    return super.processTypeConvert(globalConfig, fieldType);\n                }\n            }\n            \n            mpg.setDataSource(dsc);\n    \n            // 包配置\n            /* 指定模块名称 */\n            PackageConfig pc = new PackageConfig();\n            pc.setModuleName(scanner("模块名"));\n            pc.setParent("com.sans");\n            mpg.setPackageInfo(pc);\n    \n            // 自定义配置\n            InjectionConfig cfg = new InjectionConfig() {\n                @Override\n                public void initMap() {\n                    // to do nothing\n                }\n            };\n    \n            // 如果模板引擎是 freemarker  从依赖包的 templates下查找模板\n            String templatePath = "/templates/mapper.java.ftl";\n            // 如果模板引擎是 velocity\n            // String templatePath = "/templates/mapper.xml.vm";\n    \n            // 自定义输出配置\n            List<FileOutConfig> focList = new ArrayList<>();\n            // 自定义配置会被优先输出\n            focList.add(new FileOutConfig(templatePath) {\n                @Override\n                public String outputFile(TableInfo tableInfo) {\n                    // 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！\n                    return projectPath + "/src/main/resources/mapper/" + pc.getModuleName()\n                            + "/" + tableInfo.getEntityName() + "Mapper" + StringPool.DOT_XML;\n                }\n            });\n            /*\n            cfg.setFileCreate(new IFileCreate() {\n                @Override\n                public boolean isCreate(ConfigBuilder configBuilder, FileType fileType, String filePath) {\n                    // 判断自定义文件夹是否需要创建\n                    checkDir("调用默认方法创建的目录，自定义目录用");\n                    if (fileType == FileType.MAPPER) {\n                        // 已经生成 mapper 文件判断存在，不想重新生成返回 false\n                        return !new File(filePath).exists();\n                    }\n                    // 允许生成模板文件\n                    return true;\n                }\n            });\n            */\n            cfg.setFileOutConfigList(focList);\n            mpg.setCfg(cfg);\n    \n            // 配置模板\n           // TemplateConfig templateConfig = new TemplateConfig();\n    \n            // 配置自定义输出模板\n            //指定自定义模板路径，注意不要带上.ftl/.vm, 会根据使用的模板引擎自动识别\n            // templateConfig.setEntity("templates/entity2.java");\n            // templateConfig.setService();\n            // templateConfig.setController();\n    \n            //templateConfig.setXml(null);\n           // mpg.setTemplate(templateConfig);\n    \n            // 策略配置\n            StrategyConfig strategy = new StrategyConfig();\n            strategy.setNaming(NamingStrategy.underline_to_camel);\n            strategy.setColumnNaming(NamingStrategy.underline_to_camel);\n    //        strategy.setSuperEntityClass("你自己的父类实体,没有就不用设置!");\n            strategy.setEntityLombokModel(true);\n            strategy.setRestControllerStyle(true);\n            // 公共父类\n    //        strategy.setSuperControllerClass("你自己的父类控制器,没有就不用设置!");\n            // 写于父类中的公共字段\n    //        strategy.setSuperEntityColumns("id");\n            strategy.setEnableSqlFilter(false);//开启支持输入正则表达式\n            strategy.setInclude(scanner("表名，多个英文逗号分割").split(","));\n            strategy.setControllerMappingHyphenStyle(true);\n            strategy.setTablePrefix(pc.getModuleName() + "_");\n    \n            //设置生成自动填充注解的表字段\n            ArrayList<TableFill> list = new ArrayList<>();\n            list.add(new TableFill("update_date", FieldFill.INSERT_UPDATE));\n            list.add(new TableFill("create_date", FieldFill.INSERT));\n            list.add(new TableFill("del_flag", FieldFill.INSERT));\n            strategy.setTableFillList(list);\n            strategy.setLogicDeleteFieldName("del_flag");//设置生成逻辑删除注解对应表字段名\n            mpg.setStrategy(strategy);\n            mpg.setTemplateEngine(new FreemarkerTemplateEngine());\n            mpg.execute();\n        }\n    }\n    \n\n# 3.5.1之后\n\n步骤：\n\n 1. 引入必要jar freemarker模板、annotations配置注解应用、mybatis-plus-generator生成核心\n    \n    <dependency>\n        <groupId>com.baomidou</groupId>\n        <artifactId>mybatis-plus-generator</artifactId>\n        <version>3.5.2</version>\n    </dependency>\n    <dependency>\n        <groupId>org.freemarker</groupId>\n        <artifactId>freemarker</artifactId>\n        <version>2.3.31</version>\n    </dependency>\n    <dependency>\n        <groupId>org.jetbrains</groupId>\n        <artifactId>annotations</artifactId>\n        <version>16.0.1</version>\n    </dependency>\n    \n    \n    > 生成后可以直接删除 freemarker模板、mybatis-plus-generator生成核心\n\n 2. 反向工程启动类\n    \n    > 注意参数的填充\n    \n    import com.baomidou.mybatisplus.generator.FastAutoGenerator;\n    import com.baomidou.mybatisplus.generator.config.DataSourceConfig;\n    import com.baomidou.mybatisplus.generator.config.GlobalConfig;\n    import com.baomidou.mybatisplus.generator.config.converts.MySqlTypeConvert;\n    import com.baomidou.mybatisplus.generator.config.querys.MySqlQuery;\n    import com.baomidou.mybatisplus.generator.config.rules.DbColumnType;\n    import com.baomidou.mybatisplus.generator.config.rules.IColumnType;\n    import com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;\n    \n    public class BuilderApplication {\n    \n        public static void main(String[] args) {\n    \n            String url = "jdbc:mysql://localhost:3306/test?serverTimezone=UTC";\n            String username = "root";\n            String passwoed = "root";\n            String baomidou = "柏竹";\n            String packagePath = "com.sans";\n            String generatePath = "D:\\\\Code\\\\Java\\\\Drill\\\\Guangdong embedded\\\\01 Study\\\\JavaEE\\\\220607SpringCloud\\\\220607WebService\\\\220607WebService\\\\Restful-Server\\\\src\\\\main\\\\java";\n    \n            DataSourceConfig.Builder dataSourceBuilder = new DataSourceConfig.Builder(url, username, passwoed)\n                    .dbQuery(new MySqlQuery())\n                    .typeConvert(new MySqlTypeConvert() {\n                        @Override\n                        public IColumnType processTypeConvert(@org.jetbrains.annotations.NotNull GlobalConfig globalConfig,\n                                                              @org.jetbrains.annotations.NotNull String fieldType) {\n                            // 比较库字段类型\n                            if ("datetime".equals(fieldType)) {\n                                // 满足则返回需要对应的实体类型\n                                return DbColumnType.DATE;\n                            }\n                            return super.processTypeConvert(globalConfig, fieldType);\n                        }\n                    });\n    \n    \n            /**\n             * 配置文档：https://baomidou.com/pages/981406/\n             */\n            FastAutoGenerator.create(dataSourceBuilder)\n                    // 全局配置\n                    .globalConfig(builder -> {\n                        builder.author(baomidou)\n    //                            .enableSwagger()\n                                .disableOpenDir()\n                                .fileOverride()\n                                .outputDir(generatePath); // 指定输出目录\n                    })\n                    // 包配置\n                    .packageConfig(builder -> {\n                        builder.parent(packagePath); // 设置父包名\n    //                            .moduleName(moduleName); // 设置父包模块名\n    //                            .pathInfo(Collections.singletonMap(OutputFile.mapper, XMLPath)); // 设置mapperXml生成路径\n                    })\n                    // 策略配置\n                    .strategyConfig(builder -> {\n                        // 指定表\n                        builder.addInclude("book") // 设置需要生成的表名\n    //                            .addInclude("news_detail")\n                                .enableCapitalMode()\n                                // Entity 策略配置\n                                // 逻辑删除/乐观锁 字段\n                                .entityBuilder()\n                                .versionColumnName("version")\n                                .versionPropertyName("version")\n                                .logicDeleteColumnName("deleted")\n                            \t/.enableLombok() // 启动 lombok 模型\n                                .mapperBuilder()\n                                .enableBaseResultMap()\n                                .enableMapperAnnotation()\n                        ;\n                    })\n                    .templateEngine(new FreemarkerTemplateEngine())  // 使用Freemarker引擎模板，默认的是Velocity引擎模板\n                    .execute();\n        }\n    }\n    \n\n\n# JSON整合\n\nSpringBoot 自带有 jackson 和 gson , 一般JSON操作是通过 ObjectMapper对象 进行操作(工具类)\n\n> SpringBoot 一般情况是使用自动注入形式调用 ObjectMapper对象\n\n# 对象>JSON\n\nUser user = new User();\nString userJson = new ObjectMapper().writeValueAsString(user);\n//...\n\n\n# JSON>对象\n\n// 单对象\nString json = "{name:\'Sans\', age:22}";\nUser user = new ObjectMapper().readValue(josn, User.class);\n// 数组\nString jsonArrayStr = "[{\\"id\\":\\"123\\",\\"name\\":\\"张三\\"},{\\"id\\":\\"456\\",\\"name\\":\\"李四\\"}]";\nList<Person> personList = objectMapper.readValue(jsonArrayStr, new TypeReference<List<Person>>() {});\n\n\n# 自定义工具类\n\npublic class JsonUtil {\n\n    public static final ObjectMapper objectMapper = new ObjectMapper();\n\n    static {\n        //忽略字段不匹配错误\n objectMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n    }\n\n    /**\n     * 创建 ObjectNode\n     * @return\n     */\n    public static ObjectNode createJson() {\n        return objectMapper.createObjectNode();\n    }\n\n    /**\n     * 字符串转 java bean\n     * @param json\n     * @param clazz\n     * @param <T>\n     * @return\n     */\n    public static <T> T string2Bean(String json, Class<T> clazz){\n        T t = null;\n        try {\n            t = objectMapper.readValue(json,clazz);\n        } catch (JsonProcessingException e) {\n            e.printStackTrace();\n        }\n        return t;\n    }\n\n    /**\n     * 字符串转 Map\n     * @param json\n     * @param clazz\n     * @param <T>\n     * @return\n     */\n    public static <T> Map<String,Object> string2Map(String json, Class<T> clazz){\n        Map<String,Object> map = null;\n        try {\n            map = objectMapper.readValue(json, new TypeReference<Map<String,Object>>() {});\n        } catch (JsonProcessingException e) {\n            map = Collections.emptyMap();\n            e.printStackTrace();\n        }\n        return map;\n    }\n\n    /**\n     * 字符串转 List<Bean>\n     * @param json\n     * @param clazz\n     * @param <T>\n     * @return\n     */\n    public static <T> List<T> string2BeanList(String json, Class<T> clazz){\n        List<T> t = null;\n        try {\n            t = objectMapper.readValue(json, new TypeReference<List<T>>() {});\n        } catch (JsonProcessingException e) {\n            t = Collections.emptyList();\n            e.printStackTrace();\n        }\n        return t;\n    }\n\n    /**\n     * 字符串转 Bean[]\n     * @param json\n     * @param clazz\n     * @param <T>\n     * @return\n     */\n    public static <T> T[] string2BeanArray(String json, Class<T> clazz){\n        T[] t = null;\n        try {\n            t = objectMapper.readValue(json, new TypeReference<T[]>() {});\n        } catch (JsonProcessingException e) {\n            t = (T[])new Object[0];\n            e.printStackTrace();\n        }\n        return t;\n    }\n\n    /**\n     * 字符串转 JsonNode\n     * @param json\n     * @return\n     */\n    public static JsonNode string2Json(String json) {\n        JsonNode jsonNode = null;\n        try {\n            jsonNode = objectMapper.readTree(json);\n        } catch (JsonProcessingException e) {\n            e.printStackTrace();\n        }\n        return jsonNode;\n    }\n\n    /**\n     * java bean 或者 Map 或者 JsonNode 转字符串\n     * @param o\n     * @return\n     */\n    public static String object2String(Object o) {\n        String json = null;\n        try {\n            json = objectMapper.writeValueAsString(o);\n        } catch (JsonProcessingException e) {\n            e.printStackTrace();\n        }\n        return json;\n    }\n\n    /**\n     * java bean 或者 Map 或者 JsonNode 转 JsonNode\n     * @param o\n     * @return\n     */\n    public static JsonNode object2Json(Object o) {\n        JsonNode jsonNode = null;\n        try {\n            String jsonString = objectMapper.writeValueAsString(o);\n            jsonNode = objectMapper.readTree(jsonString);\n        } catch (JsonProcessingException e) {\n            e.printStackTrace();\n        }\n        return jsonNode;\n    }\n\n    /**\n     * jsonNode 转 JsonNode\n     * @param jsonNode\n     * @return\n     */\n    public static <T> T json2Bean(JsonNode jsonNode, Class<T> clazz) {\n        String json = jsonNode.toString();\n        return string2Bean(json, clazz);\n    }\n}\n\n\n应用实例\n\n// 数组\npublic static void main(String[] args) {\n    ObjectNode person = objectMapper.createObjectNode();\n    person.put("id","1101");\n    person.put("name","张三");\n    person.put("age",35);\n    person.put("sex","男");\n\n    List<ObjectNode> children = new ArrayList<>(1);\n    ObjectNode child = objectMapper.createObjectNode();\n    child.put("id","1102");\n    child.put("name","张小三");\n    child.put("age",12);\n    child.put("sex","男");\n\n    children.add(child);\n\n    person.putArray("children").addAll(children);\n\n    System.out.println(person.toPrettyString());\n}\n\n\n\n# 部署\n\n\n# Jar打包\n\n大致流程\n\n 1. jdk安装 , 并配置\n 2. Maven打包项目 , 上传服务器\n 3. 运行jar项目\n\n> SpringBoot内置集成Tomcat , 无需安装即可应用\n\n项目打包\n\nMaven -> 双击package , 加载完会在 /target(缓存路径) 上看到 .jar 文件 , 在Liunx系统里运行即可\n\n运行jar包项目\n\nnohup java -jar shop-0.0.1-SNAPSHOT.jar > logName.log 2>&1 &\n\n\n指令说明\n\n * ==nohup java -jar shop-0.0.1-SNAPSHOT.jar== 运行项目 , 不挂断运行\n * ==Log.log 2>&1== 表示将stdout和stderr合并后重定向到log.file\n\n> 运行后可以看到 一串数值 , 可通过 ==jps==指令 进行查看进程\n\n关闭进程 :\n\n# 查指定端口 (查8080)\nnetstat -nlp|grep 8080\n# 确定端口的 PID\nkill -9 {PID}\n\n\n\n# Docker打包/群辉挂载\n\n 0. jar打包\n\n 1. 创建 dorderfile.txt (编辑配置文件) , 保存后取出后缀 .txt\n    \n    # Docker image for springboot file run\n    # VERSION 0.0.1\n    # Author: \n    # 基础镜像使用java\n    FROM openjdk:8\n    # 作者\n    MAINTAINER Sans\n    # VOLUME 指定了临时文件目录为/tmp。\n    # 其效果是在主机 /var/lib/docker 目录下创建了一个临时文件，并链接到容器的/tmp\n    VOLUME /tmp \n    # 将jar包添加到容器中并更名为xx.jar (demo.jar -> test.jar)\n    ADD demo.jar test.jar \n    # 运行jar包\n    RUN bash -c \'touch /test.jar\'\n    ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/test.jar"]\n    \n\n 2. 执行镜像打包 (在含有 dockerfild 和 xx.jar 执行以下文件)\n    \n    sudo docker build . -t demo-name:v1.0\n    \n\n 3. 打开docker , 镜像加载即可 (配置按照默认)\n\n 4. 反向代理 , 控制面板 -> 登录门户 -> 高级 -> 反向代理服务器 新增 来源 *:端口 ; 目的 locakhost:本地端口\n\n 5. 外部访问即可\n\n\n# SSL域名认证\n\nSSL能够将该网站变为更安全的网站 , HTTPS独有的协议\n\n阿里云申请后 : 下载JKS 证书类型(里面有 key和password 两个文件)\n\nkey放到 resources目录 即可\n\napplication文件配置\n\n# 域名 SSL配置\nserver.ssl.key-store=classpath:8840811_bozhu.free.svipss.top.jks\nserver.ssl.key-store-password=xxxx\nserver.ssl.key-store-type=JKS\n\n\n> server.ssl.key-store : key文件的全名称 server.ssl.key-store-password : 第二个文件夹的内容粘贴出来 server.ssl.key-store-type : 认证类型 JKS\n\n直接访问https接口 , 也可以设置重定向为https\n\n\n# SSH\n\n先连接OpenWrt 作为代理主机进行操作\n\nOpenWrt SSH访问在\n\n==系统 -> 管理权 -> Dropbear 实例== : 启动网关端口...\n\n群辉SSH 先访问OpenWrt作为代理进行内网访问群辉SSHComponent',normalizedContent:'# springboot\n\n\n# 概述\n\nspring boot 是 spring 快速开发的脚手架，spring boot 大大优化了 spring的 ==复杂配置== 和 ==依赖配置版本== 问题\n\n特点\n\n 1. 独立运行 spring项目\n 2. 内嵌 tomcat 和 jetty 容器 , 无需打包war文件\n 3. 简化 maven配置\n 4. 无 代码生成/xml配置\n 5. ...\n\n\n# 首次应用\n\n\n# spring boot无xml应用web项目\n\n模拟原生的servlet搭建web\n\n> 该配置方式学习了解即可，并非针对学习！！\n\n 1. 创建 maven无骨架项目 idea创建maven项目 （无骨架java项目）\n\n 2. pom.xml 引入 springboot相关依赖\n    \n    <packaging>war</packaging>\n    \x3c!-- 集中定义依赖版本号 --\x3e\n    <properties>\n        <spring.version>5.1.2.release</spring.version>\n        <pagehelper.version>4.2.1</pagehelper.version>\n    </properties>\n    \n    <dependencies>\n    \n        \x3c!-- spring --\x3e\n        <dependency>\n            <groupid>org.springframework</groupid>\n            <artifactid>spring-context</artifactid>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework</groupid>\n            <artifactid>spring-beans</artifactid>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupid>org.springframework</groupid>\n            <artifactid>spring-webmvc</artifactid>\n            <version>${spring.version}</version>\n        </dependency>\n        <dependency>\n            <groupid>javax.servlet</groupid>\n            <artifactid>javax.servlet-api</artifactid>\n            <version>4.0.1</version>\n            <scope>provided</scope>\n        </dependency>\n        \x3c!-- jstl --\x3e\n        <dependency>\n            <groupid>javax.servlet</groupid>\n            <artifactid>jstl</artifactid>\n            <version>1.2</version>\n        </dependency>\n    </dependencies>\n    \n    <build>\n        <plugins>\n            <plugin>\n                <groupid>org.apache.maven.plugins</groupid>\n                <artifactid>maven-compiler-plugin</artifactid>\n                <version>3.7.0</version>\n                <configuration>\n                    <source>1.8</source>\n                    <target>1.8</target>\n                    <encoding>utf-8</encoding>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n    \n\n 3. 建立 模拟web.xml配置 的java程序类 webinit类\n    \n    web.xml文件配置 (比对示例的配置文件\n    \n    <servlet>\n        <servlet-name>dispatcherservlet</servlet-name>\n        <servlet-class>org.springframework.web.servlet.dispatcherservlet</servlet-class>\n        <init-param>\n            <param-name>contextconfiglocation</param-name>\n            <param-value>classpath*:springmvc.xml</param-value>\n        </init-param>\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n    <servlet-mapping>\n        <servlet-name>dispatcherservlet</servlet-name>\n        <url-pattern>/</url-pattern>\n    </servlet-mapping>\n    \n    \n    java程序配置 （应用代码\n    \n    public class webinit implements webapplicationinitializer {\n        // 初始化配置\n        @override\n        public void onstartup(servletcontext servletcontext) throws servletexception {\n            // 指定 spring配置类\n            annotationconfigwebapplicationcontext context = new annotationconfigwebapplicationcontext();\n            context.register(springmvcconfig.class);\n    \n            // 添加serlvet并指定映射\n            servletregistration.dynamic springmvc =\n                    servletcontext.addservlet("springmvc",new dispatcherservlet(context));\n            springmvc.addmapping("/");\n            springmvc.setloadonstartup(1);\n        }\n    }\n    \n    \n    > springmvcconfig类 需要指定加载的 springmvc配置的类，在下面\n\n 4. 创建 springmvc配置类\n    \n    web.xml文件配置 (比对示例的配置文件\n    \n    <mvc:annotation-driven />\n    <context:component-scan base-package="com.sans"/>\n    <bean class="org.springframework.web.servlet.view.internalresourceviewresolver">\n    \t<property name="prefix" value="/html/"/>\n    \t<property name="suffix" value=".html"/>\n    </bean>\n    \n    \n    java程序配置 （应用代码\n    \n    @configuration\n    @componentscan("com.sans")\n    @enablewebmvc\n    public class springmvcconfig implements webmvcconfigurer {\n    // 组件注解加载 xml：<mvc:default-servlet-handler/>\n    @override\n    public void configuredefaultservlethandling(defaultservlethandlerconfigurer configurer) {\n        configurer.enable();\n    }\n    \n    @bean\n    public viewresolver viewresolver() {\n        internalresourceviewresolver viewresolver = new internalresourceviewresolver();\n        viewresolver.setprefix("/html/");\n        viewresolver.setsuffix(".html");\n        return viewresolver;\n    }\n    \n\n 5. 创建 controller\n    \n    package com.controller;\n    \n    import org.springframework.beans.factory.annotation.autowired;\n    import org.springframework.web.bind.annotation.getmapping;\n    import org.springframework.web.bind.annotation.restcontroller;\n    \n    import javax.sql.datasource;\n    \n    @controller\n    public class hellocontroller {\n        @requestmapping("/hello")\n        public string hello() {\n            return "test";\n        }\n    }\n    \n\n 6. 在web项目访问 html/test.html文件 访问即可\n\n项目结构\n\n  .\n  |\n  ├── src\n  |    ├── main\n  |\t   |\t├── java\n  |\t   |\t|\t  └── com\n  |\t   |    |   \t   ├── controller\n  |    |    |          |      └── hellocontroller.java\n  |    |    |          └── config\n  |    |    |                 ├── springmvcconfig.java\n  |    |    |                 └── webinit.java\n  |\t   |\t└──\tresources\n  |\t  test\n  └── pom.xml\n\n\n\n# spring boot启动器应用web项目\n\n 1. 创建 maven无骨架项目 idea创建maven项目 （无骨架java项目）\n\n 2. pom.xml 引入 springboot相关依赖\n    \n    <project>\n        ...\n        \x3c!--父工程坐标\n            web相关应用无需配置再配置版本号(解决版本冲突问题)\n        --\x3e\n        <parent>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-parent</artifactid>\n            <version>2.0.0.release</version>\n        </parent>\n      \n        <dependencies>\n            \x3c!--当中包含 tomcat、springmvc、...（有关web应用，自动配置）--\x3e\n            <dependency>\n                <groupid>org.springframework.boot</groupid>\n                <artifactid>spring-boot-starter-web</artifactid>\n            </dependency>\n        </dependencies>\n    ...\n    </project>\n    \n\n 3. 创建 application启动器类 全限定名 com.application\n    \n    package com;\n    \n    import org.springframework.boot.springapplication;\n    import org.springframework.boot.autoconfigure.springbootapplication;\n    \n    // @springbootapplication启动类\n    @springbootapplication\n    public class application {\n        \n        public static void main(string[] args) {\n            springapplication.run(application.class , args);\n        }\n    \n    }\n    \n\n 4. 创建 hellocontroller控制器类 全限定名 com.controller.application (为了方便看出构架结构)\n    \n    package com.controller;\n    \n    import org.springframework.beans.factory.annotation.autowired;\n    import org.springframework.web.bind.annotation.getmapping;\n    import org.springframework.web.bind.annotation.restcontroller;\n    \n    import javax.sql.datasource;\n    \n    @restcontroller\n    public class hellocontroller {\n        \n        @getmapping("/hello")\n        public string hello() {\n            return "hello , spring boot...";\n        }\n        \n    }\n    \n\n 5. 启动类启用main方法，再浏览器访问：http://localhost:8080/hello （页面返回有信息表示成功！）\n    \n    \n\n项目结构\n\n  .\n  |\n  ├── src\n  |    ├── main\n  |\t   |\t├── java\n  |\t   |\t|\t  └── com\n  |\t   |    |   \t   ├── controller\n  |    |    |          |        └── hellocontroller.java\n  |\t   |    | \t\t   └── application.java\n  |\t   |\t└──\tresources\n  |\t  test\n  └── pom.xml\n\n\n\n# 数据配置\n\nspring boot应用的是全注解配置（java程序配置\n\n常用注解：\n\n * @configuration 声明在类上，作为配置类（代替xml文件）\n\n * @bean 声明在方法上，将方法返回值导入bean容器（代替 标签）\n\n * @value 属性注入（需要属性文件进行搭配应用）\n\n * @propertysource 引入读取外部属性文件\n\n * @configurationproperties 引入读取外部属性文件，自动注入 成员变量（需要指定前缀 、properties文件\n\n * @enableconfigurationproperties\n   \n   自动注入 @configurationproperties类\n\n * @requestmapping 负责url路由映射 , 可以添加映射规则(请求类型/响应体/请求头/...)\n\n * @restcontroller 响应的对象都会转换为json格式\n\n * @component 把类对象实例化到 bean容器 (类似于\n\n * @postconstruct 方法 在配置类 执行的构造函数 和自动注入 后执行初始化的方法(类似servlet的init()方法)\n\n * \n\n\n# bean配置\n\n通过 spring boot 还原 spring配置连接池 的操作\n\nspring 原配置\n\n\x3c!-- 配置连接池 --\x3e\n<bean id="datasource" class="com.alibaba.druid.pool.druiddatasource"\ninit-method="init" destroy-method="close">\n\t<property name="url" value="${jdbc.url}" />\n\t<property name="username" value="${jdbc.username}" />\n\t<property name="password" value="${jdbc.password}" />\n</bean>\n\n\nspring boot配置\n\n 1. 在以上篇章 首次应用的代码 基础上进行更改\n\n 2. pom.xml 引入 druid连接池依赖\n    \n    <dependency>\n    \t<groupid>com.alibaba</groupid>\n    \t<artifactid>druid</artifactid>\n    \t<version>1.1.10</version>\n    </dependency>\n    \n\n 3. 创建 jdbc.properties文件 到 resources资源中\n    \n    jdbc.driverclassname=com.mysql.jdbc.driver\n    jdbc.url=jdbc:mysql://127.0.0.1:3306/test\n    jdbc.username=root\n    jdbc.password=root\n    \n\n 4. 创建 jdbcconfig配置类\n    \n    package com.config;\n    \n    import com.alibaba.druid.pool.druiddatasource;\n    import org.springframework.beans.factory.annotation.value;\n    import org.springframework.boot.context.properties.enableconfigurationproperties;\n    import org.springframework.context.annotation.bean;\n    import org.springframework.context.annotation.configuration;\n    import org.springframework.context.annotation.propertysource;\n    \n    import javax.sql.datasource;\n    \n    //配置类\n    @configuration\n    //读取数据文件\n    @propertysource("classpath:jdbc.properties")\n    public class jdbcconfig {\n    \n        /** 属性\n         * 注入属性\n         */\n        @value("${jdbc.driverclassname}")\n        string driverclassname;\n        @value("${jdbc.url}")\n        string url;\n        @value("${jdbc.username}")\n        string username;\n        @value("${jdbc.password}")\n        string password;\n    \n        /** 对象\n         *  声明的bean方法返回值会加入到spring容器中\n         *  说明：\n         *      - 注解方法 bean对象\n         *      - 默认对象名id(bean的id) 与 方法名 一致\n         *      - 自定义bean对象名，可在注解 @bean("自定义名称"),指定新对象\n         */\n        @bean\n        public datasource datasource() {\n            druiddatasource datasource = new druiddatasource();\n            datasource.setdriverclassname(driverclassname);\n            datasource.seturl(url);\n            datasource.setusername(username);\n            datasource.setpassword(password);\n            return datasource;\n        }\n    \n    }\n    \n\n 5. 在 hellocontroller控制类 自动注入测试\n    \n    package com.controller;\n    \n    import org.springframework.beans.factory.annotation.autowired;\n    import org.springframework.web.bind.annotation.getmapping;\n    import org.springframework.web.bind.annotation.restcontroller;\n    \n    import javax.sql.datasource;\n    \n    @restcontroller\n    public class hellocontroller {\n        \n        // 该注解自动匹配名称进行指定注入\n        @autowired\n        private datasource datasource;\n    \n        @getmapping("/hello")\n        public string hello() {\n            return "hello , spring boot..." + datasource;\n        }\n        \n    }\n    \n\n 6. 启用main方法调试测试。可利用断点进行查看配置连接池的参数传递情况\n\n\n# controller配置\n\ncontroller配置中 spring提供有以下两种注解进行应用\n\n * @controller 请求包含有 页面和数据\n * @restcontroller 请求只有 数据\n\n> 一般情况下使用的 @restcontroller 居多 , 前后端分离嘛 . @controller 则需要搭配模板引擎进行应用\n\n参数传递 直接上代码 , 详细了解进入 springmvc参数传递篇\n\n@restcontroller\npublic class paramscontroller {\n\n    // http://localhost:8080/gettest1\n    @requestmapping(value = "gettest1", method = requestmethod.get)\n    public string gettest1() {\n        return "get请求1";\n    }\n\n    // http://localhost:8080/gettest2?nickname=zs&phone=123\n    @requestmapping(value = "gettest2", method = requestmethod.get)\n    public string gettest2(string nickname, string phone) {\n        system.out.println("nickname = " + nickname);\n        system.out.println("phone = " + phone);\n        return "get请求2";\n    }\n\n    // http://localhost:8080/gettest3?name=zs\n    @requestmapping(value = "gettest3", method = requestmethod.get)\n    public string gettest3(@requestparam("name") string nickname) {\n        system.out.println("nickname = " + nickname);\n        return "get请求3";\n    }\n\n    // http://localhost:8080/posttest1\n    @requestmapping(value = "/posttest1", method = requestmethod.post)\n    public string posttest1() {\n        return "post请求1";\n    }\n\n    // http://localhost:8080/posttest2\n    /*\n    * application/x-www-form-urlencoded : {\n    *   username:zs,\n    *   password:123\n    * }\n     * */\n    @requestmapping(value = "/posttest2", method = requestmethod.post)\n    public string posttest2(string username, string password) {\n        system.out.println("username = " + username);\n        system.out.println("password = " + password);\n        return "post请求2";\n    }\n\n    // http://localhost:8080/posttest3\n    /*\n     * application/x-www-form-urlencoded : {\n     *   username:zs,\n     *   password:123\n     * }\n     * */\n    @requestmapping(value = "/posttest3", method = requestmethod.post)\n    public string posttest3(myuser user) {\n        system.out.println(user);\n        return "post请求3";\n    }\n\n    // http://localhost:8080/posttest4\n    /*\n       application/json : {\n         "username":"zs",\n         "password":"123"\n       }\n     */\n    @requestmapping(value = "/posttest4", method = requestmethod.post)\n    public string posttest4(@requestbody myuser user) {\n        system.out.println(user);\n        return "post请求4";\n    }\n\n    // http://localhost:8080/test/xxx...\n    @getmapping("/test/**")\n    public string test() {\n        return "通配符请求";\n    }\n}\n\n\n通配符\n\n * * : 任意单词\n * ** : 任意路径\n * ? : 任意单个字符\n\n> 通常使用的 * 较多 , 比如指定未知文件名的文件等等...\n\n\n# 自动注入配置\n\nspringboot注解配置 正是优化 spring注解配置 的存在。虽然以上spring注解配置可行，但配置依旧有些许繁琐。\n\n# @configurationproperties\n\n该注解有两种实现方式 类/方法 上\n\n# 定义在类上\n\n将 类的成员变量 与 配置文件key值 进行匹配赋予值，赋予值的前提需要指定 配置文件的前缀字符串prefix\n\n例如：\n\njdbc.driver.username=root\njdbc.driver.password=root\n\n\n@configurationproperties(prefix = "jdbc.driver")\npublic class jdbcproperties {\n    private string driverclassname;\n    private string url;\n    private string username;\n    private string password;\n    // settre/gettre 方法省略 （一定一定不能少写\n}\n\n\n> 应用需要搭配 @enableconfigurationproperties注解 进行使用\n\n# 定义在方法上\n\nbean方法 返回直接声明使用，这一过程无需@enableconfigurationproperties注解 进行读取类对象应用\n\n> 应用前提： 注入的对象必须有 set方法\n\n// 声明要注入属性前缀，springboot会自动把相关属性通过set方法进行注入到datasource中\n// 应用前提删除 jdbcproperties属性读取类 已经使用 属性的前缀值 进行读取\n@bean\n@configurationproperties (prefix = "jdbc")\npublic datasource datasource() {\n    return new druiddatasource();\n}\n\n\n# @enableconfigurationproperties\n\n用于声明指定获取存储参数的对象，参数 value 其值为 指定某个存储参数的类\n\n自动注入方式：\n\n 1. @autowired注入\n 2. 声明有@bean的方法参数注入\n\n以下示例以连接池的配置进行测试\n\n 1. 创建 jdbcproperties属性读取类 ，全限定名 com.config.jdbcproperties\n    \n    package com.config;\n    \n    import org.springframework.boot.context.properties.configurationproperties;\n    \n    /** 属性读取类\n     * @configurationproperties （属性配置）\n     *      prefix = "jdbc" , 配置数据的前缀为jdbc的值 (它只会读取前缀为jdbc的值)\n     */\n    @configurationproperties(prefix = "jdbc")\n    public class jdbcproperties {\n    \n        private string driverclassname;\n        private string username;\n        private string password;\n        private string url;\n        \n        // set 和 get \n        ...\n    }\n    \n\n 2. jdbcconfig配置类 ，全限定名 com.config.jdbcconfig\n    \n    package com.config;\n    \n    import com.alibaba.druid.pool.druiddatasource;\n    import org.springframework.beans.factory.annotation.autowired;\n    import org.springframework.boot.context.properties.enableconfigurationproperties;\n    import org.springframework.context.annotation.bean;\n    import org.springframework.context.annotation.configuration;\n    \n    import javax.sql.datasource;\n    \n    // 定义 配置类\n    @configuration\n    // 定义 加载配置文件\n    @propertysource("classpath:jdbc.properties")\n    // 定义 启动加载实体\n    @enableconfigurationproperties(jdbcproperties.class)\n    public class jdbcconfig {\n    \n        /** 方式1 （成员变量注入\n         *  步骤：\n         *    1. 加载配置文件 @propertysource("classpath:jdbc.properties")\n         *    2. 成员变量赋予值 @value()\n         */\n        @value("${jdbc.driverclassname}")\n        private string driverclassname;\n        @value("${jdbc.url}")\n        private string url;\n        @value("${jdbc.username}")\n        private string username;\n        @value("${jdbc.password}")\n        private string password;\n    \n        @bean\n        public datasource datasource01() {\n            druiddatasource datasource = new druiddatasource();\n            datasource.setdriverclassname(driverclassname);\n            datasource.seturl(url);\n            datasource.setusername(username);\n            datasource.setpassword(password);\n            return datasource;\n        }\n    \n        /** 方式2 （实体对象注入\n         *  步骤：\n         *    1. 创建承载的实体 jdbcproperties对应前缀属性指定填充。通过 @configurationproperties注解实现参数填充\n         *    2. 加载配置文件 @propertysource("classpath:jdbc.properties")\n         *    3. 启动指定实体类的自动注入 @enableconfigurationproperties(jdbcproperties.class)\n         *    4. 承载实体对象自动注入 @autowired\n         */\n        @autowired\n        private jdbcproperties jdbcproperties;\n    \n        @bean\n        public datasource datasource02() {\n            druiddatasource datasource = new druiddatasource();\n            datasource.setdriverclassname(jdbcproperties.getdriverclassname());\n            datasource.seturl(jdbcproperties.geturl());\n            datasource.setusername(jdbcproperties.getusername());\n            datasource.setpassword(jdbcproperties.getpassword());\n            return datasource;\n        }\n    \n        /** 方式3 （方法参数注入\n         *  步骤：\n         *    1. 创建承载的实体 jdbcproperties对应前缀属性指定填充。通过 @configurationproperties注解实现参数填充\n         *    2. 加载配置文件 @propertysource("classpath:jdbc.properties")\n         *    3. 注解加载配置文件 @enableconfigurationproperties(jdbcproperties.class)\n         *    4. 方法参数直接应用\n         */\n        @bean\n        public datasource datasource03(jdbcproperties jdbc) {\n            druiddatasource datasource = new druiddatasource();\n            datasource.setdriverclassname(jdbc.getdriverclassname());\n            datasource.seturl(jdbc.geturl());\n            datasource.setusername(jdbc.getusername());\n            datasource.setpassword(jdbc.getpassword());\n            return datasource;\n        }\n        \n        /** 方式4 （@configurationproperties注入\n         *  创建承载的实体 jdbcproperties对应前缀属性指定填充。通过 @configurationproperties注解实现 数据直接填充\n         */\n        @bean\n        @configurationproperties(prefix = "jdbc.driver")\n        public datasource datasource04() {\n            return new druiddatasource();\n        }\n    \n    }\n    \n\n 3. controller层。自动注入，断点测试\n    \n    @restcontroller\n    public class hellocontoller {\n    \n        // bean配置注入\n        @autowired\n        private datasource datasource01;\n        // @enableconfigurationproperties 注解注入\n        @autowired\n        private datasource datasource02;\n        // @enableconfigurationproperties 方法参数注入\n        @autowired\n        private datasource datasource03;\n        // @configurationproperties注入\n        @autowired\n        private datasource datasource04;\n    \n        /**\n         *  运行时 断点查看 成员变量\n         */\n        @getmapping("/hello")\n        public string hello() {\n            return "hello";\n        }\n    \n    }\n    \n\n 4. 启用main方法调试测试\n\n\n# 配置文件\n\nspringboot 在启动时会将 resources 目录下的 application.properties 或 apllication.yml 文件 作为其默认配置文件（它们可以包含多个文件）\n\n.properties 和 .yml 的区别\n\n * 配置结构：.properties 线性结构 ；.yml 树状结构\n * 分割方式：.properties 以 . 进行分割；.yml 以 : 进行分割\n\n.properties配置文件\n\n# properties格式\nenvironments.dev.url=http://dev.bar.com\nenvironments.dev.name=developer setup\nenvironments.prod.url=http://foo.bar.com\nenvironments.prod.name=my cool app\nmy.servers[0]=dev.bar.com\nmy.servers[1]=foo.bar.com\n\n\n.yml配置文件\n\n# yaml格式\nenvironments:\n\tdev:\n\t\turl: http://dev.bar.com\n\t\tname: developer setup\n\tprod:\n\t\turl: http://foo.bar.com\n\t\tname: my cool app\nmy:\n\tservers:\n\t\t- dev.bar.com\n\t\t- foo.bar.com\n\n\n优先级\n\n目录的配置文件都会被加载，且顺序就是它们的优先级依次降低\n\n 1. file：./config/\n 2. file：./config/*/\n 3. file：./\n 4. classpath：/config/\n 5. classpath：/\n\n相同位置的 application.properties 和 application.yml ，而application.properties 更优先加载\n\n> file： 指当前项目根目录\n> \n> **classpath：**指当前项目的类路径，即 resources 目录\n\n多个配置文件存在的时候且它们有相同的配置内容情况下，springboot会根据优先级进行覆盖低级的配置，形成互补配置：\n\n * 存在相同配置内容，高级覆盖低级的配置内容\n * 存在不同的配置内容，所有配置内容都读取\n\n示例：\n\n在以上的基础进行测试\n\n\n\napplication.yml文件\n\n# 类路径下的 config 目录下\n# 端口号为8090\n# 上下文路径为 /test2\nserver:\n    port: 8090\n    servlet:\n        context-path: /test2\n#...\n\n\napplication.properties文件\n\nserver.port=8080\nserver.servlet.path=/test1\n#...\n\n\n启动 springboot，控制信息：\n\n\n\n通过浏览器访问测试\n\n\n\n> 出现以上字样，因本地 test1、test2没有对应的资源\n\n\n# session集群共享\n\nspringboot默认情况下存session到本机中 , 多台服务器不会共享session\n\n**解决方案 : **\n\nspring-session 和 redis 整合\n\n 1. 引入 redis 和 spring-session redis jar包\n 2. 配好 redis连接 和 session存储方式\n\n# redis 配置\nspring:\n    redis:\n        port: 6379\n        host: localhost\n        database: 0\n    session:\n    \tstore-type: redis\n\n\n> session的读取会通过redis进行的\n\n\n# 计划任务\n\n@enablescheduling 在配置类上使用，开启计划任务的支持\n\n 1. @enablescheduling定义指定启动类 application上\n 2. @scheduled定义指定方法 预定执行(运行频率/运行周期等配置...)\n 3. 运行即可\n\n\n# 热部署\n\n在实际开发中会频繁的修改后台类文件 , 而且每次修改都需要重新进行编译运行 , 因此非常的麻烦 .\n\nspring boot 提供了 devtools组件 , 热部署正是解决了该问题 , devtools会监听 , classpath下的文件变动 , 触发 restart类加载器加载该类 , 实现文件和配置热部署功能\n\n热部署应用\n\n 1. pon.xml\n    \n    \x3c!-- 热部署 --\x3e\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-devtools</artifactid>\n        <optional>true</optional>\n    </dependency>\n    \n\n 2. application.properties\n    \n    # 热部署\n    # 启动 热部署\n    spring.devtools.restart.enabled=true\n    # 重启目录\n    spring.devtools.restart.additional-paths=src/main/java\n    # classpath目录 修改修改不重启\n    spring.devtools.restart.exclude=static/**\n    \n\n 3. 设置启动自动构建项目 设置 -> 搜索conpile(编辑器) -> 勾选build project automatically(启动自动构建项目)\n\n 4. 设置运行时执行刷新 ==ctrl+shift+alt+/== -> 进入registry(注册表) -> 启动compiler.automake.allow.when.app.running(运行时执行)\n    \n    ps : 如果 4步骤没有该选项 , 则操作一下步骤 : 设置 -> advansed settings(高级设置) -> 勾选allow auto-make(运行时执行)\n\n> 做完以上配置 , 可以在类中边修改边测试代码啦\n\n\n# 日志\n\nspringboot 选用 slf4j 和 logback (大厂建议: slf4j)\n\nslf4j官方文档 :\n\n * https://springdoc.cn/spring-boot/features#features.logging\n * https://www.slf4j.org/manual.html\n * https://www.slf4j.org/apidocs/index.html\n\n简单日志示例 :\n\nimport org.slf4j.logger;\nimport org.slf4j.loggerfactory;\n\npublic class helloworld {\n\n  public static void main(string[] args) {\n    logger logger = loggerfactory.getlogger(helloworld.class);\n    logger.info("hello world");\n  }\n}\n\n\n# 日志级别\n\ntrace < debug < info < warn < error\n\ninfo后面的才可打印至控制台\n\n常用 trace/debug/info 三种日志输出\n\nimport org.junit.jupiter.api.test;\nimport org.slf4j.logger;\nimport org.slf4j.loggerfactory;\nimport org.springframework.boot.test.context.springboottest;\n\n@springboottest\npublic class logingapplicationtests {\n\n    // 记录器\n    logger logger = loggerfactory.getlogger(getclass());\n\n    @test\n    public void contextloads(){\n        // 日志级别\n        // trace < debug < info < warn < error\n        logger.trace("trace日志");\n        logger.debug("debug日志");\n        logger.info("info日志");\n        logger.warn("warn日志");\n        logger.error("error日志");\n    }\n\n}\n\n\n# 日志配置\n\n只需在 applicaton.properties文件 配置即可\n\n配置k                         值v                  说明\nlogging.level.com.atguigu   (boolean) true      控制台打印级别限制解除\nlogging.file.name           (string) my.log     输出日志到 指定文件(my.log)\nlogging.file.path           (string) /var/log   输出日志到 指定目录的指定文件(my.log)\nlogging.pattern.console     (string)            在控制台输出日志格式\nlogging.pattern.file        (string)            指定文件中日志输出格式\n\n> 注意 :\n> \n>  * 如果定义 loggin.path路径没有指定文件 , 则会在默认系统根路生成日志文件\n>  * 默认格式 : 日期 - 时间 - 日志级别 - 线程id - 线程名称 - 全类名 - 消息\n\n配置日志格式 :\n\n日志格式          说明\n%d            日期时间\n%thread       线程名\n%-5level      级别显示字符宽度\n%logger{50}   日志名最长50 , 否则分割\n%msg          日志消息\n%n            换行\n\n全格式 : ==%d{yyyy-mm-dd hh:mm:ss.sss} [%thread] %-5level %logger{50} - %msg%n==\n\n个人应用格式 : ==%d{mm-dd hh:mm} %-5level %msg%n==\n\n\n# 框架整合\n\nspringboot 抛弃了传统 xml 配置文件，以java程序的形式进行配置。因此其他配置整合需要应用说明\n\n\n# springmvc 整合\n\nspringboot 对 springmvc 的一些自动配置可以满足大部分需求，但也可以自定义配置类 并实现org.springframework.web.servlet.config.annotation.webmvcconfigurer接口 进行配置\n\n接口提供方法\n\n返回     方法                                                          说明\nvoid   ==addinterceptors(interceptorregistry registry)==           添加 拦截器，对请求进行拦截处理\nvoid   ==addresourcehandlers(resourcehandlerregistry registry)==   添加 或 修改静态资源\nvoid   ==addviewcontrollers(viewcontrollerregistry registry)==     无业务逻辑跳转（虚实映射重定向\nvoid   ==addcorsmappings(corsregistry registry)==                  解决跨域问题\n\n以下 springmvc配置问题 主要解决：\n\n * 修改端口\n * 静态资源加载\n * 拦截器配置\n * 虚实映射重定向\n * 跨域\n\n# 修改端口\n\n在springboot的 全局属性(application.properties文件) 进行以下配置端口：\n\n# 映射端口\nserver.port=80 \n\n\n# 静态资源加载\n\nspring boot 中 org.springframework.boot.autoconfigure.web.resourceproperties类 ，已经定义了静态资源的默认路径 ：（以下路径创建对应的目录即可直接访问\n\nprivate static final string[] classpath_resource_locations = {\n\t\t\t"classpath:/meta-inf/resources/", "classpath:/resources/",\n\t\t\t"classpath:/static/", "classpath:/public/" };\n\n\n * ==classpath:/meta-inf/resources/==\n * ==classpath:/resources/==\n * ==classpath:/static/==\n * ==classpath:/public==\n\n> classpath:/ 指定的目录是指 缓存中加载的类路径classes\n\n> 以上目录可以在项目中直接访问到指定根目录。如果自定义的资源路径则需要指定确定路径，例如：\n> \n> 项目默认的路径 : 测试访问 static/1.jpg ==localhost:8080/1.jpg==\n\n自定义静态资源路径\n\n 1. 重写方法映射 在springmvc的配置类中 重写 addresourcehandlers()方法 以下代码：\n    \n    @override\n    public void addresourcehandlers(resourcehandlerregistry registry) {\n        // 类似于 springmvc配置\n        // <mvc:resources mapping="/test/**" location="/test/"/>\n     \tregistry.addresourcehandler("/test/**").addresourcelocations("classpath:/test/");\n    }\n    \n    \n    > 如果指定实体本机文件则： ==registry.addresourcehandler("/pic/**").addresourcelocations("file:"+"d:/uploadfiles/");==\n\n 2. 修改配置文件 修改 application.properties更改规则\n    \n    # 过滤规则\n    spring.mvc.static-path-pattern=/static/**\n    # 静态资源位置\n    spring.web.resources.static-locations=classpath:/static/\n    \n    \n    > 以上是默认配置 , 可手写覆盖 , 覆盖后原有的会失效\n\n# 文件上传\n\n表单默认应用 enctype="application/x-www-form-urlencoded" , 需要改成 enctype="multipart/form-data" 进行上传文件\n\n修改默认大小限制\n\n默认每个1m , 配置修改\n\n# 单个文件最大\nspring.servlet.multipart.max-file-size=10mb\n# 单次请求最大\nspring.servlet.multipart.max-request-size=10m\n\n\n应用\n\n@restcontroller\npublic class fileuploadcontroller {\n    @postmapping("/upload")\n    public string up(string nickname, multipartfile photo , httpservletrequest request) throws ioexception {\n        system.out.println("nickname = " + nickname);\n\n        // 图片信息\n        system.out.println("图片原始名称: "+photo.getoriginalfilename());\n        system.out.println("图片类型: "+photo.getcontenttype());\n\n        string path = request.getservletcontext().getrealpath("/upload/");\n        system.out.println("path = " + path);\n\n        // 存储\n        savefile(photo,path);\n        return "上传完毕";\n    }\n\n    // 存储\n    private void savefile(multipartfile photo, string path) throws ioexception {\n\n        file dir = new file(path);\n        // 目录空则创建\n        if (!dir.exists()) {\n            dir.mkdir();\n        }\n        file file = new file(path + photo.getoriginalfilename());\n        photo.transferto(file);\n    }\n}\n\n\n# 拦截器\n\n拦截器需要自行配置 。 springmvc拦截器类配置了解\n\nspring boot 定义了 handlerinterceptor接口 , 该接口实现了自定义拦截器的功能 , 可以重写以下三个过程方法进行 :\n\n 1. 请求前 ==prehandle(httpservletrequest request, httpservletresponse response, object handler)==\n    \n    参数：handler 被拦截的控制器对象（mycontroller） 返回：是否允许放行，false拦截\n\n 2. 请求处理后 ==posthandle(httpservletrequest request, httpservletresponse response, object handler, modelandview modelandview)==\n    \n    参数：handler 被拦截的控制器对象 ；modelandview 控制器方法的返回值\n\n 3. 请求最后 ==aftercompletion(httpservletrequest request, httpservletresponse response, object handler, exception ex)== 参数：handler 被拦截的控制器对象 ；ex 控制器方法异常\n\n\n\n应用\n\n 1. 创建 myinterceptor自定义拦截器类 （模拟日志形式进行输出）\n    \n    public class myinterceptor implements handlerinterceptor {\n    \n        private logger logger = loggerfactory.getlogger(logininterceptor.class);\n        \n        @override\n        public boolean prehandle(httpservletrequest request , httpservletresponse response , object handler) {\n            logger.debug("处理器执行前执行!");\n            return true;\n        }\n        \n        @override\n        public void posthandle(httpservletrequest request , httpservletresponse response , object handler , modelandview modelandview) throws exception {\n            logger.debug("处理器执行后执行!");\n        }\n        \n        @override\n        public void aftercompletion(httpservletrequest request , httpservletresponse response , object handler , exception ex) throws exception {\n            logger.debug("跳转后执行！");\n        }\n        \n    }\n    \n\n 2. 在springmvc的配置类中 重写 addinterceptors方法 添加自定义拦截器 应用前提需要将 自定义拦截类 添加到spring容器中进行指定注入\n    \n    @configuration\n    public class springmvcconfig implements webmvcconfigurer {\n    \t@override\n    \tpublic void addinterceptors(interceptorregistry registry) {\n    \t\t// 通过registry来注册拦截器，通过addpathpatterns来添加拦截路径 (不加则拦截所有)\n    \t\tregistry.addinterceptor(new myinterceptor()).addpathpatterns("/user/**");\n    \t}\n    }\n    \n\n 3. 在 全局属性(application.properties文件) 进行添加属性（此时在控制器是看不到日志的输出） 因 记录打印 级别 : debug ，日志打印 级别 ：info\n    \n    # 设置 com.*包 的日志级别为debug \n    logging.level.com.*=debug\n    \n\n 4. 启用main方法调试测试，浏览器访问有效路径，看见控制台打印日志信息表示完成！！！\n\n# 虚实映射重定向\n\n主要意图是把 访问的uri 转换至 自定义uri ，达到重定向效果 实现需要在 springmvc的配置类中 重写 addviewcontrollers()方法 以下代码：\n\n@override\npublic void addviewcontrollers(viewcontrollerregistry registry) {\n    registry.addviewcontroller("/").setviewname("login.html");\n    registry.setorder(ordered.highest_precedence);\n}\n\n\n> 首次访问重定向值登录页面，且设置最高优先级\n\n# 跨域\n\ncors 是种 跨域资源共享的技术标准 , 为了更好的解决前端跨域请求 , cors请求分为 简单请求 / 非简单请求 分别对跨域提供支持\n\n跨域 : 当一个请求 url 的 协议/域名/端口 三者任意一个 与 当前页面url不同 称为 跨域\n\n# 简单请求\n\n请求方法 : get / post / head 未自定义的请求头 : accept / accept-language / content--language / last-event--ld / content-type content-type 的值只有以下三种 : text/plain , multipart/form-data , application/x-www-form-urlencode\n\n前端发出请求时 : cors的策略在请求头新增了个 origin字段(url) , 用于告诉服务器来自哪里\n\n后端收到请求后 :\n\n可以根据 origin字段 判断是否允许请求访问 , 如果允许 会在http头信息添加 access-control-allow-origin字段(应用端口)\n\n# 非简单请求\n\n非简单请求时 浏览器会在真实请求发出前增加一次option请求 称为预检请求\n\n预检请求将真实请求的信息 , 包括请求方法/自定义头字段/源信息 添加到http头信息字段中 , 询问服务器是否允许这样的操作\n\n前端发出请求 :\n\noptions /test http/1.1\norigin: http://www.test.com\naccess-control-request-method: get\n# 请求的自定义头字段\naccess-control-request-headers: x-custom-header\nhost: www.test.com\n\n\n后端收到请求后 : 会对 origin / access-control-request-method / access-control-request-headers 字段进行验证 , 后端请求允许通过后会返回\n\n# 真实请求 请求允许 来源url/方法/头信息\naccess-control-allow-origin: http://www.test.com\naccess-control-allow-methods: get,post,put,delete\naccess-control-allow-headers: x-custom-header\n# 允许 用户 发送/处理 cookie\naccess-control-allow-credentials: true\n# 允许 请求有效期 毫秒\naccess-control-max-age: 1728000\n\n\n# springboot解决方案\n\n解决跨域问题需要在 springmvc的配置类中 重写 addcorsmappings()方法 以下代码：\n\nspringboot 2.4.0版本前 :\n\n@override\npublic void addcorsmappings(corsregistry registry) {\n    // 允许访问的路径\n        registry.addmapping("/**")\n                // 是否发送 cookie\n                .allowcredentials(true)\n                // 允许 跨域访问的源\n                .allowedorigins("*")\n                // 允许 接收的请求类型\n                .allowedmethods("post","get")\n                // 允许 头部设置\n                .allowedheaders("*")\n                // 允许 有效期\n                .maxage(1800);\n}\n\n\nspringboot 2.4.0版本后 :\n方法名更变为 : allowedorigins => allowedoriginpatterns\n\n@override\npublic void addcorsmappings(corsregistry registry) {\n    // 允许访问的路径\n    registry.addmapping("/**")\n            // 是否发送 cookie\n            .allowcredentials(true)\n            // 允许 跨域访问的源\n            .allowedoriginpatterns("*")\n            // 允许 接收的请求类型\n            .allowedmethods("post","get")\n            // 允许 头部设置\n            .allowedheaders("*")\n            // 允许 有效期\n            .maxage(1800);\n}\n\n\n方案2 : 在启动器类加上注解 @crossorigin . 也可实现跨域功能 (ps注意版本问题)\n\n# url图片\n\n@controller\n@requestmapping(value = "/image")\npublic class imagecontroller {\n    @requestmapping(value = "/get",produces = mediatype.image_jpeg_value)\n    @responsebody\n    public byte[] getimage() throws ioexception {\n        file file = new file("d:/test.jpg");\n        fileinputstream inputstream = new fileinputstream(file);\n        byte[] bytes = new byte[inputstream.available()];\n        inputstream.read(bytes, 0, inputstream.available());\n        return bytes;\n    }\n}\n\n\n\n# jdbc 整合\n\nspringboot 中默认自动配置有 hikaricp连接池（hikaricp连接池是目前最快的连接池）\n\n 1. 引入依赖 pom.xml文件\n    \n    \x3c!--jdbc--\x3e\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-jdbc</artifactid>\n    </dependency>\n    \x3c!--测试--\x3e\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-test</artifactid>\n    </dependency>\n    \x3c!--mysql--\x3e\n    <dependency>\n        <groupid>mysql</groupid>\n        <artifactid>mysql-connector-java</artifactid>\n        <version>5.1.46</version>\n    </dependency>\n    \n    \n    > 连接数据库 mysql的依赖 ，需要添加依赖 和 自行配置版本号。因 该依赖并非是 springboot的相关组件\n\n 2. 在springboot的 全局属性(application.properties文件) 添加参数\n    \n    # 连接四大参数\n    spring.datasource.url=jdbc:mysql://localhost:3306/库名\n    spring.datasource.username=root\n    spring.datasource.password=root\n    # 可省略，springboot自动推断\n    #spring.datasource.driverclassname=com.mysql.jdbc.driver\n    #spring.datasource.hikari.idle-timeout=60000\n    #spring.datasource.hikari.maximum-pool-size=30\n    #spring.datasource.hikari.minimum-idle=10\n    \n\n 3. 创建 user实体类 （指定库中的表列属性信息）\n    \n    public class user implements serializable {\n        \n        private long id;\n        // 用户名\n        private string username;\n        // 密码\n        private string password;\n        // 姓名\n        private string name;\n        // 年龄\n        private integer age;\n        // 性别，1男性，2女性\n        private integer sex;\n        // 出生日期\n        private date birthday;\n        \n        //省略 get 、 set 和 tostring\n    }\n    \n    \n    > 表列名 和 类属性名 一致，在这一说法的前提它们支持 驼峰命名 和 下划线命名 如： (库列名) user_name -> (类属性名)username\n\n 4. 创建 jdbcdao操作类\n    \n    @repository\n    public class jdbcdao {\n        \n        @autowired\n        private jdbctemplate jdbctemplate;\n        \n        public list<user> findall() {\n            // beanpropertyrowmapper : 可将同名的字段赋值给属性 （支持驼峰、下划线）\n            return jdbctemplate.query("select * from tb_user" ,\n                    new beanpropertyrowmapper<>(user.class));\n        }\n        \n    }\n    \n\n 5. 测试\n    \n    @runwith(springrunner.class)\n    @springboottest\n    public class jdbcdaotest extends testcase {\n        \n        @autowired\n        private jdbcdao jdbcdao;\n        \n        @test\n        public void testfindall() {\n            system.out.println("jdbcdao : " + jdbcdao);\n            \n            for (user user : jdbcdao.findall()) {\n                system.out.println(user);\n            }\n        }\n        \n    }\n    \n\n\n# mybatis 整合\n\n 1. 引入依赖 pom.xml文件\n    \n    \x3c!--mybatis --\x3e\n    <dependency>\n        <groupid>org.mybatis.spring.boot</groupid>\n        <artifactid>mybatis-spring-boot-starter</artifactid>\n        <version>1.3.2</version>\n    </dependency>\n    \x3c!--测试--\x3e\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-test</artifactid>\n    </dependency>\n    \n\n 2. 在springboot的 全局属性(application.properties文件) 添加参数\n    \n    # mybatis 别名扫描\n    mybatis.type-aliases-package=com.pojo\n    # mapper.xml文件位置 (使用在有映射的前提)\n    mybatis.mapper-locations=classpath:mappers/*.xml\n    \n\n 3. 创建 user实体类 （指定库中的表列属性信息）\n    \n    package com.pojo;\n    \n    import javax.persistence.*;\n    import java.io.serializable;\n    import java.util.date;\n    \n    public class user implements serializable {\n        \n        private long id;\n        // 用户名\n        private string username;\n        // 密码\n        private string password;\n        // 姓名\n        private string name;\n        // 年龄\n        private integer age;\n        // 性别，1男性，2女性\n        private integer sex;\n        // 出生日期\n        private date birthday;\n        \n        //省略 get 、 set 和 tostring\n    }\n    \n    \n    > 表列名 和 类属性名 一致，mybatis不支持 驼峰、下划线 命名方式\n\n 4. 创建 usermapping接口 ，全限定名 com.mapping.usermapping\n    \n    package com.dao;\n    \n    import com.pojo.user;\n    import java.util.list;\n    \n    public interface usermapping {\n        list<user> findall();\n    }\n    \n\n 5. 创建 usermapping.xml映射文件\n    \n    <?xml version="1.0" encoding="utf-8"?>\n    <!doctype mapper\n            public "-//mybatis.org//dtd mapper 3.0//en"\n            "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n    <mapper namespace="com.mapping.usermapping">\n    \n        <select id="findall" resulttype="user">\n            select * from tb_user\n        </select>\n    \n    </mapper>\n    \n\n 6. mapper映射加载 。加载方式有两种\n    \n    1. 使用 @mapping注解 在 usermapping接口 添加 @mapper注解 进行识别\n       \n       @mapper\n       public interface usermapper {\n           ....\n       }\n       \n    \n    2. 使用 @mapperscan注解 扫描的包 在 @springbootapplication注解下的启动类，添加@mapperscan注解 value参数为 扫描的包路径\n       \n       package com;\n       import org.mybatis.spring.annotation.mapperscan;\n       import org.springframework.boot.springapplication;\n       import org.springframework.boot.autoconfigure.springbootapplication;\n       \n       // 启动类\n       @springbootapplication\n       @mapperscan("com.mapping")\n       public class application {\n           public static void main(string[] args) {\n               springapplication.run(application.class , args);\n           }\n       }\n       \n\n 7. 测试\n    \n    package com.dao;\n    \n    import junit.framework.testcase;\n    import org.junit.test;\n    import org.junit.runner.runwith;\n    import org.springframework.beans.factory.annotation.autowired;\n    import org.springframework.boot.test.context.springboottest;\n    import org.springframework.test.context.junit4.springrunner;\n    \n    @runwith(springrunner.class)\n    @springboottest\n    public class userdaotest extends testcase {\n        \n        @autowired\n        private usermapping usermapping;\n        \n        @test\n        public void findall() {\n             for (user user : usermapping.findall()) {\n                system.out.println(user);\n            }\n        }\n    }\n    \n\n\n# tk-mybatis 整合\n\n由于mybatis的使用会出现一些功能上的问题，和大量的xml文件。当库表结构进行改动，则实体和xml文件都需要重新更改。因此为了避免以上情况 ，应用 tk-mybatis框架\n\n使用前注意事项：\n\n * tk-mybatis依赖引入 后就无需再引入mybatis依赖\n * 支持 驼峰、下划线 命名方式，需要手动纠正\n * 实体类中 主键一定要映射 @generatedvalue注解 映射主键策略（该字段自增、...等其他索引约束）\n * 类与表不匹配的情况，使用 jpa注解 纠正（名相同无需添加注解）\n   1. 类名 = 表名 ，在类上添加 @table注解 name参数为 纠正的表名\n   2. 属性名 = 字段名，在属性上添加 @column注解 name参数为 纠正的字段名\n * 如果 前面有导入 mybatis构件的类 ，需要更改为 tk-mybatis构件的类\n * 接口一旦继承了 tk.mybatis.mapper.common.mapper接口 就可实现以下mapper通用方法\n\nmapper通用方法\n\n返回        方法                                                             说明\nlist<t>   select(t record)                                               查询 根据实体类属性值进行查询\nt         selectbyprimarykey(object key)                                 查询 根据主键进行查询\nlist<t>   selectall()                                                    查询 所有结果\nt         selectone(t record)                                            查询 根据实体类属性值进行查询，只能返回一个，多个则异常\nint       selectcount(t record)                                          查询 表中的总条数\nint       insert(t record)                                               插入 一个实体类 ，null属性值也会保存，而不是库中的默认值\nint       insertselective(t record)                                      插入 一个实体类 ，null属性值不会保存，而应用库中的默认值\nint       updatebyprimarykey(t record)                                   更新 根据主键更新所有字段，null属性值也会被更新\nint       updatebyprimarykeyselective(t record)                          更新 根据主键更新字段，null属性值不会被更新\nint       delete(t record)                                               删除 根据实体类属性值进行条件删除\nint       deletebyprimarykey(object key)                                 删除 根据主键进行删除\nlist<t>   selectbyexample(object example)                                查询 根据example条件进行查询\nint       selectbyexample(object example)                                查询 根据example条件进行查询总条数\nint       updatebyexample(@param("record") t record, @param("example")   更新 根据example条件进行更新为 record实体类 全部属性，null属性值也会被更新\n          object example)\nint       updatebyexampleselective(@param("record") t record,            更新 根据example条件进行更新为 record实体类 全部属性，null属性值不会被更新\n          @param("example") object example)\nint       deletebyexample(object example)                                删除 根据example条件进行删除\n\n# 应用实现\n\n以下应用实例：\n\n数据库展示\n\ntb_user表 （其他数据自行引入）\n\n字段名         类型        主键\nid          bigint    t\nuser_name   varchar   f\npassword    varchar   f\nname        varchar   f\nage         int       f\nsex         int       f\nbirthday    date      f\n\n 1. 引入依赖 pom.xml\n    \n    <dependency>\n        <groupid>tk.mybatis</groupid>\n        <artifactid>mapper-spring-boot-starter</artifactid>\n        <version>2.0.2</version>\n    </dependency>\n    \n\n 2. 创建 user实体类 （指定库中的表列属性信息）\n    \n    package com.pojo;\n    \n    import javax.persistence.*;\n    import java.io.serializable;\n    import java.util.date;\n    \n    @table(name = "tb_user")\n    public class user implements serializable {\n        \n        //主键 ，主键策略为 自增\n        @id\n        @generatedvalue(strategy = generationtype.identity)\n        private long id;\n        // 用户名\n        @column(name = "user_name")\n        private string username;\n        // 密码\n        private string password;\n        // 姓名\n        private string name;\n        // 年龄\n        private integer age;\n        // 性别，1男性，2女性\n        private integer sex;\n        // 出生日期\n        private date birthday;\n        \n        //省略 get 、 set 和 tostring\n    }\n    \n\n 3. 创建 usermapping接口 ，全限定名 com.mapping.usermapping （继承接口即可实现mapper通用方法）\n    \n    package com.mapping;\n    \n    import com.domain.user;\n    import tk.mybatis.mapper.common.mapper;\n    \n    public interface usermapping extends mapper<user> {\n    }\n    \n    \n    > 不要忘记应用的是 tk.mybatis.mapper.common.mapper接口 构件\n\n 4. 使用 @mapperscan注解 扫描的包 在 @springbootapplication注解下的启动类，添加@mapperscan注解 value参数为 扫描的包路径\n    \n    package com;\n    // import org.mybatis.spring.annotation.mapperscan;\n    import tk.mybatis.spring.annotation.mapperscan;\n    import org.springframework.boot.springapplication;\n    import org.springframework.boot.autoconfigure.springbootapplication;\n    \n    // 启动类\n    @springbootapplication\n    @mapperscan("com.mapping")\n    public class application {\n        public static void main(string[] args) {\n            springapplication.run(application.class , args);\n        }\n    }\n    \n    \n    > 不要忘记应用的是 tk.mybatis.mapper.common.mapper接口 构件\n\n 5. 测试\n    \n    package com.mapping;\n    \n    import com.domain.user;\n    import junit.framework.testcase;\n    import org.junit.test;\n    import org.junit.runner.runwith;\n    import org.springframework.beans.factory.annotation.autowired;\n    import org.springframework.boot.test.context.springboottest;\n    import org.springframework.test.context.junit4.springrunner;\n    import tk.mybatis.mapper.entity.example;\n    import java.util.list;\n    \n    @runwith(springrunner.class)\n    @springboottest\n    public class usermappingtest extends testcase {\n        \n        @autowired\n        private usermapping usermapping;\n        \n        //查所有\n        @test\n        public void testfindall() {\n            usermapping.selectall().foreach(user -> {\n                system.out.println(user);\n            });\n        }\n        \n        //查id\n        @test\n        public void testfindbyid() {\n            user user = usermapping.selectbyprimarykey(5);\n            system.out.println("user : " + user);\n        }\n        \n        //插入\n        @test\n        public void testinsert(){\n            user user = new user();\n            user.setusername("lishi");\n            user.setname("李四");\n            user.setpassword("1");\n            user.setage(21);\n            user.setsex(1);\n            int i = usermapping.insertselective(user);\n            system.out.println("插入结果 : " + i);\n        }\n        \n        // example条件查询\n        @test\n        public void testfindbyexample() {\n            example example = new example(user.class);\n            \n            // 展示1\n            // sql：select * from tb_user where ( name like \'%张%\' )\n            example.createcriteria().andlike("name","%张%");\n            \n            // 展示2\n            // sql：select * from tb_user where ( name like \'%张%\' and password = \'1\' )\n            // example.createcriteria().andlike("name","%张%").andequalto("password","1");\n            usermapping.selectbyexample(example).foreach(user -> {\n                system.out.println(user);\n            });\n        }\n    }\n    \n\n# 自定义映射文件查询\n\n自定义映射文件用于进行复杂的sql语句进行对库编辑\n\n应用前说明：\n\n * 应用后 驼峰、下划线 命名失效\n\n应用实现 在以上代码原有的基础上进行编辑！\n\n 1. 在springboot的 全局属性(application.properties文件) 添加参数\n    \n    # mybatis 别名扫描\n    mybatis.type-aliases-package=com.pojo\n    # mapper.xml文件位置 (使用在有映射的前提)\n    mybatis.mapper-locations=classpath:mappers/*.xml\n    \n\n 2. 创建 usermapper.xml文件 资源路径 resources/mappers/usermapper.xml\n    \n    <?xml version="1.0" encoding="utf-8"?>\n    <!doctype mapper\n            public "-//mybatis.org//dtd mapper 3.0//en"\n            "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n    <mapper namespace="com.mapping.usermapping">\n    \n        <select id="findbyuser" resulttype="user">\n            select * from\n            tb_user\n            <where>\n                <if test="name != null">\n                    name like \'%${name}%\'\n                </if>\n                <if test="password != null">\n                    and password like \'%${password}%\'\n                </if>\n            </where>\n        </select>\n    \n    </mapper>\n    \n    \n    > 注意 mapper节点 映射指定的接口路径\n\n 3. 编辑 usermapping接口 ，全限定名 com.mapping.usermapping\n    \n    package com.mapping;\n    \n    import com.domain.user;\n    import tk.mybatis.mapper.common.mapper;\n    import java.util.list;\n    \n    public interface usermapping extends mapper<user> {\n        // 自定义复杂sql方法\n        public list<user> findbyuser(user user);\n    }\n    \n\n 4. 测试， 在 usermappingtest测试类 中\n    \n    // 自定义方法\n    @test\n    public void testfindbyuser() {\n        \n        user user = new user();\n        user.setname("张");\n        // user.setpassword("1");g\n        usermapping.findbyuser(user).foreach(u -> {\n            system.out.println(u);\n        });\n        \n    }\n    \n\n\n# 视图框架整合\n\nthymeleaf是用于 web 和 独立环境 的java模板引擎（类似于jsp）\n\nspringboot 为 thymeleaf 提供一系列的默认配置，thymeleaf依赖 一旦导入，项目会自动配置\n\n优点：\n\n * thymeleaf 在有网络和无网络的环境下皆可运行，通过美工实现页面数据的动静结合 有网络则覆盖静态显示的内容数据 无网络则显示默认静态的内容数据\n * springboot完美整合，springboot默认整合thymeleaf\n\n# 表达式\n\nthymeleaf有3表达式\n\n * 变量表达式${...}\n * 选择表达式*{...}\n * url表达式@{...}\n\n# 变量表达式\n\n==${...}== 变量表达式可以直接过去域中的数据。接收方式和jsp一样，但使用呈现方式不一样\n\n示例：（后端响应变量 "good" : "thymeleaf very good!"）\n\n\x3c!--响应的变量 good的值为 “thymeleaf very good!” --\x3e\n<h5>表达式</h5>\n<span>${good}</span><br>\n<span th:text="${good}">你好 thymleaf</span><br>\n<span>${good}</span><br>\n\n\x3c!-- 结果预览\n表达式\n${good}\nthymeleaf very good!\n${good}\n--\x3e\n\n\n# 选择表达式\n\n==*{...}== 选择表达式 也称 星号表达式，不过这一操作需要预先通过选择一个对象进行充当上下文容器的变量执行\n\n示例：（后端响应变量 {"cat" : "猫","dog" : "狗"}）\n\n<div th:object="${pet}">\n    <span th:text="*{dog}"></span> <br>\n    <span th:text="*{cat}"></span> <br>\n</div>\n\n\x3c!-- 浏览器预览结果\n狗\n猫\n--\x3e\n\n\n# url表达式\n\nurl表达式 是把一个有效的信息 添加到url，也是url重写\n\n重写形式有3种：\n\n * url表达式\n * 文本替换\n * 字符串拼接\n\n\x3c!-- url表达式 （无参\n\t结果：href="main.html" \n--\x3e\n<a th:href="@{/main}">\n\n\x3c!-- url表达式（有参\n\t后端响应：{user.id : 1,user.name : "张三"}\n\t结果：href="/del?id=1&name=张三" \n--\x3e\n<a th:href="@{/del(id=*{id},name=${user.name})}">删除</a>\n    \n\x3c!-- 文本替换\n\t结果：href="/update/1" \n--\x3e\n<a th:href="@{|/update/*{id}|}">修改</a>\n\n\x3c!-- 字符串拼接\n\t 结果：href="/approve/1" \n--\x3e\n<a th:href="\'/approve/\'+*{id}">审核</a>\n\n\n# th属性\n\n关键字           功能介绍                     案例\nth:id         替换id                     <input th:id="\'xxx\' + ${collect.id}"/>\nth:text       文本替换                     <p th:text="${user.name}">张三</p>\nth:utext      支持html的文本替换              <p th:utext="${htmlcontent}">content</p>\nth:object     替换对象                     <div th:object="${user}">\nth:value      属性赋值                     <input th:value="${user.id}"/>\nth:with       变量赋值运算                   <div th:with="iseven=${prodstat.count}%2==0"></div>\nth:style      设置样式                     th:style="\'display:\' + @{(${sitrue} ? \'none\' :\n                                       \'inline-block\')} + \'\'"\nth:onclick    点击事件                     th:onclick="\'getcollect()\'"\nth:each       属性赋值                     <tr th:each="user,userstat:${users}"/>\nth:if         判断条件                     <a th:if="${userid == collect.userid}" >\nth:unless     和th:if判断相反               <a th:href="@{/login}" th:unless=${session.user !=\n                                       null}>login</a>\nth:href       链接地址                     <a th:href="@{/login}" th:unless=${session.user !=\n                                       null}>login</a> />\nth:switch     多选择 配合th:case 使用         <div th:switch="${user.role}">\nth:case       th:switch的一个分支           <p th:case="\'admin\'">user is an administrator</p>\nth:fragment   布局标签，定义一个代码片段，方便其它地方引用   <div th:fragment="alert">\nth:include    布局标签，替换内容到引入的文件          <head th:include="layout :: htmlhead"\n                                       th:with="title=\'xx\'"></head> />\nth:replace    布局标签，替换整个标签到引入的文件        <div th:replace="fragments/header :: title"></div>\nth:selected   selected选择框 选中           th:selected="(${xxx.id} == ${configobj.dd})"\nth:src        图片类地址引入                  <img class="img-responsive" alt="app logo"\n                                       th:src="@{/img/logo.png}" />\nth:inline     定义js脚本可以使用变量             <script type="text/javascript" th:inline="javascript">\nth:action     表单提交的地址                  <form action="subscribe.html" th:action="@{/subscribe}">\nth:remove     删除某个属性                   <tr th:remove="all">\n                                       1. all: 删除所有\n                                       2. body: 不删本身, 删除其所有的子标签\n                                       3. tag: 删除本身，但不删除它的子标签\n                                       4. all-but-first: 仅保留第一个子标签，其他删除\n                                       5. none: 什么也不做\nth:attr       设置标签属性，多个属性可以用逗号分隔       <img th:attr="src=@{/image/aa.jpg},title=#{logo}"/>\n                                       一般比较少使用（难以阅读\n\n常用th属性 示例：\n\n条件判断 th:if/th:unless 判断属性是否成立，如果成立则显示\n\n\x3c!-- 响应：{"numbers":[1,2,3]} --\x3e\n<a th:if="${numbers.length > 0}">测试1</a><br>\n<a th:if="${numbers.length <= 0}">测试2</a><br>\n<a th:unless="${numbers.length <= 0}">测试3</a><br>\n\n\x3c!-- 预览结果\n测试1\n\n测试3\n--\x3e\n\n\nfor循环 th:each\n\n组成拆解：==...==\n\nstatus状态对象的属性：\n\n类型        status属性   说明\nint       index      迭代当前对象（从0开始）\nint       count      迭代当前对象（从1开始）\nint       size       被迭代的对象大小\n-         current    当前迭代变量\nboolean   even       当前迭代值 是否为 偶数\nboolean   odd        当前迭代值 是否为 奇数\nboolean   first      当前迭代值 是否为 第一个\nboolean   last       当前迭代值 是否为 最后一个\n\n\x3c!-- \n\t响应："users":[{\n\t\t\t"id":"1",\n\t\t\t"name":"张三",\n\t\t\t"username":"zhangsan",\n\t\t\t"age":"23",\n\t\t\t"sex":1,\n\t\t\t"birthday":"1980-02-30"\n\t\t},...]\n--\x3e\n<tr th:each="user ,status : ${users}" th:object="${user}">\n    <td th:text="${status.count}">1</td>\n    <td th:text="*{id}">233</td>\n    <td data-th-text="*{name}">张三</td>\n    <td th:text="${user.username}">zhangsan</td>\n    <td th:text="${user.age}">20</td>\n    <td th:text="${user.sex} == 1 ? \'男\': \'女\'">男</td>\n    <td th:text="${user.birthday}">1980-02-30</td>\n    <td>\n        \x3c!--不同参数 形式--\x3e\n        <a th:href="@{/del(id=*{id},name=${user.name})}">删除</a>\n        \x3c!--文本替换 形式--\x3e\n        <a th:href="@{|/update/*{id}|}">修改</a>\n        \x3c!--字符串拼接 形式--\x3e\n        <a th:href="\'/approve/\'+*{id}">审核</a>\n    </td>\n</tr>\n\n\n# 内置对象\n\nthymeleaf提供了一系列utiliy对象，可直接通过#进行访问：\n\n * strings： 字符串工具对象，常用方法有：equals、equalsignorecase、length、trim、touppercase、tolowercase、indexof、substring、replace、startswith、endswith，contains 和 containsignorecase 等\n * numbers： 数字工具对象，常用的方法有：formatdecimal 等\n * bools： 布尔工具对象，常用的方法有：istrue 和 isfalse 等\n * arrays： 数组工具对象，常用的方法有：toarray、length、isempty、contains 和 containsall 等；\n * lists/sets： list/set 集合工具对象，常用的方法有：tolist、size、isempty、contains、containsall 和 sort 等\n * maps： map 集合工具对象，常用的方法有：size、isempty、containskey 和 containsvalue 等\n * dates： 日期工具对象，常用的方法有：format、year、month、hour 和 createnow 等\n\n<h4>dates</h4>\n<p th:text="${#dates.createnow()}">获取当前日期</p>\n<p th:text="${#dates.format(#dates.createnow())}">日期格式化</p>\n<p th:text="${#dates.format(#dates.createnow(),\'yyyy-mm-dd hh:mm:ss\')}">日期自定义格式化</p>\n\x3c!-- 预览结果\ndates\nmon sep 20 14:57:12 cst 2021\n2021年9月20日 下午02时57分12秒\n2021-09-20 14:57:12\n--\x3e\n\n\x3c!-- 响应："good":"thymeleaf very good!"--\x3e\n<h4>strings</h4>\n<p th:text="${#strings.substring(good, 6, 9)}">截取字符串</p>\n<p th:text="${#strings.length(good)}">获得长度</p>\n<p th:text="${#strings.randomalphanumeric(6)}">随机字符串</p>\n<p th:text="${#strings.equals(good, \'hello\')}">比较</p>\n\x3c!--  预览结果\neaf\n20\nni5qpi\nfalse\n--\x3e\n\n\n更多了解：thymeleaf （19 appendix b: expression utility objects）\n\n# 首次应用\n\n前提说明：\n\n * 在 .html文件 需要添加以下的命名空间（否则无法识别 th属性标签 == .... ==\n\n * 后端的 资源文件 需要存放指定目录 classpath:/templates/*\n   \n   默认前缀： templates/ 默认后缀： .html\n   \n   \n\n * 测试优化。在修改页面的时，由于缓存并非立即呈现效果，因此可通过添加以下全参关闭缓存\n   \n   # 开发阶段关闭 thymeleaf的模板缓存\n   spring.thymeleaf.cache=false\n   \n\n应用步骤：\n\n 1. 引入依赖\n    \n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-thymeleaf</artifactid>\n    </dependency>\n    \n\n 2. 创建前端文件。路径：==templates/thymeleafview.html==\n    \n    <!doctype html>\n    <html lang="en" xmlns:th="http://www.w3.org/1999/xhtml">\n    <head>\n        <meta charset="utf-8">\n        <title>title</title>\n    </head>\n    <body>\n        <ul>\n            <li th:each="user,userstat : ${userlist}" th:object="${user}">\n                <span th:text="*{id}"></span> ==\n                <span th:text="*{name}"></span> ==\n                <span th:text="${user.age}"></span>\n            </li>\n        </ul>\n    </body>\n    </html>\n    \n\n 3. 封装 user实体类\n    \n    public class user {\n        string id;\n        string name;\n        int age;\n        \n        // 构造全参/无参 、set 、get方法省略。。。\n    }\n    \n\n 4. 编辑 controller控制器\n    \n    @controller\n    public class hellocontroller {\n    \n        @getmapping("/findall")\n        public modelandview findall() {\n            modelandview view = new modelandview();\n    \n            list<user> list = new arraylist<user>(){{\n                add(new user("2","张三",33));\n                add(new user("3","李四",34));\n                add(new user("4","王五",35));\n                add(new user("5","赵六",36));\n            }};\n    \n            view.addobject("userlist",list);\n            view.setviewname("thymeleafview");\n            return view;\n        }\n    }\n    \n\n 5. 启动直接访问即可，结果示例\n    \n    <body>\n        <ul>\n            <li>\n                <span>2</span> ==\n                <span>张三</span> ==\n                <span>33</span>\n            </li>\n            <li>\n                <span>3</span> ==\n                <span>李四</span> ==\n                <span>34</span>\n            </li>\n            <li>\n                <span>4</span> ==\n                <span>王五</span> ==\n                <span>35</span>\n            </li>\n            <li>\n                <span>5</span> ==\n                <span>赵六</span> ==\n                <span>36</span>\n            </li>\n        </ul>\n    </body>\n    \n\n\n# shiro整合\n\nshiro是开源的安全框架，可以完全处理身份验证，授权，会话加密等\n\n这里只讲解 springboot 整合 shrio，进一步了解，进入shiro文章进行深入学习\n\n应用步骤：\n\n 1. 引入依赖\n    \n    \x3c!-- shiro --\x3e\n    <dependency>\n        <groupid>org.apache.shiro</groupid>\n        <artifactid>shiro-spring-boot-web-starter</artifactid>\n        <version>1.4.0-rc2</version>\n    </dependency>\n    \n\n 2. 创建配置类 shiroconfig\n    \n    @configuration\n    @component\n    public class shiroconfig {\n    \n        @bean\n        public shirofilterfactorybean shirofilterfactorybean(org.apache.shiro.mgt.securitymanager securitymanager) {\n    \n            shirofilterfactorybean shirofilterfactorybean = new shirofilterfactorybean();\n            shirofilterfactorybean.setsecuritymanager(securitymanager);\n    \n            // 定义默认路径\n            shirofilterfactorybean.setloginurl("/dologin");\n            shirofilterfactorybean.setsuccessurl("/index");\n            shirofilterfactorybean.setunauthorizedurl("/refuse.html");\n    \n            // 过滤器链\n            linkedhashmap<string, string> filterchaindefinitionmap = new linkedhashmap<>();\n            filterchaindefinitionmap.put("/", "anon");\n            filterchaindefinitionmap.put("/static/css/**", "anon");\n            filterchaindefinitionmap.put("/static/js/**", "anon");\n            filterchaindefinitionmap.put("/static/images/**", "anon");\n            filterchaindefinitionmap.put("/static/register", "anon");\n            filterchaindefinitionmap.put("/toregister", "anon");\n            filterchaindefinitionmap.put("/login.html", "anon");\n            filterchaindefinitionmap.put("/logout", "logout");\n            filterchaindefinitionmap.put("/**", "authc");\n    \n            // 配置过滤器\n            shirofilterfactorybean.setfilterchaindefinitionmap(filterchaindefinitionmap);\n    \n            // 自定义过滤器\n            // map<string, filter> filters = new hashmap<>();\n            // filters.put("authc", new customformauthenticationfilter());\n            // shirofilterfactorybean.setfilters(filters);\n    \n            return shirofilterfactorybean;\n        }\n    \n        @bean\n        public shirofilterchaindefinition shirofilterchaindefinition() {\n            defaultshirofilterchaindefinition chaindefinition = new defaultshirofilterchaindefinition();\n    \n            // logged in users with the \'admin\' role\n            //chaindefinition.addpathdefinition("/admin/**", "authc, roles[admin]");\n    \n            // logged in users with the \'document:read\' permission\n            //chaindefinition.addpathdefinition("/docs/**", "authc, perms[document:read]");\n    \n            // all other paths require a logged in user\n            //chaindefinition.addpathdefinition("/logout", "logout");\n            //chaindefinition.addpathdefinition("/**", "authc");\n            return chaindefinition;\n        }\n    \n        @bean\n        public defaultwebsecuritymanager securitymanager(realm realm) {\n            defaultwebsecuritymanager securitymanager = new defaultwebsecuritymanager();\n            securitymanager.setrealm(realm);\n    //       securitymanager.setremembermemanager(remembermemanager());\n    //       securitymanager.setcachemanager(getehcachemanager());\n    //       securitymanager.setsessionmanager(sessionmanager());\n            return securitymanager;\n        }\n    \n        @bean\n        public realm shirorealm() {\n            return new shirorealm();\n        }\n    \n    //    /**\n    //     * 密码校验规则hashedcredentialsmatcher\n    //     * 这个类是为了对密码进行编码的 ,\n    //     * 防止密码在数据库里明码保存 , 当然在登陆认证的时候 ,\n    //     * 这个类也负责对form里输入的密码进行编码\n    //     * 处理认证匹配处理器：如果自定义需要实现继承hashedcredentialsmatcher\n    //     */\n    //    @bean("hashedcredentialsmatcher")\n    //    public hashedcredentialsmatcher hashedcredentialsmatcher() {\n    //        hashedcredentialsmatcher credentialsmatcher = new hashedcredentialsmatcher();\n    //        //指定加密方式为md5\n    //        credentialsmatcher.sethashalgorithmname("md5");\n    //        //加密次数\n    //        credentialsmatcher.sethashiterations(1024);\n    //        credentialsmatcher.setstoredcredentialshexencoded(true);\n    //        return credentialsmatcher;\n    //    }\n    \n    \n    //    @bean("authrealm")\n    //    @dependson("lifecyclebeanpostprocessor")//可选\n    //    public authrealm authrealm(@qualifier("hashedcredentialsmatcher") hashedcredentialsmatcher matcher) {\n    //        authrealm authrealm = new authrealm();\n    //        authrealm.setauthorizationcachingenabled(false);\n    //        authrealm.setcredentialsmatcher(matcher);\n    //        return authrealm;\n    //    }\n    }\n    \n\n 3. 创建领域\n    \n    public class shirorealm extends authorizingrealm {\n    \n        @autowired\n        private auctionuserservice auctionuserservice;\n    \n        @override\n        protected authorizationinfo dogetauthorizationinfo(principalcollection principals) {\n            return null;\n        }\n    \n        /**\n         * 身份验证\n         * @param token 包含用户主体和凭据的身份验证令牌。\n         * @return\n         * @throws authenticationexception\n         */\n        @override\n        protected authenticationinfo dogetauthenticationinfo(authenticationtoken token) throws authenticationexception {\n            string username = (string) token.getprincipal();\n            auctionuser user = auctionuserservice.finduserbyname(username);\n            if (user == null) return null;\n            return new simpleauthenticationinfo(user, user.getuserpassword(),"shirorealm");\n        }\n    }\n    \n\n 4. 三个步骤即可实现引入shiro（如果需要其他功能可以在配置类中进行添加！）\n\n\n# mybatis plus整合\n\nmybatis plus是mybatis的增强工具，在mybatis的基础上做了增强不改变的开发实现，从而提高效率。\n\n官方文档：https://baomidou.com/pages/24112f/\n\n特点：\n\n * 无侵入。只做增强不做改变\n * 消耗小。启动只注入curd\n * 增强crud操作。内置通用mapper\n * 内置代码生成器。采用maven插件生成映射\n * 分页插件多功能。支持多种数据库\n * 内置全局拦截器。可分析增删改过程进行阻断\n\n# 首次应用\n\n应用大致流程 :\n\n 1. 引入pon.xml依赖\n 2. 更改库数据相关配置\n 3. 启动器类 添加@mapperscan注解\n\n应用\n\n 1. 引入依赖 pom.xml\n    \n    \x3c!-- mybatisplus --\x3e\n    <dependency>\n        <groupid>com.baomidou</groupid>\n        <artifactid>mybatis-plus-boot-starter</artifactid>\n        <version>3.4.2</version>\n    </dependency>\n    \x3c!-- mysql驱动 --\x3e\n    <dependency>\n        <groupid>mysql</groupid>\n        <artifactid>mysql-connector-java</artifactid>\n        <version>5.1.48</version>\n    </dependency>\n    \x3c!-- 连接池 --\x3e\n    <dependency>\n        <groupid>com.alibaba</groupid>\n        <artifactid>druid-spring-boot-starter</artifactid>\n        <version>1.1.20</version>\n    </dependency>\n    \n\n 2. 配置文件 application\n    \n    # mybatis\n    # 连接池\n    spring.datasource.type=com.alibaba.druid.pool.druiddatasource\n    # 驱动\n    spring.datasource.driver-class-name=com.mysql.jdbc.driver\n    # url/账号/密码\n    spring.datasource.url=jdbc:mysql://localhost:3306/test?usessl=false\n    spring.datasource.username=root\n    spring.datasource.password=root\n    mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.stdoutimpl\n    \n    \n    > 这里连接库的用户名和密码可以省略不写，或者随意设定\n\n 3. 创建 库数据 和 创建实体类 (省略\n\n 4. 创建 usermapper接口\n    \n    @mapper\n    public interface usermapper extends basemapper<user> {}\n    \n    \n    > 继承实现mapper通用方法\n\n 5. springboot 启动类 添加注解 @mapperscan\n    \n    @springbootapplication\n    @mapperscan("com.mapper")\n    public class application {\n        public static void main(string[] args) {\n            springapplication.run(application.class , args);\n        }\n    }\n    \n    \n    > @mapperscan注解 扫描 mapper文件夹 的包路径\n\n 6. 测试\n    \n    // 启动器spring测试启动环境\n    @runwith(springrunner.class)\n    // 启动类\n    @springboottest(classes = application.class)\n    public class usermappertest {\n        \n        @autowired\n        private usermapper usermapper;\n        \n        @test\n        public void testfindbyall() {\n            \n            list<user> users = usermapper.selectlist(null);\n            users.foreach(system.out::println);\n            // assert.assertequals(26 , users.size());\n        }\n    }\n    \n\n# 注解配置\n\n常用注解说明：\n\n注解            值               说明\n@tablename    value：纠正表名      表名注解\n@tableid      value：纠正主键字段名   主键注解\n              type：主键策略类型\n@tablefield   value：纠正字段名     字段注解(非主键)\n              exist：是否为库字段\n              fill：默认值填充\n\n更多注解：https://baomidou.com/pages/223848/\n\n> ps : @tableid/@tablefield 纠正后 set方法也需要修改 , 因 使用set注入 , 否则失效\n\n# 内置 crud\n\n官网说明 : 更多详细\n\n# 新增\n\n@test\n    public void testinsert() {\n        assert.asserttrue(usermapper.insert(new user().setname("张三").setage(3)) > 0);\n        usermapper.selectlist(null).foreach(system.out::println);\n    }\n    /*\n        user(id=1, name=jone, age=18, email=test1@baomidou.com, phone=null)\n        user(id=2, name=jack, age=20, email=test2@baomidou.com, phone=null)\n        user(id=3, name=tom, age=28, email=test3@baomidou.com, phone=null)\n        user(id=4, name=sandy, age=21, email=test4@baomidou.com, phone=null)\n        user(id=5, name=kaikeba, age=331, email=test4@baomidou.com, phone=null)\n        user(id=6, name=billie, age=24, email=test5@baomidou.com, phone=null)\n        user(id=7, name=张三, age=3, email=null, phone=null)\n     */\n\n\n# 删除\n\n@test\n    public void testdelbyid() {\n        assert.asserttrue(usermapper.deletebyid(3) > 0);\n        usermapper.selectlist(null).foreach(system.out::println);\n    }\n    /*\n        user(id=1, name=jone, age=18, email=test1@baomidou.com, phone=null)\n        user(id=2, name=jack, age=20, email=test2@baomidou.com, phone=null)\n        user(id=4, name=sandy, age=21, email=test4@baomidou.com, phone=null)\n        user(id=5, name=kaikeba, age=331, email=test4@baomidou.com, phone=null)\n        user(id=6, name=billie, age=24, email=test5@baomidou.com, phone=null)\n     */\n    \n    @test\n    public void testdeletes1() {\n        assert.asserttrue(usermapper.delete(new querywrapper<user>().like("name","j")) > 0);\n        usermapper.selectlist(null).foreach(system.out::println);\n    }\n    /*\n        user(id=3, name=tom, age=28, email=test3@baomidou.com, phone=null)\n        user(id=4, name=sandy, age=21, email=test4@baomidou.com, phone=null)\n        user(id=5, name=kaikeba, age=331, email=test4@baomidou.com, phone=null)\n        user(id=6, name=billie, age=24, email=test5@baomidou.com, phone=null)\n     */\n    \n    @test\n    public void testdeletes2() {\n        assert.asserttrue(usermapper.delete(wrappers.<user>query().like("name","j")) > 0);\n        usermapper.selectlist(null).foreach(system.out::println);\n    }\n    /*\n        user(id=3, name=tom, age=28, email=test3@baomidou.com, phone=null)\n        user(id=4, name=sandy, age=21, email=test4@baomidou.com, phone=null)\n        user(id=5, name=kaikeba, age=331, email=test4@baomidou.com, phone=null)\n        user(id=6, name=billie, age=24, email=test5@baomidou.com, phone=null)\n     */\n    \n    @test\n    public void testdeletes3() {\n        assert.asserttrue(usermapper.delete(wrappers.<user>query().lambda().like(user::getname,"j")) > 0);\n        usermapper.selectlist(null).foreach(system.out::println);\n    }\n    /*\n        user(id=3, name=tom, age=28, email=test3@baomidou.com, phone=null)\n        user(id=4, name=sandy, age=21, email=test4@baomidou.com, phone=null)\n        user(id=5, name=kaikeba, age=331, email=test4@baomidou.com, phone=null)\n        user(id=6, name=billie, age=24, email=test5@baomidou.com, phone=null)\n    */\n    \n    @test\n    public void testdeletes4() {\n        assert.asserttrue(usermapper.delete(new querywrapper<user>().lambda().like(user::getname,"j")) > 0);\n        usermapper.selectlist(null).foreach(system.out::println);\n    }\n    /*\n        user(id=3, name=tom, age=28, email=test3@baomidou.com, phone=null)\n        user(id=4, name=sandy, age=21, email=test4@baomidou.com, phone=null)\n        user(id=5, name=kaikeba, age=331, email=test4@baomidou.com, phone=null)\n        user(id=6, name=billie, age=24, email=test5@baomidou.com, phone=null)\n    */\n\n\n# 更改\n\n@test\n    public void testupdatebyid() {\n        usermapper.updatebyid(new user().setid(3l).setname("先科"));\n        usermapper.selectlist(null).foreach(system.out::println);\n    }\n    /*\n        user(id=1, name=jone, age=18, email=test1@baomidou.com, phone=null)\n        user(id=2, name=jack, age=20, email=test2@baomidou.com, phone=null)\n        user(id=3, name=先科, age=28, email=test3@baomidou.com, phone=null)\n        user(id=4, name=sandy, age=21, email=test4@baomidou.com, phone=null)\n        user(id=5, name=kaikeba, age=331, email=test4@baomidou.com, phone=null)\n        user(id=6, name=billie, age=24, email=test5@baomidou.com, phone=null)\n     */\n    \n    @test\n    public void testupdate1() {\n        usermapper.update(null, wrappers.<user>update().set("name","kkkbbb").like("name","tom"));\n        usermapper.selectlist(null).foreach(system.out::println);\n    }\n    /*\n        user(id=1, name=jone, age=18, email=test1@baomidou.com, phone=null)\n        user(id=2, name=jack, age=20, email=test2@baomidou.com, phone=null)\n        user(id=3, name=先科, age=28, email=test3@baomidou.com, phone=null)\n        user(id=4, name=sandy, age=21, email=test4@baomidou.com, phone=null)\n        user(id=5, name=kaikeba, age=331, email=test4@baomidou.com, phone=null)\n        user(id=6, name=billie, age=24, email=test5@baomidou.com, phone=null)\n     */\n    \n    @test\n    public void testupdate2() {\n        usermapper.update(new user().setname("kkkbbb"), wrappers.<user>update().like("name","tom"));\n        usermapper.selectlist(null).foreach(system.out::println);\n    }\n    /*\n        user(id=1, name=jone, age=18, email=test1@baomidou.com, phone=null)\n        user(id=2, name=jack, age=20, email=test2@baomidou.com, phone=null)\n        user(id=3, name=kkkbbb, age=28, email=test3@baomidou.com, phone=null)\n        user(id=4, name=sandy, age=21, email=test4@baomidou.com, phone=null)\n        user(id=5, name=kaikeba, age=331, email=test4@baomidou.com, phone=null)\n        user(id=6, name=billie, age=24, email=test5@baomidou.com, phone=null)\n     */\n\n\n# 查询\n\n@test\n    public void testfindbybasic() {\n        system.out.println(usermapper.selectlist(wrappers.<user>query().eq("name","jone")));\n    }\n    /*\n        [user(id=1, name=jone, age=18, email=test1@baomidou.com, phone=null)]\n     */\n    \n    @test\n    public void testfindprojection1() {\n        usermapper.selectlist(new querywrapper<user>().select("id","name")).foreach(system.out::println);\n    }\n    /*\n        user(id=1, name=jone, age=null, email=null, phone=null)\n        user(id=2, name=jack, age=null, email=null, phone=null)\n        user(id=3, name=tom, age=null, email=null, phone=null)\n        user(id=4, name=sandy, age=null, email=null, phone=null)\n        user(id=5, name=kaikeba, age=null, email=null, phone=null)\n        user(id=6, name=billie, age=null, email=null, phone=null)\n     */\n    \n    @test\n    public void testfindprojection2() {\n        usermapper.selectlist(new querywrapper<user>().select("id","name").like("name","j")).foreach(system.out::println);\n    }\n    /*\n        user(id=1, name=jone, age=null, email=null, phone=null)\n        user(id=2, name=jack, age=null, email=null, phone=null)\n     */\n    \n    @test\n    public void testfindprojection3() {\n        usermapper.selectlist(new querywrapper<user>().select("id","name").lambda().like(user::getname,"j")).foreach(system.out::println);\n    }\n    /*\n        user(id=1, name=jone, age=null, email=null, phone=null)\n        user(id=2, name=jack, age=null, email=null, phone=null)\n     */\n\n\n# 自定义 sql\n\n自定义sql是写在 mapper接口的方法上 , 值直接写sql语句\n\n注解        说明\n@insert   插入\n@update   更新\n@delete   删除\n@select   查询\n\ncrud按照指定的规则编写sql即可 , 如果需要传递参数 点击跳转\n\n@mapper\npublic interface usermapper extends basemapper<user> {\n    @select("select * from users")\n    list<user> findall();\n}\n\n\n# 条件构造器\n\n条件构造器主要作用在 sql语句中添加where条件 , 从而自动生成约束的sql . 主要比较贴合 hibernate 的使用方式\n\n条件构造器两大分类 : (它们的父类 abstractwrapper抽象类)\n\n * **querywrapper **\n * updatewrapper\n\n> 以上有各自独有的属性详细自行官网查询 条件构造器更多详细\n\n应用 :\n\n// 最终where约束语句 (默认全参存在)\n// select xxx from xxx where\n// \t\t(ex.del_flag=0 and ex.examine_user_id=su.id and su.office_id=so.id) and\n// \t\t(ex.type=?) and (su.name like \'%?%\') and (so.id=?);\n@override\npublic list<examinedo> selectbycondition(map<string, object> map) {\n\n    querywrapper<examinedo> query = new querywrapper<>();\n\n    // 三表连接的 关键字段的 sql约束代码\n    query.apply("ex.del_flag=0 and ex.examine_user_id=su.id and su.office_id=so.id");\n\n    /**\n     * sql约束拼接参数说明：\n     *   参数1.判断该对象是否可行（指该属性数据是有效且不为空\n     *   参数2.指定比较的字段 字符串（一般指定的字符串\n     *   参数3.指定比较的数据 外面获取到的\n     */\n    query.eq(map.containskey("type") && !objectutils.isempty(map.get("type")),"ex.type",map.get("type"))\n            .like(map.containskey("name") && !objectutils.isempty(map.get("name")),"su.name",map.get("name"))\n            .eq(map.containskey("officeid") && !objectutils.isempty(map.get("officeid")),"so.id",map.get("officeid"));\n\t// mapper传递对象即可\n    return basemapper.selectbycondition(query);\n}\n\n\n# 传参操作\n\n手写sql多多少少都会需要参数的传递 , 因此有以下三种方式进行传递参数 :\n\n 1. 实体类 根据实体的 属性 进行匹配信息\n 2. map 根据map哈希中的 k键 匹配 v值\n 3. @param 根据 参数值 映射匹配\n 4. 条件构造器 只需添加一个对象即可自动生成 约束sql 官方说明 : 条件构造器使用方式\n\n示例：\n\n// 实体类\n// 实体类包含的属性json展示 users{id,name}\n@select("select su.*  " +\n        "from  " +\n        "sys_user su " +\n        "where " +\n        "su.id= #{id} " +\n        "and su.name= #{name} " )\nlist<sysuser> findbyid(users user);\n\n// map\n// map = {id:23,name:"张三"}\n@select("select su.*  " +\n        "from  " +\n        "sys_user su " +\n        "where " +\n        "su.id= #{id} " +\n        "and su.name= #{name} " )\nlist<sysuser> findbyid(map<string,object> map);\n\n// @param\n@select("select su.*  " +\n        "from  " +\n        "sys_user su " +\n        "where " +\n        "su.id= #{id} " )\nlist<sysuser> findbyid(@param("id")integer id);\n\n// 条件构造器\n@select("select * from mysql_data ${ew.customsqlsegment}")\nlist<mysqldata> getall(@param(constants.wrapper) wrapper wrapper);\n\n\n# 多表查询\n\n多个表查询难免会有些稍微复杂的sql . 多表查询分为 一对多/一对一/多对多 三种类型\n\n注解         以往标签            说明\n@result    <id>/<result>   结果集封装 . 包含有以下属性 :\n                           - column : 数据表字段名称\n                           - property : 类中对应的属性名\n                           - one : 与@one搭配 , 进行一对一的映射\n                           - many : 与@many搭配 , 进行一对多的映射\n@results   <resultmap>     和@result 使用 , 封装 一个/多个 结果集\n@one       <assocation>    一对一结果集封装 , 使用格式如下 :\n                           @result(column="xx",property="xx",one=@one(select="xx",...))\n@many      <collection>    一对多结果集封装 , 使用格式如下 :\n                           @result(column="xx",property="xx",many=@many(select="xx",...))\n\n> 注意 :\n> \n>  * 一旦使用了 @results注解 封装的当前对象全部属性都要重新手写\n>  * 使用 @one/@many 注解 , 一般情况使用 select属性值 指定全限定名类的方法(如: byid/...)\n\n应用\n\n主要编写核心部分 , 其他代码简单表示即可\n\nuser 用户实体\n\n类型       名称          表对应的字段      注解规则\nint      id          id          \nstring   username    username    \nstring   password    password    \nlist     orderlist   oid(提取二查)   @tablefield(exist = false)\n\norder 订单实体\n\n类型       名称          表对应的字段      注解规则\nstring   id          id          \ndate     ordertime   ordertime   \ndouble   total       total       \nuser     user        uid(提取二查)   @tablefield(exist = false)\n\n一对多 一人有多个订单 usermapper接口\n\n@mapper\npublic interface usermapper extends basemapper<user> {\n    // 查所用用户并且包含订单\n    @select("select * from user")\n    @results({\n            @result(column = "id", property = "id"),\n            @result(column = "username", property = "username"),\n            @result(column = "password", property = "password"),\n            @result(column = "id", property = "orderlist",javatype = list.class,\n                    many = @many(select = "com.sans.demoapplication.mapper.ordermapper.findbyuid"))\n    })\n    list<user> findall();\n}\n\n\n> @many注解中属性seelct的值 : 是指定路径类的方法\n\n多对多 每个订单必须有一个用户 ordermapper接口\n\n@mapper\npublic interface ordermapper extends basemapper<order> {\n\n    // 查所有\n    @select("select  id,ordertime,total,uid  from `order`")\n    @results({\n            @result(column = "id",property = "id"),\n            @result(column = "ordertime",property = "ordertime"),\n            @result(column = "total",property = "total"),\n            @result(column = "uid", property = "user" ,javatype = user.class ,\n                    one = @one(select = "com.sans.demoapplication.mapper.usermapper.selectbyid"))\n    })\n    list<order> findallorder();\n\n    // 按uid 查订单\n    @select("select id,ordertime,total from `order` where uid=#{uid}")\n    list<order> findbyuid(int uid);\n\n}\n\n\n> @one注解中属性seelct的值 : 是指定路径类的方法 (该类继承有 basemapper接口 里面有内置的crud)\n\n# 分页插件\n\n以下分页功能的实现 , 基于以上的基础进行实现\n\n分页应用方式有3种形式：\n\n * 内置分页\n * xml分页\n * pagehelper分页\n\n三种分页区别\n\n         内置分页    xml分页          pagehelper分页\njar包引入   无       无              有\n配置       拦截器配置   全局配置 + 手写sql   引入bean\n分页信息     简略      自定义            详细\n复杂度      低       高              一般\n\n# 内置分页\n\n 1. 创建 mp配置类 mybatisplusconfig.java ，全限定名类 : com.config.mybatisplusconfig\n    \n    package com.config;\n    \n    import com.baomidou.mybatisplus.extension.plugins.paginationinterceptor;\n    import com.baomidou.mybatisplus.extension.plugins.pagination.optimize.jsqlparsercountoptimize;\n    import org.springframework.context.annotation.bean;\n    import org.springframework.context.annotation.configuration;\n    \n    @configuration\n    public class mybatisplusconfig {\n        \n        /**\n         * 分页插件\n         */\n        @bean\n        public paginationinterceptor paginationinterceptor() {\n            paginationinterceptor paginationinterceptor = new paginationinterceptor();\n            // 开启 count 的 join 优化,只针对 left join !!!\n            paginationinterceptor.setcountsqlparser(new jsqlparsercountoptimize(true));\n            return paginationinterceptor;\n        }\n        \n    }\n    \n\n 2. 测试\n    \n    @autowired\n    private usermapper mapper;\n    \n    //····\n    \n    @test\n    public void testselectpage() {\n        \n        page<user> page = new page<>(2, 3);\n        page<user> result = mapper.selectpage(page, wrappers.<user>query());\n    \n        result.getrecords().foreach(system.out :: println);\n        system.out.println("总数：" + result.gettotal());\n        system.out.println("总页数：" + result.getpages());\n        system.out.println("每行数：" + result.getsize());\n    \n        /**\n         * 验证分页信息\n         *      1. 总数 > 3\n         *      2. 页总数 = 3\n          */\n        assertthat(result.gettotal()).isgreaterthan(3);\n        assertthat(result.getrecords().size()).isequalto(3);\n        \n    }\n    \n    /*\n    \n    user(id=4, name=jack, age=20, email=test2@baomidou.com)\n    user(id=5, name=jack, age=20, email=test2@baomidou.com)\n    user(id=6, name=jack, age=20, email=test2@baomidou.com)\n    总数：17\n    总页数：6\n    每行数：3\n    \n    */\n    \n\n# xml分页\n\n 1. 添加属性 ，全局配置文件 application.yml\n    \n    mybatis-plus :\n      type-aliases-package : com.pojo.user\n      mapper-locations: classpath:/mapper/*.xml\n    \n\n 2. 映射类添加方法 usermapper.java\n    \n    @mapper\n    public interface usermapper extends basemapper<user> {\n        \n        /**\n         * 用户列表分页查询 （xml）\n         * param()注解：替换了原旧名称进行应用参数属性 如 p.属性、c.属性\n         * @param page 分页对象\n         * @param conditioin 约束查询数据\n         * @return\n         */\n        public page<user> selectuserbypage(@param ("p") ipage<user> page, @param("c") user conditioin);\n    }\n    \n\n 3. 创建映射文件 usermapper.xml ，路径 resources/mapper/usermapper.xml\n    \n    <?xml version="1.0" encoding="utf-8"?>\n    <!doctype mapper\n            public "-//mybatis.org//dtd mapper 3.0//en"\n            "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n    <mapper namespace="com.mapper.usermapper">\n    \n        <sql id="selectsql">\n            select `user`.id,`user`.name,`user`.age,`user`.email\n            from user\n        </sql>\n    \n        <select id="selectuserbypage" resulttype="user">\n            <include refid="selectsql"></include>\n            <where>\n                <if test="c.age !=null">\n                    age = #{c.age}\n                </if>\n                <if test="c.email !=null">\n                    and email like \'%${c.email}%\'\n                </if>\n            </where>\n        </select>\n    \n    </mapper>\n    \n    \n    > 注意： namespace 属性指定的值是 实现的接口\n\n 4. 测试\n    \n    //xml分页\n    @test\n    public void testselectuserbypage() {\n        page<user> page = new page<>(1,2);\n    \n        user u = new user();\n        u.setage(20);\n        u.setemail("test2");\n        \n        page<user> pr = mapper.selectuserbypage(page , u);\n        \n        \n        system.out.println("总数：" + pr.gettotal());\n        system.out.println("总页数：" + pr.getpages());\n        system.out.println("每行数：" + pr.getsize());\n        system.out.println("===========");\n        pr.getrecords().foreach(system.out::println);\n    }\n    \n    /*\n    \n    总数：13\n    总页数：7\n    每行数：2\n    ===========\n    user(id=2, name=jack, age=20, email=test2@baomidou.com)\n    user(id=3, name=jack, age=20, email=test2@baomidou.com)\n    \n    */\n    \n    \n    > 注意： 约束条件查询结果条数 必须要 大于 分页每页数\n\n# pagehelper分页\n\n 1. 引入独有依赖 pom.xml\n    \n    \x3c!--pagehelper分页--\x3e\n    <dependency>\n        <groupid>com.github.pagehelper</groupid>\n        <artifactid>pagehelper</artifactid>\n        <version>5.1.11</version>\n    </dependency>\n    \n\n 2. 编辑 mp配置类 mybatisplusconfig.java ，全限定名：com.config.mybatisplusconfig\n    \n    package com.config;\n    \n    import com.baomidou.mybatisplus.extension.plugins.paginationinterceptor;\n    import com.baomidou.mybatisplus.extension.plugins.pagination.optimize.jsqlparsercountoptimize;\n    import com.github.pagehelper.pageinterceptor;\n    import org.mybatis.spring.annotation.mapperscan;\n    import org.springframework.context.annotation.bean;\n    import org.springframework.context.annotation.configuration;\n    \n    @configuration\n    @mapperscan("com.mapper")\n    public class mybatisplusconfig {\n        \n        //···\n        \n        /**\n         * pagehelper的分页插件\n         */\n        @bean\n        public pageinterceptor pageinterceptor() {\n            return new pageinterceptor();\n        }\n        \n    }\n    \n\n 3. 映射类添加方法 usermapper.java （可选测试）\n    \n    package com.mapper;\n    \n    import com.baomidou.mybatisplus.core.mapper.basemapper;\n    import com.baomidou.mybatisplus.core.metadata.ipage;\n    import com.baomidou.mybatisplus.extension.plugins.pagination.page;\n    import com.sans.pojo.user;\n    import org.apache.ibatis.annotations.mapper;\n    import org.apache.ibatis.annotations.param;\n    \n    import java.util.list;\n    \n    @mapper\n    public interface usermapper extends basemapper<user> {\n        \n        //···\n        \n        /**\n         * 用户列表分页查询 （pagehelper）\n         * @param conditioin 约束查询数据\n         * @return\n         */\n        public list<user> selectuserbypage2(user conditioin);\n        \n    }\n    \n\n 4. 编辑映射文件 usermapper.xml ，路径 resources/mapper/usermapper.xml（可选测试）\n    \n    <?xml version="1.0" encoding="utf-8"?>\n    <!doctype mapper\n            public "-//mybatis.org//dtd mapper 3.0//en"\n            "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n    <mapper namespace="com.sans.mapper.usermapper">\n    \n        <sql id="selectsql">\n            select `user`.id,`user`.name,`user`.age,`user`.email\n            from user\n        </sql>\n    \n        \x3c!-- ····· --\x3e\n    \n        \x3c!-- pagehelper 映射分页查询--\x3e\n        <select id="selectuserbypage2" resulttype="user">\n            <include refid="selectsql"></include>\n            <where>\n                <if test="age !=null">\n                    age = #{age}\n                </if>\n                <if test="email !=null">\n                    and email like \'%${email}%\'\n                </if>\n            </where>\n        </select>\n    \n    </mapper>\n    \n\n 5. 测试\n    \n    // pagehelper分页\n    @test\n    public void testselectuserbypage2() {\n    \n        user u = new user();\n        u.setage(20);\n        u.setemail("test2");\n        pageinfo<user> page = pagehelper.startpage(1,2).doselectpageinfo(() ->{\n            // 方法选择测试 (他们测试结果一致)\n            // 1. 自定义xml\n            mapper.selectuserbypage2(u);\n            // 2. mp 内置方法\n            // mapper.selectlist(wrappers.<user>query().eq("age",20).like("email","test2"));\n        });\n    \n        page.getlist().foreach(system.out :: println);\n    \n        system.out.println("===========");\n    \n        system.out.println("总行数=" + page.gettotal());\n        system.out.println("总页数=" + page.getpages());\n        system.out.println("每页行数=" + page.getpagesize());\n    \n        system.out.println("当前页=" + page.getpagenum());\n        system.out.println("起始行数=" + page.getstartrow());\n    \n        system.out.println("是第一页=" + page.isisfirstpage());\n        system.out.println("是最后页=" + page.isislastpage());\n    \n        system.out.println("还有下一页=" + page.ishasnextpage());\n        system.out.println("还有上一页=" + page.ishaspreviouspage());\n    \n        system.out.println("页码列表" + arrays.tostring(page.getnavigatepagenums()));\n    }\n    \n    /*\n    \n    user(id=2, name=jack, age=20, email=test2@baomidou.com)\n    user(id=3, name=jack, age=20, email=test2@baomidou.com)\n    ===========\n    总行数=13\n    总页数=7\n    每页行数=2\n    当前页=1\n    起始行数=1\n    是第一页=true\n    是最后页=false\n    还有下一页=true\n    还有上一页=false\n    页码列表[1, 2, 3, 4, 5, 6, 7]\n    \n    */\n    \n\n官方文档：mybatis-plus (baomidou.com)\n\n# 反向工程\n\n官方在 3.5.1 以上和以下 分别 生成方式都不一样，因此做了两个示例\n\n工程配置文档：添加跳转\n\n# 3.5.1之前\n\n步骤：\n\n 1. 引入必要jar freemarker模板、lombok简化实体、mybatis-plus-generator生成核心\n    \n    <dependency>\n        <groupid>org.freemarker</groupid>\n        <artifactid>freemarker</artifactid>\n        <version>2.3.31</version>\n    </dependency>\n    <dependency>\n        <groupid>org.projectlombok</groupid>\n        <artifactid>lombok</artifactid>\n    </dependency>\n    <dependency>\n        <groupid>com.baomidou</groupid>\n        <artifactid>mybatis-plus-generator</artifactid>\n        <version>3.4.1</version>\n    </dependency>\n    \n    \n    > 生成后可以直接删除 freemarker模板、mybatis-plus-generator生成核心\n\n 2. 反向工程启动类\n    \n    必要提示说明：\n    \n    * 数据源配置\n    * 作者\n    * 生成路径\n    * 模组名（启动输入\n    * 表名（启动输入\n    \n    import com.baomidou.mybatisplus.annotation.fieldfill;\n    import com.baomidou.mybatisplus.annotation.idtype;\n    import com.baomidou.mybatisplus.core.exceptions.mybatisplusexception;\n    import com.baomidou.mybatisplus.core.toolkit.stringpool;\n    import com.baomidou.mybatisplus.core.toolkit.stringutils;\n    import com.baomidou.mybatisplus.generator.autogenerator;\n    import com.baomidou.mybatisplus.generator.injectionconfig;\n    import com.baomidou.mybatisplus.generator.config.*;\n    import com.baomidou.mybatisplus.generator.config.po.tablefill;\n    import com.baomidou.mybatisplus.generator.config.po.tableinfo;\n    import com.baomidou.mybatisplus.generator.config.rules.namingstrategy;\n    import com.baomidou.mybatisplus.generator.engine.freemarkertemplateengine;\n    \n    import java.util.arraylist;\n    import java.util.list;\n    import java.util.scanner;\n    \n    public class mysqlgenerator {\n    \n        /**\n         * <p>\n         * 读取控制台内容\n         * </p>\n         */\n        public static string scanner(string tip) {\n            scanner scanner = new scanner(system.in);\n            stringbuilder help = new stringbuilder();\n            help.append("请输入" + tip + "：");\n            system.out.println(help.tostring());\n            if (scanner.hasnext()) {\n                string ipt = scanner.next();\n                if (stringutils.isnotblank(ipt)) {\n                    return ipt;\n                }\n            }\n            throw new mybatisplusexception("请输入正确的" + tip + "！");\n        }\n    \n        public static void main(string[] args) {\n            // 代码生成器\n            autogenerator mpg = new autogenerator();\n    \n            // 全局配置\n            globalconfig gc = new globalconfig();\n            string projectpath = system.getproperty("user.dir");\n            /*\n            指定工程名称\n            指定作者\n            *  */\n            gc.setoutputdir(projectpath + "/newssys/src/main/java");\n            gc.setauthor("sasn");\n            gc.setopen(false);\n            gc.setidtype(idtype.auto);//设置全局id自增\n            gc.setbaseresultmap(true);//设置生成baseresultmap\n            // gc.setswagger2(true); 实体属性 swagger2 注解\n            mpg.setglobalconfig(gc);\n    \n            // 数据源配置\n            /* 写自己的连接源 */\n            datasourceconfig dsc = new datasourceconfig();\n            dsc.seturl("jdbc:mysql://localhost:3306/test?servertimezone=utc");\n            // dsc.setschemaname("public");\n            dsc.setdrivername("com.mysql.jdbc.driver");\n            dsc.setusername("root");\n            dsc.setpassword("root");\n            \n            // 库数据 和 实体数据字段手动匹配配置\n            dsc.settypeconvert(new mysqltypeconvert() {\n                @override\n                public icolumntype processtypeconvert(@org.jetbrains.annotations.notnull globalconfig globalconfig,\n                                                      @org.jetbrains.annotations.notnull string fieldtype) {\n                    // 比较库字段类型\n                    if ("datetime".equals(fieldtype)) {\n                        // 满足则返回需要对应的实体类型\n                        return dbcolumntype.date;\n                    }\n                    if ("float".equals(fieldtype)) {\n                        return dbcolumntype.base_double;\n                    }\n                    switch (fieldtype) {\n                        case "text" :\n                        case "mediumtext" :\n                            return dbcolumntype.string;\n                        default:\n                            break;\n                    }\n                    return super.processtypeconvert(globalconfig, fieldtype);\n                }\n            }\n            \n            mpg.setdatasource(dsc);\n    \n            // 包配置\n            /* 指定模块名称 */\n            packageconfig pc = new packageconfig();\n            pc.setmodulename(scanner("模块名"));\n            pc.setparent("com.sans");\n            mpg.setpackageinfo(pc);\n    \n            // 自定义配置\n            injectionconfig cfg = new injectionconfig() {\n                @override\n                public void initmap() {\n                    // to do nothing\n                }\n            };\n    \n            // 如果模板引擎是 freemarker  从依赖包的 templates下查找模板\n            string templatepath = "/templates/mapper.java.ftl";\n            // 如果模板引擎是 velocity\n            // string templatepath = "/templates/mapper.xml.vm";\n    \n            // 自定义输出配置\n            list<fileoutconfig> foclist = new arraylist<>();\n            // 自定义配置会被优先输出\n            foclist.add(new fileoutconfig(templatepath) {\n                @override\n                public string outputfile(tableinfo tableinfo) {\n                    // 自定义输出文件名 ， 如果你 entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！\n                    return projectpath + "/src/main/resources/mapper/" + pc.getmodulename()\n                            + "/" + tableinfo.getentityname() + "mapper" + stringpool.dot_xml;\n                }\n            });\n            /*\n            cfg.setfilecreate(new ifilecreate() {\n                @override\n                public boolean iscreate(configbuilder configbuilder, filetype filetype, string filepath) {\n                    // 判断自定义文件夹是否需要创建\n                    checkdir("调用默认方法创建的目录，自定义目录用");\n                    if (filetype == filetype.mapper) {\n                        // 已经生成 mapper 文件判断存在，不想重新生成返回 false\n                        return !new file(filepath).exists();\n                    }\n                    // 允许生成模板文件\n                    return true;\n                }\n            });\n            */\n            cfg.setfileoutconfiglist(foclist);\n            mpg.setcfg(cfg);\n    \n            // 配置模板\n           // templateconfig templateconfig = new templateconfig();\n    \n            // 配置自定义输出模板\n            //指定自定义模板路径，注意不要带上.ftl/.vm, 会根据使用的模板引擎自动识别\n            // templateconfig.setentity("templates/entity2.java");\n            // templateconfig.setservice();\n            // templateconfig.setcontroller();\n    \n            //templateconfig.setxml(null);\n           // mpg.settemplate(templateconfig);\n    \n            // 策略配置\n            strategyconfig strategy = new strategyconfig();\n            strategy.setnaming(namingstrategy.underline_to_camel);\n            strategy.setcolumnnaming(namingstrategy.underline_to_camel);\n    //        strategy.setsuperentityclass("你自己的父类实体,没有就不用设置!");\n            strategy.setentitylombokmodel(true);\n            strategy.setrestcontrollerstyle(true);\n            // 公共父类\n    //        strategy.setsupercontrollerclass("你自己的父类控制器,没有就不用设置!");\n            // 写于父类中的公共字段\n    //        strategy.setsuperentitycolumns("id");\n            strategy.setenablesqlfilter(false);//开启支持输入正则表达式\n            strategy.setinclude(scanner("表名，多个英文逗号分割").split(","));\n            strategy.setcontrollermappinghyphenstyle(true);\n            strategy.settableprefix(pc.getmodulename() + "_");\n    \n            //设置生成自动填充注解的表字段\n            arraylist<tablefill> list = new arraylist<>();\n            list.add(new tablefill("update_date", fieldfill.insert_update));\n            list.add(new tablefill("create_date", fieldfill.insert));\n            list.add(new tablefill("del_flag", fieldfill.insert));\n            strategy.settablefilllist(list);\n            strategy.setlogicdeletefieldname("del_flag");//设置生成逻辑删除注解对应表字段名\n            mpg.setstrategy(strategy);\n            mpg.settemplateengine(new freemarkertemplateengine());\n            mpg.execute();\n        }\n    }\n    \n\n# 3.5.1之后\n\n步骤：\n\n 1. 引入必要jar freemarker模板、annotations配置注解应用、mybatis-plus-generator生成核心\n    \n    <dependency>\n        <groupid>com.baomidou</groupid>\n        <artifactid>mybatis-plus-generator</artifactid>\n        <version>3.5.2</version>\n    </dependency>\n    <dependency>\n        <groupid>org.freemarker</groupid>\n        <artifactid>freemarker</artifactid>\n        <version>2.3.31</version>\n    </dependency>\n    <dependency>\n        <groupid>org.jetbrains</groupid>\n        <artifactid>annotations</artifactid>\n        <version>16.0.1</version>\n    </dependency>\n    \n    \n    > 生成后可以直接删除 freemarker模板、mybatis-plus-generator生成核心\n\n 2. 反向工程启动类\n    \n    > 注意参数的填充\n    \n    import com.baomidou.mybatisplus.generator.fastautogenerator;\n    import com.baomidou.mybatisplus.generator.config.datasourceconfig;\n    import com.baomidou.mybatisplus.generator.config.globalconfig;\n    import com.baomidou.mybatisplus.generator.config.converts.mysqltypeconvert;\n    import com.baomidou.mybatisplus.generator.config.querys.mysqlquery;\n    import com.baomidou.mybatisplus.generator.config.rules.dbcolumntype;\n    import com.baomidou.mybatisplus.generator.config.rules.icolumntype;\n    import com.baomidou.mybatisplus.generator.engine.freemarkertemplateengine;\n    \n    public class builderapplication {\n    \n        public static void main(string[] args) {\n    \n            string url = "jdbc:mysql://localhost:3306/test?servertimezone=utc";\n            string username = "root";\n            string passwoed = "root";\n            string baomidou = "柏竹";\n            string packagepath = "com.sans";\n            string generatepath = "d:\\\\code\\\\java\\\\drill\\\\guangdong embedded\\\\01 study\\\\javaee\\\\220607springcloud\\\\220607webservice\\\\220607webservice\\\\restful-server\\\\src\\\\main\\\\java";\n    \n            datasourceconfig.builder datasourcebuilder = new datasourceconfig.builder(url, username, passwoed)\n                    .dbquery(new mysqlquery())\n                    .typeconvert(new mysqltypeconvert() {\n                        @override\n                        public icolumntype processtypeconvert(@org.jetbrains.annotations.notnull globalconfig globalconfig,\n                                                              @org.jetbrains.annotations.notnull string fieldtype) {\n                            // 比较库字段类型\n                            if ("datetime".equals(fieldtype)) {\n                                // 满足则返回需要对应的实体类型\n                                return dbcolumntype.date;\n                            }\n                            return super.processtypeconvert(globalconfig, fieldtype);\n                        }\n                    });\n    \n    \n            /**\n             * 配置文档：https://baomidou.com/pages/981406/\n             */\n            fastautogenerator.create(datasourcebuilder)\n                    // 全局配置\n                    .globalconfig(builder -> {\n                        builder.author(baomidou)\n    //                            .enableswagger()\n                                .disableopendir()\n                                .fileoverride()\n                                .outputdir(generatepath); // 指定输出目录\n                    })\n                    // 包配置\n                    .packageconfig(builder -> {\n                        builder.parent(packagepath); // 设置父包名\n    //                            .modulename(modulename); // 设置父包模块名\n    //                            .pathinfo(collections.singletonmap(outputfile.mapper, xmlpath)); // 设置mapperxml生成路径\n                    })\n                    // 策略配置\n                    .strategyconfig(builder -> {\n                        // 指定表\n                        builder.addinclude("book") // 设置需要生成的表名\n    //                            .addinclude("news_detail")\n                                .enablecapitalmode()\n                                // entity 策略配置\n                                // 逻辑删除/乐观锁 字段\n                                .entitybuilder()\n                                .versioncolumnname("version")\n                                .versionpropertyname("version")\n                                .logicdeletecolumnname("deleted")\n                            \t/.enablelombok() // 启动 lombok 模型\n                                .mapperbuilder()\n                                .enablebaseresultmap()\n                                .enablemapperannotation()\n                        ;\n                    })\n                    .templateengine(new freemarkertemplateengine())  // 使用freemarker引擎模板，默认的是velocity引擎模板\n                    .execute();\n        }\n    }\n    \n\n\n# json整合\n\nspringboot 自带有 jackson 和 gson , 一般json操作是通过 objectmapper对象 进行操作(工具类)\n\n> springboot 一般情况是使用自动注入形式调用 objectmapper对象\n\n# 对象>json\n\nuser user = new user();\nstring userjson = new objectmapper().writevalueasstring(user);\n//...\n\n\n# json>对象\n\n// 单对象\nstring json = "{name:\'sans\', age:22}";\nuser user = new objectmapper().readvalue(josn, user.class);\n// 数组\nstring jsonarraystr = "[{\\"id\\":\\"123\\",\\"name\\":\\"张三\\"},{\\"id\\":\\"456\\",\\"name\\":\\"李四\\"}]";\nlist<person> personlist = objectmapper.readvalue(jsonarraystr, new typereference<list<person>>() {});\n\n\n# 自定义工具类\n\npublic class jsonutil {\n\n    public static final objectmapper objectmapper = new objectmapper();\n\n    static {\n        //忽略字段不匹配错误\n objectmapper.configure(deserializationfeature.fail_on_unknown_properties, false);\n    }\n\n    /**\n     * 创建 objectnode\n     * @return\n     */\n    public static objectnode createjson() {\n        return objectmapper.createobjectnode();\n    }\n\n    /**\n     * 字符串转 java bean\n     * @param json\n     * @param clazz\n     * @param <t>\n     * @return\n     */\n    public static <t> t string2bean(string json, class<t> clazz){\n        t t = null;\n        try {\n            t = objectmapper.readvalue(json,clazz);\n        } catch (jsonprocessingexception e) {\n            e.printstacktrace();\n        }\n        return t;\n    }\n\n    /**\n     * 字符串转 map\n     * @param json\n     * @param clazz\n     * @param <t>\n     * @return\n     */\n    public static <t> map<string,object> string2map(string json, class<t> clazz){\n        map<string,object> map = null;\n        try {\n            map = objectmapper.readvalue(json, new typereference<map<string,object>>() {});\n        } catch (jsonprocessingexception e) {\n            map = collections.emptymap();\n            e.printstacktrace();\n        }\n        return map;\n    }\n\n    /**\n     * 字符串转 list<bean>\n     * @param json\n     * @param clazz\n     * @param <t>\n     * @return\n     */\n    public static <t> list<t> string2beanlist(string json, class<t> clazz){\n        list<t> t = null;\n        try {\n            t = objectmapper.readvalue(json, new typereference<list<t>>() {});\n        } catch (jsonprocessingexception e) {\n            t = collections.emptylist();\n            e.printstacktrace();\n        }\n        return t;\n    }\n\n    /**\n     * 字符串转 bean[]\n     * @param json\n     * @param clazz\n     * @param <t>\n     * @return\n     */\n    public static <t> t[] string2beanarray(string json, class<t> clazz){\n        t[] t = null;\n        try {\n            t = objectmapper.readvalue(json, new typereference<t[]>() {});\n        } catch (jsonprocessingexception e) {\n            t = (t[])new object[0];\n            e.printstacktrace();\n        }\n        return t;\n    }\n\n    /**\n     * 字符串转 jsonnode\n     * @param json\n     * @return\n     */\n    public static jsonnode string2json(string json) {\n        jsonnode jsonnode = null;\n        try {\n            jsonnode = objectmapper.readtree(json);\n        } catch (jsonprocessingexception e) {\n            e.printstacktrace();\n        }\n        return jsonnode;\n    }\n\n    /**\n     * java bean 或者 map 或者 jsonnode 转字符串\n     * @param o\n     * @return\n     */\n    public static string object2string(object o) {\n        string json = null;\n        try {\n            json = objectmapper.writevalueasstring(o);\n        } catch (jsonprocessingexception e) {\n            e.printstacktrace();\n        }\n        return json;\n    }\n\n    /**\n     * java bean 或者 map 或者 jsonnode 转 jsonnode\n     * @param o\n     * @return\n     */\n    public static jsonnode object2json(object o) {\n        jsonnode jsonnode = null;\n        try {\n            string jsonstring = objectmapper.writevalueasstring(o);\n            jsonnode = objectmapper.readtree(jsonstring);\n        } catch (jsonprocessingexception e) {\n            e.printstacktrace();\n        }\n        return jsonnode;\n    }\n\n    /**\n     * jsonnode 转 jsonnode\n     * @param jsonnode\n     * @return\n     */\n    public static <t> t json2bean(jsonnode jsonnode, class<t> clazz) {\n        string json = jsonnode.tostring();\n        return string2bean(json, clazz);\n    }\n}\n\n\n应用实例\n\n// 数组\npublic static void main(string[] args) {\n    objectnode person = objectmapper.createobjectnode();\n    person.put("id","1101");\n    person.put("name","张三");\n    person.put("age",35);\n    person.put("sex","男");\n\n    list<objectnode> children = new arraylist<>(1);\n    objectnode child = objectmapper.createobjectnode();\n    child.put("id","1102");\n    child.put("name","张小三");\n    child.put("age",12);\n    child.put("sex","男");\n\n    children.add(child);\n\n    person.putarray("children").addall(children);\n\n    system.out.println(person.toprettystring());\n}\n\n\n\n# 部署\n\n\n# jar打包\n\n大致流程\n\n 1. jdk安装 , 并配置\n 2. maven打包项目 , 上传服务器\n 3. 运行jar项目\n\n> springboot内置集成tomcat , 无需安装即可应用\n\n项目打包\n\nmaven -> 双击package , 加载完会在 /target(缓存路径) 上看到 .jar 文件 , 在liunx系统里运行即可\n\n运行jar包项目\n\nnohup java -jar shop-0.0.1-snapshot.jar > logname.log 2>&1 &\n\n\n指令说明\n\n * ==nohup java -jar shop-0.0.1-snapshot.jar== 运行项目 , 不挂断运行\n * ==log.log 2>&1== 表示将stdout和stderr合并后重定向到log.file\n\n> 运行后可以看到 一串数值 , 可通过 ==jps==指令 进行查看进程\n\n关闭进程 :\n\n# 查指定端口 (查8080)\nnetstat -nlp|grep 8080\n# 确定端口的 pid\nkill -9 {pid}\n\n\n\n# docker打包/群辉挂载\n\n 0. jar打包\n\n 1. 创建 dorderfile.txt (编辑配置文件) , 保存后取出后缀 .txt\n    \n    # docker image for springboot file run\n    # version 0.0.1\n    # author: \n    # 基础镜像使用java\n    from openjdk:8\n    # 作者\n    maintainer sans\n    # volume 指定了临时文件目录为/tmp。\n    # 其效果是在主机 /var/lib/docker 目录下创建了一个临时文件，并链接到容器的/tmp\n    volume /tmp \n    # 将jar包添加到容器中并更名为xx.jar (demo.jar -> test.jar)\n    add demo.jar test.jar \n    # 运行jar包\n    run bash -c \'touch /test.jar\'\n    entrypoint ["java","-djava.security.egd=file:/dev/./urandom","-jar","/test.jar"]\n    \n\n 2. 执行镜像打包 (在含有 dockerfild 和 xx.jar 执行以下文件)\n    \n    sudo docker build . -t demo-name:v1.0\n    \n\n 3. 打开docker , 镜像加载即可 (配置按照默认)\n\n 4. 反向代理 , 控制面板 -> 登录门户 -> 高级 -> 反向代理服务器 新增 来源 *:端口 ; 目的 locakhost:本地端口\n\n 5. 外部访问即可\n\n\n# ssl域名认证\n\nssl能够将该网站变为更安全的网站 , https独有的协议\n\n阿里云申请后 : 下载jks 证书类型(里面有 key和password 两个文件)\n\nkey放到 resources目录 即可\n\napplication文件配置\n\n# 域名 ssl配置\nserver.ssl.key-store=classpath:8840811_bozhu.free.svipss.top.jks\nserver.ssl.key-store-password=xxxx\nserver.ssl.key-store-type=jks\n\n\n> server.ssl.key-store : key文件的全名称 server.ssl.key-store-password : 第二个文件夹的内容粘贴出来 server.ssl.key-store-type : 认证类型 jks\n\n直接访问https接口 , 也可以设置重定向为https\n\n\n# ssh\n\n先连接openwrt 作为代理主机进行操作\n\nopenwrt ssh访问在\n\n==系统 -> 管理权 -> dropbear 实例== : 启动网关端口...\n\n群辉ssh 先访问openwrt作为代理进行内网访问群辉sshcomponent',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"RabbitMQ",frontmatter:{title:"RabbitMQ",author:"柏竹",permalink:"/backend/afbo8k",date:"2020-02-18T00:00:00.000Z",categories:["后端","框架"],tags:["消息队列"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/04.%E6%A1%86%E6%9E%B6%E6%8A%80%E6%9C%AF/06.RabbitMQ.html",relativePath:"01.后端/04.框架技术/06.RabbitMQ.md",key:"v-266c61ea",path:"/backend/afbo8k/",headers:[{level:2,title:"介绍",slug:"介绍",normalizedTitle:"介绍",charIndex:15},{level:3,title:"MQ特性",slug:"mq特性",normalizedTitle:"mq特性",charIndex:506},{level:4,title:"可靠性",slug:"可靠性",normalizedTitle:"可靠性",charIndex:514},{level:4,title:"顺序性",slug:"顺序性",normalizedTitle:"顺序性",charIndex:696},{level:4,title:"幂等性",slug:"幂等性",normalizedTitle:"幂等性",charIndex:900},{level:3,title:"MQ分类",slug:"mq分类",normalizedTitle:"mq分类",charIndex:1196},{level:4,title:"ActiveMQ",slug:"activemq",normalizedTitle:"activemq",charIndex:1204},{level:4,title:"Kafka",slug:"kafka",normalizedTitle:"kafka",charIndex:1321},{level:4,title:"RocketMQ",slug:"rocketmq",normalizedTitle:"rocketmq",charIndex:1504},{level:4,title:"RabbitMQ (学习)",slug:"rabbitmq-学习",normalizedTitle:"rabbitmq (学习)",charIndex:1662},{level:3,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:1776},{level:3,title:"Web管理",slug:"web管理",normalizedTitle:"web管理",charIndex:2402},{level:4,title:"安装",slug:"安装-2",normalizedTitle:"安装",charIndex:1776},{level:4,title:"用户管理",slug:"用户管理",normalizedTitle:"用户管理",charIndex:2654},{level:2,title:"核心",slug:"核心",normalizedTitle:"核心",charIndex:3197},{level:3,title:"简单模式 Hello World",slug:"简单模式-hello-world",normalizedTitle:"简单模式 hello world",charIndex:4064},{level:4,title:"工具类优化",slug:"工具类优化",normalizedTitle:"工具类优化",charIndex:7016},{level:3,title:"工作模式 Work queues",slug:"工作模式-work-queues",normalizedTitle:"工作模式 work queues",charIndex:7588},{level:4,title:"轮询分发",slug:"轮询分发",normalizedTitle:"轮询分发",charIndex:7657},{level:4,title:"消息应答",slug:"消息应答",normalizedTitle:"消息应答",charIndex:669},{level:5,title:"自动应答",slug:"自动应答",normalizedTitle:"自动应答",charIndex:6436},{level:5,title:"手动应答",slug:"手动应答",normalizedTitle:"手动应答",charIndex:9227},{level:4,title:"持久化",slug:"持久化",normalizedTitle:"持久化",charIndex:622},{level:5,title:"队列持久化",slug:"队列持久化",normalizedTitle:"队列持久化",charIndex:11976},{level:5,title:"消息持久化",slug:"消息持久化",normalizedTitle:"消息持久化",charIndex:12239},{level:4,title:"信道堆积",slug:"信道堆积",normalizedTitle:"信道堆积",charIndex:12461},{level:3,title:"发布确认模式 Publisher Confirms",slug:"发布确认模式-publisher-confirms",normalizedTitle:"发布确认模式 publisher confirms",charIndex:553},{level:3,title:"发布/订阅 模式 Publish/Subscribe",slug:"发布-订阅-模式-publish-subscribe",normalizedTitle:"发布/订阅 模式 publish/subscribe",charIndex:18144},{level:4,title:"交换机 Exchange",slug:"交换机-exchange",normalizedTitle:"交换机 exchange",charIndex:18314},{level:4,title:"临时队列",slug:"临时队列",normalizedTitle:"临时队列",charIndex:18760},{level:4,title:"绑定 binding",slug:"绑定-binding",normalizedTitle:"绑定 binding",charIndex:18940},{level:4,title:"direct",slug:"direct",normalizedTitle:"direct",charIndex:18394},{level:4,title:"topic",slug:"topic",normalizedTitle:"topic",charIndex:18502},{level:4,title:"fnout",slug:"fnout",normalizedTitle:"fnout",charIndex:18590},{level:4,title:"代码实战",slug:"代码实战",normalizedTitle:"代码实战",charIndex:19915},{level:5,title:"direct点对点测试",slug:"direct点对点测试",normalizedTitle:"direct点对点测试",charIndex:22173},{level:5,title:"topic发布订阅",slug:"topic发布订阅",normalizedTitle:"topic发布订阅",charIndex:22366},{level:5,title:"广播 fnout",slug:"广播-fnout",normalizedTitle:"广播 fnout",charIndex:19902},{level:2,title:"进阶",slug:"进阶",normalizedTitle:"进阶",charIndex:22935},{level:3,title:"死信队列",slug:"死信队列",normalizedTitle:"死信队列",charIndex:626},{level:4,title:"测试",slug:"测试",normalizedTitle:"测试",charIndex:6860},{level:3,title:"整合SpringBoot",slug:"整合springboot",normalizedTitle:"整合springboot",charIndex:29171},{level:4,title:"快速入门",slug:"快速入门",normalizedTitle:"快速入门",charIndex:29263},{level:4,title:"操作对象",slug:"操作对象",normalizedTitle:"操作对象",charIndex:30973},{level:4,title:"消费者",slug:"消费者",normalizedTitle:"消费者",charIndex:660},{level:3,title:"延迟队列",slug:"延迟队列",normalizedTitle:"延迟队列",charIndex:31419},{level:4,title:"应用方式",slug:"应用方式",normalizedTitle:"应用方式",charIndex:31660},{level:4,title:"代码示例",slug:"代码示例",normalizedTitle:"代码示例",charIndex:13668},{level:4,title:"代码测试",slug:"代码测试",normalizedTitle:"代码测试",charIndex:36656},{level:4,title:"插件拓展",slug:"插件拓展",normalizedTitle:"插件拓展",charIndex:37412},{level:5,title:"应用方式",slug:"应用方式-2",normalizedTitle:"应用方式",charIndex:31660},{level:5,title:"代码示例",slug:"代码示例-2",normalizedTitle:"代码示例",charIndex:13668},{level:5,title:"代码测试",slug:"代码测试-2",normalizedTitle:"代码测试",charIndex:36656},{level:3,title:"发布确认高级",slug:"发布确认高级",normalizedTitle:"发布确认高级",charIndex:41223},{level:4,title:"",slug:"代码示例-3",normalizedTitle:"",charIndex:0},{level:4,title:"代码测试",slug:"代码测试-3",normalizedTitle:"代码测试",charIndex:36656},{level:3,title:"回退消息",slug:"回退消息",normalizedTitle:"回退消息",charIndex:637},{level:4,title:"代码示例",slug:"代码示例-4",normalizedTitle:"代码示例",charIndex:13668},{level:4,title:"代码测试",slug:"代码测试-4",normalizedTitle:"代码测试",charIndex:36656},{level:3,title:"备用交换机",slug:"备用交换机",normalizedTitle:"备用交换机",charIndex:631},{level:4,title:"代码示例",slug:"代码示例-5",normalizedTitle:"代码示例",charIndex:13668},{level:4,title:"代码测试",slug:"代码测试-5",normalizedTitle:"代码测试",charIndex:36656},{level:3,title:"队列优先级",slug:"队列优先级",normalizedTitle:"队列优先级",charIndex:54690},{level:4,title:"测试",slug:"测试-2",normalizedTitle:"测试",charIndex:6860},{level:3,title:"惰性队列",slug:"惰性队列",normalizedTitle:"惰性队列",charIndex:56974},{level:2,title:"集群",slug:"集群",normalizedTitle:"集群",charIndex:57727},{level:3,title:"Docker",slug:"docker",normalizedTitle:"docker",charIndex:57825}],headersStr:"介绍 MQ特性 可靠性 顺序性 幂等性 MQ分类 ActiveMQ Kafka RocketMQ RabbitMQ (学习) 安装 Web管理 安装 用户管理 核心 简单模式 Hello World 工具类优化 工作模式 Work queues 轮询分发 消息应答 自动应答 手动应答 持久化 队列持久化 消息持久化 信道堆积 发布确认模式 Publisher Confirms 发布/订阅 模式 Publish/Subscribe 交换机 Exchange 临时队列 绑定 binding direct topic fnout 代码实战 direct点对点测试 topic发布订阅 广播 fnout 进阶 死信队列 测试 整合SpringBoot 快速入门 操作对象 消费者 延迟队列 应用方式 代码示例 代码测试 插件拓展 应用方式 代码示例 代码测试 发布确认高级  代码测试 回退消息 代码示例 代码测试 备用交换机 代码示例 代码测试 队列优先级 测试 惰性队列 集群 Docker",content:'# RabbitMQ\n\n\n# 介绍\n\nRabbitMQ 是个中间件 , 负责 接收/存储/转发 消息数据 . 类似 平时快递派送的过程\n\n是什么?\n\nMQ 本质是个队列 , 先进先出 消息推送 , 是种跨进程通信机制的上下游传递消息 . 主要解决不同对象通信的序列\n\n为什么用?\n\n * 流量消锋 : 如果系统最大多处理1W条请求 , 且还是高峰期的时候 , 很有可能会突破1W导致宕机 . MQ可以队列缓冲 , 防止宕机 (高峰期体验差 , 但能保障了不会宕机)\n * 应用解耦 : 系统有多个子系统 , 在业务涉及多个子系统完成时 , 当中的一个子系统宕机了 , 导致该业务异常无法运作 . MQ可以将要处理的业务缓存到消息队列中 , 由消息队列进行访问子系统执行业务 , 防止不一致运作问题 , 提高可用性\n * 异步处理 : 假如 A调用B , 但B需要执行很长一段时间 , 但A想知道B执行的进度 , 以往 会通过 A调用API查B进度 , 显然不优雅 . MQ可以使用消息总线 , A调用B后 , MQ会监控B进度(A实时得到B进度) , B处理完后 会发消息给MQ , 由MQ转发至A .\n\n\n# MQ特性\n\n# 可靠性\n\n消息丢失一般有3情况 :\n\n * 生产者丢失 通过 [发布确认](#发布确认模式 Publisher Confirms) , 确保 生产者 发送消息到MQ (SpringBoot应用\n * MQ丢失 通过 持久化/死信队列/备用交换机/回退消息 , 确保消息在MQ中不会丢失\n * 消费者丢失 通过 消息应答 , 确保 消费者 消费成功ack响应\n\n# 顺序性\n\n * 1个消费者消费1个队列是没有顺序问题的\n * 多个消费者消费同一个队列时就出现消费顺序的问题 . 可以考虑将一个队列分为多个队列 , 将需要保证顺序的消息发到一个队列里 , 一个队列对应一个消费者\n * 当消息在消费者端用多线程处理时 , 也会出现顺序问题 . 可以考虑在内存中维护多个队列 , 将MQ发来的需要保证顺序的消息放在同一个内存队列里 , 然后一个线程处理一个队列里的消息\n\n# 幂等性\n\n保证一条消息不会被重复消费 , 也不会对数据库产生影响\n\n场景 :\n\n * 手机验证码 , 只能使用一次 , 再次发送验证码 , 则会刷新原旧的验证码\n * 订单支付 , 每个订单只能支付一次\n\n**解决方案 : **\n\n * 消息使用 全局ID (可 通过时间戳/UUID等方式) , 确保唯一性 , 当写入数据时先判断是否存在 , 存在就没必要插入了 , 保证了不会重复插入现象\n * 采用 Redis 自带的天然幂等性 setnx\n\n参考文章 : https://blog.csdn.net/zw791029369/article/details/109561457\n\n\n# MQ分类\n\n# ActiveMQ\n\n优点 : 单机 万级吞吐量 , 时效性s级 , 可用性高 , 基于主从架构实现高可用性 , 消息可靠性较低的概率丢失数据 缺点 : 官方社区对 ActiveMQ5.x 维护越来越少 , 高吞吐量场景较少使用\n\n# Kafka\n\nKafka是大数据消息的中间件 , 满受大厂的采纳\n\n优点 : 单机 百万级吞吐量 , 时效性ms级 , 运作稳定 ; 分布式 , 少数宕机 , 也不会造成影响 . 消息有序 , 有UI管理页面 , 日志实时更新\n\n缺点 : 单机超过64个队列 , 消息队列多 , 响应长 (轮询) , 实时性取决轮询间隔 , 业务失败不能重试 , 社区更新慢\n\n# RocketMQ\n\n自 阿里巴巴 开源产品 , Java实现 , 参考了 Kafka设计 的改进版\n\n优点 : 单机 十万级吞吐量 , 可用性高 , 分布式架构 , 消息0丢失 , 支持 10亿级别的消息堆积 , 数据堆积不会影响性能\n\n缺点 : 语言拓展少 , 现阶段Java/C++实现 , 社区活跃一般\n\n# RabbitMQ (学习)\n\n是当前主流的消息中间件之一\n\n优点 : 高并发 , 性能高 , 单机万级吞吐量 , 跨平台 , 多语言支持 , 文档齐全 , 社区活跃高 , 更新频繁\n\n缺点 : 商业收费 , 学习成本高\n\n\n# 安装\n\n官方 : https://www.rabbitmq.com/download.html\n\n下载\n\n * MQ : RabbitMQ 下载地址 选择以 noarch.rpm 结尾的安装包\n * Erlang : Erlang 下载地址 , Erlang 和 RabbitMQ 版本对照 (MQ采用Erang语言开发 , 因此需要安装环境)\n\n> 注意Linux版本支持\n\n**安装步骤 : **\n\n 1. Linux上传文件 , 创建目录文件放置里面 ==mkdir /usr/local/rabbitmq==\n\n 2. 安装 Erlang , RabbitMQ , socat(MQ依赖插件)\n    \n    # Erlang\n    rpm -ivh erlang-21.3-1.el7.x86_64.rpm\n    \t# 检查版本 quit退出\n    \terl -v\n    # socat 依赖插件\n    yum install socat -y\n    # RabbitMQ\n    rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm\n    \t# 启动服务\n    \tsystemctl start rabbitmq-server\n    \t# 查看服务状态 (active绿色表示成功)\n    \tsystemctl status rabbitmq-server\n    \n\n\n# Web管理\n\n方便 查阅/操作 MQ\n\n# 安装\n\n 1. 执行指令安装 ==rabbitmq-plugins enable rabbitmq_management==\n 2. 重启MQ服务\n 3. Web访问 http://ip:15672 (IP为 Linux地址)\n 4. 账号密码为 guest (账号密码相同)\n 5. 在终端中添加账号 , 并且给予权限\n\n注意 :\n\n * 安装前提关闭MQ服务\n * Linux防火墙开放 15672端口(Web管理) , 5672端口(API连接)\n\n# 用户管理\n\n创建用户 ==rabbitmqctl add_user <用户名> <密码>==\n\n查看用户 ==rabbitmqctl list_users==\n\n修改密码 ==rabbitmqctl change_password <用户名> <新密码>==\n\n删除用户\n\n==rabbitmqctl delete_user <用户名>==\n\n设置用户 ==rabbitmqctl set_user_tags <用户名> <角色>==\n\n角色              说明\nadministrator   可以登录控制台、查看所有信息、并对rabbitmq进行管理\nmonToring       监控者；登录控制台，查看所有信息\npolicymaker     策略制定者；登录控制台指定策略\nmanagment       普通管理员；登录控制\n\n权限分配\n\n# 为用户添加资源权限，添加配置、写、读权限\n# rabbitmqctl set_permissions [-p <vhostpath>] <user> <conf> <write> <read>\nrabbitmqctl set_permissions -p "/" bozhu ".*" ".*" ".*"\n\n\n\n# 核心\n\n官方JavaAPI文档 : https://rabbitmq.github.io/rabbitmq-java-client/api/current/\n\n以下几大模式通过 Java API实现 , 模式的发送过程 , 在项目中需要引入以下依赖\n\n点击查看 Maven配置\n\n<dependencies>\n    \x3c!--rabbitmq 依赖客户端--\x3e\n    <dependency>\n        <groupId>com.rabbitmq</groupId>\n        <artifactId>amqp-client</artifactId>\n        <version>5.8.0</version>\n    </dependency>\n    \x3c!--操作文件流的一个依赖--\x3e\n    <dependency>\n        <groupId>commons-io</groupId>\n        <artifactId>commons-io</artifactId>\n        <version>2.6</version>\n    </dependency>\n</dependencies>\n\x3c!--指定 jdk 编译版本--\x3e\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-compiler-plugin</artifactId>\n            <configuration>\n                <source>8</source>\n                <target>8</target>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n\n\n\n# 简单模式 Hello World\n\nJava API实现 , 模拟发送接收过程\n\n基本方法\n\n返回       方法                                                      说明\n-        ==queueDeclare(String queue, boolean durable, boolean   发送消息\n         exclusive, boolean autoDelete, Map<String, Object>\n         arguments)==\nString   ==basicConsume(String queue, boolean autoAck,           接收消息 , 返回消息序列号\n         DeliverCallback deliverCallback, CancelCallback\n         cancelCallback)==\n\n实现步骤 :\n\n 1. 消息生产者\n    \n    点击查看代码\n    \n    public class Producer {\n        // 队列名称\n        public static final String QUERY_NAME = "hello";\n    \n        // 发消息\n        public static void main(String[] args) throws Exception {\n            // 连接工厂\n            ConnectionFactory factory = new ConnectionFactory();\n            // 基础信息\n            factory.setHost("192.168.186.128");\n            factory.setUsername("bozhu");\n            factory.setPassword("123123");\n            Connection connection = factory.newConnection();\n            // 频道\n            Channel channel = connection.createChannel();\n            /**\n             * 生成队列\n             * 参数 :\n             *  1. 队列名称\n             *  2. 队列消息是否持久化(是否磁盘存储)\n             *  3. 队列是否进行消息共享(多个消费者共享)\n             *  4. 是否自动删除(最后消费者开端连接后)\n             *  5. 其他参数\n             */\n            channel.queueDeclare(QUERY_NAME, false, false, false, null);\n    \n            // 发消息\n            String msg = "hello world";\n    \n            /**\n             * 发送消息\n             *  1. 指定交换机\n             *  2. 路由key值(本次队列名称)\n             *  3. 其他参数信息\n             *  4. 发送消息的消息体\n             */\n            channel.basicPublish("", QUERY_NAME, null, msg.getBytes());\n            System.out.println("send Success");\n        }\n    }\n    \n\n 2. 消息消费者\n    \n    点击查看代码\n    \n    public class Consumer {\n    \n        public static final String QUERY_NAME = "hello";\n    \n        public static void main(String[] args) throws Exception {\n            // 连接工厂\n            ConnectionFactory factory = new ConnectionFactory();\n            // 基础信息\n            factory.setHost("192.168.186.128");\n            factory.setUsername("bozhu");\n            factory.setPassword("123123");\n            Connection connection = factory.newConnection();\n            // 频道\n            Channel channel = connection.createChannel();\n    \n            /**\n             * 接收消息\n             *  1. 指定队列\n             *  2. 成功后是否自动应答\n             *  3. 未成功回调信息\n             *  4. 取消回调信息\n             */\n            channel.basicConsume(QUERY_NAME, true,\n                    (consumerTag, message) -> {\n                        System.out.println(new String(message.getBody()));\n                    },\n                    consumerTag -> {\n                        System.out.println("消息被中断");\n                    }\n            );\n        }\n    }\n    \n\n 3. 测试 , 运行 生产者 => Web查看业务队列 => 运行 消费者 => Web查看业务队列\n\n以上步骤中看出 生产者在运行后 , Web管理中可以看到队列新增了条 消息 (需要等待消费者消费) . 当消费者运行后会消耗掉该 消息\n\n> 消费者类 不能用 junit测试 接口写 , 否则没有监听的效果\n\n# 工具类优化\n\n实现复用 , 减少代码重写\n\npublic class RabbitMqUtils {\n\n    public static Channel getChanel() {\n        ConnectionFactory factory = new ConnectionFactory();\n        factory.setHost("192.168.186.128");\n        factory.setUsername("bozhu");\n        factory.setPassword("123123");\n        Channel channel;\n        try {\n            Connection connection = factory.newConnection();\n            channel = connection.createChannel();\n        } catch (IOException | TimeoutException e) {\n            throw new RuntimeException(e);\n        }\n        return channel;\n    }\n    \n}\n\n\n\n# 工作模式 Work queues\n\n工作模式 主要思想是为了避免消息密集型的形式堆积 , 工作模式可以在多线程消费者中进行分发任务\n\n# 轮询分发\n\n轮询消费队列中的数据 , 消费者们会轮询进行消费消息 (每个消息只能被消费一次)\n\n大致实现 :\n\n 1. 批发生产者\n 2. 多线程消费者\n 3. 运行测试 , 查看消费者的消费情况\n\n> 利用上面的 工具类 获取频道 (复用代码)\n\n生产者\n\n/**\n * 生产者\n */\npublic class Producer {\n\n    // 队列名称\n    public static final String QUERY_NAME = "hello";\n\n    // 发消息\n    public static void main(String[] args) throws Exception {\n        Channel chanel = RabbitMqUtils.getChanel();\n        String msg = "hello world";\n        chanel.queueDeclare(QUERY_NAME, false, false, false, null);\n        for (int i = 0; i < 10; i++) {\n            // 发消息\n            String str = msg + i;\n            chanel.basicPublish("", QUERY_NAME, null, str.getBytes());\n            System.out.println("发送成功 => " + str);\n        }\n    }\n\n}\n\n\n消费者\n\n服务形式多线程运行 , 可以区分出 消费者分别为 C1/C2/C3 , 在当中配置字符 , 来区分消费者\n\n/**\n * 消费者\n */\npublic class Consumer {\n\n    public static final String QUERY_NAME = "hello";\n\n    public static void main(String[] args) throws IOException {\n\n        System.out.println(args[0]+" 已运行!");\n\n        Channel chanel = RabbitMqUtils.getChanel();\n\n        chanel.basicConsume(QUERY_NAME, false, (consumerTag, message) -> {\n            System.out.println("成功 =>"+consumerTag+" : "+new String(message.getBody()));\n        }, consumerTag -> {\n            System.out.println("失败");\n        });\n    }\n    \n}\n\n\n运行测试\n\n先运行所有 生产者(此时消费者会处于等待消费的状态) , 后运行 消费者 , 运行后可以看出消费者消费方式是轮询形式的\n\n多服务运行 *\n\nmain方法运行会传递 args 参数 , 我们可以在以下进行传参运行\n\n 1. 配置好 , 填充参数 (如果多参数需要空格分开)\n 2. 打开服务(Alt+8) , 批量运行\n\n# 消息应答\n\n为了保证发送过程不丢失信息 , MQ引入了消息应答机制 . 例如 : 注册账号 , 填写表单信息 , 确认提交的过程\n\n应答机制 : 在消费者消耗处理后 , 才会告诉 MQ 进行删除消息\n\nMQ有两种应答机制 :\n\n * 自动应答(默认)\n * 手动应答\n\n可以在 ==Channel.basicConsume()== 方法的 autoAck参数 进行控制 手动/自动\n\n> 一般情况建议选择手动应答 , 防止数据丢失问题\n\n# 自动应答\n\n自动应答 是为了解决 高吞吐/安全传输 方面做出了权衡 .\n\nMQ不在乎消费者是否处理完成 , 都会告诉MQ删除队列 .\n\n情况 :\n\n * 消费者 处理失败也没有异常 , 会 自动补偿 , MQ会重新向消费者投递消息\n * 消费者 异常了 , MQ会认为消费成功 , 会对消息进行删除 , 导致数据丢失\n\n> **重新入队机制 : **\n> \n> 消费者处理消息过程 , 突然宕机 , 没有ack确认 , MQ得知消息未完全处理 , 会将其消息重新排队列 , 由其他消费者处理\n\n# 手动应答\n\n手动应答 , 消费者处理后 , 两种可能 :\n\n * 消费者手动 ack(确认应答) , 告诉MQ消息完成进行删除\n * 消费者自动 nack(拒绝应答) , 告诉MQ处理失败 , 消息不会删除\n\n应答方法\n\n返回     方法                                                        说明\nvoid   ==basicAck(long deliveryTag, boolean multiple)==          确认收到\nvoid   ==basicReject(long deliveryTag, boolean requeue)==        拒绝消息\nvoid   ==basicNack(long deliveryTag, boolean multiple, boolean   拒绝收到\n       requeue)==\n\n手动应答 和 重入队列机制 代码实例\n\n生产者\n\n/**\n * 消息在手动应答是不丢失、放回队列中重新消费\n * @author Sans\n */\npublic class Task {\n\n    public static final String QUEUE_NAME = "ack_queue";\n\n    public static void main(String[] args) throws Exception {\n        Channel chanel = RabbitMqUtils.getChanel();\n\n        // 声明对队列\n        chanel.queueDeclare(QUEUE_NAME, false, false, false, null);\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNext()) {\n            String msg = sc.next();\n            chanel.basicPublish("", QUEUE_NAME,null, msg.getBytes(StandardCharsets.UTF_8));\n            System.out.println("发送消息 => "+msg);\n        }\n        \n    }\n}\n\n\n消费者\n\n说明 : 配置两个消费者 , 一个消费者等待1s ; 另一个消费者等待10s . 参数分别是 :\n\n * ==c1 1000==\n * ==c2 10000==\n\n/**\n * 消费者\n * @author Sans\n */\npublic class Consumer {\n\n    public static final String QUEUE_NAME = "ack_queue";\n\n    /**\n     * @param args [线程名 , 休眠执行时长]\n     * @throws Exception\n     */\n    public static void main(String[] args) throws Exception {\n\n        Channel chanel = RabbitMqUtils.getChanel();\n\n        System.out.println(args[0]+" : 运行");\n\n        chanel.basicConsume(QUEUE_NAME, false, (consumerTag, message)->{\n            // 等待\n            try {\n                Thread.sleep(Long.parseLong(args[1]));\n            } catch (InterruptedException e) {\n                throw new RuntimeException(e);\n            }\n\n            System.out.println("接受到的消息:"+new String(message.getBody(), StandardCharsets.UTF_8));\n            /*\n             * 手动应答\n             * 1.消息的标记Tag\n             * 2.是否批量应答 false表示不批量应答信道中的消息\n             */\n            chanel.basicAck(message.getEnvelope().getDeliveryTag(),false);\n        },(consumerTag)->{\n        });\n    }\n\n}\n\n\n宕机模拟测试\n\n先运行 生产者 , 后运行2个消费者 , 最后生产者输入消息 , 以时间线来分析运作过程\n\n时间    生产者            消费者1(1S)    消费者2(10S)\n5s    发送 11 ; 发送22   收到11->ack   \n10s   -                          收到22->ack\n15s   发送 33 : 发送44   收到33->ack   收到44->...(关闭)\n16s                  收到44->ack   \n\n# 持久化\n\n持久化是将队列数据存储到磁盘中 , 并非在内存中 . 哪怕宕机停掉 , 不至于数据丢失的情况\n\n# 队列持久化\n\n在队列声明queueDeclare方法 中的第二个参数设为 true , 启动 队列持久化\n\n==queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map<String, Object> arguments)==\n\n注意 :\n\n * 原先队列中有非持久化 , 且队列名相同 , 那么会抛出错误 , 需要删除原先队列 , 并重新声明\n * 队列持久化 , 并不能进行对队列中的消息进行持久化\n\n# 消息持久化\n\n在消息发送的basicPublish方法 中的第二个参数设为 MessageProperties.PERSISTENT_TEXT_PLAIN , 启动 队列持久化\n\n==basicPublish(String exchange, String routingKey, boolean mandatory, BasicProperties props, byte[] body)==\n\n> 代码复用上面的即可 , 无需展示!\n\n# 信道堆积\n\n信道堆积 是指MQ发送到消费者的信道消息堆积数(缓冲区) . 缓冲区中默认情况是可以无限堆积的 , 因此需要自行控制堆积数 , 以防不必要的消息等待处理\n\n信道堆积主要通过 ==basicQos(prefetchCount)==方法 控制信道堆积数(默认0->无限)\n\n情况测试\n\n当生产者大量生产消息 , 且又有多个消费者(效率不同)时 :\n\n * 未指定堆积数 : 处理慢的消费者会堆积多个消息等待处理 , 处理快的可能会处于闲置状态\n * 指定堆积数 : 处理慢的消费者 , 当消息堆积到达指定数值 , 轮询分发消息会跳过该消费者\n\n> 轮询分发 : 会将所有消息平均分发被每个消费者中 , 等待消费\n> \n> 默认情况下每条信道能够堆积无数条\n\n注意 :\n\n * 应答需要设为 手动应答 , 否则qos , 不会生效\n\n\n# 发布确认模式 Publisher Confirms\n\n发布确认 是保证了消息完好的推送到MQ队列中 , 确保数据不会丢失 , 以便消费者消费使用\n\n大致步骤 :\n\n 1. 获取信道\n 2. 信道启动 发布确认模式 ==confirmSelect()==方法\n 3. 向MQ推送消息 ==basicPublish()==方法\n 4. 向MQ发送确认 ==waitForConfirms()==方法\n\n异步发布 走以下步骤\n\n 5. MQ返回状态 至 监听器 进行回调 ack/nack (成功/失败)\n 6. 失败重新推送 (回至步骤3操作)\n\n主要方法\n\n返回                方法                                                  说明\nvoid              ==confirmSelect()==                                 启动 发布确认模式\nboolean           ==waitForConfirms()==                               向MQ发送 发布确认\nConfirmListener   ==addConfirmListener(ConfirmCallback ackCallback,   监听器 , 监听发布状态 成功/失败 , 以lambda形式 回调它们\n                  ConfirmCallback nackCallback)==\n\n确认发布 可分为以下类型 :\n\n * 单体 同步等待确认 , 简单 , 吞吐量有限\n * 批量 批量同步等待确认 , 简单 , 一旦出问题难以判断\n * 异步 高性能 , 采用 监听器监听发布状态 和 ConcurrentSkipListMap哈希表 多线程管理 , 能够准确异常\n\n耗时 : 单体 > 批量 > 异步\n\n三种模式代码示例 :\n\n秒表工具类\n\n/**\n * 秒表计时工具\n */\npublic class StopWatchUtils {\n\n    public static long start;\n    public static long totalTime;\n\n    public static void start(){\n        start = System.currentTimeMillis();\n    }\n\n    public static void stop(){\n        totalTime = System.currentTimeMillis() - start;\n    }\n\n    public static long getTotalTime() {\n        return totalTime;\n    }\n\n}\n\n\n测试耗时\n\n点击查看代码\n\n/**\n * 1000条消息发布测试\n */\npublic class Producer {\n\n    public static long MSG_COUNT = 1000;\n\n    public static void main(String[] args) throws Exception {\n        // 单体发布测试 (耗时 => 1391ms\n        //publishMesIndividually();\n        // 批量发布测试 (耗时 => 85ms\n        //publishMesBatch();\n        // 异步发布测试 (耗时 => 28ms\n        publishMesAsync();\n    }\n\n    /**\n     * 异步发布\n     * 只管发 , 成功/失败 由监听器管\n     */\n    private static void publishMesAsync() throws IOException {\n        Channel chanel = RabbitMqUtils.getChanel();\n        String queueName = UUID.randomUUID().toString();\n        // 队列声明 (持久化\n        chanel.queueDeclare(queueName, true, false, false, null);\n        // 启动确认发布\n        chanel.confirmSelect();\n\n        /*\n          线程安全有序的哈希表 , 使用高并发情况\n            - 轻松记录 序号与消息 的关联\n            - 通过序号轻松批量删除条目\n            - 支持多线程\n         */\n        ConcurrentSkipListMap<Long, String> outstandingConfirms = new ConcurrentSkipListMap<>();\n\n        /*\n          监听器 (监听消息是否成功)\n          参数1: 消息确认回调\n          参数2: 消息失败回调\n            - deliveryTag 消息标记\n            - multiple 是否批量\n         */\n        chanel.addConfirmListener(\n                (deliveryTag, multiple) -> {\n                    // 是否批量\n                    if (multiple) {\n                        // 获取已经确认的视图\n                        ConcurrentNavigableMap<Long, String> confirmed = outstandingConfirms.headMap(deliveryTag);\n                        // 清除视图内容\n                        confirmed.clear();\n                    } else {\n                        // 直接删除序号\n                        outstandingConfirms.remove(deliveryTag);\n                    }\n                    System.out.println("确认消息 => " + deliveryTag);\n                },\n                (deliveryTag, multiple) -> {\n                    String msg = outstandingConfirms.remove(deliveryTag);\n                    System.out.println("失败消息[" + msg + "] => " + deliveryTag);\n                });\n\n        StopWatchUtils.start();\n        // 发消息\n        for (int i = 1; i <= MSG_COUNT; i++) {\n            String msg = "msg => " + i;\n            chanel.basicPublish("", queueName, null, msg.getBytes(StandardCharsets.UTF_8));\n            // 存下所有 生产者发送的消息 K(消息序列号):V(消息内容)\n            outstandingConfirms.put(chanel.getNextPublishSeqNo(), msg);\n        }\n        StopWatchUtils.stop();\n        System.out.println("耗时 => " + StopWatchUtils.getTotalTime() + "ms");\n    }\n\n    /**\n     * 批量发布\n     * 发布多个确认一次\n     */\n    private static void publishMesBatch() throws Exception {\n        Channel chanel = RabbitMqUtils.getChanel();\n        String queueName = UUID.randomUUID().toString();\n        // 队列声明 (持久化\n        chanel.queueDeclare(queueName, true, false, false, null);\n        // 启动确认发布\n        chanel.confirmSelect();\n\n        // 批单位\n        int batchSize = 100;\n\n        StopWatchUtils.start();\n        for (int i = 1; i <= MSG_COUNT; i++) {\n            String msg = "msg => " + i;\n            chanel.basicPublish("", queueName, null, msg.getBytes(StandardCharsets.UTF_8));\n            if (i % batchSize == 0) {\n                if (chanel.waitForConfirms()) System.out.println("第" + i / batchSize + "批发送成功" + msg);\n            }\n        }\n        StopWatchUtils.stop();\n        System.out.println("耗时 => " + StopWatchUtils.getTotalTime() + "ms");\n\n    }\n\n    /**\n     * 单体发布\n     * 发布一次确认一次\n     */\n    public static void publishMesIndividually() throws Exception {\n        Channel chanel = RabbitMqUtils.getChanel();\n        String queueName = UUID.randomUUID().toString();\n        // 队列声明 (持久化\n        chanel.queueDeclare(queueName, true, false, false, null);\n        // 启动确认发布\n        chanel.confirmSelect();\n\n        StopWatchUtils.start();\n        for (int i = 0; i < MSG_COUNT; i++) {\n            String msg = "msg => " + i;\n            chanel.basicPublish("", queueName, null, msg.getBytes(StandardCharsets.UTF_8));\n            if (chanel.waitForConfirms()) {\n                System.out.println("发送成功 " + msg);\n            }\n        }\n        StopWatchUtils.stop();\n        System.out.println("耗时 => " + StopWatchUtils.getTotalTime() + "ms");\n    }\n\n}\n\n\n\n# 发布/订阅 模式 Publish/Subscribe\n\n发布订阅模式是生产者推送的消息 , 其他消费者都均可收到该消息\n\n大致流程 :\n\n 1. 声明交换机 , 并设置 fanout 类型\n 2. 生产者发送消息 到交换机\n 3. 消费者队列绑定交换机 , 并配置 RoutingKey路由规则 (类似订阅)\n 4. 消费者接收消息\n\n# 交换机 Exchange\n\n生产者生产的消息不会直接发送到队列中的 , 而是发送到交换机 , 由交换机推入队列\n\n交换机类型 : (点击跳转代码示例)\n\n * direct(点对点) (默认) 交换机会匹配 生产者发送的 RoutingKey 与 消费者队列绑定交换机的 RoutingKey . 相同才能实现点对点发送 . 如果没有匹配到一个 , 很有可能会丢失数据\n * topic(发布订阅) 交换机会 通配符匹配 生产者发送的 RoutingKey 与 消费者队列绑定交换机的 RoutingKey , 符合条件的队列都会收到分发的消息\n * fnout(广播) 只要消费者绑定有该类型交换机 , 不管RoutingKey是否匹配 , 都会接收广播消息\n * ...\n\n交换机 声明方法\n\n==Channel.exchangeDeclare(String exchange, String type)==\n\n * exchange : 交换机名称\n * type : 交换类型\n\n# 临时队列\n\n临时队列 , 字面意思暂时使用的队列\n\n队列特性 :\n\n * 随机名称\n * 断开消费者连接队列自动删除\n\nWeb管理页中 , 可以看到队列状态是 AD Excl (自动删除)\n\n临时队列创建\n\n==queueDeclare()==\n\n一般去会获取队列标识进行食用 ==chanel.queueDeclare().getQueue();==\n\n# 绑定 binding\n\nExchange交换机 创建后需要绑定队列才会进行推送消息至消费者 . 可以绑定多个队列 , 消息推送是根据 Routing Kye(路由规则) 来确定指定队列\n\n点击查看代码\n\n\n\n> 交换机只负责转发消息 , 并没有存储消息的能力 , 因此如果没有任何队列与Exchange绑定，或者没有符合路由规则的队列 , 那么消息会丢失\n\n绑定方法\n\n==queueBind(String queue, String exchange, String routingKey)==\n\n * queue : 队列名\n * exchange : 交换机\n * routing Key : 路由Key\n\n> 重载方法 , 可在最后面携带参数 , 详细自行API\n\nWeb管理页 绑定\n\nExchanges -> 指定Exchange交换机 -> Bindings\n\n2\n\n# direct\n\n交换机会匹配 生产者发送的 RoutingKey 与 消费者队列绑定交换机的 RoutingKey . 相同才能实现点对点发送 . 如果没有匹配到一个 , 很有可能会丢失数据\n\n代码示例 : 点击跳转\n\n# topic\n\n交换机会根据 通配符匹配 生产者发送的 RoutingKey 与 消费者队列绑定交换机的 RoutingKey , 符合条件的队列都会收到分发的消息\n\n通配符说明 :\n\n * * 代替一个单词\n * # 代替0个/多个单词\n\n> 特殊情况 :\n> \n>  * 如果只有一个 # 那么将会接收通道的所有数据\n>  * 如果没有 #/* 出现 , 默认采用 direct\n\n匹配案例 :\n\nROUTINGKEY            通配值        说明\ncom.sans.color        *.sans.*   匹配3个单词中的中间单词 sans\ncom.sans.color.red    #.red      匹配最后为 red\ncom.sans.color.blue   con.#      匹配开头为 com\n\n代码示例 : 点击跳转\n\n# fnout\n\n只要消费者绑定有该类型交换机 , 不管RoutingKey是否匹配 , 都会接收广播消息\n\n代码示例 : [点击跳转](#广播 fnout)\n\n# 代码实战\n\n通用代码 , 参数自控\n\n> 食用说明 :\n> \n>  1. 采用Main传参控制 , 跳转了解\n>  2. 采用信道获取工具类 , 跳转了解\n\n生产者\n\n/**\n * 广播发送\n * @author Sans\n */\npublic class Producer {\n\n    /**\n     * @param args [交换机名, 交换机类型, 路由key]\n     * @throws Exception\n     */\n    public static void main(String[] args) throws Exception {\n\n        String exchangeName = args[0];\n        String exchangeTypeParam = args[1];\n        // 如果未赋予值 , 默认为 ""\n        String routingKey = args.length == 2 ? "" : args[2];\n\n        System.out.println("[交换机名, 交换机类型, 路由key]");\n        System.out.println(Arrays.toString(args));\n\n        // 枚举验证\n        BuiltinExchangeType exchangeType = null;\n        for (BuiltinExchangeType value : BuiltinExchangeType.values()) {\n            if (value.getType().equals(exchangeTypeParam)) exchangeType = value;\n        }\n        if (exchangeType == null) return;\n\n        Channel channel = RabbitMqUtils.getChanel();\n        /*\n          声明一个exchange\n          1.exchange的名称\n          2.exchange的类型\n         */\n        channel.exchangeDeclare(exchangeName, exchangeType);\n\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            String message = scanner.next();\n            // 发布消息\n            channel.basicPublish(exchangeName, routingKey, null, message.getBytes(StandardCharsets.UTF_8));\n            System.out.println("生产者发出消息:" + message);\n        }\n    }\n\n}\n\n\n消费者\n\n/**\n * 消费者\n * @author Sans\n */\npublic class Consumer {\n\n    /**\n     * @param args [交换机名, 路由key]\n     * @throws Exception\n     */\n    public static void main(String[] args) throws Exception {\n\n        String exchangeName = args[0];\n        String routingKey = args[1];\n        System.out.println("[交换机名, 路由key]");\n        System.out.println(Arrays.toString(args));\n\n\n        Channel chanel = RabbitMqUtils.getChanel();\n        // 临时队列\n        String queueName = chanel.queueDeclare().getQueue();\n        // 绑定交换机\n        chanel.queueBind(queueName, exchangeName, routingKey);\n\n        // 接收消息\n        chanel.basicConsume(queueName, true,(consumerTag,message)->{\n            System.out.println("收到消息 => "+new String(message.getBody(), StandardCharsets.UTF_8));\n        },consumerTag->{});\n\n    }\n}\n\n\n以上Main中接收参数分别说明\n\n身份    接收参数\n生产者   [交换机名, 交换机类型, 路由key]\n消费者   [交换机名, 路由key]\n\n# direct点对点测试\n\n运行顺序   应用程序服务   参数传递(直接复制即可)\n1      生产者 P1   ==color direct blue==\n2      消费者 C1   ==color blue==\n3      消费者 C2   ==color black==\n\n结果 : C1消费了 , C2无消费 . 只有 RoutingKey 匹配的消费者消费消息\n\n# topic发布订阅\n\n运行顺序   应用程序服务   传递参数(直接复制即可)\n1      生产者 P1   ==color topic com.sans.red==\n2      消费者 C1   ==color #.red==\n3      消费者 C2   ==color com.#==\n4      消费者 C3   ==color com.*==\n5      消费者 C4   ==color *.red==\n6      消费者 C5   ==color #==\n7      消费者 C6   ==color *==\n\n结果 : C1 , C2 , C5 消费者消费了 , 其余未消费 . 只有 RoutingKey通配符匹配 的消费者消费消息\n\n# 广播 fnout\n\n运行顺序   应用程序服务   传递参数(直接复制即可)\n1      生产者 P1   ==color fnout red==\n2      消费者 C1   ==color black==\n3      消费者 C2   ==color blue==\n4      消费者 C3   ==color yellow==\n\n结果 : 所有消费者都消费了 . 消费者收到消息不会受到 RoutingKey的影响 , 只需绑定就可以收到通知\n\n\n# 进阶\n\n\n# 死信队列\n\n死信 是无法被消费的消息\n\n情况 : 生产者 发送消息 MQ , 消费者 从 队列 取出 , 由于某些原因导致 队列 中的某些消息无法被消费 , 这样的消息没有得到处理 , 称之为死信\n\n场景 : 用户下订单时 , 点击支付 , 但又未在指定时间支付 , 死信队列机制会误认为异常消息 , 消息将会投入死信队列中\n\n触发机制 :\n\n * 消息 TTL 过期\n * 队列到达最大长度\n * 消息被拒 , 使用 channel.basicNack/channel.basicReject 应答 , 并且参数requeue为false(不回流队列)\n\n> 交换机 和 队列 中的配置 , 一旦有修改 需要删除 重新运行\n\nWeb管理页中 , 可以看到队列状态是 DLX(死信交换机) , DLK (死信routingKey)\n\n**代码示例 : **\n\n初始化构架声明\n\n点击查看代码\n\n/**\n * 初始化架构\n * 初始化 交换机 , 队列 结构信息\n * @author Sans\n */\npublic class InitialArchitecture {\n\n    // 普通交换机的名称\n    public static final String NORMAL_EXCHANGE = "normal_exchange";\n    // 死信交换机的名称\n    public static final String DEAD_EXCHANGE = "dead_exchange";\n\n    // 普通队列的名称\n    public static final String NORMAL_QUEUE = "normal_queue";\n    // 死信队列的名称\n    public static final String DEAD_QUEUE = "dead_queue";\n    \n    public static void main(String[] args) throws Exception {\n        Channel chanel = RabbitMqUtils.getChanel();\n\n        String normalRoutingKey = "sans";\n        String deadRoutingKey = "dead";\n        \n        // 重新初始化 , 删除以往相同名称的 交换机和队列\n        chanel.exchangeDelete(NORMAL_EXCHANGE);\n        chanel.exchangeDelete(DEAD_EXCHANGE);\n        chanel.queueDelete(NORMAL_QUEUE);\n        chanel.queueDelete(DEAD_QUEUE);\n\n        // 声明 普通,死信 交换机\n        chanel.exchangeDeclare(NORMAL_EXCHANGE, BuiltinExchangeType.DIRECT);\n        chanel.exchangeDeclare(DEAD_EXCHANGE, BuiltinExchangeType.DIRECT);\n\n        Map<String, Object> arguments = new HashMap<>();\n        // 正常的队列设置死信交换机\n        arguments.put("x-dead-letter-exchange", DEAD_EXCHANGE);\n        // 设置死信routingKey\n        arguments.put("x-dead-letter-routing-key", deadRoutingKey);\n        /* 超出长度 测试\n           设置队列最大长度\n        */ \n        //arguments.put("x-max-length", 6);\n\n        // 声明 普通队列 , 死信队列\n        chanel.queueDeclare(NORMAL_QUEUE, false, false, false, arguments);\n        chanel.queueDeclare(DEAD_QUEUE, false, false, false, null);\n\n        // 普通队列 绑定 普通交换机\n        chanel.queueBind(NORMAL_QUEUE, NORMAL_EXCHANGE, normalRoutingKey);\n        // 死信队列 绑定 死信交换机\n        chanel.queueBind(DEAD_QUEUE, DEAD_EXCHANGE, deadRoutingKey);\n    }\n}\n\n\n生产者\n\n点击查看代码\n\n/**\n * 生产者\n * @author Sans\n */\npublic class Producer {\n\n    // 普通交换机的名称\n    public static final String NORMAL_EXCHANGE = "normal_exchange";\n\n    public static void main(String[] args) throws Exception {\n        Channel chanel = RabbitMqUtils.getChanel();\n\n        String routingKey = "sans";\n\n        for (int i = 0; i < 10; i++) {\n            String msg = "msg " + i;\n            /** TTL 超时测试\n                参数3 : 构造者构建参数 ttl时间参数\n            */\n            chanel.basicPublish(NORMAL_EXCHANGE,\n                    routingKey,\n                    //new AMQP.BasicProperties().builder().expiration("10000").build(),\n                    null,\n                    msg.getBytes(StandardCharsets.UTF_8));\n            System.out.println("发送成功 => " + msg);\n        }\n\n    }\n\n}\n\n\n消费者1\n\n点击查看代码\n\n/**\n * 消费者1\n * @author Sans\n */\npublic class Consumer1 {\n\n    // 普通队列的名称\n    public static final String NORMAL_QUEUE = "normal_queue";\n\n    public static void main(String[] args) throws Exception {\n        Channel chanel = RabbitMqUtils.getChanel();\n\n        // 处理消息\n        chanel.basicConsume(NORMAL_QUEUE, true, (consumerTag, message) -> {\n            String msg = new String(message.getBody(), StandardCharsets.UTF_8);\n            System.out.println("接收消息 => " + msg);\n            // 消息拒绝 测试\n            //long deliveryTag = message.getEnvelope().getDeliveryTag();\n            //if ("msg 4".equals(msg)) {\n            //    /* 拒绝 消息/收到\n            //        拒绝收到 (参数3: false防止回流队列): chanel.basicNack(deliveryTag, false, false);\n            //        拒绝消息 (参数2: false防止回流队列): chanel.basicReject(deliveryTag, false);\n            //     */\n            //    //chanel.basicNack(deliveryTag, false, false);\n            //    chanel.basicReject(deliveryTag, false);\n            //    System.out.println("拒绝 => " + msg);\n            //}else{\n            //    chanel.basicAck(deliveryTag, false);\n            //    System.out.println("接收消息 => " + msg);\n            //}\n        }, consumerTag -> {\n        });\n\n    }\n}\n\n\n消费者2 (死信消费)\n\n点击查看代码\n\n/**\n * 消费者2\n * @author Sans\n */\npublic class Consumer2 {\n\n    // 死信队列的名称\n    public static final String DEAD_QUEUE = "dead_queue";\n\n    public static void main(String[] args) throws Exception {\n        Channel chanel = RabbitMqUtils.getChanel();\n\n        // 处理消息\n        chanel.basicConsume(DEAD_QUEUE, true, (consumerTag, message) -> {\n            System.out.println("接收消息 => " + new String(message.getBody(), StandardCharsets.UTF_8));\n        }, consumerTag -> {\n        });\n\n    }\n}\n\n\n# 测试\n\n触发死信机制 : 有3种触发条件 , 分别围绕它们的条件进行测试\n\n过期触发TTL\n\n 0. 配置 生产者发送方法 ==basicPublish()== 中的第三参数 添加消息属性 (采用构造者模式构造类) ==new AMQP.BasicProperties().builder().expiration("10000").build()== (TTL设置10s过期)\n 1. 运行 初始化架构\n 2. 运行 生产者\n 3. 观察 Web管理页 , 普通队列中的所有消息 过期推送至 死信队列中\n 4. 运行 消费者2 , 清除死信队列中的消息\n\n队列到达最大长度\n\n 0. 配置 初始化架构 , 在 声明普通队列 ==queueDeclare()==方法 中的第五个参数 编辑队列属性 Map集合新增 : ==arguments.put("x-max-length", 6);== (队列设置最大长度为6条消息)\n 1. 运行 初始化架构\n 2. 运行 生产者\n 3. 运行 消费者1\n 4. 观察 Web管理页 , 普通队列中的消息 , 有部分消息会被排挤到 死信队列中\n 5. 运行 消费者2 , 清除死信队列中的消息\n\n> 注意 :\n> \n>  * 初始化架构类中的配置 一旦修改了 , 则需要删除掉原旧的 交换机/队列 , 在运行 (配置更改了会冲突)\n>  * 为了尽可能的展现消息进入 死信队列中 , 要确保上一次所修改的配置是否还原 , 以防上次的配置影响数据混乱\n\n消息被拒绝\n\n 0. 配置 消费者1 , 手动应答请求 , 指定部分拒绝接收\n    \n    chanel.basicConsume(NORMAL_QUEUE, false, (consumerTag, message) -> {\n        String msg = new String(message.getBody(), StandardCharsets.UTF_8);\n        long deliveryTag = message.getEnvelope().getDeliveryTag();\n        if ("msg 4".equals(msg)) {\n            /* 拒绝 消息/收到\n                拒绝收到 (参数3: false防止回流队列): chanel.basicNack(deliveryTag, false, false);\n                拒绝消息 (参数2: false防止回流队列): chanel.basicReject(deliveryTag, false);\n             */\n            //chanel.basicNack(deliveryTag, false, false);\n            chanel.basicReject(deliveryTag, false);\n            System.out.println("拒绝 => " + msg);\n        }else{\n            chanel.basicAck(deliveryTag, false);\n            System.out.println("接收消息 => " + msg);\n        }\n    }, consumerTag -> {\n    });\n    \n\n 1. 运行 初始化架构\n\n 2. 运行 生产者1\n\n 3. 运行 消费者1\n\n 4. 观察 Web管理页 , 普通队列中的消息 , 有一条 msg4消息 被拒绝 至死信队列中\n\n 5. 运行 消费者2 , 清除死信队列中的消息\n\n\n# 整合SpringBoot\n\nSpringboot文档 : https://docs.spring.io/spring-amqp/reference/html/amqp.html\n\n# 快速入门\n\n引入依赖\n\n\x3c!--RabbitMQ 依赖--\x3e\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-amqp</artifactId>\n</dependency>\n\n\napplication配置\n\nserver:\n    port: 8088\nspring:\n    rabbitmq:\n        host: 8.130.47.114\n        port: 5672\n        username: bozhu\n        password: 123123\n\n\n> 端口容易冲突 , 建议修改\n\nRabbitmqConfig配置类\n\n交换机和队列 , 以及绑定 , 等操作是通过实例化形式进行的 , 以下由配置类形式展示\n\n简单结构\n\n\n\n点击查看代码\n\n@Configuration\npublic class RabbitmqConfig {\n   \n   // 交换机\n   String aExchange = "a_exchange";\n   String deadExchange = "dead_exchange";\n   // 队列\n   String aQueue = "a_queue";\n   String deadQueue = "dead_queue";\n   \n   String routingKeyA = "RKA"\n   String routingKeyB = "RKB"\n   \n   /**\n    * 交换机\n    */\n   @Bean\n   public DirectExchange aExchange() {\n       return new DirectExchange(aExchange);\n   }\n   @Bean\n   public DirectExchange deadExchange() {\n       return new DirectExchange(deadExchange);\n   }\n   \n   /**\n    * 队列\n    */\n   @Bean\n   public Queue aQueue() {\n       // 配置 死信交换机, 死信RoutingKey, 过期TTL\n       return QueueBuilder.durable(aExchange)\n               .deadLetterExchange(deadExchange)\n               .deadLetterRoutingKey(routingKeyB)\n               .ttl(10*1000)\n               .build();\n   }\n   @Bean\n   public Queue deadQueue() {\n       return QueueBuilder.durable(deadQueue).build();\n   }\n   \n   /**\n    * 绑定\n    */\n   @Bean\n   public Binding bindingAqueueToAexchange(Queue aQueue , DirectExchange aExchange) {\n       return BindingBuilder.bind(aQueue).to(aExchange).with(routingKeyA);\n   }\n   @Bean\n   public Binding queueBbindX(Queue deadQueue , DirectExchange deadExchange) {\n       return BindingBuilder.bind(deadQueue).to(deadExchange).with(routingKeyB);\n   }\n}\n\n\n# 操作对象\n\n类                说明\nRabbitTemplate   简化的 发送/接收 消息类\nAmqpAdmin        携带式对AMQP管理操作类\n\n生产者发送消息 : ==RabbitTemplate.convertAndSend()==\n\n# 消费者\n\n@Component\npublic class QueueConsumer {\n    // 队列处理消息\n    // 注解指定队列名\n    @RabbitListener(queues = "QA")\n    public void receiveDead(Message message, Channel channel) {\n        String msg = new String(message.getBody(), StandardCharsets.UTF_8);\n        System.out.println("处理消息 => " + msg);\n    }\n}\n\n\n\n# 延迟队列\n\n延迟队列 是用来存放到指定时间才被释放消息的队列\n\n延迟队列机制 和 死信 TTL过期 相似 , 但延迟队列对时间的控制较灵活 , 应用应用场景广泛\n\n场景 :\n\n 1. 下单十分钟未支付自动取消订单\n 2. 新建店铺 , 如果十天未上传商品 , 则自动发送消息提醒\n 3. 新用户注册后 , 三天未登录则进行短信提醒\n 4. 用户发起退款 , 如果三天未处理则通知相关运营人员\n 5. 会议预定 , 指定时间的前十分钟提醒参加会议\n\n可以控制任意时间点发送通知\n\n# 应用方式\n\n延迟配置\n\n在 队列 中配置延迟属性\n\n/* 变量说明\n\tNORMAL_QUEUE_A : 队列名称\n\tDEAD_EXCHANGE_Y : 死信交换机名称\n\tROUTING_DEAD_QUEUE_KEY : 死信RoutingKey\n*/\n@Bean\npublic Queue aQueue() {\n    // 配置 死信交换机, 死信RoutingKey, 过期TTL\n    return QueueBuilder.durable(NORMAL_QUEUE_A)\n            .deadLetterExchange(DEAD_EXCHANGE_Y)\n            .deadLetterRoutingKey(ROUTING_DEAD_QUEUE_KEY)\n            .ttl(10*1000)\n            .build();\n}\n\n\n在 生产者 消息发送方法 中配置延迟\n\n指定消息TTL在队列中超时时长 : ==message.getMessageProperties().setExpiration(ttl);==\n\n// 发送消息方法\nrabbitTemplate.convertAndSend(NORMAL_EXCHANGE_X, ROUTING_KEY_QUEUE_C, msg,\n        message -> {\n            message.getMessageProperties().setExpiration(ttl);\n            return message;\n        }\n);\n\n\n# 代码示例\n\n架构 :\n\n\n\n初始化架构 RabbitmqConfig\n\n点击查看代码\n\n@Configuration\npublic class RabbitmqConfig {\n\n    // 普通/死信 交换机\n    public static final String NORMAL_EXCHANGE_X = "EX";\n    public static final String DEAD_EXCHANGE_Y = "EY";\n    // 死信 队列\n    public static final String DEAD_QUEUE = "QD";\n    // 普通 队列\n    public static final String NORMAL_QUEUE_A = "QA";\n    public static final String NORMAL_QUEUE_B = "QB";\n    public static final String NORMAL_QUEUE_C = "QC";\n\n    // RoutingKey\n    public static final String ROUTING_KEY_QUEUE_A = "RQA";\n    public static final String ROUTING_KEY_QUEUE_B = "RQB";\n    public static final String ROUTING_KEY_QUEUE_C = "RQC";\n    // 死信 RoutingKey\n    public static final String ROUTING_DEAD_QUEUE_KEY = "RQD";\n\n    /**\n     * 交换机\n     */\n    @Bean\n    public DirectExchange xExchange() {\n        return new DirectExchange(NORMAL_EXCHANGE_X);\n    }\n\n    @Bean\n    public DirectExchange yExchange() {\n        return new DirectExchange(DEAD_EXCHANGE_Y);\n    }\n\n    /**\n     * 队列\n     */\n    @Bean\n    public Queue aQueue() {\n        // 配置 死信交换机, 死信RoutingKey, 过期TTL\n        return QueueBuilder.durable(NORMAL_QUEUE_A)\n                .deadLetterExchange(DEAD_EXCHANGE_Y)\n                .deadLetterRoutingKey(ROUTING_DEAD_QUEUE_KEY)\n                .ttl(10*1000)\n                .build();\n    }\n\n    @Bean\n    public Queue bQueue() {\n        // 配置 死信交换机, 死信RoutingKey, 过期TTL\n        return QueueBuilder.durable(NORMAL_QUEUE_B)\n                .deadLetterExchange(DEAD_EXCHANGE_Y)\n                .deadLetterRoutingKey(ROUTING_DEAD_QUEUE_KEY)\n                .ttl(40*1000)\n                .build();\n    }\n\n    @Bean\n    public Queue cQueue() {\n        // 配置 死信交换机, 死信RoutingKey\n        return QueueBuilder.durable(NORMAL_QUEUE_C)\n                .deadLetterExchange(DEAD_EXCHANGE_Y)\n                .deadLetterRoutingKey(ROUTING_DEAD_QUEUE_KEY)\n                .build();\n    }\n\n\n    @Bean\n    public Queue deadQueue() {\n        return QueueBuilder.durable(DEAD_QUEUE).build();\n    }\n\n    /**\n     * 绑定\n     * 比较示例 : 普通队列绑定 普通队列 --- 普通交换机\n     * chanel.queueBind(NORMAL_QUEUE, NORMAL_EXCHANGE, normalRoutingKey);\n     */\n    @Bean\n    public Binding queueAbindingX(Queue aQueue , DirectExchange xExchange) {\n        return BindingBuilder.bind(aQueue).to(xExchange).with(ROUTING_KEY_QUEUE_A);\n    }\n    @Bean\n    public Binding queueBbindingX(Queue bQueue , DirectExchange xExchange) {\n        return BindingBuilder.bind(bQueue).to(xExchange).with(ROUTING_KEY_QUEUE_B);\n    }\n    @Bean\n    public Binding queueCbindingX(Queue cQueue, DirectExchange xExchange) {\n        return BindingBuilder.bind(cQueue).to(xExchange).with(ROUTING_KEY_QUEUE_C);\n    }\n    @Bean\n    public Binding queueDbindingY(Queue deadQueue , DirectExchange yExchange) {\n        return BindingBuilder.bind(deadQueue).to(yExchange).with(ROUTING_DEAD_QUEUE_KEY);\n    }\n}\n\n\n生产者 ProducerSendMessageController\n\n点击查看代码\n\n@RestController\n@RequestMapping("/producer")\npublic class ProducerSendMessageController {\n\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @GetMapping("/send/{msg}")\n    public void sendMessage(@PathVariable String msg) {\n        System.out.println("收到请求 => " + msg);\n\n        // 发送消息\n        rabbitTemplate.convertAndSend(NORMAL_EXCHANGE_X, ROUTING_KEY_QUEUE_B, "B队列(40 000ms) =>" + msg);\n        rabbitTemplate.convertAndSend(NORMAL_EXCHANGE_X, ROUTING_KEY_QUEUE_A, "A队列(10 000ms) =>" + msg);\n    }\n\t\n    /**\n     * QC 发送消息(自定义时长)\n     * @param msg 消息\n     * @param ttl 过期时长 ms\n     */\n    @GetMapping("/qcSend/{msg}/{ttl}")\n    public void sendMessage(@PathVariable String msg, @PathVariable String ttl) {\n        System.out.printf("收到请求 => [%s, %s]%n", msg, ttl);\n        rabbitTemplate.convertAndSend(NORMAL_EXCHANGE_X, ROUTING_KEY_QUEUE_C, msg,\n                message -> {\n                    message.getMessageProperties().setExpiration(ttl);\n                    return message;\n                }\n        );\n    }\n\n}\n\n\n死信消费者 DeadQueueConsumer\n\n@Component\npublic class DeadQueueConsumer {\n\t// 死信处理\n    @RabbitListener(queues = DEAD_QUEUE)\n    public void receiveDead(Message message, Channel channel) {\n        String msg = new String(message.getBody(), StandardCharsets.UTF_8);\n        System.out.println("死信消费 => " + new Date() + " : " + msg);\n    }\n}\n\n\n# 代码测试\n\n测试 QA 和 QB 队列 TTL过期测试\n\n 1. 访问 http://localhost:8088/producer/send/lisi\n 2. 观察 控制台 , 死信队列打印的消息(等待10s/40s)\n\n> 他们队列是分开分发一条消息 互不干扰 , 等待时间分别是 10s/40s\n\n测试 QC 队列多消息\n\n 1. 连续访问 http://localhost:8088/producer/qcSend/GOGO/10000\n\n 2. 连续访问 http://localhost:8088/producer/qcSend/GOGOGO/15000\n\n 3. 连续访问 http://localhost:8088/producer/qcSend/GO/5000\n\n 4. 观察 控制台 , 消息是共同在队列中进行等待时间\n    \n    收到请求 => [GOGO, 10000]\n    收到请求 => [GOGOGO, 15000]\n    收到请求 => [GO, 5000]\n    死信消费 => Mon Mar 06 11:25:59 CST 2023 : GOGO\n    死信消费 => Mon Mar 06 11:26:05 CST 2023 : GOGOGO\n    死信消费 => Mon Mar 06 11:26:05 CST 2023 : GO\n    \n\n> 在 多消息同一队列中 , 消息的TTL过期时间是同时加载的 , 并且是有序的 .\n> \n> 问题不难发现 , 同一时间发送两条消息 , 如果 第一个消息的TTL 大于 第二条消息的TTL , 即使 第二条消息的TTL已超时 , 也必须等待 第一条消息的TTL过期 , 最后也是按照先后顺序处理消息\n\n# 插件拓展\n\n该插件正是解决上面的问题 , 采用交换机的插件类型 , 能够实现 消息TTL等待是在交换机中等待执行 , 避免了在队列中排队的问题\n\n插件官网 : https://www.rabbitmq.com/community-plugins.html\n\n插件GitHub : https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases\n\n安装 :\n\n 1. 进入MQ插件目录 , 并将下载好的插件放进去 .ez格式 (选择自己的版本号) ==cd /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins==\n\n 2. 安装插件 (不需 填写版本和文件后缀) ==rabbitmq-plugins enable rabbitmq_delayed_message_exchange==\n\n 3. 重启RabbitMQ ==systemctl restart rabbitmq-server==\n\n 4. 观察 Web管理页 , 新增交换机 , 查看类型是否多出了 x-delayed-message类型\n\n> 下载注意版本兼容问题\n\n# 应用方式\n\n交换机声明\n\n采用 自定义交换机 进行实例化声明\n\n@Bean\npublic CustomExchange delayedExchange() {\n    Map<String, Object> arguments = new HashMap<>();\n    arguments.put("x-delayed-type", "direct");\n    return new CustomExchange(\n            DELAYED_EXCHANGE_NAME, "x-delayed-message", true, false, arguments);\n}\n\n\n消费者延迟发送\n\n往消息添加 x-delay头 属性 , 延迟功能 ==message.getMessageProperties().setDelay(ttl);==\n\n/* 变量说明\n\tDELAYED_EXCHANGE_NAME : 交换机名称\n\tDELAYED_ROUTING_KEY : RoutingKey\n\tmsg : 发送消息\n\tttl : 消息延迟时长\n*/\nrabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY ,msg , message -> {\n    // 为消息属性添加延迟功能\n    message.getMessageProperties().setDelay(ttl);\n    return message;\n});\n\n\n# 代码示例\n\n例图就不展示了 , 一个交换机: delayed.exchange , 一个队列: delayed.queue , 生产者 , 消费者\n\n主要测试 队列TTL过期循序问题\n\n初始化架构 DelayedQueueConfig\n\n@Configuration\npublic class DelayedQueueConfig {\n\n    // 交换机, 队列, routingKey\n    public static final String DELAYED_EXCHANGE_NAME = "delayed.exchange";\n    public static final String DELAYED_QUEUE_NAME = "delayed.queue";\n    public static final String DELAYED_ROUTING_KEY = "delayed.routingkey";\n\n    /** 自定义交换机\n     *  由于是自定义类型\n     */\n    @Bean\n    public CustomExchange delayedExchange() {\n        Map<String, Object> arguments = new HashMap<>();\n        arguments.put("x-delayed-type", "direct");\n        return new CustomExchange(\n                DELAYED_EXCHANGE_NAME, "x-delayed-message", true, false, arguments);\n    }\n\n    @Bean\n    public Queue delayedQueue() {\n        return new Queue(DELAYED_QUEUE_NAME);\n    }\n\n    @Bean\n    public Binding delayedQueueBindingDelayedExchange(Queue delayedQueue, CustomExchange delayedExchange) {\n        return BindingBuilder.bind(delayedQueue).to(delayedExchange).with(DELAYED_ROUTING_KEY).noargs();\n    }\n\n}\n\n\n生产者\n\n@RestController\n@RequestMapping("/producer")\npublic class ProducerSendMessageController {\n\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @GetMapping("/delayed/{msg}/{ttl}")\n    public void sendDelayedMessage(@PathVariable String msg, @PathVariable Integer ttl) {\n        System.out.printf("收到请求 => [%s, %s]%n", msg, ttl);\n        rabbitTemplate.convertAndSend(DELAYED_EXCHANGE_NAME, DELAYED_ROUTING_KEY,msg , message -> {\n            // 设置方式和以往不同 , 这个是设置延迟\n            // message.getMessageProperties().setExpiration(ttl + "");\n            message.getMessageProperties().setDelay(ttl);\n            return message;\n        });\n    }\n}\n\n\n消费者\n\n/**\n * 消费者\n * @author Sans\n */\n@Component\npublic class QueueConsumer {\n    @RabbitListener(queues = DELAYED_QUEUE_NAME)\n    public void delayedConsumer(Message message, Channel channel) {\n        String msg = new String(message.getBody(), StandardCharsets.UTF_8);\n        System.out.println("消费消息 => " + new Date() + " : " + msg);\n    }\n}\n\n\n# 代码测试\n\n队列多消息测试\n\n 1. 连续访问 http://localhost:8088/producer/delayed/GOGO/10000\n\n 2. 连续访问 http://localhost:8088/producer/delayed/GOGOGO/15000\n\n 3. 连续访问 http://localhost:8088/producer/delayed/GO/5000\n\n 4. 观察 控制台 , 消息的延迟时间 是否按照有小到大的顺序 进行处理\n    \n    收到请求 => [GOGO, 10000]\n    收到请求 => [GOGOGO, 15000]\n    收到请求 => [GO, 5000]\n    消费消息 => Mon Mar 06 11:29:26 CST 2023 : GO\n    消费消息 => Mon Mar 06 11:29:29 CST 2023 : GOGO\n    消费消息 => Mon Mar 06 11:29:35 CST 2023 : GOGOGO\n    \n\n在Web管理页中 , 是在交换机查看 延迟的消息 , 并非在队列中查看 , 消息直到延迟时间到期才会释放\n\n\n# 发布确认高级\n\n生产者发送消息后会进行备份到缓存中 , 如果成功则从缓存删除该备份的消息 , 否则在缓存中执行定时任务 , 重新从缓存中重新发布至 交换机 , 直到成功为止\n\n大致流程 :\n\n 1. 配置 ==spring.rabbitmq.publisher-confirm-type: correlated==\n\n 2. 声明基本架构 (交换机/队列/绑定)\n\n 3. 生产者正常发送消息\n\n 4. 消费者正常接收消息\n\n 5. 编写 回调类 , 实现 RabbitTemplate.ConfirmCallback回调接口 (交换机)\n\n 6. 重写 confirm()回调方法 (成功/失败 都会走该方法)\n\n 7. 内部类接口注入 (由于是内部类不能直接拿去使用 , 不过可以通过以下形式注入其中)\n    \n    @Resource\n    RabbitTemplate rabbitTemplate;\n    /* @PostConstruct注解 \n        在配置类 执行的构造函数 和 自动注入 后执行初始化的方法(类似servlet的init()方法) \n    */\n    @PostConstruct\n    public void init() {\n        // 发布确认\n        rabbitTemplate.setConfirmCallback(this);\n    }\n    \n\n 8. 测试\n\n配置\n\n生产者的类型确认使用 spring.rabbitmq.publisher-confirm-type\n\n配置值          说明\nnone(默认)     不做任何确认操作\ncorrelated   消息到交换机触发 回调\nsimple       通过手动 waitForConfirms()返回结果回答(少用)\n\n# 代码示例\n\n例图就不展示了 , 一个交换机: confirm.exchange , 一个队列: confirm.queue , 生产者 , 消费者\n\n配置\n\n==spring.rabbitmq.publisher-confirm-type: correlated==\n\n基本架构\n\n@Configuration\npublic class ConfirmConfig {\n\n    // 交换机, 队列, routingKey\n    public static final String CONFIRM_EXCHANGE_NAME = "confirm.exchange";\n    public static final String CONFIRM_QUEUE_NAME = "confirm.queue";\n    public static final String CONFIRM_ROUTING_KEY = "confirm.routingkey";\n\n    @Bean\n    public DirectExchange confirmExchange() {\n        return new DirectExchange(CONFIRM_EXCHANGE_NAME);\n    }\n\n    @Bean\n    public Queue confirmQueue() {\n        return QueueBuilder.durable(CONFIRM_QUEUE_NAME).build();\n    }\n\n    @Bean\n    public Binding confirmQueueBindingConfirmExchange(Queue confirmQueue, DirectExchange confirmExchange) {\n        return BindingBuilder.bind(confirmQueue).to(confirmExchange).with(CONFIRM_ROUTING_KEY);\n    }\n\n}\n\n\n生产者\n\n@RestController\n@RequestMapping("/producer")\npublic class ProducerSendMessageController {\n\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @GetMapping("/confirm/{msg}")\n    public void confirmSendMessage(@PathVariable String msg) {\n        System.out.println("confirmSend => " + msg);\n        // 回调相关数据对象\n        CorrelationData correlationData = new CorrelationData("1");\n        rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME, CONFIRM_ROUTING_KEY, msg, correlationData);\n    }\n\n}\n\n\n消费者\n\n@Component\npublic class QueueConsumer {\n    @RabbitListener(queues = CONFIRM_QUEUE_NAME)\n    public void confirmConsumer(Message message, Channel channel) {\n        String msg = new String(message.getBody(), StandardCharsets.UTF_8);\n        System.out.println("confirmConsumer => " + new Date() + " : " + msg);\n    }\n}\n\n\n回调类\n\n@Component\npublic class MyCallBack implements RabbitTemplate.ConfirmCallback, RabbitTemplate.ReturnsCallback {\n\n    @Resource\n    RabbitTemplate rabbitTemplate;\n\t\n    // 注入内部类接口\n    @PostConstruct\n    public void init() {\n        // 发布确认\n        rabbitTemplate.setConfirmCallback(this);\n    }\n\n    /**\n     * 交换机确认回调方法\n     * @param correlationData 回调的相关数据\n     * @param ack ack为true，nack为false\n     * @param cause 原因，对于nack，如果可用，否则为null\n     */\n    @Override\n    public void confirm(CorrelationData correlationData, boolean ack, String cause) {\n        String id = correlationData == null ? "" : correlationData.getId();\n        if (ack) {\n            System.out.println("Success => " + id);\n        } else {\n            System.out.println("Failure => " + id + " [" + cause + "] ");\n        }\n    }\n}\n\n\n# 代码测试\n\n根据可控变量分析 , 可分析出可能情况 :\n\n * 生产者 找不到交换机\n * 找到交换机 , 但找不到队列\n\n验证请求 : http://localhost:8088/producer/confirm/GO\n\n生产者 找不到交换机 模拟故障操作 : 更改 生产者发送方法所指定的交换机名 , 试图寻找个不存在的交换机 测试结果 : 触发 ConfirmCallback()回调函数 , 失败 , 找不到交换机\n\nconfirmSend => GO\nFailure => confirm2 [channel error; protocol method: #method&lt;channel.close>(reply-code=404, reply-text=NOT_FOUND - no exchange \'no\' in vhost \'/\', class-id=60, method-id=40)] \n\n\n找到交换机 , 但找不到队列\n\n模拟故障操作 : (以下两个故障结果是一致的)\n\n * 更改 生产者发送方法指定的RoutingKey\n * 新建交换机 , 不进行绑定队列\n\n测试结果 : 触发 ConfirmCallback()回调函数 , 成功 , 但消息没有得到消费 . 由于找不到队列消息而丢失\n\nconfirmSend => GO\nSuccess => confirm3\n\n\n> 通过以上情况测试不难发现 , 仅靠 交换机 的确认是不行的 , 还需要在 队列 中进行确认消息 !\n> \n> 可以通过退回消息 , 解决该问题\n\n\n# 回退消息\n\n回退消息 主要功能是 确认消息发到队列中 . 也解决了上面进入队列确认的问题\n\n实现 基于 发布确认代码 新增 配置/代码\n\n 1. 配置 ==spring.rabbitmq.publisher-returns: true==\n\n 2. 编写 回调类 , 实现 RabbitTemplate.ReturnsCallback回调接口 (队列)\n\n 3. 重写 returnedMessage()回调方法 , 找不到交换机失败回调\n\n 4. 内部类接口注入 (由于是内部类不能直接拿去使用 , 不过可以通过以下形式注入其中)\n\n# 代码示例\n\n复用上面的 发布确认代码\n\n配置 ==spring.rabbitmq.publisher-returns: true==\n\n生产者\n\n点击查看代码\n\n@GetMapping("/messageFallback/{msg}")\npublic void messageFallbackSend(@PathVariable String msg) {\n    System.out.println("messageFallbackSend => " + msg);\n    // 发送成功\n    CorrelationData correlationData1 = new CorrelationData("messageFallback1");\n    rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME, CONFIRM_ROUTING_KEY, msg, correlationData1);\n    // 生产者 找不到交换机\n    //CorrelationData correlationData2 = new CorrelationData("messageFallback2");\n    //rabbitTemplate.convertAndSend("no", "", msg, correlationData2);\n    // 交换机 找不到RoutingKey\n    //CorrelationData correlationData3 = new CorrelationData("messageFallback3");\n    //rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME, "no", msg, correlationData3);\n    // 交换机 找不到队列\n    //CorrelationData correlationData4 = new CorrelationData("messageFallback4");\n    //rabbitTemplate.convertAndSend("testNoNull", "", msg, correlationData4);\n}\n\n\n回调类\n\n点击查看代码\n\n@Component\npublic class MyCallBack implements RabbitTemplate.ConfirmCallback, RabbitTemplate.ReturnsCallback {\n\n    @Resource\n    RabbitTemplate rabbitTemplate;\n\n    @PostConstruct\n    public void init() {\n        // 发布确认\n        rabbitTemplate.setConfirmCallback(this);\n        // 消息回退\n        rabbitTemplate.setReturnsCallback(this);\n    }\n\n    /**\n     * 交换机确认回调方法\n     * @param correlationData 回调的相关数据\n     * @param ack ack为true，nack为false\n     * @param cause 原因，对于nack，如果可用，否则为null\n     */\n    @Override\n    public void confirm(CorrelationData correlationData, boolean ack, String cause) {\n        String id = correlationData == null ? "" : correlationData.getId();\n        if (ack) {\n            System.out.println("Success => " + id);\n        } else {\n            System.out.println("Failure => " + id + " [" + cause + "] ");\n        }\n    }\n\n    /**\n     * 回退消息\n     *  当消息过程不能达到目的地 , 则将消息返回给生产者\n     * @param returned 返回的消息和元数据\n     */\n    @Override\n    public void returnedMessage(ReturnedMessage returned) {\n        System.out.println("回退消息 ==>");\n        System.out.println("  消息: " + new String(returned.getMessage().getBody(), StandardCharsets.UTF_8));\n        System.out.println("  交换机名: " + returned.getExchange());\n        System.out.println("  RoutingKey: " + returned.getRoutingKey());\n        System.out.println("  退回原因: " + returned.getReplyText());\n    }\n}\n\n\n# 代码测试\n\n根据可控变量分析 , 可分析出可能情况 :\n\n * 生产者 找不到交换机\n * 生产者 找到交换机 , 但找不到队列\n\n验证请求 : http://localhost:8088/producer/messageFallback/GO\n\n生产者 找不到交换机 模拟故障操作 : 更改 生产者发送方法所指定的交换机名 , 试图寻找个不存在的交换机 测试结果 : 触发 ConfirmCallback()回调函数 , 失败 , 找不到交换机\n\nmessageFallbackSend => GO\nFailure => messageFallback2 [channel error; protocol method: #method&lt;channel.close>(reply-code=404, reply-text=NOT_FOUND - no exchange \'no\' in vhost \'/\', class-id=60, method-id=40)] \n\n\n生产者 找到交换机 , 但找不到队列\n\n模拟故障操作 : (以下两个故障结果是一致的)\n\n * 更改 生产者发送方法指定的RoutingKey\n * 新建交换机 , 不进行绑定队列\n\n测试结果 : 触发 ConfirmCallback()(成功)和returnedMessage()(失败) 回调函数 , 但消息没有得到消费 . 由于找不到队列消息而丢失\n\nmessageFallbackSend => GO\n回退消息 ==>\n  消息: GO\n  交换机名: confirm.exchange\n  RoutingKey: no\n  退回原因: NO_ROUTE\nSuccess => messageFallback3\n\n\n\n# 备用交换机\n\n备用交换机 , 字面意思 , 当某一交换机匹配不到RoutingKey指定的队列 , 那么会交给 备用交换机 处理 .\n\n一般情况 备用交换机 , 用来处理消费者 监控/报警 等操作\n\n应用方式\n\n在配置交换机Bean的时候可以通过 构造者模式中的 alternate()方法 指定备用交换机\n\n/* 变量说明\n\tBACKUP_EXCHANGE_NORMAL: 普通交换机名\n\tBACKUP_EXCHANGE_BACKUP: 备份交换机名\n*/\n@Bean\npublic DirectExchange backupNormalExchange() {\n    return ExchangeBuilder.directExchange(BACKUP_EXCHANGE_NORMAL)\n            .durable(true)\n            // 备用\n            .alternate(BACKUP_EXCHANGE_BACKUP)\n            .build();\n}\n\n\n# 代码示例\n\n架构图\n\n\n\n基本架构\n\n点击查看代码\n\n@Configuration\npublic class BackupConfig {\n\n    // 交换机\n    public static final String BACKUP_EXCHANGE_NORMAL = "backup.exchange.normal";\n    public static final String BACKUP_EXCHANGE_BACKUP = "backup.exchange.backup";\n\n    // 队列\n    public static final String BACKUP_QUEUE_NORMAL = "backup.queue.normal";\n    public static final String BACKUP_QUEUE_BACKUP = "backup.queue.backup";\n    public static final String BACKUP_QUEUE_WARNING = "backup.queue.warning";\n\n    // routingKey\n    public static final String BACKUP_ROUTING_KEY_NORMAL = "backup.routingkey.normal";\n\n    /**\n     * 交换机\n     */\n    @Bean\n    public DirectExchange backupNormalExchange() {\n        return ExchangeBuilder.directExchange(BACKUP_EXCHANGE_NORMAL)\n                .durable(true)\n                // 备用\n                .alternate(BACKUP_EXCHANGE_BACKUP)\n                .build();\n    }\n    @Bean\n    public FanoutExchange backupExchange() {\n        // 广播\n        return new FanoutExchange(BACKUP_EXCHANGE_BACKUP);\n    }\n\n    /**\n     * 队列\n     */\n    @Bean\n    public Queue backupNormalQueue() {\n        return QueueBuilder.durable(BACKUP_QUEUE_NORMAL).build();\n    }\n    @Bean\n    public Queue backupBackupQueue() {\n        return QueueBuilder.durable(BACKUP_QUEUE_BACKUP).build();\n    }\n    @Bean\n    public Queue backupWarningQueue() {\n        return QueueBuilder.durable(BACKUP_QUEUE_WARNING).build();\n    }\n\n    /**\n     * 绑定\n     */\n    @Bean\n    public Binding bindingNormalQueueToNormalExchange(Queue backupNormalQueue, DirectExchange backupNormalExchange) {\n        return BindingBuilder.bind(backupNormalQueue).to(backupNormalExchange).with(BACKUP_ROUTING_KEY_NORMAL);\n    }\n    @Bean\n    public Binding bindingBackupBackupQueueToBackupExchange(Queue backupBackupQueue, FanoutExchange backupExchange) {\n        return BindingBuilder.bind(backupBackupQueue).to(backupExchange);\n    }\n    @Bean\n    public Binding bindingBackupWarningQueueToBackupExchange(Queue backupWarningQueue, FanoutExchange backupExchange) {\n        return BindingBuilder.bind(backupWarningQueue).to(backupExchange);\n    }\n}\n\n\n生产者\n\n点击查看代码\n\n@RestController\n@RequestMapping("/producer")\npublic class ProducerSendMessageController {\n\n    @Resource\n    private RabbitTemplate rabbitTemplate;\n\n    @GetMapping("/backup/{msg}")\n    public void backupSend(@PathVariable String msg) {\n        System.out.println("backupSend => " + msg);\n        // 发送成功\n        CorrelationData correlationData1 = new CorrelationData("backupSend>1");\n        rabbitTemplate.convertAndSend(BACKUP_EXCHANGE_NORMAL, BACKUP_ROUTING_KEY_NORMAL, msg, correlationData1);\n        // 生产者 找不到交换机\n        //CorrelationData correlationData2 = new CorrelationData("backupSend>2");\n        //rabbitTemplate.convertAndSend(BACKUP_EXCHANGE_NORMAL+"123", BACKUP_ROUTING_KEY_NORMAL, msg, correlationData2);\n        // 交换机 找不到RoutingKey\n        //CorrelationData correlationData3 = new CorrelationData("backupSend>3");\n        //rabbitTemplate.convertAndSend(BACKUP_EXCHANGE_NORMAL, BACKUP_ROUTING_KEY_NORMAL+"123", msg, correlationData3);\n        // 交换机 找不到队列\n        //CorrelationData correlationData4 = new CorrelationData("backupSend>4");\n        //rabbitTemplate.convertAndSend("testNoNull", "", msg, correlationData4);\n    }\n}\n\n\n消费者\n\n点击查看代码\n\n@Component\npublic class QueueConsumer {\n    /**\n     * 备份交换机\n     */\n    // 正常消费者\n    @RabbitListener(queues = BACKUP_QUEUE_NORMAL)\n    public void backupNormalConsumer(Message message, Channel channel) {\n        String msg = new String(message.getBody(), StandardCharsets.UTF_8);\n        System.out.println("backupNormalConsumer => " + new Date() + " : " + msg);\n    }\n    // 备份消费者\n    @RabbitListener(queues = BACKUP_QUEUE_BACKUP)\n    public void backupConsumer(Message message, Channel channel) {\n        String msg = new String(message.getBody(), StandardCharsets.UTF_8);\n        System.out.println("backupConsumer => " + new Date() + " : " + msg);\n    }\n    // 警告消费者\n    @RabbitListener(queues = BACKUP_QUEUE_WARNING)\n    public void backupWarningConsumer(Message message, Channel channel) {\n        String msg = new String(message.getBody(), StandardCharsets.UTF_8);\n        System.out.println("backupWarningConsumer => " + new Date() + " : " + msg);\n    }\n\n}\n\n\n# 代码测试\n\n根据可控变量分析 , 可分析出可能情况 :\n\n * 生产者 找不到交换机\n * 交换机 RoutingKey匹配不到队列\n * 交换机 未绑定队列\n * 备用交换机 未绑定队列\n\n验证请求 : http://localhost:8088/producer/messageFallback/GO\n\n> 模拟故障操作 , 在生产者类中写有 , 去掉注释测试即可\n\n生产者 找不到交换机\n\n模拟故障操作 : 更改 生产者发送方法所指定的交换机名 , 试图寻找个不存在的交换机 测试结果 : ConfirmCallback() 回调失败\n\nbackupSend => GO\nFailure => backupSend>2 [channel error; protocol method: #method&lt;channel.close>(reply-code=404, reply-text=NOT_FOUND - no exchange \'backup.exchange.normal123\' in vhost \'/\', class-id=60, method-id=40)] \n\n\n交换机 RoutingKey匹配不到队列\n\n模拟故障操作 : 更改 生产者发送方法指定的RoutingKey\n\n测试结果 : ConfirmCallback() 回调成功 , 并且 备用交换机处理消息\n\nbackupSend => GO \nSuccess => backupSend>3\nbackupWarningConsumer => Tue Mar 07 14:40:37 CST 2023 : GO\nbackupConsumer => Tue Mar 07 14:40:37 CST 2023 : GO\n\n\n交换机 未绑定队列\n\n模拟故障操作 : 新建交换机 , 不进行绑定队列 测试结果 : ConfirmCallback() 回调成功 , 在交换机中 触发returnedMessage()退回消息 , 备用交换机未处理消息\n\nbackupSend => GO\n回退消息 ==>\n  消息: GO\n  交换机名: testNoNull\n  RoutingKey: \n  退回原因: NO_ROUTE\nSuccess => backupSend>4\n\n\n备用交换机 未绑定队列\n\n模拟故障操作 : 备用交换机 , 不进行绑定队列 (在Web管理页 解绑 重发消息即可实现)\n\n测试结果 : ConfirmCallback() 回调成功 , 在备用交换机中 触发returnedMessage()退回消息 , 备用交换机未处理消息\n\nbackupSend => GO\n回退消息 ==>\n  消息: GO\n  交换机名: backup.exchange.normal\n  RoutingKey: backup.routingkey.normal123\n  退回原因: NO_ROUTE\nSuccess => backupSend>3\n\n\n> 在上面4种情况观察分析 , 可以发现 交换机一旦未绑定队列 , 会使 消息回退 , 也不会执行备用交换机方案\n\n\n# 队列优先级\n\n不难想象 , 在双十一高峰期 , 订单会非常多 . 有时 公司出于利益方面 , 划分出客户等级 , 等级越高的客户他们的单子往往在拥挤的时候优先得到解决\n\n在MQ当中优先级取值范围 : 0 ~ 255 (数值越大越优先)\n\n应用方式\n\n配置\n\n在 队列 中配置 优先级属性\n\n/* 变量说明\n    CONFIRM_QUEUE_NAME: 队列名\n*/\n@Bean\npublic Queue priorityQueue() {\n    return QueueBuilder.durable("priority.Queue")\n            // 优先级 优先级最大值\n            .maxPriority(40)\n            .build();\n}\n\n\n在 生产者 消息发送方法 中配置优先级\n\n指定 消息 在队列中的优先级 : ==message.getMessageProperties().setPriority(n);==\n\n@GetMapping("/priority/{msg}")\npublic void priorityBend(@PathVariable String msg) {\n    // 优先级倒过来 ,\n    System.out.println("priorityBend => " + msg);\n    for (int i = 0; i < 20; i++) {\n        CorrelationData correlationData = new CorrelationDat22a(msg + i);\n        int finalI = i;\n        rabbitTemplate.convertAndSend(CONFIRM_EXCHANGE_NAME, CONFIRM_ROUTING_KEY, msg + i, message -> {\n            message.getMessageProperties().setPriority(finalI);\n            return message;\n        }, correlationData);\n    }\n}\n\n\n# 测试\n\n源代码基本架构 点击跳转\n\n测试步骤 :\n\n 1. 注释掉消费者代码\n 2. 运行项目\n 3. 访问 http://localhost:8088/producer/priority/GO (发送消息)\n 4. 观察方式 , 有两种: Web管理页 (能看到消息明细) ; 控制台(测试顺序)\n\nWeb观察\n\n进入 Queues -> 选择队列 -> Get Messages\n\n控制台观察 : 恢复消费者代码(去除先前注解) , 重新运行项目\n\nconfirmConsumer => Tue Mar 07 21:55:26 CST 2023 : GO19\nconfirmConsumer => Tue Mar 07 21:55:26 CST 2023 : GO18\nconfirmConsumer => Tue Mar 07 21:55:26 CST 2023 : GO17\nconfirmConsumer => Tue Mar 07 21:55:26 CST 2023 : GO16\nconfirmConsumer => Tue Mar 07 21:55:26 CST 2023 : GO15\nconfirmConsumer => Tue Mar 07 21:55:26 CST 2023 : GO14\nconfirmConsumer => Tue Mar 07 21:55:26 CST 2023 : GO13\nconfirmConsumer => Tue Mar 07 21:55:26 CST 2023 : GO12\nconfirmConsumer => Tue Mar 07 21:55:26 CST 2023 : GO11\nconfirmConsumer => Tue Mar 07 21:55:26 CST 2023 : GO10\nconfirmConsumer => Tue Mar 07 21:55:26 CST 2023 : GO9\nconfirmConsumer => Tue Mar 07 21:55:26 CST 2023 : GO8\nconfirmConsumer => Tue Mar 07 21:55:26 CST 2023 : GO7\nconfirmConsumer => Tue Mar 07 21:55:26 CST 2023 : GO6\nconfirmConsumer => Tue Mar 07 21:55:26 CST 2023 : GO5\nconfirmConsumer => Tue Mar 07 21:55:26 CST 2023 : GO4\nconfirmConsumer => Tue Mar 07 21:55:26 CST 2023 : GO3\nconfirmConsumer => Tue Mar 07 21:55:26 CST 2023 : GO2\nconfirmConsumer => Tue Mar 07 21:55:26 CST 2023 : GO1\nconfirmConsumer => Tue Mar 07 21:55:26 CST 2023 : GO0\n\n\n\n# 惰性队列\n\n惰性队列 主要作用的将消息尽可能的存到磁盘中 , 而消费者响应消息的时候才会被加载到内存中 , 设计初衷主要是容纳更多的消息 , 以免高峰期导致内存爆炸现象\n\n不同情况下的队列 :\n\n * 普通队列(default) : 消息保存到内存中 (尽可能提高性能)\n * 惰性队列(lazy) : 消息保存到磁盘中 (尽可能存储更多的消息)\n\n惰性优点 :\n\n * 消费者失效 , 消息堆积情况\n * 大量消息 , 占用内存小\n\n应用 :\n\n 1. 在 队列 中配置 模式属性 : ==x-queue-mode: lazy==\n 2. 大量发送消息\n 3. 观察 Web内存占用情况\n\nSpringBoot 配置\n\n在 队列 中配置 惰性属性\n\n@Bean\npublic Queue lazyQueue() {\n    return QueueBuilder.durable("lazy.Queue")\n            // 惰性\n        \t.lazy()\n            .build();\n}\n\n\n高压测试\n\n在 100W 条消息的内存情况下\n\n * 普通 : 5.2MiB ≈ 5.078125MB ≈ 5078.1KB\n * 惰性 : 1.1MiB ≈ 1.07421875MB ≈ 1074.2KB\n\n> GB 是 生厂商为了方便计算 , 以十进制 10的3次方运算 . 如 : 1000MB = 1GB\n> \n> GiB 而是 操作系统是采用 , 以二进制 2的10次方运算 . 如 : 1MiB = 1024KiB\n> \n> 为了便于理解 可以将 MiB为MB (其他单位也是如此)\n\n采用 异步发布消息 100W条消息\n\n普通 :\n\n\n\n惰性 :\n\n\n\n\n# 集群\n\n以往的操作都是处于一台机器操作 , 那么该机器宕机了 , 就不能服务 , 因此我们只可以使用多台服务器连接形成集群 , 提高可用率 , 哪怕其中一台宕机了也可以完好的将数据保留\n\n下面采用Docker模拟多台服务器应用\n\n\n# Docker\n\n在Docker中 部署安装RabbitMQ\n\n 0. 安装Docker (网上教程烂大街..)\n\n 1. 查看版本 https://hub.docker.com/_/rabbitmq , 并拉取下载 建议下载含有Web管理页 , 镜像中带有 mangement版本的\n\n 2. 启动docker容器\n    \n    docker run -d --name [容器名称]  \\\n    -p 5672:5672  \\\n    -p 15672:15672  \\\n    -v `pwd`/data:/home/rabbitmq  \\\n    --hostname [节点名称]  \\\n    -e RABBITMQ_DEFAULT_USER=admin  \\\n    -e RABBITMQ_DEFAULT_PASS=admin rabbitmq:[tag标签] \\\n    \n    \n    我个人的应用方式 (端口小修一下)\n    \n    docker run -d --name rabbitmq03  \\\n    -p 5674:5672  \\\n    -p 15674:15672  \\\n    -v `pwd`/data:/home/rabbitmq  \\\n    --hostname node03  \\\n    -e RABBITMQ_DEFAULT_USER=admin  \\\n    -e RABBITMQ_DEFAULT_PASS=admin  \\\n    rabbitmq:3.11.10-management\n    \n    \n    选项说明 :\n    \n    选项           说明\n    -d           后台运行\n    --name       指定容器名称\n    -p           指定端口 [外部端口]:[容器端口] (5672:连接访问; 15672: Web管理页)\n    -v           映射 目录/文件\n    --hostname   主机名 (较为重要 集群作为 节点名称 使用)\n    -e           指定环境变量 (默认账号密码)\n\n 3. Web打开 http://ip:15672/ / http://ip:15673/ / http://ip:15674/\n\n 4. 账号密码 : admin\n\n**检查 : **\n\n * 检查docker容器 ==docker ps -a==\n * 检查端口是否调试好 ==docker port {容器id}==\n * 查看防火墙是否开放端口\n\n> MQ容器不同版本的端口很有可能不同 , 可通过 ==docker ps -a== 进行检查',normalizedContent:'# rabbitmq\n\n\n# 介绍\n\nrabbitmq 是个中间件 , 负责 接收/存储/转发 消息数据 . 类似 平时快递派送的过程\n\n是什么?\n\nmq 本质是个队列 , 先进先出 消息推送 , 是种跨进程通信机制的上下游传递消息 . 主要解决不同对象通信的序列\n\n为什么用?\n\n * 流量消锋 : 如果系统最大多处理1w条请求 , 且还是高峰期的时候 , 很有可能会突破1w导致宕机 . mq可以队列缓冲 , 防止宕机 (高峰期体验差 , 但能保障了不会宕机)\n * 应用解耦 : 系统有多个子系统 , 在业务涉及多个子系统完成时 , 当中的一个子系统宕机了 , 导致该业务异常无法运作 . mq可以将要处理的业务缓存到消息队列中 , 由消息队列进行访问子系统执行业务 , 防止不一致运作问题 , 提高可用性\n * 异步处理 : 假如 a调用b , 但b需要执行很长一段时间 , 但a想知道b执行的进度 , 以往 会通过 a调用api查b进度 , 显然不优雅 . mq可以使用消息总线 , a调用b后 , mq会监控b进度(a实时得到b进度) , b处理完后 会发消息给mq , 由mq转发至a .\n\n\n# mq特性\n\n# 可靠性\n\n消息丢失一般有3情况 :\n\n * 生产者丢失 通过 [发布确认](#发布确认模式 publisher confirms) , 确保 生产者 发送消息到mq (springboot应用\n * mq丢失 通过 持久化/死信队列/备用交换机/回退消息 , 确保消息在mq中不会丢失\n * 消费者丢失 通过 消息应答 , 确保 消费者 消费成功ack响应\n\n# 顺序性\n\n * 1个消费者消费1个队列是没有顺序问题的\n * 多个消费者消费同一个队列时就出现消费顺序的问题 . 可以考虑将一个队列分为多个队列 , 将需要保证顺序的消息发到一个队列里 , 一个队列对应一个消费者\n * 当消息在消费者端用多线程处理时 , 也会出现顺序问题 . 可以考虑在内存中维护多个队列 , 将mq发来的需要保证顺序的消息放在同一个内存队列里 , 然后一个线程处理一个队列里的消息\n\n# 幂等性\n\n保证一条消息不会被重复消费 , 也不会对数据库产生影响\n\n场景 :\n\n * 手机验证码 , 只能使用一次 , 再次发送验证码 , 则会刷新原旧的验证码\n * 订单支付 , 每个订单只能支付一次\n\n**解决方案 : **\n\n * 消息使用 全局id (可 通过时间戳/uuid等方式) , 确保唯一性 , 当写入数据时先判断是否存在 , 存在就没必要插入了 , 保证了不会重复插入现象\n * 采用 redis 自带的天然幂等性 setnx\n\n参考文章 : https://blog.csdn.net/zw791029369/article/details/109561457\n\n\n# mq分类\n\n# activemq\n\n优点 : 单机 万级吞吐量 , 时效性s级 , 可用性高 , 基于主从架构实现高可用性 , 消息可靠性较低的概率丢失数据 缺点 : 官方社区对 activemq5.x 维护越来越少 , 高吞吐量场景较少使用\n\n# kafka\n\nkafka是大数据消息的中间件 , 满受大厂的采纳\n\n优点 : 单机 百万级吞吐量 , 时效性ms级 , 运作稳定 ; 分布式 , 少数宕机 , 也不会造成影响 . 消息有序 , 有ui管理页面 , 日志实时更新\n\n缺点 : 单机超过64个队列 , 消息队列多 , 响应长 (轮询) , 实时性取决轮询间隔 , 业务失败不能重试 , 社区更新慢\n\n# rocketmq\n\n自 阿里巴巴 开源产品 , java实现 , 参考了 kafka设计 的改进版\n\n优点 : 单机 十万级吞吐量 , 可用性高 , 分布式架构 , 消息0丢失 , 支持 10亿级别的消息堆积 , 数据堆积不会影响性能\n\n缺点 : 语言拓展少 , 现阶段java/c++实现 , 社区活跃一般\n\n# rabbitmq (学习)\n\n是当前主流的消息中间件之一\n\n优点 : 高并发 , 性能高 , 单机万级吞吐量 , 跨平台 , 多语言支持 , 文档齐全 , 社区活跃高 , 更新频繁\n\n缺点 : 商业收费 , 学习成本高\n\n\n# 安装\n\n官方 : https://www.rabbitmq.com/download.html\n\n下载\n\n * mq : rabbitmq 下载地址 选择以 noarch.rpm 结尾的安装包\n * erlang : erlang 下载地址 , erlang 和 rabbitmq 版本对照 (mq采用erang语言开发 , 因此需要安装环境)\n\n> 注意linux版本支持\n\n**安装步骤 : **\n\n 1. linux上传文件 , 创建目录文件放置里面 ==mkdir /usr/local/rabbitmq==\n\n 2. 安装 erlang , rabbitmq , socat(mq依赖插件)\n    \n    # erlang\n    rpm -ivh erlang-21.3-1.el7.x86_64.rpm\n    \t# 检查版本 quit退出\n    \terl -v\n    # socat 依赖插件\n    yum install socat -y\n    # rabbitmq\n    rpm -ivh rabbitmq-server-3.8.8-1.el7.noarch.rpm\n    \t# 启动服务\n    \tsystemctl start rabbitmq-server\n    \t# 查看服务状态 (active绿色表示成功)\n    \tsystemctl status rabbitmq-server\n    \n\n\n# web管理\n\n方便 查阅/操作 mq\n\n# 安装\n\n 1. 执行指令安装 ==rabbitmq-plugins enable rabbitmq_management==\n 2. 重启mq服务\n 3. web访问 http://ip:15672 (ip为 linux地址)\n 4. 账号密码为 guest (账号密码相同)\n 5. 在终端中添加账号 , 并且给予权限\n\n注意 :\n\n * 安装前提关闭mq服务\n * linux防火墙开放 15672端口(web管理) , 5672端口(api连接)\n\n# 用户管理\n\n创建用户 ==rabbitmqctl add_user <用户名> <密码>==\n\n查看用户 ==rabbitmqctl list_users==\n\n修改密码 ==rabbitmqctl change_password <用户名> <新密码>==\n\n删除用户\n\n==rabbitmqctl delete_user <用户名>==\n\n设置用户 ==rabbitmqctl set_user_tags <用户名> <角色>==\n\n角色              说明\nadministrator   可以登录控制台、查看所有信息、并对rabbitmq进行管理\nmontoring       监控者；登录控制台，查看所有信息\npolicymaker     策略制定者；登录控制台指定策略\nmanagment       普通管理员；登录控制\n\n权限分配\n\n# 为用户添加资源权限，添加配置、写、读权限\n# rabbitmqctl set_permissions [-p <vhostpath>] <user> <conf> <write> <read>\nrabbitmqctl set_permissions -p "/" bozhu ".*" ".*" ".*"\n\n\n\n# 核心\n\n官方javaapi文档 : https://rabbitmq.github.io/rabbitmq-java-client/api/current/\n\n以下几大模式通过 java api实现 , 模式的发送过程 , 在项目中需要引入以下依赖\n\n点击查看 maven配置\n\n<dependencies>\n    \x3c!--rabbitmq 依赖客户端--\x3e\n    <dependency>\n        <groupid>com.rabbitmq</groupid>\n        <artifactid>amqp-client</artifactid>\n        <version>5.8.0</version>\n    </dependency>\n    \x3c!--操作文件流的一个依赖--\x3e\n    <dependency>\n        <groupid>commons-io</groupid>\n        <artifactid>commons-io</artifactid>\n        <version>2.6</version>\n    </dependency>\n</dependencies>\n\x3c!--指定 jdk 编译版本--\x3e\n<build>\n    <plugins>\n        <plugin>\n            <groupid>org.apache.maven.plugins</groupid>\n            <artifactid>maven-compiler-plugin</artifactid>\n            <configuration>\n                <source>8</source>\n                <target>8</target>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n\n\n\n# 简单模式 hello world\n\njava api实现 , 模拟发送接收过程\n\n基本方法\n\n返回       方法                                                      说明\n-        ==queuedeclare(string queue, boolean durable, boolean   发送消息\n         exclusive, boolean autodelete, map<string, object>\n         arguments)==\nstring   ==basicconsume(string queue, boolean autoack,           接收消息 , 返回消息序列号\n         delivercallback delivercallback, cancelcallback\n         cancelcallback)==\n\n实现步骤 :\n\n 1. 消息生产者\n    \n    点击查看代码\n    \n    public class producer {\n        // 队列名称\n        public static final string query_name = "hello";\n    \n        // 发消息\n        public static void main(string[] args) throws exception {\n            // 连接工厂\n            connectionfactory factory = new connectionfactory();\n            // 基础信息\n            factory.sethost("192.168.186.128");\n            factory.setusername("bozhu");\n            factory.setpassword("123123");\n            connection connection = factory.newconnection();\n            // 频道\n            channel channel = connection.createchannel();\n            /**\n             * 生成队列\n             * 参数 :\n             *  1. 队列名称\n             *  2. 队列消息是否持久化(是否磁盘存储)\n             *  3. 队列是否进行消息共享(多个消费者共享)\n             *  4. 是否自动删除(最后消费者开端连接后)\n             *  5. 其他参数\n             */\n            channel.queuedeclare(query_name, false, false, false, null);\n    \n            // 发消息\n            string msg = "hello world";\n    \n            /**\n             * 发送消息\n             *  1. 指定交换机\n             *  2. 路由key值(本次队列名称)\n             *  3. 其他参数信息\n             *  4. 发送消息的消息体\n             */\n            channel.basicpublish("", query_name, null, msg.getbytes());\n            system.out.println("send success");\n        }\n    }\n    \n\n 2. 消息消费者\n    \n    点击查看代码\n    \n    public class consumer {\n    \n        public static final string query_name = "hello";\n    \n        public static void main(string[] args) throws exception {\n            // 连接工厂\n            connectionfactory factory = new connectionfactory();\n            // 基础信息\n            factory.sethost("192.168.186.128");\n            factory.setusername("bozhu");\n            factory.setpassword("123123");\n            connection connection = factory.newconnection();\n            // 频道\n            channel channel = connection.createchannel();\n    \n            /**\n             * 接收消息\n             *  1. 指定队列\n             *  2. 成功后是否自动应答\n             *  3. 未成功回调信息\n             *  4. 取消回调信息\n             */\n            channel.basicconsume(query_name, true,\n                    (consumertag, message) -> {\n                        system.out.println(new string(message.getbody()));\n                    },\n                    consumertag -> {\n                        system.out.println("消息被中断");\n                    }\n            );\n        }\n    }\n    \n\n 3. 测试 , 运行 生产者 => web查看业务队列 => 运行 消费者 => web查看业务队列\n\n以上步骤中看出 生产者在运行后 , web管理中可以看到队列新增了条 消息 (需要等待消费者消费) . 当消费者运行后会消耗掉该 消息\n\n> 消费者类 不能用 junit测试 接口写 , 否则没有监听的效果\n\n# 工具类优化\n\n实现复用 , 减少代码重写\n\npublic class rabbitmqutils {\n\n    public static channel getchanel() {\n        connectionfactory factory = new connectionfactory();\n        factory.sethost("192.168.186.128");\n        factory.setusername("bozhu");\n        factory.setpassword("123123");\n        channel channel;\n        try {\n            connection connection = factory.newconnection();\n            channel = connection.createchannel();\n        } catch (ioexception | timeoutexception e) {\n            throw new runtimeexception(e);\n        }\n        return channel;\n    }\n    \n}\n\n\n\n# 工作模式 work queues\n\n工作模式 主要思想是为了避免消息密集型的形式堆积 , 工作模式可以在多线程消费者中进行分发任务\n\n# 轮询分发\n\n轮询消费队列中的数据 , 消费者们会轮询进行消费消息 (每个消息只能被消费一次)\n\n大致实现 :\n\n 1. 批发生产者\n 2. 多线程消费者\n 3. 运行测试 , 查看消费者的消费情况\n\n> 利用上面的 工具类 获取频道 (复用代码)\n\n生产者\n\n/**\n * 生产者\n */\npublic class producer {\n\n    // 队列名称\n    public static final string query_name = "hello";\n\n    // 发消息\n    public static void main(string[] args) throws exception {\n        channel chanel = rabbitmqutils.getchanel();\n        string msg = "hello world";\n        chanel.queuedeclare(query_name, false, false, false, null);\n        for (int i = 0; i < 10; i++) {\n            // 发消息\n            string str = msg + i;\n            chanel.basicpublish("", query_name, null, str.getbytes());\n            system.out.println("发送成功 => " + str);\n        }\n    }\n\n}\n\n\n消费者\n\n服务形式多线程运行 , 可以区分出 消费者分别为 c1/c2/c3 , 在当中配置字符 , 来区分消费者\n\n/**\n * 消费者\n */\npublic class consumer {\n\n    public static final string query_name = "hello";\n\n    public static void main(string[] args) throws ioexception {\n\n        system.out.println(args[0]+" 已运行!");\n\n        channel chanel = rabbitmqutils.getchanel();\n\n        chanel.basicconsume(query_name, false, (consumertag, message) -> {\n            system.out.println("成功 =>"+consumertag+" : "+new string(message.getbody()));\n        }, consumertag -> {\n            system.out.println("失败");\n        });\n    }\n    \n}\n\n\n运行测试\n\n先运行所有 生产者(此时消费者会处于等待消费的状态) , 后运行 消费者 , 运行后可以看出消费者消费方式是轮询形式的\n\n多服务运行 *\n\nmain方法运行会传递 args 参数 , 我们可以在以下进行传参运行\n\n 1. 配置好 , 填充参数 (如果多参数需要空格分开)\n 2. 打开服务(alt+8) , 批量运行\n\n# 消息应答\n\n为了保证发送过程不丢失信息 , mq引入了消息应答机制 . 例如 : 注册账号 , 填写表单信息 , 确认提交的过程\n\n应答机制 : 在消费者消耗处理后 , 才会告诉 mq 进行删除消息\n\nmq有两种应答机制 :\n\n * 自动应答(默认)\n * 手动应答\n\n可以在 ==channel.basicconsume()== 方法的 autoack参数 进行控制 手动/自动\n\n> 一般情况建议选择手动应答 , 防止数据丢失问题\n\n# 自动应答\n\n自动应答 是为了解决 高吞吐/安全传输 方面做出了权衡 .\n\nmq不在乎消费者是否处理完成 , 都会告诉mq删除队列 .\n\n情况 :\n\n * 消费者 处理失败也没有异常 , 会 自动补偿 , mq会重新向消费者投递消息\n * 消费者 异常了 , mq会认为消费成功 , 会对消息进行删除 , 导致数据丢失\n\n> **重新入队机制 : **\n> \n> 消费者处理消息过程 , 突然宕机 , 没有ack确认 , mq得知消息未完全处理 , 会将其消息重新排队列 , 由其他消费者处理\n\n# 手动应答\n\n手动应答 , 消费者处理后 , 两种可能 :\n\n * 消费者手动 ack(确认应答) , 告诉mq消息完成进行删除\n * 消费者自动 nack(拒绝应答) , 告诉mq处理失败 , 消息不会删除\n\n应答方法\n\n返回     方法                                                        说明\nvoid   ==basicack(long deliverytag, boolean multiple)==          确认收到\nvoid   ==basicreject(long deliverytag, boolean requeue)==        拒绝消息\nvoid   ==basicnack(long deliverytag, boolean multiple, boolean   拒绝收到\n       requeue)==\n\n手动应答 和 重入队列机制 代码实例\n\n生产者\n\n/**\n * 消息在手动应答是不丢失、放回队列中重新消费\n * @author sans\n */\npublic class task {\n\n    public static final string queue_name = "ack_queue";\n\n    public static void main(string[] args) throws exception {\n        channel chanel = rabbitmqutils.getchanel();\n\n        // 声明对队列\n        chanel.queuedeclare(queue_name, false, false, false, null);\n        scanner sc = new scanner(system.in);\n        while (sc.hasnext()) {\n            string msg = sc.next();\n            chanel.basicpublish("", queue_name,null, msg.getbytes(standardcharsets.utf_8));\n            system.out.println("发送消息 => "+msg);\n        }\n        \n    }\n}\n\n\n消费者\n\n说明 : 配置两个消费者 , 一个消费者等待1s ; 另一个消费者等待10s . 参数分别是 :\n\n * ==c1 1000==\n * ==c2 10000==\n\n/**\n * 消费者\n * @author sans\n */\npublic class consumer {\n\n    public static final string queue_name = "ack_queue";\n\n    /**\n     * @param args [线程名 , 休眠执行时长]\n     * @throws exception\n     */\n    public static void main(string[] args) throws exception {\n\n        channel chanel = rabbitmqutils.getchanel();\n\n        system.out.println(args[0]+" : 运行");\n\n        chanel.basicconsume(queue_name, false, (consumertag, message)->{\n            // 等待\n            try {\n                thread.sleep(long.parselong(args[1]));\n            } catch (interruptedexception e) {\n                throw new runtimeexception(e);\n            }\n\n            system.out.println("接受到的消息:"+new string(message.getbody(), standardcharsets.utf_8));\n            /*\n             * 手动应答\n             * 1.消息的标记tag\n             * 2.是否批量应答 false表示不批量应答信道中的消息\n             */\n            chanel.basicack(message.getenvelope().getdeliverytag(),false);\n        },(consumertag)->{\n        });\n    }\n\n}\n\n\n宕机模拟测试\n\n先运行 生产者 , 后运行2个消费者 , 最后生产者输入消息 , 以时间线来分析运作过程\n\n时间    生产者            消费者1(1s)    消费者2(10s)\n5s    发送 11 ; 发送22   收到11->ack   \n10s   -                          收到22->ack\n15s   发送 33 : 发送44   收到33->ack   收到44->...(关闭)\n16s                  收到44->ack   \n\n# 持久化\n\n持久化是将队列数据存储到磁盘中 , 并非在内存中 . 哪怕宕机停掉 , 不至于数据丢失的情况\n\n# 队列持久化\n\n在队列声明queuedeclare方法 中的第二个参数设为 true , 启动 队列持久化\n\n==queuedeclare(string queue, boolean durable, boolean exclusive, boolean autodelete, map<string, object> arguments)==\n\n注意 :\n\n * 原先队列中有非持久化 , 且队列名相同 , 那么会抛出错误 , 需要删除原先队列 , 并重新声明\n * 队列持久化 , 并不能进行对队列中的消息进行持久化\n\n# 消息持久化\n\n在消息发送的basicpublish方法 中的第二个参数设为 messageproperties.persistent_text_plain , 启动 队列持久化\n\n==basicpublish(string exchange, string routingkey, boolean mandatory, basicproperties props, byte[] body)==\n\n> 代码复用上面的即可 , 无需展示!\n\n# 信道堆积\n\n信道堆积 是指mq发送到消费者的信道消息堆积数(缓冲区) . 缓冲区中默认情况是可以无限堆积的 , 因此需要自行控制堆积数 , 以防不必要的消息等待处理\n\n信道堆积主要通过 ==basicqos(prefetchcount)==方法 控制信道堆积数(默认0->无限)\n\n情况测试\n\n当生产者大量生产消息 , 且又有多个消费者(效率不同)时 :\n\n * 未指定堆积数 : 处理慢的消费者会堆积多个消息等待处理 , 处理快的可能会处于闲置状态\n * 指定堆积数 : 处理慢的消费者 , 当消息堆积到达指定数值 , 轮询分发消息会跳过该消费者\n\n> 轮询分发 : 会将所有消息平均分发被每个消费者中 , 等待消费\n> \n> 默认情况下每条信道能够堆积无数条\n\n注意 :\n\n * 应答需要设为 手动应答 , 否则qos , 不会生效\n\n\n# 发布确认模式 publisher confirms\n\n发布确认 是保证了消息完好的推送到mq队列中 , 确保数据不会丢失 , 以便消费者消费使用\n\n大致步骤 :\n\n 1. 获取信道\n 2. 信道启动 发布确认模式 ==confirmselect()==方法\n 3. 向mq推送消息 ==basicpublish()==方法\n 4. 向mq发送确认 ==waitforconfirms()==方法\n\n异步发布 走以下步骤\n\n 5. mq返回状态 至 监听器 进行回调 ack/nack (成功/失败)\n 6. 失败重新推送 (回至步骤3操作)\n\n主要方法\n\n返回                方法                                                  说明\nvoid              ==confirmselect()==                                 启动 发布确认模式\nboolean           ==waitforconfirms()==                               向mq发送 发布确认\nconfirmlistener   ==addconfirmlistener(confirmcallback ackcallback,   监听器 , 监听发布状态 成功/失败 , 以lambda形式 回调它们\n                  confirmcallback nackcallback)==\n\n确认发布 可分为以下类型 :\n\n * 单体 同步等待确认 , 简单 , 吞吐量有限\n * 批量 批量同步等待确认 , 简单 , 一旦出问题难以判断\n * 异步 高性能 , 采用 监听器监听发布状态 和 concurrentskiplistmap哈希表 多线程管理 , 能够准确异常\n\n耗时 : 单体 > 批量 > 异步\n\n三种模式代码示例 :\n\n秒表工具类\n\n/**\n * 秒表计时工具\n */\npublic class stopwatchutils {\n\n    public static long start;\n    public static long totaltime;\n\n    public static void start(){\n        start = system.currenttimemillis();\n    }\n\n    public static void stop(){\n        totaltime = system.currenttimemillis() - start;\n    }\n\n    public static long gettotaltime() {\n        return totaltime;\n    }\n\n}\n\n\n测试耗时\n\n点击查看代码\n\n/**\n * 1000条消息发布测试\n */\npublic class producer {\n\n    public static long msg_count = 1000;\n\n    public static void main(string[] args) throws exception {\n        // 单体发布测试 (耗时 => 1391ms\n        //publishmesindividually();\n        // 批量发布测试 (耗时 => 85ms\n        //publishmesbatch();\n        // 异步发布测试 (耗时 => 28ms\n        publishmesasync();\n    }\n\n    /**\n     * 异步发布\n     * 只管发 , 成功/失败 由监听器管\n     */\n    private static void publishmesasync() throws ioexception {\n        channel chanel = rabbitmqutils.getchanel();\n        string queuename = uuid.randomuuid().tostring();\n        // 队列声明 (持久化\n        chanel.queuedeclare(queuename, true, false, false, null);\n        // 启动确认发布\n        chanel.confirmselect();\n\n        /*\n          线程安全有序的哈希表 , 使用高并发情况\n            - 轻松记录 序号与消息 的关联\n            - 通过序号轻松批量删除条目\n            - 支持多线程\n         */\n        concurrentskiplistmap<long, string> outstandingconfirms = new concurrentskiplistmap<>();\n\n        /*\n          监听器 (监听消息是否成功)\n          参数1: 消息确认回调\n          参数2: 消息失败回调\n            - deliverytag 消息标记\n            - multiple 是否批量\n         */\n        chanel.addconfirmlistener(\n                (deliverytag, multiple) -> {\n                    // 是否批量\n                    if (multiple) {\n                        // 获取已经确认的视图\n                        concurrentnavigablemap<long, string> confirmed = outstandingconfirms.headmap(deliverytag);\n                        // 清除视图内容\n                        confirmed.clear();\n                    } else {\n                        // 直接删除序号\n                        outstandingconfirms.remove(deliverytag);\n                    }\n                    system.out.println("确认消息 => " + deliverytag);\n                },\n                (deliverytag, multiple) -> {\n                    string msg = outstandingconfirms.remove(deliverytag);\n                    system.out.println("失败消息[" + msg + "] => " + deliverytag);\n                });\n\n        stopwatchutils.start();\n        // 发消息\n        for (int i = 1; i <= msg_count; i++) {\n            string msg = "msg => " + i;\n            chanel.basicpublish("", queuename, null, msg.getbytes(standardcharsets.utf_8));\n            // 存下所有 生产者发送的消息 k(消息序列号):v(消息内容)\n            outstandingconfirms.put(chanel.getnextpublishseqno(), msg);\n        }\n        stopwatchutils.stop();\n        system.out.println("耗时 => " + stopwatchutils.gettotaltime() + "ms");\n    }\n\n    /**\n     * 批量发布\n     * 发布多个确认一次\n     */\n    private static void publishmesbatch() throws exception {\n        channel chanel = rabbitmqutils.getchanel();\n        string queuename = uuid.randomuuid().tostring();\n        // 队列声明 (持久化\n        chanel.queuedeclare(queuename, true, false, false, null);\n        // 启动确认发布\n        chanel.confirmselect();\n\n        // 批单位\n        int batchsize = 100;\n\n        stopwatchutils.start();\n        for (int i = 1; i <= msg_count; i++) {\n            string msg = "msg => " + i;\n            chanel.basicpublish("", queuename, null, msg.getbytes(standardcharsets.utf_8));\n            if (i % batchsize == 0) {\n                if (chanel.waitforconfirms()) system.out.println("第" + i / batchsize + "批发送成功" + msg);\n            }\n        }\n        stopwatchutils.stop();\n        system.out.println("耗时 => " + stopwatchutils.gettotaltime() + "ms");\n\n    }\n\n    /**\n     * 单体发布\n     * 发布一次确认一次\n     */\n    public static void publishmesindividually() throws exception {\n        channel chanel = rabbitmqutils.getchanel();\n        string queuename = uuid.randomuuid().tostring();\n        // 队列声明 (持久化\n        chanel.queuedeclare(queuename, true, false, false, null);\n        // 启动确认发布\n        chanel.confirmselect();\n\n        stopwatchutils.start();\n        for (int i = 0; i < msg_count; i++) {\n            string msg = "msg => " + i;\n            chanel.basicpublish("", queuename, null, msg.getbytes(standardcharsets.utf_8));\n            if (chanel.waitforconfirms()) {\n                system.out.println("发送成功 " + msg);\n            }\n        }\n        stopwatchutils.stop();\n        system.out.println("耗时 => " + stopwatchutils.gettotaltime() + "ms");\n    }\n\n}\n\n\n\n# 发布/订阅 模式 publish/subscribe\n\n发布订阅模式是生产者推送的消息 , 其他消费者都均可收到该消息\n\n大致流程 :\n\n 1. 声明交换机 , 并设置 fanout 类型\n 2. 生产者发送消息 到交换机\n 3. 消费者队列绑定交换机 , 并配置 routingkey路由规则 (类似订阅)\n 4. 消费者接收消息\n\n# 交换机 exchange\n\n生产者生产的消息不会直接发送到队列中的 , 而是发送到交换机 , 由交换机推入队列\n\n交换机类型 : (点击跳转代码示例)\n\n * direct(点对点) (默认) 交换机会匹配 生产者发送的 routingkey 与 消费者队列绑定交换机的 routingkey . 相同才能实现点对点发送 . 如果没有匹配到一个 , 很有可能会丢失数据\n * topic(发布订阅) 交换机会 通配符匹配 生产者发送的 routingkey 与 消费者队列绑定交换机的 routingkey , 符合条件的队列都会收到分发的消息\n * fnout(广播) 只要消费者绑定有该类型交换机 , 不管routingkey是否匹配 , 都会接收广播消息\n * ...\n\n交换机 声明方法\n\n==channel.exchangedeclare(string exchange, string type)==\n\n * exchange : 交换机名称\n * type : 交换类型\n\n# 临时队列\n\n临时队列 , 字面意思暂时使用的队列\n\n队列特性 :\n\n * 随机名称\n * 断开消费者连接队列自动删除\n\nweb管理页中 , 可以看到队列状态是 ad excl (自动删除)\n\n临时队列创建\n\n==queuedeclare()==\n\n一般去会获取队列标识进行食用 ==chanel.queuedeclare().getqueue();==\n\n# 绑定 binding\n\nexchange交换机 创建后需要绑定队列才会进行推送消息至消费者 . 可以绑定多个队列 , 消息推送是根据 routing kye(路由规则) 来确定指定队列\n\n点击查看代码\n\n\n\n> 交换机只负责转发消息 , 并没有存储消息的能力 , 因此如果没有任何队列与exchange绑定，或者没有符合路由规则的队列 , 那么消息会丢失\n\n绑定方法\n\n==queuebind(string queue, string exchange, string routingkey)==\n\n * queue : 队列名\n * exchange : 交换机\n * routing key : 路由key\n\n> 重载方法 , 可在最后面携带参数 , 详细自行api\n\nweb管理页 绑定\n\nexchanges -> 指定exchange交换机 -> bindings\n\n2\n\n# direct\n\n交换机会匹配 生产者发送的 routingkey 与 消费者队列绑定交换机的 routingkey . 相同才能实现点对点发送 . 如果没有匹配到一个 , 很有可能会丢失数据\n\n代码示例 : 点击跳转\n\n# topic\n\n交换机会根据 通配符匹配 生产者发送的 routingkey 与 消费者队列绑定交换机的 routingkey , 符合条件的队列都会收到分发的消息\n\n通配符说明 :\n\n * * 代替一个单词\n * # 代替0个/多个单词\n\n> 特殊情况 :\n> \n>  * 如果只有一个 # 那么将会接收通道的所有数据\n>  * 如果没有 #/* 出现 , 默认采用 direct\n\n匹配案例 :\n\nroutingkey            通配值        说明\ncom.sans.color        *.sans.*   匹配3个单词中的中间单词 sans\ncom.sans.color.red    #.red      匹配最后为 red\ncom.sans.color.blue   con.#      匹配开头为 com\n\n代码示例 : 点击跳转\n\n# fnout\n\n只要消费者绑定有该类型交换机 , 不管routingkey是否匹配 , 都会接收广播消息\n\n代码示例 : [点击跳转](#广播 fnout)\n\n# 代码实战\n\n通用代码 , 参数自控\n\n> 食用说明 :\n> \n>  1. 采用main传参控制 , 跳转了解\n>  2. 采用信道获取工具类 , 跳转了解\n\n生产者\n\n/**\n * 广播发送\n * @author sans\n */\npublic class producer {\n\n    /**\n     * @param args [交换机名, 交换机类型, 路由key]\n     * @throws exception\n     */\n    public static void main(string[] args) throws exception {\n\n        string exchangename = args[0];\n        string exchangetypeparam = args[1];\n        // 如果未赋予值 , 默认为 ""\n        string routingkey = args.length == 2 ? "" : args[2];\n\n        system.out.println("[交换机名, 交换机类型, 路由key]");\n        system.out.println(arrays.tostring(args));\n\n        // 枚举验证\n        builtinexchangetype exchangetype = null;\n        for (builtinexchangetype value : builtinexchangetype.values()) {\n            if (value.gettype().equals(exchangetypeparam)) exchangetype = value;\n        }\n        if (exchangetype == null) return;\n\n        channel channel = rabbitmqutils.getchanel();\n        /*\n          声明一个exchange\n          1.exchange的名称\n          2.exchange的类型\n         */\n        channel.exchangedeclare(exchangename, exchangetype);\n\n        scanner scanner = new scanner(system.in);\n        while (scanner.hasnext()) {\n            string message = scanner.next();\n            // 发布消息\n            channel.basicpublish(exchangename, routingkey, null, message.getbytes(standardcharsets.utf_8));\n            system.out.println("生产者发出消息:" + message);\n        }\n    }\n\n}\n\n\n消费者\n\n/**\n * 消费者\n * @author sans\n */\npublic class consumer {\n\n    /**\n     * @param args [交换机名, 路由key]\n     * @throws exception\n     */\n    public static void main(string[] args) throws exception {\n\n        string exchangename = args[0];\n        string routingkey = args[1];\n        system.out.println("[交换机名, 路由key]");\n        system.out.println(arrays.tostring(args));\n\n\n        channel chanel = rabbitmqutils.getchanel();\n        // 临时队列\n        string queuename = chanel.queuedeclare().getqueue();\n        // 绑定交换机\n        chanel.queuebind(queuename, exchangename, routingkey);\n\n        // 接收消息\n        chanel.basicconsume(queuename, true,(consumertag,message)->{\n            system.out.println("收到消息 => "+new string(message.getbody(), standardcharsets.utf_8));\n        },consumertag->{});\n\n    }\n}\n\n\n以上main中接收参数分别说明\n\n身份    接收参数\n生产者   [交换机名, 交换机类型, 路由key]\n消费者   [交换机名, 路由key]\n\n# direct点对点测试\n\n运行顺序   应用程序服务   参数传递(直接复制即可)\n1      生产者 p1   ==color direct blue==\n2      消费者 c1   ==color blue==\n3      消费者 c2   ==color black==\n\n结果 : c1消费了 , c2无消费 . 只有 routingkey 匹配的消费者消费消息\n\n# topic发布订阅\n\n运行顺序   应用程序服务   传递参数(直接复制即可)\n1      生产者 p1   ==color topic com.sans.red==\n2      消费者 c1   ==color #.red==\n3      消费者 c2   ==color com.#==\n4      消费者 c3   ==color com.*==\n5      消费者 c4   ==color *.red==\n6      消费者 c5   ==color #==\n7      消费者 c6   ==color *==\n\n结果 : c1 , c2 , c5 消费者消费了 , 其余未消费 . 只有 routingkey通配符匹配 的消费者消费消息\n\n# 广播 fnout\n\n运行顺序   应用程序服务   传递参数(直接复制即可)\n1      生产者 p1   ==color fnout red==\n2      消费者 c1   ==color black==\n3      消费者 c2   ==color blue==\n4      消费者 c3   ==color yellow==\n\n结果 : 所有消费者都消费了 . 消费者收到消息不会受到 routingkey的影响 , 只需绑定就可以收到通知\n\n\n# 进阶\n\n\n# 死信队列\n\n死信 是无法被消费的消息\n\n情况 : 生产者 发送消息 mq , 消费者 从 队列 取出 , 由于某些原因导致 队列 中的某些消息无法被消费 , 这样的消息没有得到处理 , 称之为死信\n\n场景 : 用户下订单时 , 点击支付 , 但又未在指定时间支付 , 死信队列机制会误认为异常消息 , 消息将会投入死信队列中\n\n触发机制 :\n\n * 消息 ttl 过期\n * 队列到达最大长度\n * 消息被拒 , 使用 channel.basicnack/channel.basicreject 应答 , 并且参数requeue为false(不回流队列)\n\n> 交换机 和 队列 中的配置 , 一旦有修改 需要删除 重新运行\n\nweb管理页中 , 可以看到队列状态是 dlx(死信交换机) , dlk (死信routingkey)\n\n**代码示例 : **\n\n初始化构架声明\n\n点击查看代码\n\n/**\n * 初始化架构\n * 初始化 交换机 , 队列 结构信息\n * @author sans\n */\npublic class initialarchitecture {\n\n    // 普通交换机的名称\n    public static final string normal_exchange = "normal_exchange";\n    // 死信交换机的名称\n    public static final string dead_exchange = "dead_exchange";\n\n    // 普通队列的名称\n    public static final string normal_queue = "normal_queue";\n    // 死信队列的名称\n    public static final string dead_queue = "dead_queue";\n    \n    public static void main(string[] args) throws exception {\n        channel chanel = rabbitmqutils.getchanel();\n\n        string normalroutingkey = "sans";\n        string deadroutingkey = "dead";\n        \n        // 重新初始化 , 删除以往相同名称的 交换机和队列\n        chanel.exchangedelete(normal_exchange);\n        chanel.exchangedelete(dead_exchange);\n        chanel.queuedelete(normal_queue);\n        chanel.queuedelete(dead_queue);\n\n        // 声明 普通,死信 交换机\n        chanel.exchangedeclare(normal_exchange, builtinexchangetype.direct);\n        chanel.exchangedeclare(dead_exchange, builtinexchangetype.direct);\n\n        map<string, object> arguments = new hashmap<>();\n        // 正常的队列设置死信交换机\n        arguments.put("x-dead-letter-exchange", dead_exchange);\n        // 设置死信routingkey\n        arguments.put("x-dead-letter-routing-key", deadroutingkey);\n        /* 超出长度 测试\n           设置队列最大长度\n        */ \n        //arguments.put("x-max-length", 6);\n\n        // 声明 普通队列 , 死信队列\n        chanel.queuedeclare(normal_queue, false, false, false, arguments);\n        chanel.queuedeclare(dead_queue, false, false, false, null);\n\n        // 普通队列 绑定 普通交换机\n        chanel.queuebind(normal_queue, normal_exchange, normalroutingkey);\n        // 死信队列 绑定 死信交换机\n        chanel.queuebind(dead_queue, dead_exchange, deadroutingkey);\n    }\n}\n\n\n生产者\n\n点击查看代码\n\n/**\n * 生产者\n * @author sans\n */\npublic class producer {\n\n    // 普通交换机的名称\n    public static final string normal_exchange = "normal_exchange";\n\n    public static void main(string[] args) throws exception {\n        channel chanel = rabbitmqutils.getchanel();\n\n        string routingkey = "sans";\n\n        for (int i = 0; i < 10; i++) {\n            string msg = "msg " + i;\n            /** ttl 超时测试\n                参数3 : 构造者构建参数 ttl时间参数\n            */\n            chanel.basicpublish(normal_exchange,\n                    routingkey,\n                    //new amqp.basicproperties().builder().expiration("10000").build(),\n                    null,\n                    msg.getbytes(standardcharsets.utf_8));\n            system.out.println("发送成功 => " + msg);\n        }\n\n    }\n\n}\n\n\n消费者1\n\n点击查看代码\n\n/**\n * 消费者1\n * @author sans\n */\npublic class consumer1 {\n\n    // 普通队列的名称\n    public static final string normal_queue = "normal_queue";\n\n    public static void main(string[] args) throws exception {\n        channel chanel = rabbitmqutils.getchanel();\n\n        // 处理消息\n        chanel.basicconsume(normal_queue, true, (consumertag, message) -> {\n            string msg = new string(message.getbody(), standardcharsets.utf_8);\n            system.out.println("接收消息 => " + msg);\n            // 消息拒绝 测试\n            //long deliverytag = message.getenvelope().getdeliverytag();\n            //if ("msg 4".equals(msg)) {\n            //    /* 拒绝 消息/收到\n            //        拒绝收到 (参数3: false防止回流队列): chanel.basicnack(deliverytag, false, false);\n            //        拒绝消息 (参数2: false防止回流队列): chanel.basicreject(deliverytag, false);\n            //     */\n            //    //chanel.basicnack(deliverytag, false, false);\n            //    chanel.basicreject(deliverytag, false);\n            //    system.out.println("拒绝 => " + msg);\n            //}else{\n            //    chanel.basicack(deliverytag, false);\n            //    system.out.println("接收消息 => " + msg);\n            //}\n        }, consumertag -> {\n        });\n\n    }\n}\n\n\n消费者2 (死信消费)\n\n点击查看代码\n\n/**\n * 消费者2\n * @author sans\n */\npublic class consumer2 {\n\n    // 死信队列的名称\n    public static final string dead_queue = "dead_queue";\n\n    public static void main(string[] args) throws exception {\n        channel chanel = rabbitmqutils.getchanel();\n\n        // 处理消息\n        chanel.basicconsume(dead_queue, true, (consumertag, message) -> {\n            system.out.println("接收消息 => " + new string(message.getbody(), standardcharsets.utf_8));\n        }, consumertag -> {\n        });\n\n    }\n}\n\n\n# 测试\n\n触发死信机制 : 有3种触发条件 , 分别围绕它们的条件进行测试\n\n过期触发ttl\n\n 0. 配置 生产者发送方法 ==basicpublish()== 中的第三参数 添加消息属性 (采用构造者模式构造类) ==new amqp.basicproperties().builder().expiration("10000").build()== (ttl设置10s过期)\n 1. 运行 初始化架构\n 2. 运行 生产者\n 3. 观察 web管理页 , 普通队列中的所有消息 过期推送至 死信队列中\n 4. 运行 消费者2 , 清除死信队列中的消息\n\n队列到达最大长度\n\n 0. 配置 初始化架构 , 在 声明普通队列 ==queuedeclare()==方法 中的第五个参数 编辑队列属性 map集合新增 : ==arguments.put("x-max-length", 6);== (队列设置最大长度为6条消息)\n 1. 运行 初始化架构\n 2. 运行 生产者\n 3. 运行 消费者1\n 4. 观察 web管理页 , 普通队列中的消息 , 有部分消息会被排挤到 死信队列中\n 5. 运行 消费者2 , 清除死信队列中的消息\n\n> 注意 :\n> \n>  * 初始化架构类中的配置 一旦修改了 , 则需要删除掉原旧的 交换机/队列 , 在运行 (配置更改了会冲突)\n>  * 为了尽可能的展现消息进入 死信队列中 , 要确保上一次所修改的配置是否还原 , 以防上次的配置影响数据混乱\n\n消息被拒绝\n\n 0. 配置 消费者1 , 手动应答请求 , 指定部分拒绝接收\n    \n    chanel.basicconsume(normal_queue, false, (consumertag, message) -> {\n        string msg = new string(message.getbody(), standardcharsets.utf_8);\n        long deliverytag = message.getenvelope().getdeliverytag();\n        if ("msg 4".equals(msg)) {\n            /* 拒绝 消息/收到\n                拒绝收到 (参数3: false防止回流队列): chanel.basicnack(deliverytag, false, false);\n                拒绝消息 (参数2: false防止回流队列): chanel.basicreject(deliverytag, false);\n             */\n            //chanel.basicnack(deliverytag, false, false);\n            chanel.basicreject(deliverytag, false);\n            system.out.println("拒绝 => " + msg);\n        }else{\n            chanel.basicack(deliverytag, false);\n            system.out.println("接收消息 => " + msg);\n        }\n    }, consumertag -> {\n    });\n    \n\n 1. 运行 初始化架构\n\n 2. 运行 生产者1\n\n 3. 运行 消费者1\n\n 4. 观察 web管理页 , 普通队列中的消息 , 有一条 msg4消息 被拒绝 至死信队列中\n\n 5. 运行 消费者2 , 清除死信队列中的消息\n\n\n# 整合springboot\n\nspringboot文档 : https://docs.spring.io/spring-amqp/reference/html/amqp.html\n\n# 快速入门\n\n引入依赖\n\n\x3c!--rabbitmq 依赖--\x3e\n<dependency>\n    <groupid>org.springframework.boot</groupid>\n    <artifactid>spring-boot-starter-amqp</artifactid>\n</dependency>\n\n\napplication配置\n\nserver:\n    port: 8088\nspring:\n    rabbitmq:\n        host: 8.130.47.114\n        port: 5672\n        username: bozhu\n        password: 123123\n\n\n> 端口容易冲突 , 建议修改\n\nrabbitmqconfig配置类\n\n交换机和队列 , 以及绑定 , 等操作是通过实例化形式进行的 , 以下由配置类形式展示\n\n简单结构\n\n\n\n点击查看代码\n\n@configuration\npublic class rabbitmqconfig {\n   \n   // 交换机\n   string aexchange = "a_exchange";\n   string deadexchange = "dead_exchange";\n   // 队列\n   string aqueue = "a_queue";\n   string deadqueue = "dead_queue";\n   \n   string routingkeya = "rka"\n   string routingkeyb = "rkb"\n   \n   /**\n    * 交换机\n    */\n   @bean\n   public directexchange aexchange() {\n       return new directexchange(aexchange);\n   }\n   @bean\n   public directexchange deadexchange() {\n       return new directexchange(deadexchange);\n   }\n   \n   /**\n    * 队列\n    */\n   @bean\n   public queue aqueue() {\n       // 配置 死信交换机, 死信routingkey, 过期ttl\n       return queuebuilder.durable(aexchange)\n               .deadletterexchange(deadexchange)\n               .deadletterroutingkey(routingkeyb)\n               .ttl(10*1000)\n               .build();\n   }\n   @bean\n   public queue deadqueue() {\n       return queuebuilder.durable(deadqueue).build();\n   }\n   \n   /**\n    * 绑定\n    */\n   @bean\n   public binding bindingaqueuetoaexchange(queue aqueue , directexchange aexchange) {\n       return bindingbuilder.bind(aqueue).to(aexchange).with(routingkeya);\n   }\n   @bean\n   public binding queuebbindx(queue deadqueue , directexchange deadexchange) {\n       return bindingbuilder.bind(deadqueue).to(deadexchange).with(routingkeyb);\n   }\n}\n\n\n# 操作对象\n\n类                说明\nrabbittemplate   简化的 发送/接收 消息类\namqpadmin        携带式对amqp管理操作类\n\n生产者发送消息 : ==rabbittemplate.convertandsend()==\n\n# 消费者\n\n@component\npublic class queueconsumer {\n    // 队列处理消息\n    // 注解指定队列名\n    @rabbitlistener(queues = "qa")\n    public void receivedead(message message, channel channel) {\n        string msg = new string(message.getbody(), standardcharsets.utf_8);\n        system.out.println("处理消息 => " + msg);\n    }\n}\n\n\n\n# 延迟队列\n\n延迟队列 是用来存放到指定时间才被释放消息的队列\n\n延迟队列机制 和 死信 ttl过期 相似 , 但延迟队列对时间的控制较灵活 , 应用应用场景广泛\n\n场景 :\n\n 1. 下单十分钟未支付自动取消订单\n 2. 新建店铺 , 如果十天未上传商品 , 则自动发送消息提醒\n 3. 新用户注册后 , 三天未登录则进行短信提醒\n 4. 用户发起退款 , 如果三天未处理则通知相关运营人员\n 5. 会议预定 , 指定时间的前十分钟提醒参加会议\n\n可以控制任意时间点发送通知\n\n# 应用方式\n\n延迟配置\n\n在 队列 中配置延迟属性\n\n/* 变量说明\n\tnormal_queue_a : 队列名称\n\tdead_exchange_y : 死信交换机名称\n\trouting_dead_queue_key : 死信routingkey\n*/\n@bean\npublic queue aqueue() {\n    // 配置 死信交换机, 死信routingkey, 过期ttl\n    return queuebuilder.durable(normal_queue_a)\n            .deadletterexchange(dead_exchange_y)\n            .deadletterroutingkey(routing_dead_queue_key)\n            .ttl(10*1000)\n            .build();\n}\n\n\n在 生产者 消息发送方法 中配置延迟\n\n指定消息ttl在队列中超时时长 : ==message.getmessageproperties().setexpiration(ttl);==\n\n// 发送消息方法\nrabbittemplate.convertandsend(normal_exchange_x, routing_key_queue_c, msg,\n        message -> {\n            message.getmessageproperties().setexpiration(ttl);\n            return message;\n        }\n);\n\n\n# 代码示例\n\n架构 :\n\n\n\n初始化架构 rabbitmqconfig\n\n点击查看代码\n\n@configuration\npublic class rabbitmqconfig {\n\n    // 普通/死信 交换机\n    public static final string normal_exchange_x = "ex";\n    public static final string dead_exchange_y = "ey";\n    // 死信 队列\n    public static final string dead_queue = "qd";\n    // 普通 队列\n    public static final string normal_queue_a = "qa";\n    public static final string normal_queue_b = "qb";\n    public static final string normal_queue_c = "qc";\n\n    // routingkey\n    public static final string routing_key_queue_a = "rqa";\n    public static final string routing_key_queue_b = "rqb";\n    public static final string routing_key_queue_c = "rqc";\n    // 死信 routingkey\n    public static final string routing_dead_queue_key = "rqd";\n\n    /**\n     * 交换机\n     */\n    @bean\n    public directexchange xexchange() {\n        return new directexchange(normal_exchange_x);\n    }\n\n    @bean\n    public directexchange yexchange() {\n        return new directexchange(dead_exchange_y);\n    }\n\n    /**\n     * 队列\n     */\n    @bean\n    public queue aqueue() {\n        // 配置 死信交换机, 死信routingkey, 过期ttl\n        return queuebuilder.durable(normal_queue_a)\n                .deadletterexchange(dead_exchange_y)\n                .deadletterroutingkey(routing_dead_queue_key)\n                .ttl(10*1000)\n                .build();\n    }\n\n    @bean\n    public queue bqueue() {\n        // 配置 死信交换机, 死信routingkey, 过期ttl\n        return queuebuilder.durable(normal_queue_b)\n                .deadletterexchange(dead_exchange_y)\n                .deadletterroutingkey(routing_dead_queue_key)\n                .ttl(40*1000)\n                .build();\n    }\n\n    @bean\n    public queue cqueue() {\n        // 配置 死信交换机, 死信routingkey\n        return queuebuilder.durable(normal_queue_c)\n                .deadletterexchange(dead_exchange_y)\n                .deadletterroutingkey(routing_dead_queue_key)\n                .build();\n    }\n\n\n    @bean\n    public queue deadqueue() {\n        return queuebuilder.durable(dead_queue).build();\n    }\n\n    /**\n     * 绑定\n     * 比较示例 : 普通队列绑定 普通队列 --- 普通交换机\n     * chanel.queuebind(normal_queue, normal_exchange, normalroutingkey);\n     */\n    @bean\n    public binding queueabindingx(queue aqueue , directexchange xexchange) {\n        return bindingbuilder.bind(aqueue).to(xexchange).with(routing_key_queue_a);\n    }\n    @bean\n    public binding queuebbindingx(queue bqueue , directexchange xexchange) {\n        return bindingbuilder.bind(bqueue).to(xexchange).with(routing_key_queue_b);\n    }\n    @bean\n    public binding queuecbindingx(queue cqueue, directexchange xexchange) {\n        return bindingbuilder.bind(cqueue).to(xexchange).with(routing_key_queue_c);\n    }\n    @bean\n    public binding queuedbindingy(queue deadqueue , directexchange yexchange) {\n        return bindingbuilder.bind(deadqueue).to(yexchange).with(routing_dead_queue_key);\n    }\n}\n\n\n生产者 producersendmessagecontroller\n\n点击查看代码\n\n@restcontroller\n@requestmapping("/producer")\npublic class producersendmessagecontroller {\n\n    @resource\n    private rabbittemplate rabbittemplate;\n\n    @getmapping("/send/{msg}")\n    public void sendmessage(@pathvariable string msg) {\n        system.out.println("收到请求 => " + msg);\n\n        // 发送消息\n        rabbittemplate.convertandsend(normal_exchange_x, routing_key_queue_b, "b队列(40 000ms) =>" + msg);\n        rabbittemplate.convertandsend(normal_exchange_x, routing_key_queue_a, "a队列(10 000ms) =>" + msg);\n    }\n\t\n    /**\n     * qc 发送消息(自定义时长)\n     * @param msg 消息\n     * @param ttl 过期时长 ms\n     */\n    @getmapping("/qcsend/{msg}/{ttl}")\n    public void sendmessage(@pathvariable string msg, @pathvariable string ttl) {\n        system.out.printf("收到请求 => [%s, %s]%n", msg, ttl);\n        rabbittemplate.convertandsend(normal_exchange_x, routing_key_queue_c, msg,\n                message -> {\n                    message.getmessageproperties().setexpiration(ttl);\n                    return message;\n                }\n        );\n    }\n\n}\n\n\n死信消费者 deadqueueconsumer\n\n@component\npublic class deadqueueconsumer {\n\t// 死信处理\n    @rabbitlistener(queues = dead_queue)\n    public void receivedead(message message, channel channel) {\n        string msg = new string(message.getbody(), standardcharsets.utf_8);\n        system.out.println("死信消费 => " + new date() + " : " + msg);\n    }\n}\n\n\n# 代码测试\n\n测试 qa 和 qb 队列 ttl过期测试\n\n 1. 访问 http://localhost:8088/producer/send/lisi\n 2. 观察 控制台 , 死信队列打印的消息(等待10s/40s)\n\n> 他们队列是分开分发一条消息 互不干扰 , 等待时间分别是 10s/40s\n\n测试 qc 队列多消息\n\n 1. 连续访问 http://localhost:8088/producer/qcsend/gogo/10000\n\n 2. 连续访问 http://localhost:8088/producer/qcsend/gogogo/15000\n\n 3. 连续访问 http://localhost:8088/producer/qcsend/go/5000\n\n 4. 观察 控制台 , 消息是共同在队列中进行等待时间\n    \n    收到请求 => [gogo, 10000]\n    收到请求 => [gogogo, 15000]\n    收到请求 => [go, 5000]\n    死信消费 => mon mar 06 11:25:59 cst 2023 : gogo\n    死信消费 => mon mar 06 11:26:05 cst 2023 : gogogo\n    死信消费 => mon mar 06 11:26:05 cst 2023 : go\n    \n\n> 在 多消息同一队列中 , 消息的ttl过期时间是同时加载的 , 并且是有序的 .\n> \n> 问题不难发现 , 同一时间发送两条消息 , 如果 第一个消息的ttl 大于 第二条消息的ttl , 即使 第二条消息的ttl已超时 , 也必须等待 第一条消息的ttl过期 , 最后也是按照先后顺序处理消息\n\n# 插件拓展\n\n该插件正是解决上面的问题 , 采用交换机的插件类型 , 能够实现 消息ttl等待是在交换机中等待执行 , 避免了在队列中排队的问题\n\n插件官网 : https://www.rabbitmq.com/community-plugins.html\n\n插件github : https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases\n\n安装 :\n\n 1. 进入mq插件目录 , 并将下载好的插件放进去 .ez格式 (选择自己的版本号) ==cd /usr/lib/rabbitmq/lib/rabbitmq_server-3.8.8/plugins==\n\n 2. 安装插件 (不需 填写版本和文件后缀) ==rabbitmq-plugins enable rabbitmq_delayed_message_exchange==\n\n 3. 重启rabbitmq ==systemctl restart rabbitmq-server==\n\n 4. 观察 web管理页 , 新增交换机 , 查看类型是否多出了 x-delayed-message类型\n\n> 下载注意版本兼容问题\n\n# 应用方式\n\n交换机声明\n\n采用 自定义交换机 进行实例化声明\n\n@bean\npublic customexchange delayedexchange() {\n    map<string, object> arguments = new hashmap<>();\n    arguments.put("x-delayed-type", "direct");\n    return new customexchange(\n            delayed_exchange_name, "x-delayed-message", true, false, arguments);\n}\n\n\n消费者延迟发送\n\n往消息添加 x-delay头 属性 , 延迟功能 ==message.getmessageproperties().setdelay(ttl);==\n\n/* 变量说明\n\tdelayed_exchange_name : 交换机名称\n\tdelayed_routing_key : routingkey\n\tmsg : 发送消息\n\tttl : 消息延迟时长\n*/\nrabbittemplate.convertandsend(delayed_exchange_name, delayed_routing_key ,msg , message -> {\n    // 为消息属性添加延迟功能\n    message.getmessageproperties().setdelay(ttl);\n    return message;\n});\n\n\n# 代码示例\n\n例图就不展示了 , 一个交换机: delayed.exchange , 一个队列: delayed.queue , 生产者 , 消费者\n\n主要测试 队列ttl过期循序问题\n\n初始化架构 delayedqueueconfig\n\n@configuration\npublic class delayedqueueconfig {\n\n    // 交换机, 队列, routingkey\n    public static final string delayed_exchange_name = "delayed.exchange";\n    public static final string delayed_queue_name = "delayed.queue";\n    public static final string delayed_routing_key = "delayed.routingkey";\n\n    /** 自定义交换机\n     *  由于是自定义类型\n     */\n    @bean\n    public customexchange delayedexchange() {\n        map<string, object> arguments = new hashmap<>();\n        arguments.put("x-delayed-type", "direct");\n        return new customexchange(\n                delayed_exchange_name, "x-delayed-message", true, false, arguments);\n    }\n\n    @bean\n    public queue delayedqueue() {\n        return new queue(delayed_queue_name);\n    }\n\n    @bean\n    public binding delayedqueuebindingdelayedexchange(queue delayedqueue, customexchange delayedexchange) {\n        return bindingbuilder.bind(delayedqueue).to(delayedexchange).with(delayed_routing_key).noargs();\n    }\n\n}\n\n\n生产者\n\n@restcontroller\n@requestmapping("/producer")\npublic class producersendmessagecontroller {\n\n    @resource\n    private rabbittemplate rabbittemplate;\n\n    @getmapping("/delayed/{msg}/{ttl}")\n    public void senddelayedmessage(@pathvariable string msg, @pathvariable integer ttl) {\n        system.out.printf("收到请求 => [%s, %s]%n", msg, ttl);\n        rabbittemplate.convertandsend(delayed_exchange_name, delayed_routing_key,msg , message -> {\n            // 设置方式和以往不同 , 这个是设置延迟\n            // message.getmessageproperties().setexpiration(ttl + "");\n            message.getmessageproperties().setdelay(ttl);\n            return message;\n        });\n    }\n}\n\n\n消费者\n\n/**\n * 消费者\n * @author sans\n */\n@component\npublic class queueconsumer {\n    @rabbitlistener(queues = delayed_queue_name)\n    public void delayedconsumer(message message, channel channel) {\n        string msg = new string(message.getbody(), standardcharsets.utf_8);\n        system.out.println("消费消息 => " + new date() + " : " + msg);\n    }\n}\n\n\n# 代码测试\n\n队列多消息测试\n\n 1. 连续访问 http://localhost:8088/producer/delayed/gogo/10000\n\n 2. 连续访问 http://localhost:8088/producer/delayed/gogogo/15000\n\n 3. 连续访问 http://localhost:8088/producer/delayed/go/5000\n\n 4. 观察 控制台 , 消息的延迟时间 是否按照有小到大的顺序 进行处理\n    \n    收到请求 => [gogo, 10000]\n    收到请求 => [gogogo, 15000]\n    收到请求 => [go, 5000]\n    消费消息 => mon mar 06 11:29:26 cst 2023 : go\n    消费消息 => mon mar 06 11:29:29 cst 2023 : gogo\n    消费消息 => mon mar 06 11:29:35 cst 2023 : gogogo\n    \n\n在web管理页中 , 是在交换机查看 延迟的消息 , 并非在队列中查看 , 消息直到延迟时间到期才会释放\n\n\n# 发布确认高级\n\n生产者发送消息后会进行备份到缓存中 , 如果成功则从缓存删除该备份的消息 , 否则在缓存中执行定时任务 , 重新从缓存中重新发布至 交换机 , 直到成功为止\n\n大致流程 :\n\n 1. 配置 ==spring.rabbitmq.publisher-confirm-type: correlated==\n\n 2. 声明基本架构 (交换机/队列/绑定)\n\n 3. 生产者正常发送消息\n\n 4. 消费者正常接收消息\n\n 5. 编写 回调类 , 实现 rabbittemplate.confirmcallback回调接口 (交换机)\n\n 6. 重写 confirm()回调方法 (成功/失败 都会走该方法)\n\n 7. 内部类接口注入 (由于是内部类不能直接拿去使用 , 不过可以通过以下形式注入其中)\n    \n    @resource\n    rabbittemplate rabbittemplate;\n    /* @postconstruct注解 \n        在配置类 执行的构造函数 和 自动注入 后执行初始化的方法(类似servlet的init()方法) \n    */\n    @postconstruct\n    public void init() {\n        // 发布确认\n        rabbittemplate.setconfirmcallback(this);\n    }\n    \n\n 8. 测试\n\n配置\n\n生产者的类型确认使用 spring.rabbitmq.publisher-confirm-type\n\n配置值          说明\nnone(默认)     不做任何确认操作\ncorrelated   消息到交换机触发 回调\nsimple       通过手动 waitforconfirms()返回结果回答(少用)\n\n# 代码示例\n\n例图就不展示了 , 一个交换机: confirm.exchange , 一个队列: confirm.queue , 生产者 , 消费者\n\n配置\n\n==spring.rabbitmq.publisher-confirm-type: correlated==\n\n基本架构\n\n@configuration\npublic class confirmconfig {\n\n    // 交换机, 队列, routingkey\n    public static final string confirm_exchange_name = "confirm.exchange";\n    public static final string confirm_queue_name = "confirm.queue";\n    public static final string confirm_routing_key = "confirm.routingkey";\n\n    @bean\n    public directexchange confirmexchange() {\n        return new directexchange(confirm_exchange_name);\n    }\n\n    @bean\n    public queue confirmqueue() {\n        return queuebuilder.durable(confirm_queue_name).build();\n    }\n\n    @bean\n    public binding confirmqueuebindingconfirmexchange(queue confirmqueue, directexchange confirmexchange) {\n        return bindingbuilder.bind(confirmqueue).to(confirmexchange).with(confirm_routing_key);\n    }\n\n}\n\n\n生产者\n\n@restcontroller\n@requestmapping("/producer")\npublic class producersendmessagecontroller {\n\n    @resource\n    private rabbittemplate rabbittemplate;\n\n    @getmapping("/confirm/{msg}")\n    public void confirmsendmessage(@pathvariable string msg) {\n        system.out.println("confirmsend => " + msg);\n        // 回调相关数据对象\n        correlationdata correlationdata = new correlationdata("1");\n        rabbittemplate.convertandsend(confirm_exchange_name, confirm_routing_key, msg, correlationdata);\n    }\n\n}\n\n\n消费者\n\n@component\npublic class queueconsumer {\n    @rabbitlistener(queues = confirm_queue_name)\n    public void confirmconsumer(message message, channel channel) {\n        string msg = new string(message.getbody(), standardcharsets.utf_8);\n        system.out.println("confirmconsumer => " + new date() + " : " + msg);\n    }\n}\n\n\n回调类\n\n@component\npublic class mycallback implements rabbittemplate.confirmcallback, rabbittemplate.returnscallback {\n\n    @resource\n    rabbittemplate rabbittemplate;\n\t\n    // 注入内部类接口\n    @postconstruct\n    public void init() {\n        // 发布确认\n        rabbittemplate.setconfirmcallback(this);\n    }\n\n    /**\n     * 交换机确认回调方法\n     * @param correlationdata 回调的相关数据\n     * @param ack ack为true，nack为false\n     * @param cause 原因，对于nack，如果可用，否则为null\n     */\n    @override\n    public void confirm(correlationdata correlationdata, boolean ack, string cause) {\n        string id = correlationdata == null ? "" : correlationdata.getid();\n        if (ack) {\n            system.out.println("success => " + id);\n        } else {\n            system.out.println("failure => " + id + " [" + cause + "] ");\n        }\n    }\n}\n\n\n# 代码测试\n\n根据可控变量分析 , 可分析出可能情况 :\n\n * 生产者 找不到交换机\n * 找到交换机 , 但找不到队列\n\n验证请求 : http://localhost:8088/producer/confirm/go\n\n生产者 找不到交换机 模拟故障操作 : 更改 生产者发送方法所指定的交换机名 , 试图寻找个不存在的交换机 测试结果 : 触发 confirmcallback()回调函数 , 失败 , 找不到交换机\n\nconfirmsend => go\nfailure => confirm2 [channel error; protocol method: #method&lt;channel.close>(reply-code=404, reply-text=not_found - no exchange \'no\' in vhost \'/\', class-id=60, method-id=40)] \n\n\n找到交换机 , 但找不到队列\n\n模拟故障操作 : (以下两个故障结果是一致的)\n\n * 更改 生产者发送方法指定的routingkey\n * 新建交换机 , 不进行绑定队列\n\n测试结果 : 触发 confirmcallback()回调函数 , 成功 , 但消息没有得到消费 . 由于找不到队列消息而丢失\n\nconfirmsend => go\nsuccess => confirm3\n\n\n> 通过以上情况测试不难发现 , 仅靠 交换机 的确认是不行的 , 还需要在 队列 中进行确认消息 !\n> \n> 可以通过退回消息 , 解决该问题\n\n\n# 回退消息\n\n回退消息 主要功能是 确认消息发到队列中 . 也解决了上面进入队列确认的问题\n\n实现 基于 发布确认代码 新增 配置/代码\n\n 1. 配置 ==spring.rabbitmq.publisher-returns: true==\n\n 2. 编写 回调类 , 实现 rabbittemplate.returnscallback回调接口 (队列)\n\n 3. 重写 returnedmessage()回调方法 , 找不到交换机失败回调\n\n 4. 内部类接口注入 (由于是内部类不能直接拿去使用 , 不过可以通过以下形式注入其中)\n\n# 代码示例\n\n复用上面的 发布确认代码\n\n配置 ==spring.rabbitmq.publisher-returns: true==\n\n生产者\n\n点击查看代码\n\n@getmapping("/messagefallback/{msg}")\npublic void messagefallbacksend(@pathvariable string msg) {\n    system.out.println("messagefallbacksend => " + msg);\n    // 发送成功\n    correlationdata correlationdata1 = new correlationdata("messagefallback1");\n    rabbittemplate.convertandsend(confirm_exchange_name, confirm_routing_key, msg, correlationdata1);\n    // 生产者 找不到交换机\n    //correlationdata correlationdata2 = new correlationdata("messagefallback2");\n    //rabbittemplate.convertandsend("no", "", msg, correlationdata2);\n    // 交换机 找不到routingkey\n    //correlationdata correlationdata3 = new correlationdata("messagefallback3");\n    //rabbittemplate.convertandsend(confirm_exchange_name, "no", msg, correlationdata3);\n    // 交换机 找不到队列\n    //correlationdata correlationdata4 = new correlationdata("messagefallback4");\n    //rabbittemplate.convertandsend("testnonull", "", msg, correlationdata4);\n}\n\n\n回调类\n\n点击查看代码\n\n@component\npublic class mycallback implements rabbittemplate.confirmcallback, rabbittemplate.returnscallback {\n\n    @resource\n    rabbittemplate rabbittemplate;\n\n    @postconstruct\n    public void init() {\n        // 发布确认\n        rabbittemplate.setconfirmcallback(this);\n        // 消息回退\n        rabbittemplate.setreturnscallback(this);\n    }\n\n    /**\n     * 交换机确认回调方法\n     * @param correlationdata 回调的相关数据\n     * @param ack ack为true，nack为false\n     * @param cause 原因，对于nack，如果可用，否则为null\n     */\n    @override\n    public void confirm(correlationdata correlationdata, boolean ack, string cause) {\n        string id = correlationdata == null ? "" : correlationdata.getid();\n        if (ack) {\n            system.out.println("success => " + id);\n        } else {\n            system.out.println("failure => " + id + " [" + cause + "] ");\n        }\n    }\n\n    /**\n     * 回退消息\n     *  当消息过程不能达到目的地 , 则将消息返回给生产者\n     * @param returned 返回的消息和元数据\n     */\n    @override\n    public void returnedmessage(returnedmessage returned) {\n        system.out.println("回退消息 ==>");\n        system.out.println("  消息: " + new string(returned.getmessage().getbody(), standardcharsets.utf_8));\n        system.out.println("  交换机名: " + returned.getexchange());\n        system.out.println("  routingkey: " + returned.getroutingkey());\n        system.out.println("  退回原因: " + returned.getreplytext());\n    }\n}\n\n\n# 代码测试\n\n根据可控变量分析 , 可分析出可能情况 :\n\n * 生产者 找不到交换机\n * 生产者 找到交换机 , 但找不到队列\n\n验证请求 : http://localhost:8088/producer/messagefallback/go\n\n生产者 找不到交换机 模拟故障操作 : 更改 生产者发送方法所指定的交换机名 , 试图寻找个不存在的交换机 测试结果 : 触发 confirmcallback()回调函数 , 失败 , 找不到交换机\n\nmessagefallbacksend => go\nfailure => messagefallback2 [channel error; protocol method: #method&lt;channel.close>(reply-code=404, reply-text=not_found - no exchange \'no\' in vhost \'/\', class-id=60, method-id=40)] \n\n\n生产者 找到交换机 , 但找不到队列\n\n模拟故障操作 : (以下两个故障结果是一致的)\n\n * 更改 生产者发送方法指定的routingkey\n * 新建交换机 , 不进行绑定队列\n\n测试结果 : 触发 confirmcallback()(成功)和returnedmessage()(失败) 回调函数 , 但消息没有得到消费 . 由于找不到队列消息而丢失\n\nmessagefallbacksend => go\n回退消息 ==>\n  消息: go\n  交换机名: confirm.exchange\n  routingkey: no\n  退回原因: no_route\nsuccess => messagefallback3\n\n\n\n# 备用交换机\n\n备用交换机 , 字面意思 , 当某一交换机匹配不到routingkey指定的队列 , 那么会交给 备用交换机 处理 .\n\n一般情况 备用交换机 , 用来处理消费者 监控/报警 等操作\n\n应用方式\n\n在配置交换机bean的时候可以通过 构造者模式中的 alternate()方法 指定备用交换机\n\n/* 变量说明\n\tbackup_exchange_normal: 普通交换机名\n\tbackup_exchange_backup: 备份交换机名\n*/\n@bean\npublic directexchange backupnormalexchange() {\n    return exchangebuilder.directexchange(backup_exchange_normal)\n            .durable(true)\n            // 备用\n            .alternate(backup_exchange_backup)\n            .build();\n}\n\n\n# 代码示例\n\n架构图\n\n\n\n基本架构\n\n点击查看代码\n\n@configuration\npublic class backupconfig {\n\n    // 交换机\n    public static final string backup_exchange_normal = "backup.exchange.normal";\n    public static final string backup_exchange_backup = "backup.exchange.backup";\n\n    // 队列\n    public static final string backup_queue_normal = "backup.queue.normal";\n    public static final string backup_queue_backup = "backup.queue.backup";\n    public static final string backup_queue_warning = "backup.queue.warning";\n\n    // routingkey\n    public static final string backup_routing_key_normal = "backup.routingkey.normal";\n\n    /**\n     * 交换机\n     */\n    @bean\n    public directexchange backupnormalexchange() {\n        return exchangebuilder.directexchange(backup_exchange_normal)\n                .durable(true)\n                // 备用\n                .alternate(backup_exchange_backup)\n                .build();\n    }\n    @bean\n    public fanoutexchange backupexchange() {\n        // 广播\n        return new fanoutexchange(backup_exchange_backup);\n    }\n\n    /**\n     * 队列\n     */\n    @bean\n    public queue backupnormalqueue() {\n        return queuebuilder.durable(backup_queue_normal).build();\n    }\n    @bean\n    public queue backupbackupqueue() {\n        return queuebuilder.durable(backup_queue_backup).build();\n    }\n    @bean\n    public queue backupwarningqueue() {\n        return queuebuilder.durable(backup_queue_warning).build();\n    }\n\n    /**\n     * 绑定\n     */\n    @bean\n    public binding bindingnormalqueuetonormalexchange(queue backupnormalqueue, directexchange backupnormalexchange) {\n        return bindingbuilder.bind(backupnormalqueue).to(backupnormalexchange).with(backup_routing_key_normal);\n    }\n    @bean\n    public binding bindingbackupbackupqueuetobackupexchange(queue backupbackupqueue, fanoutexchange backupexchange) {\n        return bindingbuilder.bind(backupbackupqueue).to(backupexchange);\n    }\n    @bean\n    public binding bindingbackupwarningqueuetobackupexchange(queue backupwarningqueue, fanoutexchange backupexchange) {\n        return bindingbuilder.bind(backupwarningqueue).to(backupexchange);\n    }\n}\n\n\n生产者\n\n点击查看代码\n\n@restcontroller\n@requestmapping("/producer")\npublic class producersendmessagecontroller {\n\n    @resource\n    private rabbittemplate rabbittemplate;\n\n    @getmapping("/backup/{msg}")\n    public void backupsend(@pathvariable string msg) {\n        system.out.println("backupsend => " + msg);\n        // 发送成功\n        correlationdata correlationdata1 = new correlationdata("backupsend>1");\n        rabbittemplate.convertandsend(backup_exchange_normal, backup_routing_key_normal, msg, correlationdata1);\n        // 生产者 找不到交换机\n        //correlationdata correlationdata2 = new correlationdata("backupsend>2");\n        //rabbittemplate.convertandsend(backup_exchange_normal+"123", backup_routing_key_normal, msg, correlationdata2);\n        // 交换机 找不到routingkey\n        //correlationdata correlationdata3 = new correlationdata("backupsend>3");\n        //rabbittemplate.convertandsend(backup_exchange_normal, backup_routing_key_normal+"123", msg, correlationdata3);\n        // 交换机 找不到队列\n        //correlationdata correlationdata4 = new correlationdata("backupsend>4");\n        //rabbittemplate.convertandsend("testnonull", "", msg, correlationdata4);\n    }\n}\n\n\n消费者\n\n点击查看代码\n\n@component\npublic class queueconsumer {\n    /**\n     * 备份交换机\n     */\n    // 正常消费者\n    @rabbitlistener(queues = backup_queue_normal)\n    public void backupnormalconsumer(message message, channel channel) {\n        string msg = new string(message.getbody(), standardcharsets.utf_8);\n        system.out.println("backupnormalconsumer => " + new date() + " : " + msg);\n    }\n    // 备份消费者\n    @rabbitlistener(queues = backup_queue_backup)\n    public void backupconsumer(message message, channel channel) {\n        string msg = new string(message.getbody(), standardcharsets.utf_8);\n        system.out.println("backupconsumer => " + new date() + " : " + msg);\n    }\n    // 警告消费者\n    @rabbitlistener(queues = backup_queue_warning)\n    public void backupwarningconsumer(message message, channel channel) {\n        string msg = new string(message.getbody(), standardcharsets.utf_8);\n        system.out.println("backupwarningconsumer => " + new date() + " : " + msg);\n    }\n\n}\n\n\n# 代码测试\n\n根据可控变量分析 , 可分析出可能情况 :\n\n * 生产者 找不到交换机\n * 交换机 routingkey匹配不到队列\n * 交换机 未绑定队列\n * 备用交换机 未绑定队列\n\n验证请求 : http://localhost:8088/producer/messagefallback/go\n\n> 模拟故障操作 , 在生产者类中写有 , 去掉注释测试即可\n\n生产者 找不到交换机\n\n模拟故障操作 : 更改 生产者发送方法所指定的交换机名 , 试图寻找个不存在的交换机 测试结果 : confirmcallback() 回调失败\n\nbackupsend => go\nfailure => backupsend>2 [channel error; protocol method: #method&lt;channel.close>(reply-code=404, reply-text=not_found - no exchange \'backup.exchange.normal123\' in vhost \'/\', class-id=60, method-id=40)] \n\n\n交换机 routingkey匹配不到队列\n\n模拟故障操作 : 更改 生产者发送方法指定的routingkey\n\n测试结果 : confirmcallback() 回调成功 , 并且 备用交换机处理消息\n\nbackupsend => go \nsuccess => backupsend>3\nbackupwarningconsumer => tue mar 07 14:40:37 cst 2023 : go\nbackupconsumer => tue mar 07 14:40:37 cst 2023 : go\n\n\n交换机 未绑定队列\n\n模拟故障操作 : 新建交换机 , 不进行绑定队列 测试结果 : confirmcallback() 回调成功 , 在交换机中 触发returnedmessage()退回消息 , 备用交换机未处理消息\n\nbackupsend => go\n回退消息 ==>\n  消息: go\n  交换机名: testnonull\n  routingkey: \n  退回原因: no_route\nsuccess => backupsend>4\n\n\n备用交换机 未绑定队列\n\n模拟故障操作 : 备用交换机 , 不进行绑定队列 (在web管理页 解绑 重发消息即可实现)\n\n测试结果 : confirmcallback() 回调成功 , 在备用交换机中 触发returnedmessage()退回消息 , 备用交换机未处理消息\n\nbackupsend => go\n回退消息 ==>\n  消息: go\n  交换机名: backup.exchange.normal\n  routingkey: backup.routingkey.normal123\n  退回原因: no_route\nsuccess => backupsend>3\n\n\n> 在上面4种情况观察分析 , 可以发现 交换机一旦未绑定队列 , 会使 消息回退 , 也不会执行备用交换机方案\n\n\n# 队列优先级\n\n不难想象 , 在双十一高峰期 , 订单会非常多 . 有时 公司出于利益方面 , 划分出客户等级 , 等级越高的客户他们的单子往往在拥挤的时候优先得到解决\n\n在mq当中优先级取值范围 : 0 ~ 255 (数值越大越优先)\n\n应用方式\n\n配置\n\n在 队列 中配置 优先级属性\n\n/* 变量说明\n    confirm_queue_name: 队列名\n*/\n@bean\npublic queue priorityqueue() {\n    return queuebuilder.durable("priority.queue")\n            // 优先级 优先级最大值\n            .maxpriority(40)\n            .build();\n}\n\n\n在 生产者 消息发送方法 中配置优先级\n\n指定 消息 在队列中的优先级 : ==message.getmessageproperties().setpriority(n);==\n\n@getmapping("/priority/{msg}")\npublic void prioritybend(@pathvariable string msg) {\n    // 优先级倒过来 ,\n    system.out.println("prioritybend => " + msg);\n    for (int i = 0; i < 20; i++) {\n        correlationdata correlationdata = new correlationdat22a(msg + i);\n        int finali = i;\n        rabbittemplate.convertandsend(confirm_exchange_name, confirm_routing_key, msg + i, message -> {\n            message.getmessageproperties().setpriority(finali);\n            return message;\n        }, correlationdata);\n    }\n}\n\n\n# 测试\n\n源代码基本架构 点击跳转\n\n测试步骤 :\n\n 1. 注释掉消费者代码\n 2. 运行项目\n 3. 访问 http://localhost:8088/producer/priority/go (发送消息)\n 4. 观察方式 , 有两种: web管理页 (能看到消息明细) ; 控制台(测试顺序)\n\nweb观察\n\n进入 queues -> 选择队列 -> get messages\n\n控制台观察 : 恢复消费者代码(去除先前注解) , 重新运行项目\n\nconfirmconsumer => tue mar 07 21:55:26 cst 2023 : go19\nconfirmconsumer => tue mar 07 21:55:26 cst 2023 : go18\nconfirmconsumer => tue mar 07 21:55:26 cst 2023 : go17\nconfirmconsumer => tue mar 07 21:55:26 cst 2023 : go16\nconfirmconsumer => tue mar 07 21:55:26 cst 2023 : go15\nconfirmconsumer => tue mar 07 21:55:26 cst 2023 : go14\nconfirmconsumer => tue mar 07 21:55:26 cst 2023 : go13\nconfirmconsumer => tue mar 07 21:55:26 cst 2023 : go12\nconfirmconsumer => tue mar 07 21:55:26 cst 2023 : go11\nconfirmconsumer => tue mar 07 21:55:26 cst 2023 : go10\nconfirmconsumer => tue mar 07 21:55:26 cst 2023 : go9\nconfirmconsumer => tue mar 07 21:55:26 cst 2023 : go8\nconfirmconsumer => tue mar 07 21:55:26 cst 2023 : go7\nconfirmconsumer => tue mar 07 21:55:26 cst 2023 : go6\nconfirmconsumer => tue mar 07 21:55:26 cst 2023 : go5\nconfirmconsumer => tue mar 07 21:55:26 cst 2023 : go4\nconfirmconsumer => tue mar 07 21:55:26 cst 2023 : go3\nconfirmconsumer => tue mar 07 21:55:26 cst 2023 : go2\nconfirmconsumer => tue mar 07 21:55:26 cst 2023 : go1\nconfirmconsumer => tue mar 07 21:55:26 cst 2023 : go0\n\n\n\n# 惰性队列\n\n惰性队列 主要作用的将消息尽可能的存到磁盘中 , 而消费者响应消息的时候才会被加载到内存中 , 设计初衷主要是容纳更多的消息 , 以免高峰期导致内存爆炸现象\n\n不同情况下的队列 :\n\n * 普通队列(default) : 消息保存到内存中 (尽可能提高性能)\n * 惰性队列(lazy) : 消息保存到磁盘中 (尽可能存储更多的消息)\n\n惰性优点 :\n\n * 消费者失效 , 消息堆积情况\n * 大量消息 , 占用内存小\n\n应用 :\n\n 1. 在 队列 中配置 模式属性 : ==x-queue-mode: lazy==\n 2. 大量发送消息\n 3. 观察 web内存占用情况\n\nspringboot 配置\n\n在 队列 中配置 惰性属性\n\n@bean\npublic queue lazyqueue() {\n    return queuebuilder.durable("lazy.queue")\n            // 惰性\n        \t.lazy()\n            .build();\n}\n\n\n高压测试\n\n在 100w 条消息的内存情况下\n\n * 普通 : 5.2mib ≈ 5.078125mb ≈ 5078.1kb\n * 惰性 : 1.1mib ≈ 1.07421875mb ≈ 1074.2kb\n\n> gb 是 生厂商为了方便计算 , 以十进制 10的3次方运算 . 如 : 1000mb = 1gb\n> \n> gib 而是 操作系统是采用 , 以二进制 2的10次方运算 . 如 : 1mib = 1024kib\n> \n> 为了便于理解 可以将 mib为mb (其他单位也是如此)\n\n采用 异步发布消息 100w条消息\n\n普通 :\n\n\n\n惰性 :\n\n\n\n\n# 集群\n\n以往的操作都是处于一台机器操作 , 那么该机器宕机了 , 就不能服务 , 因此我们只可以使用多台服务器连接形成集群 , 提高可用率 , 哪怕其中一台宕机了也可以完好的将数据保留\n\n下面采用docker模拟多台服务器应用\n\n\n# docker\n\n在docker中 部署安装rabbitmq\n\n 0. 安装docker (网上教程烂大街..)\n\n 1. 查看版本 https://hub.docker.com/_/rabbitmq , 并拉取下载 建议下载含有web管理页 , 镜像中带有 mangement版本的\n\n 2. 启动docker容器\n    \n    docker run -d --name [容器名称]  \\\n    -p 5672:5672  \\\n    -p 15672:15672  \\\n    -v `pwd`/data:/home/rabbitmq  \\\n    --hostname [节点名称]  \\\n    -e rabbitmq_default_user=admin  \\\n    -e rabbitmq_default_pass=admin rabbitmq:[tag标签] \\\n    \n    \n    我个人的应用方式 (端口小修一下)\n    \n    docker run -d --name rabbitmq03  \\\n    -p 5674:5672  \\\n    -p 15674:15672  \\\n    -v `pwd`/data:/home/rabbitmq  \\\n    --hostname node03  \\\n    -e rabbitmq_default_user=admin  \\\n    -e rabbitmq_default_pass=admin  \\\n    rabbitmq:3.11.10-management\n    \n    \n    选项说明 :\n    \n    选项           说明\n    -d           后台运行\n    --name       指定容器名称\n    -p           指定端口 [外部端口]:[容器端口] (5672:连接访问; 15672: web管理页)\n    -v           映射 目录/文件\n    --hostname   主机名 (较为重要 集群作为 节点名称 使用)\n    -e           指定环境变量 (默认账号密码)\n\n 3. web打开 http://ip:15672/ / http://ip:15673/ / http://ip:15674/\n\n 4. 账号密码 : admin\n\n**检查 : **\n\n * 检查docker容器 ==docker ps -a==\n * 检查端口是否调试好 ==docker port {容器id}==\n * 查看防火墙是否开放端口\n\n> mq容器不同版本的端口很有可能不同 , 可通过 ==docker ps -a== 进行检查',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"JDBC",frontmatter:{title:"JDBC",author:"柏竹",permalink:"/backend/0ygxqu",date:"2020-02-18T00:00:00.000Z",categories:["后端"],tags:["数据库"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/05.%E6%95%B0%E6%8D%AE%E5%BA%93/02.JDBC.html",relativePath:"01.后端/05.数据库/02.JDBC.md",key:"v-5156a597",path:"/backend/0ygxqu/",headers:[{level:2,title:"体系构架",slug:"体系构架",normalizedTitle:"体系构架",charIndex:97},{level:3,title:"体系结构",slug:"体系结构",normalizedTitle:"体系结构",charIndex:106},{level:3,title:"组件",slug:"组件",normalizedTitle:"组件",charIndex:181},{level:2,title:"首次应用",slug:"首次应用",normalizedTitle:"首次应用",charIndex:410},{level:2,title:"API",slug:"api",normalizedTitle:"api",charIndex:26},{level:3,title:"Connection",slug:"connection",normalizedTitle:"connection",charIndex:247},{level:3,title:"ResultSet",slug:"resultset",normalizedTitle:"resultset",charIndex:310},{level:3,title:"ResultSetMetaData",slug:"resultsetmetadata",normalizedTitle:"resultsetmetadata",charIndex:2171},{level:3,title:"Statement",slug:"statement",normalizedTitle:"statement",charIndex:277},{level:3,title:"PrepareStatement",slug:"preparestatement",normalizedTitle:"preparestatement",charIndex:3334},{level:2,title:"多表关系",slug:"多表关系",normalizedTitle:"多表关系",charIndex:4528},{level:2,title:"事务应用",slug:"事务应用",normalizedTitle:"事务应用",charIndex:5048},{level:3,title:"Savepoints(事务存档)",slug:"savepoints-事务存档",normalizedTitle:"savepoints(事务存档)",charIndex:5644},{level:2,title:"批量处理",slug:"批量处理",normalizedTitle:"批量处理",charIndex:6589},{level:2,title:"反射处理集",slug:"反射处理集",normalizedTitle:"反射处理集",charIndex:7275},{level:2,title:"连接池",slug:"连接池",normalizedTitle:"连接池",charIndex:8462},{level:3,title:"DBCP连接池",slug:"dbcp连接池",normalizedTitle:"dbcp连接池",charIndex:8479},{level:3,title:"C3P0连接池",slug:"c3p0连接池",normalizedTitle:"c3p0连接池",charIndex:9062},{level:3,title:"Druid连接池",slug:"druid连接池",normalizedTitle:"druid连接池",charIndex:11148},{level:3,title:"软编码",slug:"软编码",normalizedTitle:"软编码",charIndex:11512},{level:2,title:"代码索引",slug:"代码索引",normalizedTitle:"代码索引",charIndex:12518},{level:3,title:"JDBC应用",slug:"jdbc应用",normalizedTitle:"jdbc应用",charIndex:418},{level:3,title:"JDBC应用 增、删、改",slug:"jdbc应用-增、删、改",normalizedTitle:"jdbc应用 增、删、改",charIndex:3080},{level:3,title:"PreparedStatement预状态通道",slug:"preparedstatement预状态通道",normalizedTitle:"preparedstatement预状态通道",charIndex:4268},{level:3,title:"JDBC事务应用",slug:"jdbc事务应用",normalizedTitle:"jdbc事务应用",charIndex:5630},{level:3,title:"Savepoints存档",slug:"savepoints存档",normalizedTitle:"savepoints存档",charIndex:6571},{level:3,title:"SQL批处理",slug:"sql批处理",normalizedTitle:"sql批处理",charIndex:7263},{level:3,title:"JDBC整合应用",slug:"jdbc整合应用",normalizedTitle:"jdbc整合应用",charIndex:30802}],headersStr:"体系构架 体系结构 组件 首次应用 API Connection ResultSet ResultSetMetaData Statement PrepareStatement 多表关系 事务应用 Savepoints(事务存档) 批量处理 反射处理集 连接池 DBCP连接池 C3P0连接池 Druid连接池 软编码 代码索引 JDBC应用 JDBC应用 增、删、改 PreparedStatement预状态通道 JDBC事务应用 Savepoints存档 SQL批处理 JDBC整合应用",content:'# JDBC\n\nJDBC是一种SQL语句的Java API ，Java语言编写的 类和接口\n\n * 连接数据库\n * 创建 SQL语句\n * 在数据库中SQL查询\n * 查看和生成记录\n\n\n# 体系构架\n\n\n# 体系结构\n\n**JDBC API：** 提供应用程序JDBC管理器连接 **JDBC Driver Manager：** 管理器驱动程序连接\n\n\n# 组件\n\nDriverManager： 此类 管理数据库驱动程序列表 Driver： 此接口 处理与数据库服务器的通信，连接具体驱动 Connection： 该界面具有用于联系数据库的所有方法 Statement： 此接口 创建的对象将SQL语句提交到数据库 ResultSet： 在使用Statement对象执行SQL查询后，这些对象保存从数据库检索的数据。它作为一 个迭代器，允许我们移动其数据。 SQLException： 此类数据库发生的错误\n\n\n# 首次应用\n\n构建JDBC应用：\n\n 1. 导入包 import java.sql.*\n 2. **注册JDBC驱动程序 ** 通过Java程序 初始化驱动程序 Class.forName("com.mysql.cj.jdbc.Driver"); , 驱动类文件加载至内存中，并自动注册\n 3. 连接对象 通过 DriverManager.getConnection(String url, String userName, String passWord )方法 获取 Connection对象 (数据库的物理连接)\n 4. 执行查询 通过 Statement对象 构建 和 提交SQL语句到数据库\n 5. 结果集提取数据 通过 ResultSet.getXXX(String 字段名 )方法 获取结果集检索数据（XXX代表对应的数据类型）\n 6. 释放资源 关闭所有数据库资源，避免依赖JVM垃圾收集器\n\n**注册JDBC驱动程序 方法 **\n\n> Class.forName(String str) 根据路径进行加载驱动 DriverManager.registerDriver(Driver mydriver) 静态方法 对象加载\n\n点击代码示例* （JDBC应用）\n\n\n# API\n\n实现数据库连接交互信息\n\n\n# Connection\n\n连接数据库 DriverManager.getConnection()方法 建立连接，重载方法有\n\nDriverManager.getConnection(String url) DriverManager.getConnection(String url，Properties prop) DriverManager.getConnection(String url，String user，String password) DriverManager.getConnection(String url, Properties info)\n\n数据库URL配置\n\nRDBMS    JDBC驱动程序名称                        网址格式\nMYSQL8   com.mysql.cj.jdbc.Driver          jdbc:mysql://HostName:3306/databaseName?serverTimezone=UTC\nMySQL    com.mysql.jdbc.Driver             jdbc:mysql://HostName:3306/databaseName\nORACLE   oracle.jdbc.driver.OracleDriver   jdbc:oracle:thin:@HostName:Port Number：databaseName\nDB2      COM.ibm.db2.jdbc.net.DB2Driver    jdbc:db2:HostName:Port / databaseName\nSYBASE   com.sybase.jdbc.SybDriver         jdbc:sybase:Tds:HostName:Port Number / databaseName\n\nHostName： IP地址 Post： 端口 databaseName： 库名\n\n> 注意：mysql8以后的url必须添加时区 ==serverTimezone=UTC==\n\n\n# ResultSet\n\n数据库中的查询结果集 ResultSet对象 维护指向结果集中当前行的光标。 如果没有在 createStatement()方法 中指定参数 ，则自动获取TYPE_FORWARD_ONLY\n\n参数                                  说明\nResultSet.TYPE_SCROLL_INSENSITIVE   光标可前后滚动，对数据更改不敏感\nResultSet.TYPE_SCROLL_SENSITIVE     光标可前后滚动，对底层数据更改敏感\nResultSet.TYPE_FORWARD_ONLY         光标只能在结果集中向前移动\n\n\n# ResultSetMetaData\n\n一般用于获取 ResultSet对象 中字段的类型和属性的信息的对象\n\nResultSetMetaData方法\n\n返回       方法                              说明\nString   getColumnName(int column)       获取 指定字段名称（从1开始）\nString   getColumnLabel(int column)      获取 指定字段的别名（从1开始）\nint      getColumnCount()                获取 当前ResultSet对象中的字段数\nString   getColumnTypeName(int column)   检索 指定字段的库，特定的类型名称\n···      ···                             ···\n\n\n# Statement\n\n在使用 Statement对象 执行SQL语句之前，连接后得到 Connection对象 的 createStatement()方法 创建Statement对象\n\n//以下代码需要 异常 捕获或抛出\n//获取数据库的实体连接\nConnection connection = ······ ;\nStatement stmt = connection.createStatement();\n\n\nStatement方法\n\n返回          方法                          说明\nboolean     execute(String SQL)         是否存在 ResultSet对象\nint         executeUpdate(String SQL)   在数据库中执行SQL语句，并且获取 SQL语句影响的行数\nResultSet   executeQuery(String SQL)    获取 查询的结果集，迭代遍历可获取数据\nvoid        close()                     关闭对象\n\n点击代码示例* （JDBC应用 增、删、改）\n\n恶意SQL注入\n\n通过SQL命令插入Web表单提交或输入域名或页面请求的查询字符串，最终以伪信息进行SQL执行命令，示例：\n\nString username = "aa";\n//跳过判断 ； 通过 或 进行 1=1\nString password = " \'\' OR 1=1 ";\nString sql = "SELECT * FROM users WHERE username = \'"+username+"\' AND password = "+password;\n\n\n\n# PrepareStatement\n\nPrepareStatement接口 预状态通道，也是 Statement接口 的子接口，它能简化代码、预防注入恶意sql注入、提高效率的优点 SQL语句可动态的提供参数相应的数据\n\n//抛出|捕获 异常\nString sql = "SELECT * FROM users WHERE username = ? AND password = ?";\nPreparedStatement pps = Connection.prepareStatement(sql);\npps.setString(1 , "张三");\npps.setInt(2 , "123123");\n\n//执行sql\nint resultSet = pps.executeQuery();\n···\n    \npps.close();\n\n\n在当中所有参数都由 ？ 标记，执行SQL前，必须提供为每个参数提供值！！\n\nPreparedStatement方法\n\n返回          方法                           说明\nboolean     execute()                    是否存在 ResultSet对象\nint         executeUpdate()              在数据库中执行SQL语句，并且获取 SQL语句影响的行数\nResultSet   executeQuery()               获取 查询的结果集，迭代遍历可获取数据\nXXX         setXXX(int mark,XXX value)   XXX代表绑定对应的数据类型\n                                         mark： 下标锁定（下标是从1开始）\n                                         value： 指定下标赋予值\n            ···                          \nvoid        close()                      关闭对象\n\n点击代码示例* （PreparedStatement预状态通道）\n\nstatement和PreparedStatement区别\n\n 1. statement属于状态通道，PreparedStatement属于预状态通道\n 2. 预状态通道会先编译sql语句,再去执行，比statement执行效率高\n 3. 预状态通道支持占位符? ，给占位符赋值的时候，位置从1开始\n 4. 预状态通道可以防止sql注入，因 预状态通道在处理值的时候以字符串形式处理\n 5. PreparedStatement通道传递的参数只能是变量，并非变量\n\n\n# 多表关系\n\n数据库的分类有：一对一、一对多、多对多\n\n实体类通过属性的方式建立两表关系 类名=表名 、 列名=属性名\n\n实现方式原理：通过查询提取出的数据，对相应类属性进行赋值\n\n有学生类(Student)，有ID、姓名属性，生成它们的get、set方法 数据库数据 （XX库 Student表）\n\nSID   SNAME\n1     柏竹\n2     黑猫\n\n以下代码实例\n\n····\n//执行SQL\nString sql = "SELECT * FROM student";\nPreparedStatement pps = connection.prepareStatement(sql);\nresultSet = pps.executeQuery();\n\nStudent student = new Student();\nwhile (resultSet.next()){\n\tstudent.setSid(resultSet.getInt("sid"));\n\tstudent.setsName(resultSet.getString("sname"));\n}\n\n\n点击多表项目测试代码 （可以自行下载查看详细操作 · 免费）\n\n\n# 事务应用\n\n点击事务了解\n\nJDBC连接默认是 自动提交模式 ，JDBC也支持手动事务，每条SQL语句完成后自动提交到数据库 事务能使控制库数据何时进行数据更改，如果一组SQL语句视为一个逻辑单元去执行，要么全部成功，要么全部失败！\n\n通过 Connection对象 进行事务提交回滚操作！\n\n返回        方法                                  说明\nvoid      setAutoCommit(boolean autoCommit)   是否关闭自动提交事务（自动打开事务）\nboolean   getAutoCommit()                     是否为自动提交事务模式\nvoid      commit()                            提交事务\nvoid      rollback()                          回滚事务\nvoid      close()                             释放资源\n\n//connection 已连接\nconnection.setAutoCommit(false);\n\n//SQL操作\n·····\n    \n//手动提交\nconnection.commit();\n\n\n点击代码示例* （JDBC事务应用）\n\n\n# Savepoints(事务存档)\n\n事务执行过程，可设置保存点，设置保存点库数据会更变。保存存档后的点（库更改后数据是永久性的），当中出现异常，回滚事务时会返回至存档点，并非开头启动事务点！\n\n通过 Connection对象 进行存档点的操作！\n\n返回          方法                                      说明\nSavepoint   setSavepoint(String name)               定义存档点，需设存档点名\nvoid        releaseSavepoint(Savepoint savepoint)   删除指定存档点\nvoid        rollback(Savepoint savepoint)           指定回滚目的\n\nSavepoint archiveNo1 = null;\ntry {\n    ···\n    //connection 已连接\n    connection.setAutoCommit(false);\n    Statement statement = connection.createStatement();\n    \n    //SQL操作\n    ·····\n    //以上是SQL完成操作\n    archiveNo1 = connection.setSavepoint("ArchiveNo1");\n    ·····\n        \n    //手动提交\n    connection.commit();\n} catch (Exception throwables) {\n    //异常回滚\n            try {\n                connection.rollback(archiveNo1);\n                connection.commit();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n}\n\n\n点击代码示例* （Savepoints存档）\n\n\n# 批量处理\n\nJDBC允许 批量处理SQL语句 ，通过事务一次调用提交库 一次发送多条SQL语句，可减少数据库的交互次数，提高质量\n\n通过 PreparedStatement对象 、 Statement对象 实现批处理方法\n\n返回      方法                     说明\nvoid    addBatch()             PreparedStatement对象添加SQL语句\nvoid    addBatch(String sql)   Statement对象 添加SQL语句\nint[]   executeBatch()         获取批量执行的影响数(顺序=添加SQL顺序)，并执行 批量SQL语句\n\n实现步骤\n\n 1. 连接数据库 Connection对象\n 2. 设置手动事务 Connection对象 的 setAutoCommit(false)方法\n 3. 获取通道对象 PreparedStatement对象 或 Statement对象\n 4. 不同通道对象，添加方式不同！ Statement对象 通过 addBatch(sql)方法 实现添加SQL语句 PreparedStatement对象 通过 addBatch()方法 实现添加 SQL语句\n 5. 通过 通道对象 的 executeBatch()方法 批量执行SQL语句\n 6. 提交事务 Connection对象 的 commit()方法 进行提交\n\n注意： 批量处理过程中出现异常，可通过异常捕获进行回滚操作\n\n点击代码示例* （SQL批处理）\n\n\n# 反射处理集\n\n利用反射处理查询到的结果集，对应的数据赋予对象！ 注意：以下代码要求库中的字段名与类中的属性名相同，且类所有属性都有get、set方法！（类至少有一个相同）\n\n//库连接\n···\nList studentall = new ArrayList();\n//student表 = studnet类 ，且 表studnet的字段 = 类studnet的属性！！\nString sql = "SELECT * FROM student";\npps = connection.prepareStatement(sql);\nrs = pps.executeQuery();\n\n//提取 结果集 字段的类型和属性的信息\nResultSetMetaData metaData = rs.getMetaData();\n//赋予字段数\nint count = metaData.getColumnCount();\nString[] columnNames = new String[count];\n//字段数组\nfor (int i = 0 ; i < count ; i++) {\n    columnNames[i] = metaData.getColumnName(i+1);\n}\n\n//通过反射 student类中的所有方法\nMethod[] declaredMethods = student.getDeclaredMethods();\nwhile (rs.next()){\n    //无参的构造方法\n    Object s = cla.newInstance();\n    //遍历数组字段\n    for (String columnName : columnNames) {\n        //用于比较 set方法名  \n        String newColumnName = "set"+columnName;\n        //遍历类方法\n        for (Method declaredMethod : declaredMethods) {\n            //比较方法名（无视大小写）\n            if (declaredMethod.getName().equalsIgnoreCase(newColumnName)){\n                //通过反射实现方法\n                declaredMethod.invoke(s , rs.getObject(columnName));\n                break;\n            }\n        }\n        //每条数据都添加\n        list.add(s);\n    }\n}\n\n\n\n# 连接池\n\n点击连接池说明\n\n\n# DBCP连接池\n\n实现步骤：\n\n 1. 导入jdk依赖包 mysql-jdbc.jar commons-dbcp.jar commons-pool.jar\n 2. 实例 BasicDataSource对象\n 3. 功能属性实现 BasicDataSource对象 的 set方法\n 4. 获取连接 通过 BasicDataSource对象 的 getConnection()方法\n\n配置实例\n\npublic void testHard() throws SQLException{\n\t// 硬编码 使用DBCP连接池\n\tBasicDataSource source = new BasicDataSource();\n\t//设置连接的信息\n\tsource.setDriverClassName("com.mysql.jdbc.Driver");\n        //设置 url 、 用户 、 密码 ···\n\tsource.setUrl("jdbc:mysql://localhost:3306/day2");\n\tsource.setUsername("root");\n\tsource.setPassword("111");\n        //获取连接\n\tConnection connection = source.getConnection();\n}\n\n\n\n# C3P0连接池\n\nC3P0与DBCP区别\n\n 1. C3P0有自动回收空闲连接功能，DBCP没有\n 2. C3P0无需手动，DBCP需手动配置文件\n 3. C3P0配置文件命名固定（c3p0-config.xml）\n\n实现步骤：\n\n 1. 导入jdk依赖包\n    \n    mysql-jdbc.jar\n    \n    c3p0-0.9.1.2.jar (版本号)\n\n 2. 创建 c3p0-config.xml 配置文件，路径：src文件夹下\n\n 3. 手动 配置文件 调用无参的默认配置 <default-config> 调用有参的配置<named-config name="Myc3p0Test"> 自定命名\n\n 4. 实例 ComboPooledDataSource对象 无参调用默认的，有参调用自定义的\n\n 5. 获取连接 通过 ComboPooledDataSource对象 的 getConnection()方法\n\n手动配置 c3p0-config.xml 配置文件。实例：\n\n<?xml version="1.0" encoding="utf-8"?>\n<c3p0-config>\n    \x3c!-- 默认配置，如果没有指定则使用这个配置 --\x3e\n    <default-config>\n        \x3c!-- 基本配置 --\x3e\n        <property name="driverClass">com.mysql.cj.jdbc.Driver</property>\n        <property name="jdbcUrl">jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai</property>\n        <property name="user">root</property>\n        <property name="password"></property>\n        \x3c!--扩展配置--\x3e\n        \x3c!-- 连接超过1min报错--\x3e\n        <property name="checkoutTimeout">60000</property>\n        \x3c!--30秒检查空闲连接 --\x3e\n        <property name="idleConnectionTestPeriod">30</property>\n        <property name="initialPoolSize">10</property>\n        \x3c!-- 30秒不适用丢弃--\x3e\n        <property name="maxIdleTime">30</property>\n        <property name="maxPoolSize">100</property>\n        <property name="minPoolSize">10</property>\n        <property name="maxStatements">200</property>\n    </default-config>\n    \x3c!-- 命名的配置 --\x3e\n    <named-config name="Myc3p0Test">\n        <property name="driverClass">com.mysql.cj.jdbc.Driver</property>\n        <property name="jdbcUrl">jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai</property>\n        <property name="user">root</property>\n        <property name="password"></property>\n        \x3c!-- 如果池中数据连接不够时一次增长多少个 --\x3e\n        <property name="acquireIncrement">5</property>\n        <property name="initialPoolSize">20</property>\n        <property name="minPoolSize">10</property>\n        <property name="maxPoolSize">40</property>\n        <property name="maxStatements">20</property>\n        <property name="maxStatementsPerConnection">5</property>\n     </named-config>\n</c3p0-config>\n\n\n\n# Druid连接池\n\nDruid是目前大厂流行的连接池，有以下特点：\n\n 1. 秒查询 快速的聚合能力以及亚秒级的OLAP查询能力\n 2. 实时数据注入 保证在实时和离线环境下 事件的 实效性 和 统一性\n 3. 可扩展PB级存储 扩容到PB的数据量，每秒百万级别的数据注入\n 4. 多环境部署 可从多种数据系统中注入数据\n 5. 丰富社区 学习交流\n\n实现步骤： （实现方式跟DBCP差不多）\n\n 1. 导入jdk依赖包 mysql-jdbc.jar druid-1.0.9.jar （版本号）\n 2. 实例 DruidDataSource对象\n 3. 功能属性实现 DruidDataSource对象 的 set方法\n 4. 获取连接 通过 DruidDataSource对象 的 getConnection()方法\n\n\n# 软编码\n\n软编码，在项目中添加配置文件，可避免今后代码多次修改 使用 properties类型 的文件，示例\n\n#连接设置\ndriverClassName=com.mysql.jdbc.Driver\nurl=jdbc:mysql://localhost:3306/day2\nusername=root\npassword=111\n#\x3c!-- 初始化连接 --\x3e\ninitialSize=10\n#最大连接数量\nmaxActive=50\n#\x3c!-- 最大空闲连接 --\x3e\nmaxIdle=20\n#\x3c!-- 最小空闲连接 --\x3e\nminIdle=5\n#\x3c!-- 超时等待时间以毫秒为单位 6000毫秒/1000等于60秒 --\x3e\nmaxWait=6000\n\n\n属性提取\n\n提取前提注意文件路径，以下代码是 src文件夹下的路径！\n\n//方法1\n//需要添加 IOException异常捕获\nInputStream inputStream = Dbutils.class.getClassLoader().getResourceAsStream("linkInfo.properties"); \nProperties properties = new Properties();\nproperties.load(inputStream);\nString driver = properties.getProperty("driver");\nString url = properties.getProperty("url");\nString userName = properties.getProperty("user");\nString passWord = properties.getProperty("password");\n\n//方法2\nResourceBundle bundle = ResourceBundle.getBundle("文件名");\nString driver = bundle.getString("driver");\nString url = bundle.getString("url");\nString userName = bundle.getString("user");\nString passWord = bundle.getString("password");\n\n\n\n# 代码索引\n\n\n# JDBC应用\n\n（返回*）\n\n数据库数据：（Test库 student表 的数据）\n\nSNO (VARCHAR)   SNAME (VARCHAR)   SSEX (VARCHAR)   SBIRTHDAY (DATA)   CLASS (VARCHAR)\n108             曾华                男                1977-09-01         95033\n105             匡明                男                1975-10-02         95031\n107             王丽                女                1976-01-23         95033\n101             李军                男                1976-02-20         95033\n109             王芳                女                1975-02-10         95031\n103             陆君                男                1974-06-03         95031\n\nimport java.sql.*;\nimport java.util.Properties;\n\n/**\n * @Author: 柏竹\n * @Description: 一个简洁主义...\n * @Date_Created_in: 2021-03-15 22:11\n * @Modified_By:\n * @Project: JDBC应用测试\n */\n\npublic class Demo {\n    \n    public static void main(String[] args) {\n        \n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        \n        try {\n            //1. 加载驱动\n            Class.forName("com.mysql.cj.jdbc.Driver");\n            /*//也可以，通过对象 进行加载驱动\n            Driver myDriver = new com.mysql.cj.jdbc.Driver();\n            DriverManager.registerDriver( myDriver );*/\n            \n            //2. 获取连接\n            String userName = "root";\n            String passWord = "";\n            //jdbc:mysql://hostname:3306/databaseName?serverTimezone=UTC\n            String url = "jdbc:mysql://localhost:3306/test?serverTimezone=UTC";\n            connection = DriverManager.getConnection(url , userName , passWord);\n            /*//也可以，数据库URL和一个Properties对象连接\n            //前提需要导包 import java.util.Properties;\n            String URL = "jdbc:mysql://localhost:3306/test?serverTimezone=UTC";\n            Properties info = new Properties();\n            info.put("user","root");\n            info.put("password","");\n            connection = DriverManager.getConnection(URL , info);*/\n            \n            //3. 定义sql，创建状态通道（进行sql语句的发送）\n            statement = connection.createStatement();\n            resultSet = statement.executeQuery("SELECT * FROM student;");\n            \n            //4. 取出结果集信息\n            while (resultSet.next()) {\n                //取出数据\n                System.out.print("学号:" + resultSet.getInt("SNO") + ",  ");\n                System.out.print("姓名:" + resultSet.getString("SNAME") + ",  ");\n                System.out.print("性别:" + resultSet.getString("SSEX") + ",  ");\n                System.out.println("班级:" + resultSet.getString("CLASS"));\n            }\n            \n        } catch (ClassNotFoundException | SQLException e) {\n            e.printStackTrace();\n        } finally {\n            //5. 关闭，释放资源\n            try {\n                if (connection != null) {\n                    connection.close();\n                }\n                if (statement != null) {\n                    statement.close();\n                }\n                if (resultSet != null) {\n                    resultSet.close();\n                }\n            } catch (SQLException throwables) {\n                throwables.printStackTrace();\n            }\n        }\n        \n    }\n    \n}\n\n/*\n学号:108,  姓名:曾华,  性别:男,  班级:95033\n学号:105,  姓名:匡明,  性别:男,  班级:95031\n学号:107,  姓名:王丽,  性别:女,  班级:95033\n学号:101,  姓名:李军,  性别:男,  班级:95033\n学号:109,  姓名:王芳,  性别:女,  班级:95031\n学号:103,  姓名:陆君,  性别:男,  班级:95031\n*/\n\n\n\n# JDBC应用 增、删、改\n\n（返回*）\n\nimport java.sql.*;\nimport java.util.Properties;\n\n/**\n * @Author: 柏竹\n * @Description: 一个简洁主义...\n * @Date_Created_in: 2021-03-15 22:11\n * @Modified_By:\n * @Project: JDBC应用 增、删、改\n */\n\npublic class Demo2 {\n    \n    public static void main(String[] args) {\n        \n        Connection connection = null;\n        Statement statement = null;\n        ResultSet resultSet = null;\n        int result = 0;\n        \n        try {\n            //本次使用另一方法应用JDBC\n            \n            //1. 加载驱动\n            Driver myDriver = new com.mysql.cj.jdbc.Driver();\n            DriverManager.registerDriver( myDriver );\n            \n            //2. 获取连接\n            //前提需要导包 import java.util.Properties;\n            String rul = "jdbc:mysql://localhost:3306/test?serverTimezone=UTC";\n            Properties info = new Properties();\n            info.put("user","root");\n            info.put("password","");\n            connection = DriverManager.getConnection(rul , info);\n            \n            //3. 定义sql，创建状态通道（进行sql语句的发送）\n            statement = connection.createStatement();\n            \n            //4. SQL语句操作\n            \n            //建表(前提：库中没有该表 tableTest)\n            String tableName = "tableTest";\n            String newTable = "CREATE TABLE "+tableName+"(no int,name varchar(10) NOT NULL);";\n            statement.executeUpdate(newTable);\n            \n            //是否空表 （是否记录有数据）\n            if (!statement.execute("SELECT * FROM "+tableName+";")){\n                System.out.println("NULL Table....Creating");\n            }else {\n                System.out.println("NOT NULL Table");\n            }\n           \n            //新增数据10条\n            String[] name = new String[]{"Sans","Jack","Tom","Cate","Jone","Bcck"};\n            for (int i = 1 ; i <= 5 ; i++) {\n                //INSERT INTO 表名 VALUES(值1 [,值2. . .]);\n                System.out.println("INSERT INTO "+tableName+" VALUE("+i+","+name[i]+");");\n                result = statement.executeUpdate("INSERT INTO "+tableName+" VALUE("+i+",\'"+name[i-1]+"\');");\n                isItDone(result);\n                \n            }\n            \n            //修改表（将 sans名 改为 Sanscan名）\n            //UPDATE 表名 SET 字段名1 = 字段值1 [,字段名2 = 值2…] [WHERE 条件表达式];\n            System.out.println("UPDATE "+tableName+" SET "+" name = \'Sanscan\' WHERE name = \'sans\';");\n            result = statement.executeUpdate("UPDATE "+tableName+" SET "+" name = \'Sanscan\' WHERE name = \'sans\';");\n            isItDone(result);\n            \n            //删除数据 (删除名为Cate的记录)\n            //DELETE FROM 表名 [WHERE 条件表达式];\n            System.out.println("DELETE FROM "+tableName+" WHERE name = \'Cate\';");\n            result = statement.executeUpdate("DELETE FROM "+tableName+" WHERE name = \'Cate\';");\n            isItDone(result);\n            \n            //查表\n            resultSet = statement.executeQuery("SELECT * FROM "+tableName+";");\n            while (resultSet.next()) {\n                //取出数据\n                System.out.print("NO." + resultSet.getInt("no") + ", ");\n                System.out.println("Name:" + resultSet.getString("name"));\n            }\n    \n        } catch (SQLException e) {\n            e.printStackTrace();\n        } finally {\n            \n            //5. 关闭，释放资源\n            try {\n                if (connection != null) {\n                    connection.close();\n                }\n                if (statement != null) {\n                    statement.close();\n                }\n                if (resultSet != null) {\n                    resultSet.close();\n                }\n            } catch (SQLException throwables) {\n                throwables.printStackTrace();\n            }\n        }\n        \n    }\n    \n    /**测试SQL语句执行情况*/\n    private static void isItDone(int result) {\n        if (result != 0){\n            System.out.println("执行成功");\n        }\n        result = 0;\n    }\n    \n}\n/*\nNOT NULL Table\nINSERT INTO tableTest VALUE(1,Jack);\n执行成功\nINSERT INTO tableTest VALUE(2,Tom);\n执行成功\nINSERT INTO tableTest VALUE(3,Cate);\n执行成功\nINSERT INTO tableTest VALUE(4,Jone);\n执行成功\nINSERT INTO tableTest VALUE(5,Bcck);\n执行成功\nUPDATE tableTest SET  name = \'Sanscan\' WHERE name = \'sans\';\n执行成功\nDELETE FROM tableTest WHERE name = \'Cate\';\n执行成功\nNO.1, Name:Sanscan\nNO.2, Name:Jack\nNO.3, Name:Tom\nNO.5, Name:Jone\n*/\n\n\n\n# PreparedStatement预状态通道\n\n（返回*）\n\nimport java.sql.*;\n\n/**\n * @Author: 柏竹\n * @Description: 一个简洁主义...\n * @Date_Created_in: 2021-03-15 22:11\n * @Modified_By:\n * @Project: JDBC 预状态通道测试 PreparedStatement接口\n */\n\npublic class Demo3 {\n    \n    public static void main(String[] args) {\n        \n        Connection connection = null;\n        ResultSet resultSet = null;\n        PreparedStatement pps = null;\n        \n        try {\n            //1. 加载驱动\n            Class.forName("com.mysql.cj.jdbc.Driver");\n            \n            //2. 获取连接\n            String userName = "root";\n            String passWord = "";\n            //jdbc:mysql://hostname:3306/databaseName?serverTimezone=UTC\n            String url = "jdbc:mysql://localhost:3306/test?serverTimezone=UTC";\n            connection = DriverManager.getConnection(url , userName , passWord);\n            \n            /*\n            * 3. 定义PreparedStatement预状态通道（进行sql语句的发送）\n            * */\n            String sql = "SELECT * FROM student WHERE CLASS=? AND SNAME=?;";\n            pps = connection.prepareStatement(sql);\n            String uName = "95031";\n            String uClass = "王芳";\n            //通过指定下标进行赋予值\n            pps.setString(1,uName);\n            pps.setString(2,uClass);\n            \n            resultSet = pps.executeQuery();\n            \n            //4. 取出结果集信息\n            while (resultSet.next()) {\n                //取出数据\n                System.out.print("学号:" + resultSet.getInt("SNO") + ",  ");\n                System.out.print("姓名:" + resultSet.getString("SNAME") + ",  ");\n                System.out.print("性别:" + resultSet.getString("SSEX") + ",  ");\n                System.out.println("班级:" + resultSet.getString("CLASS"));\n            }\n            \n        } catch (ClassNotFoundException | SQLException e) {\n            e.printStackTrace();\n        } finally {\n            \n            //5. 关闭，释放资源\n            try {\n                if (connection != null) {\n                    connection.close();\n                }\n                if (pps != null) {\n                    pps.close();\n                }\n                if (resultSet != null) {\n                    resultSet.close();\n                }\n            } catch (SQLException throwables) {\n                throwables.printStackTrace();\n            }\n        }\n        \n    }\n    \n}\n\n/*\n学号:109,  姓名:王芳,  性别:女,  班级:95031\n*/\n\n\n\n# JDBC事务应用\n\n（返回*）\n\n数据库 test库 cs表\n\nNO（INT 主键 自增）   NAME（VARCHAR 标签名）\n···             ···\n\nimport java.sql.*;\n\n/**\n * @Author: 柏竹\n * @Description: 一个简洁主义...\n * @Date_Created_in: 2021-03-18 19:44\n * @Modified_By:\n * @Project： 手动事务\n */\n\npublic class ManualAffairTest {\n    public static void main(String[] args) {\n        \n        Connection connection = null;\n        Statement statement = null;\n        \n        try {\n            \n            Class.forName("com.mysql.cj.jdbc.Driver");\n            String userName = "root";\n            String passWord = "";\n            String url = "jdbc:mysql://localhost:3306/test?serverTimezone=UTC";\n            connection = DriverManager.getConnection(url , userName , passWord);\n            \n            //关闭自动事务\n            connection.setAutoCommit(false);\n            //通道\n            statement = connection.createStatement();\n            \n            //SQL操作\n            //新增加条数\n            String sql = "INSERT INTO cs (name) VALUES(\'11\');";\n            System.out.println("影响数 : " + statement.executeUpdate(sql));\n    \n            System.out.println("事务是否自动模式？"+ connection.getAutoCommit());\n            \n            //手动提交\n            connection.commit();\n            \n        } catch (Exception throwables) {\n            //异常回滚\n            try {\n                connection.rollback();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        } finally {\n            try {\n                 if (statement != null){\n                    statement.cancel();\n                }\n                if (connection != null) {\n                    connection.close();\n                }\n            } catch (SQLException throwables) {\n                throwables.printStackTrace();\n            }\n        }\n        \n    }\n}\n\n\n/*\n影响数 : 1\n事务是否自动模式？false\n*/\n\n\n\n# Savepoints存档\n\n（返回*）\n\nimport java.sql.*;\n\n/**\n * @Author: 柏竹\n * @Description: 一个简洁主义...\n * @Date_Created_in: 2021-03-18 22:18\n * @Modified_By:\n * @Project：Savepoints存档测试\n */\npublic class SavepointsTest {\n    public static void main(String[] args) {\n        Connection connection = null;\n        Statement statement = null;\n        Savepoint archiveNo1 = null;\n    \n        try {\n        \n            Class.forName("com.mysql.cj.jdbc.Driver");\n            String userName = "root";\n            String passWord = "";\n            String url = "jdbc:mysql://localhost:3306/test?serverTimezone=UTC";\n            connection = DriverManager.getConnection(url , userName , passWord);\n        \n            //关闭自动事务\n            connection.setAutoCommit(false);\n            //通道\n            statement = connection.createStatement();\n        \n            //SQL操作\n            //新增加条数\n            System.out.println("影响数 : " + statement.executeUpdate("INSERT INTO cs (name) VALUES(\'22a\');"));\n            //以上是SQL完成操作\n            archiveNo1 = connection.setSavepoint("ArchiveNo1");\n            System.out.println("影响数 : " + statement.executeUpdate("INSERT INTO cs (name) VALUES(\'22b\');"));\n    \n            System.out.println(3/0);\n    \n            //手动提交\n            connection.commit();\n        \n        } catch (Exception throwables) {\n            //异常回滚\n            try {\n                connection.rollback(archiveNo1);\n                connection.commit();\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        } finally {\n            try {\n                if (connection != null) {\n                    connection.close();\n                }\n            } catch (SQLException throwables) {\n                throwables.printStackTrace();\n            }\n        }\n    }\n}\n\n\n\n# SQL批处理\n\n（返回*）\n\n数据库 test库 cs表\n\nNO（INT 主键 自增）   NAME（VARCHAR 标签名）\n···             ···\n\nStatement通道实现批量处理\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.SQLException;\nimport java.sql.Statement;\n\n/**\n * @Author: 柏竹\n * @Description: 一个简洁主义...\n * @Date_Created_in: 2021-03-19 20:49\n * @Modified_By:\n * @Project： Statement通道实现批量处理\n */\npublic class StatementTest {\n    public static void main(String[] args) {\n        Connection connection = null;\n        Statement statement = null;\n    \n        try {\n            Class.forName("com.mysql.cj.jdbc.Driver");\n            String userName = "root";\n            String passWord = "";\n            String url = "jdbc:mysql://localhost:3306/test?serverTimezone=UTC";\n            connection = DriverManager.getConnection(url , userName , passWord);\n        \n            //关闭自动事务\n            connection.setAutoCommit(false);\n            //通道\n            statement = connection.createStatement();\n        \n            //SQL操作\n            //新增加条数\n            String sql1 = "INSERT INTO cs (name) VALUES(\'柏竹a\');";\n            statement.addBatch(sql1);\n            String sql2 = "INSERT INTO cs (name) VALUES(\'柏竹b\');";\n            statement.addBatch(sql2);\n            String sql3 = "INSERT INTO cs (name) VALUES(\'柏竹c\');";\n            statement.addBatch(sql3);\n            String sql4 = "INSERT INTO cs (name) VALUES(\'柏竹d\');";\n            statement.addBatch(sql4);\n            String sql5 = "INSERT INTO cs (name) VALUES(\'柏竹e\');";\n            statement.addBatch(sql5);\n        \n            //批量执行SQL语句\n            int[] ints = statement.executeBatch();\n        \n            for (int tmp : ints) {\n                System.out.println("anInt : " + tmp);\n            }\n        \n            //手动提交\n            connection.commit();\n        \n        } catch (Exception throwables) {\n            //异常回滚\n            try {\n                if (connection != null) {\n                    connection.rollback();\n                }\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        } finally {\n            try {\n                if (connection != null) {\n                    connection.close();\n                }\n                if (statement != null){\n                    statement.cancel();\n                }\n            } catch (SQLException throwables) {\n                throwables.printStackTrace();\n            }\n        }\n    }\n}\n\n\nPreparedStatement通道实现批量处理\n\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\n\n/**\n * @Author: 柏竹\n * @Description: 一个简洁主义...\n * @Date_Created_in: 2021-03-19 21:23\n * @Modified_By:\n * @Project： PreparedStatement通道实现批量处理\n */\npublic class PreparedStatementTest {\n    public static void main(String[] args) {\n        Connection connection = null;\n        PreparedStatement pps = null;\n        \n        try {\n            Class.forName("com.mysql.cj.jdbc.Driver");\n            String userName = "root";\n            String passWord = "";\n            String url = "jdbc:mysql://localhost:3306/test?serverTimezone=UTC";\n            connection = DriverManager.getConnection(url , userName , passWord);\n            \n            //关闭自动事务\n            connection.setAutoCommit(false);\n            //通道\n            String sql = "INSERT INTO cs (name) VALUES(?);";\n            pps = connection.prepareStatement(sql);\n            \n            //SQL操作\n            //新增加条数\n            pps.setString(1,"柏竹a");\n            pps.addBatch();\n            pps.setString(1,"柏竹b");\n            pps.addBatch();\n            pps.setString(1,"柏竹c");\n            pps.addBatch();\n            pps.setString(1,"柏竹d");\n            pps.addBatch();\n            pps.setString(1,"柏竹e");\n            pps.addBatch();\n            \n            //批量执行SQL语句\n            int[] ints = pps.executeBatch();\n            \n            for (int tmp : ints) {\n                System.out.println("anInt : " + tmp);\n            }\n            \n            //手动提交\n            connection.commit();\n            \n        } catch (Exception throwables) {\n            //异常回滚\n            try {\n                if (connection != null) {\n                    connection.rollback();\n                }\n            } catch (SQLException e) {\n                e.printStackTrace();\n            }\n        } finally {\n            try {\n                if (connection != null) {\n                    connection.close();\n                }\n                if (pps != null){\n                    pps.cancel();\n                }\n            } catch (SQLException throwables) {\n                throwables.printStackTrace();\n            }\n        }\n    }\n}\n\n\n\n# JDBC整合应用\n\n项目链接下载',normalizedContent:'# jdbc\n\njdbc是一种sql语句的java api ，java语言编写的 类和接口\n\n * 连接数据库\n * 创建 sql语句\n * 在数据库中sql查询\n * 查看和生成记录\n\n\n# 体系构架\n\n\n# 体系结构\n\n**jdbc api：** 提供应用程序jdbc管理器连接 **jdbc driver manager：** 管理器驱动程序连接\n\n\n# 组件\n\ndrivermanager： 此类 管理数据库驱动程序列表 driver： 此接口 处理与数据库服务器的通信，连接具体驱动 connection： 该界面具有用于联系数据库的所有方法 statement： 此接口 创建的对象将sql语句提交到数据库 resultset： 在使用statement对象执行sql查询后，这些对象保存从数据库检索的数据。它作为一 个迭代器，允许我们移动其数据。 sqlexception： 此类数据库发生的错误\n\n\n# 首次应用\n\n构建jdbc应用：\n\n 1. 导入包 import java.sql.*\n 2. **注册jdbc驱动程序 ** 通过java程序 初始化驱动程序 class.forname("com.mysql.cj.jdbc.driver"); , 驱动类文件加载至内存中，并自动注册\n 3. 连接对象 通过 drivermanager.getconnection(string url, string username, string password )方法 获取 connection对象 (数据库的物理连接)\n 4. 执行查询 通过 statement对象 构建 和 提交sql语句到数据库\n 5. 结果集提取数据 通过 resultset.getxxx(string 字段名 )方法 获取结果集检索数据（xxx代表对应的数据类型）\n 6. 释放资源 关闭所有数据库资源，避免依赖jvm垃圾收集器\n\n**注册jdbc驱动程序 方法 **\n\n> class.forname(string str) 根据路径进行加载驱动 drivermanager.registerdriver(driver mydriver) 静态方法 对象加载\n\n点击代码示例* （jdbc应用）\n\n\n# api\n\n实现数据库连接交互信息\n\n\n# connection\n\n连接数据库 drivermanager.getconnection()方法 建立连接，重载方法有\n\ndrivermanager.getconnection(string url) drivermanager.getconnection(string url，properties prop) drivermanager.getconnection(string url，string user，string password) drivermanager.getconnection(string url, properties info)\n\n数据库url配置\n\nrdbms    jdbc驱动程序名称                        网址格式\nmysql8   com.mysql.cj.jdbc.driver          jdbc:mysql://hostname:3306/databasename?servertimezone=utc\nmysql    com.mysql.jdbc.driver             jdbc:mysql://hostname:3306/databasename\noracle   oracle.jdbc.driver.oracledriver   jdbc:oracle:thin:@hostname:port number：databasename\ndb2      com.ibm.db2.jdbc.net.db2driver    jdbc:db2:hostname:port / databasename\nsybase   com.sybase.jdbc.sybdriver         jdbc:sybase:tds:hostname:port number / databasename\n\nhostname： ip地址 post： 端口 databasename： 库名\n\n> 注意：mysql8以后的url必须添加时区 ==servertimezone=utc==\n\n\n# resultset\n\n数据库中的查询结果集 resultset对象 维护指向结果集中当前行的光标。 如果没有在 createstatement()方法 中指定参数 ，则自动获取type_forward_only\n\n参数                                  说明\nresultset.type_scroll_insensitive   光标可前后滚动，对数据更改不敏感\nresultset.type_scroll_sensitive     光标可前后滚动，对底层数据更改敏感\nresultset.type_forward_only         光标只能在结果集中向前移动\n\n\n# resultsetmetadata\n\n一般用于获取 resultset对象 中字段的类型和属性的信息的对象\n\nresultsetmetadata方法\n\n返回       方法                              说明\nstring   getcolumnname(int column)       获取 指定字段名称（从1开始）\nstring   getcolumnlabel(int column)      获取 指定字段的别名（从1开始）\nint      getcolumncount()                获取 当前resultset对象中的字段数\nstring   getcolumntypename(int column)   检索 指定字段的库，特定的类型名称\n···      ···                             ···\n\n\n# statement\n\n在使用 statement对象 执行sql语句之前，连接后得到 connection对象 的 createstatement()方法 创建statement对象\n\n//以下代码需要 异常 捕获或抛出\n//获取数据库的实体连接\nconnection connection = ······ ;\nstatement stmt = connection.createstatement();\n\n\nstatement方法\n\n返回          方法                          说明\nboolean     execute(string sql)         是否存在 resultset对象\nint         executeupdate(string sql)   在数据库中执行sql语句，并且获取 sql语句影响的行数\nresultset   executequery(string sql)    获取 查询的结果集，迭代遍历可获取数据\nvoid        close()                     关闭对象\n\n点击代码示例* （jdbc应用 增、删、改）\n\n恶意sql注入\n\n通过sql命令插入web表单提交或输入域名或页面请求的查询字符串，最终以伪信息进行sql执行命令，示例：\n\nstring username = "aa";\n//跳过判断 ； 通过 或 进行 1=1\nstring password = " \'\' or 1=1 ";\nstring sql = "select * from users where username = \'"+username+"\' and password = "+password;\n\n\n\n# preparestatement\n\npreparestatement接口 预状态通道，也是 statement接口 的子接口，它能简化代码、预防注入恶意sql注入、提高效率的优点 sql语句可动态的提供参数相应的数据\n\n//抛出|捕获 异常\nstring sql = "select * from users where username = ? and password = ?";\npreparedstatement pps = connection.preparestatement(sql);\npps.setstring(1 , "张三");\npps.setint(2 , "123123");\n\n//执行sql\nint resultset = pps.executequery();\n···\n    \npps.close();\n\n\n在当中所有参数都由 ？ 标记，执行sql前，必须提供为每个参数提供值！！\n\npreparedstatement方法\n\n返回          方法                           说明\nboolean     execute()                    是否存在 resultset对象\nint         executeupdate()              在数据库中执行sql语句，并且获取 sql语句影响的行数\nresultset   executequery()               获取 查询的结果集，迭代遍历可获取数据\nxxx         setxxx(int mark,xxx value)   xxx代表绑定对应的数据类型\n                                         mark： 下标锁定（下标是从1开始）\n                                         value： 指定下标赋予值\n            ···                          \nvoid        close()                      关闭对象\n\n点击代码示例* （preparedstatement预状态通道）\n\nstatement和preparedstatement区别\n\n 1. statement属于状态通道，preparedstatement属于预状态通道\n 2. 预状态通道会先编译sql语句,再去执行，比statement执行效率高\n 3. 预状态通道支持占位符? ，给占位符赋值的时候，位置从1开始\n 4. 预状态通道可以防止sql注入，因 预状态通道在处理值的时候以字符串形式处理\n 5. preparedstatement通道传递的参数只能是变量，并非变量\n\n\n# 多表关系\n\n数据库的分类有：一对一、一对多、多对多\n\n实体类通过属性的方式建立两表关系 类名=表名 、 列名=属性名\n\n实现方式原理：通过查询提取出的数据，对相应类属性进行赋值\n\n有学生类(student)，有id、姓名属性，生成它们的get、set方法 数据库数据 （xx库 student表）\n\nsid   sname\n1     柏竹\n2     黑猫\n\n以下代码实例\n\n····\n//执行sql\nstring sql = "select * from student";\npreparedstatement pps = connection.preparestatement(sql);\nresultset = pps.executequery();\n\nstudent student = new student();\nwhile (resultset.next()){\n\tstudent.setsid(resultset.getint("sid"));\n\tstudent.setsname(resultset.getstring("sname"));\n}\n\n\n点击多表项目测试代码 （可以自行下载查看详细操作 · 免费）\n\n\n# 事务应用\n\n点击事务了解\n\njdbc连接默认是 自动提交模式 ，jdbc也支持手动事务，每条sql语句完成后自动提交到数据库 事务能使控制库数据何时进行数据更改，如果一组sql语句视为一个逻辑单元去执行，要么全部成功，要么全部失败！\n\n通过 connection对象 进行事务提交回滚操作！\n\n返回        方法                                  说明\nvoid      setautocommit(boolean autocommit)   是否关闭自动提交事务（自动打开事务）\nboolean   getautocommit()                     是否为自动提交事务模式\nvoid      commit()                            提交事务\nvoid      rollback()                          回滚事务\nvoid      close()                             释放资源\n\n//connection 已连接\nconnection.setautocommit(false);\n\n//sql操作\n·····\n    \n//手动提交\nconnection.commit();\n\n\n点击代码示例* （jdbc事务应用）\n\n\n# savepoints(事务存档)\n\n事务执行过程，可设置保存点，设置保存点库数据会更变。保存存档后的点（库更改后数据是永久性的），当中出现异常，回滚事务时会返回至存档点，并非开头启动事务点！\n\n通过 connection对象 进行存档点的操作！\n\n返回          方法                                      说明\nsavepoint   setsavepoint(string name)               定义存档点，需设存档点名\nvoid        releasesavepoint(savepoint savepoint)   删除指定存档点\nvoid        rollback(savepoint savepoint)           指定回滚目的\n\nsavepoint archiveno1 = null;\ntry {\n    ···\n    //connection 已连接\n    connection.setautocommit(false);\n    statement statement = connection.createstatement();\n    \n    //sql操作\n    ·····\n    //以上是sql完成操作\n    archiveno1 = connection.setsavepoint("archiveno1");\n    ·····\n        \n    //手动提交\n    connection.commit();\n} catch (exception throwables) {\n    //异常回滚\n            try {\n                connection.rollback(archiveno1);\n                connection.commit();\n            } catch (sqlexception e) {\n                e.printstacktrace();\n            }\n}\n\n\n点击代码示例* （savepoints存档）\n\n\n# 批量处理\n\njdbc允许 批量处理sql语句 ，通过事务一次调用提交库 一次发送多条sql语句，可减少数据库的交互次数，提高质量\n\n通过 preparedstatement对象 、 statement对象 实现批处理方法\n\n返回      方法                     说明\nvoid    addbatch()             preparedstatement对象添加sql语句\nvoid    addbatch(string sql)   statement对象 添加sql语句\nint[]   executebatch()         获取批量执行的影响数(顺序=添加sql顺序)，并执行 批量sql语句\n\n实现步骤\n\n 1. 连接数据库 connection对象\n 2. 设置手动事务 connection对象 的 setautocommit(false)方法\n 3. 获取通道对象 preparedstatement对象 或 statement对象\n 4. 不同通道对象，添加方式不同！ statement对象 通过 addbatch(sql)方法 实现添加sql语句 preparedstatement对象 通过 addbatch()方法 实现添加 sql语句\n 5. 通过 通道对象 的 executebatch()方法 批量执行sql语句\n 6. 提交事务 connection对象 的 commit()方法 进行提交\n\n注意： 批量处理过程中出现异常，可通过异常捕获进行回滚操作\n\n点击代码示例* （sql批处理）\n\n\n# 反射处理集\n\n利用反射处理查询到的结果集，对应的数据赋予对象！ 注意：以下代码要求库中的字段名与类中的属性名相同，且类所有属性都有get、set方法！（类至少有一个相同）\n\n//库连接\n···\nlist studentall = new arraylist();\n//student表 = studnet类 ，且 表studnet的字段 = 类studnet的属性！！\nstring sql = "select * from student";\npps = connection.preparestatement(sql);\nrs = pps.executequery();\n\n//提取 结果集 字段的类型和属性的信息\nresultsetmetadata metadata = rs.getmetadata();\n//赋予字段数\nint count = metadata.getcolumncount();\nstring[] columnnames = new string[count];\n//字段数组\nfor (int i = 0 ; i < count ; i++) {\n    columnnames[i] = metadata.getcolumnname(i+1);\n}\n\n//通过反射 student类中的所有方法\nmethod[] declaredmethods = student.getdeclaredmethods();\nwhile (rs.next()){\n    //无参的构造方法\n    object s = cla.newinstance();\n    //遍历数组字段\n    for (string columnname : columnnames) {\n        //用于比较 set方法名  \n        string newcolumnname = "set"+columnname;\n        //遍历类方法\n        for (method declaredmethod : declaredmethods) {\n            //比较方法名（无视大小写）\n            if (declaredmethod.getname().equalsignorecase(newcolumnname)){\n                //通过反射实现方法\n                declaredmethod.invoke(s , rs.getobject(columnname));\n                break;\n            }\n        }\n        //每条数据都添加\n        list.add(s);\n    }\n}\n\n\n\n# 连接池\n\n点击连接池说明\n\n\n# dbcp连接池\n\n实现步骤：\n\n 1. 导入jdk依赖包 mysql-jdbc.jar commons-dbcp.jar commons-pool.jar\n 2. 实例 basicdatasource对象\n 3. 功能属性实现 basicdatasource对象 的 set方法\n 4. 获取连接 通过 basicdatasource对象 的 getconnection()方法\n\n配置实例\n\npublic void testhard() throws sqlexception{\n\t// 硬编码 使用dbcp连接池\n\tbasicdatasource source = new basicdatasource();\n\t//设置连接的信息\n\tsource.setdriverclassname("com.mysql.jdbc.driver");\n        //设置 url 、 用户 、 密码 ···\n\tsource.seturl("jdbc:mysql://localhost:3306/day2");\n\tsource.setusername("root");\n\tsource.setpassword("111");\n        //获取连接\n\tconnection connection = source.getconnection();\n}\n\n\n\n# c3p0连接池\n\nc3p0与dbcp区别\n\n 1. c3p0有自动回收空闲连接功能，dbcp没有\n 2. c3p0无需手动，dbcp需手动配置文件\n 3. c3p0配置文件命名固定（c3p0-config.xml）\n\n实现步骤：\n\n 1. 导入jdk依赖包\n    \n    mysql-jdbc.jar\n    \n    c3p0-0.9.1.2.jar (版本号)\n\n 2. 创建 c3p0-config.xml 配置文件，路径：src文件夹下\n\n 3. 手动 配置文件 调用无参的默认配置 <default-config> 调用有参的配置<named-config name="myc3p0test"> 自定命名\n\n 4. 实例 combopooleddatasource对象 无参调用默认的，有参调用自定义的\n\n 5. 获取连接 通过 combopooleddatasource对象 的 getconnection()方法\n\n手动配置 c3p0-config.xml 配置文件。实例：\n\n<?xml version="1.0" encoding="utf-8"?>\n<c3p0-config>\n    \x3c!-- 默认配置，如果没有指定则使用这个配置 --\x3e\n    <default-config>\n        \x3c!-- 基本配置 --\x3e\n        <property name="driverclass">com.mysql.cj.jdbc.driver</property>\n        <property name="jdbcurl">jdbc:mysql://localhost:3306/test?servertimezone=asia/shanghai</property>\n        <property name="user">root</property>\n        <property name="password"></property>\n        \x3c!--扩展配置--\x3e\n        \x3c!-- 连接超过1min报错--\x3e\n        <property name="checkouttimeout">60000</property>\n        \x3c!--30秒检查空闲连接 --\x3e\n        <property name="idleconnectiontestperiod">30</property>\n        <property name="initialpoolsize">10</property>\n        \x3c!-- 30秒不适用丢弃--\x3e\n        <property name="maxidletime">30</property>\n        <property name="maxpoolsize">100</property>\n        <property name="minpoolsize">10</property>\n        <property name="maxstatements">200</property>\n    </default-config>\n    \x3c!-- 命名的配置 --\x3e\n    <named-config name="myc3p0test">\n        <property name="driverclass">com.mysql.cj.jdbc.driver</property>\n        <property name="jdbcurl">jdbc:mysql://localhost:3306/test?servertimezone=asia/shanghai</property>\n        <property name="user">root</property>\n        <property name="password"></property>\n        \x3c!-- 如果池中数据连接不够时一次增长多少个 --\x3e\n        <property name="acquireincrement">5</property>\n        <property name="initialpoolsize">20</property>\n        <property name="minpoolsize">10</property>\n        <property name="maxpoolsize">40</property>\n        <property name="maxstatements">20</property>\n        <property name="maxstatementsperconnection">5</property>\n     </named-config>\n</c3p0-config>\n\n\n\n# druid连接池\n\ndruid是目前大厂流行的连接池，有以下特点：\n\n 1. 秒查询 快速的聚合能力以及亚秒级的olap查询能力\n 2. 实时数据注入 保证在实时和离线环境下 事件的 实效性 和 统一性\n 3. 可扩展pb级存储 扩容到pb的数据量，每秒百万级别的数据注入\n 4. 多环境部署 可从多种数据系统中注入数据\n 5. 丰富社区 学习交流\n\n实现步骤： （实现方式跟dbcp差不多）\n\n 1. 导入jdk依赖包 mysql-jdbc.jar druid-1.0.9.jar （版本号）\n 2. 实例 druiddatasource对象\n 3. 功能属性实现 druiddatasource对象 的 set方法\n 4. 获取连接 通过 druiddatasource对象 的 getconnection()方法\n\n\n# 软编码\n\n软编码，在项目中添加配置文件，可避免今后代码多次修改 使用 properties类型 的文件，示例\n\n#连接设置\ndriverclassname=com.mysql.jdbc.driver\nurl=jdbc:mysql://localhost:3306/day2\nusername=root\npassword=111\n#\x3c!-- 初始化连接 --\x3e\ninitialsize=10\n#最大连接数量\nmaxactive=50\n#\x3c!-- 最大空闲连接 --\x3e\nmaxidle=20\n#\x3c!-- 最小空闲连接 --\x3e\nminidle=5\n#\x3c!-- 超时等待时间以毫秒为单位 6000毫秒/1000等于60秒 --\x3e\nmaxwait=6000\n\n\n属性提取\n\n提取前提注意文件路径，以下代码是 src文件夹下的路径！\n\n//方法1\n//需要添加 ioexception异常捕获\ninputstream inputstream = dbutils.class.getclassloader().getresourceasstream("linkinfo.properties"); \nproperties properties = new properties();\nproperties.load(inputstream);\nstring driver = properties.getproperty("driver");\nstring url = properties.getproperty("url");\nstring username = properties.getproperty("user");\nstring password = properties.getproperty("password");\n\n//方法2\nresourcebundle bundle = resourcebundle.getbundle("文件名");\nstring driver = bundle.getstring("driver");\nstring url = bundle.getstring("url");\nstring username = bundle.getstring("user");\nstring password = bundle.getstring("password");\n\n\n\n# 代码索引\n\n\n# jdbc应用\n\n（返回*）\n\n数据库数据：（test库 student表 的数据）\n\nsno (varchar)   sname (varchar)   ssex (varchar)   sbirthday (data)   class (varchar)\n108             曾华                男                1977-09-01         95033\n105             匡明                男                1975-10-02         95031\n107             王丽                女                1976-01-23         95033\n101             李军                男                1976-02-20         95033\n109             王芳                女                1975-02-10         95031\n103             陆君                男                1974-06-03         95031\n\nimport java.sql.*;\nimport java.util.properties;\n\n/**\n * @author: 柏竹\n * @description: 一个简洁主义...\n * @date_created_in: 2021-03-15 22:11\n * @modified_by:\n * @project: jdbc应用测试\n */\n\npublic class demo {\n    \n    public static void main(string[] args) {\n        \n        connection connection = null;\n        statement statement = null;\n        resultset resultset = null;\n        \n        try {\n            //1. 加载驱动\n            class.forname("com.mysql.cj.jdbc.driver");\n            /*//也可以，通过对象 进行加载驱动\n            driver mydriver = new com.mysql.cj.jdbc.driver();\n            drivermanager.registerdriver( mydriver );*/\n            \n            //2. 获取连接\n            string username = "root";\n            string password = "";\n            //jdbc:mysql://hostname:3306/databasename?servertimezone=utc\n            string url = "jdbc:mysql://localhost:3306/test?servertimezone=utc";\n            connection = drivermanager.getconnection(url , username , password);\n            /*//也可以，数据库url和一个properties对象连接\n            //前提需要导包 import java.util.properties;\n            string url = "jdbc:mysql://localhost:3306/test?servertimezone=utc";\n            properties info = new properties();\n            info.put("user","root");\n            info.put("password","");\n            connection = drivermanager.getconnection(url , info);*/\n            \n            //3. 定义sql，创建状态通道（进行sql语句的发送）\n            statement = connection.createstatement();\n            resultset = statement.executequery("select * from student;");\n            \n            //4. 取出结果集信息\n            while (resultset.next()) {\n                //取出数据\n                system.out.print("学号:" + resultset.getint("sno") + ",  ");\n                system.out.print("姓名:" + resultset.getstring("sname") + ",  ");\n                system.out.print("性别:" + resultset.getstring("ssex") + ",  ");\n                system.out.println("班级:" + resultset.getstring("class"));\n            }\n            \n        } catch (classnotfoundexception | sqlexception e) {\n            e.printstacktrace();\n        } finally {\n            //5. 关闭，释放资源\n            try {\n                if (connection != null) {\n                    connection.close();\n                }\n                if (statement != null) {\n                    statement.close();\n                }\n                if (resultset != null) {\n                    resultset.close();\n                }\n            } catch (sqlexception throwables) {\n                throwables.printstacktrace();\n            }\n        }\n        \n    }\n    \n}\n\n/*\n学号:108,  姓名:曾华,  性别:男,  班级:95033\n学号:105,  姓名:匡明,  性别:男,  班级:95031\n学号:107,  姓名:王丽,  性别:女,  班级:95033\n学号:101,  姓名:李军,  性别:男,  班级:95033\n学号:109,  姓名:王芳,  性别:女,  班级:95031\n学号:103,  姓名:陆君,  性别:男,  班级:95031\n*/\n\n\n\n# jdbc应用 增、删、改\n\n（返回*）\n\nimport java.sql.*;\nimport java.util.properties;\n\n/**\n * @author: 柏竹\n * @description: 一个简洁主义...\n * @date_created_in: 2021-03-15 22:11\n * @modified_by:\n * @project: jdbc应用 增、删、改\n */\n\npublic class demo2 {\n    \n    public static void main(string[] args) {\n        \n        connection connection = null;\n        statement statement = null;\n        resultset resultset = null;\n        int result = 0;\n        \n        try {\n            //本次使用另一方法应用jdbc\n            \n            //1. 加载驱动\n            driver mydriver = new com.mysql.cj.jdbc.driver();\n            drivermanager.registerdriver( mydriver );\n            \n            //2. 获取连接\n            //前提需要导包 import java.util.properties;\n            string rul = "jdbc:mysql://localhost:3306/test?servertimezone=utc";\n            properties info = new properties();\n            info.put("user","root");\n            info.put("password","");\n            connection = drivermanager.getconnection(rul , info);\n            \n            //3. 定义sql，创建状态通道（进行sql语句的发送）\n            statement = connection.createstatement();\n            \n            //4. sql语句操作\n            \n            //建表(前提：库中没有该表 tabletest)\n            string tablename = "tabletest";\n            string newtable = "create table "+tablename+"(no int,name varchar(10) not null);";\n            statement.executeupdate(newtable);\n            \n            //是否空表 （是否记录有数据）\n            if (!statement.execute("select * from "+tablename+";")){\n                system.out.println("null table....creating");\n            }else {\n                system.out.println("not null table");\n            }\n           \n            //新增数据10条\n            string[] name = new string[]{"sans","jack","tom","cate","jone","bcck"};\n            for (int i = 1 ; i <= 5 ; i++) {\n                //insert into 表名 values(值1 [,值2. . .]);\n                system.out.println("insert into "+tablename+" value("+i+","+name[i]+");");\n                result = statement.executeupdate("insert into "+tablename+" value("+i+",\'"+name[i-1]+"\');");\n                isitdone(result);\n                \n            }\n            \n            //修改表（将 sans名 改为 sanscan名）\n            //update 表名 set 字段名1 = 字段值1 [,字段名2 = 值2…] [where 条件表达式];\n            system.out.println("update "+tablename+" set "+" name = \'sanscan\' where name = \'sans\';");\n            result = statement.executeupdate("update "+tablename+" set "+" name = \'sanscan\' where name = \'sans\';");\n            isitdone(result);\n            \n            //删除数据 (删除名为cate的记录)\n            //delete from 表名 [where 条件表达式];\n            system.out.println("delete from "+tablename+" where name = \'cate\';");\n            result = statement.executeupdate("delete from "+tablename+" where name = \'cate\';");\n            isitdone(result);\n            \n            //查表\n            resultset = statement.executequery("select * from "+tablename+";");\n            while (resultset.next()) {\n                //取出数据\n                system.out.print("no." + resultset.getint("no") + ", ");\n                system.out.println("name:" + resultset.getstring("name"));\n            }\n    \n        } catch (sqlexception e) {\n            e.printstacktrace();\n        } finally {\n            \n            //5. 关闭，释放资源\n            try {\n                if (connection != null) {\n                    connection.close();\n                }\n                if (statement != null) {\n                    statement.close();\n                }\n                if (resultset != null) {\n                    resultset.close();\n                }\n            } catch (sqlexception throwables) {\n                throwables.printstacktrace();\n            }\n        }\n        \n    }\n    \n    /**测试sql语句执行情况*/\n    private static void isitdone(int result) {\n        if (result != 0){\n            system.out.println("执行成功");\n        }\n        result = 0;\n    }\n    \n}\n/*\nnot null table\ninsert into tabletest value(1,jack);\n执行成功\ninsert into tabletest value(2,tom);\n执行成功\ninsert into tabletest value(3,cate);\n执行成功\ninsert into tabletest value(4,jone);\n执行成功\ninsert into tabletest value(5,bcck);\n执行成功\nupdate tabletest set  name = \'sanscan\' where name = \'sans\';\n执行成功\ndelete from tabletest where name = \'cate\';\n执行成功\nno.1, name:sanscan\nno.2, name:jack\nno.3, name:tom\nno.5, name:jone\n*/\n\n\n\n# preparedstatement预状态通道\n\n（返回*）\n\nimport java.sql.*;\n\n/**\n * @author: 柏竹\n * @description: 一个简洁主义...\n * @date_created_in: 2021-03-15 22:11\n * @modified_by:\n * @project: jdbc 预状态通道测试 preparedstatement接口\n */\n\npublic class demo3 {\n    \n    public static void main(string[] args) {\n        \n        connection connection = null;\n        resultset resultset = null;\n        preparedstatement pps = null;\n        \n        try {\n            //1. 加载驱动\n            class.forname("com.mysql.cj.jdbc.driver");\n            \n            //2. 获取连接\n            string username = "root";\n            string password = "";\n            //jdbc:mysql://hostname:3306/databasename?servertimezone=utc\n            string url = "jdbc:mysql://localhost:3306/test?servertimezone=utc";\n            connection = drivermanager.getconnection(url , username , password);\n            \n            /*\n            * 3. 定义preparedstatement预状态通道（进行sql语句的发送）\n            * */\n            string sql = "select * from student where class=? and sname=?;";\n            pps = connection.preparestatement(sql);\n            string uname = "95031";\n            string uclass = "王芳";\n            //通过指定下标进行赋予值\n            pps.setstring(1,uname);\n            pps.setstring(2,uclass);\n            \n            resultset = pps.executequery();\n            \n            //4. 取出结果集信息\n            while (resultset.next()) {\n                //取出数据\n                system.out.print("学号:" + resultset.getint("sno") + ",  ");\n                system.out.print("姓名:" + resultset.getstring("sname") + ",  ");\n                system.out.print("性别:" + resultset.getstring("ssex") + ",  ");\n                system.out.println("班级:" + resultset.getstring("class"));\n            }\n            \n        } catch (classnotfoundexception | sqlexception e) {\n            e.printstacktrace();\n        } finally {\n            \n            //5. 关闭，释放资源\n            try {\n                if (connection != null) {\n                    connection.close();\n                }\n                if (pps != null) {\n                    pps.close();\n                }\n                if (resultset != null) {\n                    resultset.close();\n                }\n            } catch (sqlexception throwables) {\n                throwables.printstacktrace();\n            }\n        }\n        \n    }\n    \n}\n\n/*\n学号:109,  姓名:王芳,  性别:女,  班级:95031\n*/\n\n\n\n# jdbc事务应用\n\n（返回*）\n\n数据库 test库 cs表\n\nno（int 主键 自增）   name（varchar 标签名）\n···             ···\n\nimport java.sql.*;\n\n/**\n * @author: 柏竹\n * @description: 一个简洁主义...\n * @date_created_in: 2021-03-18 19:44\n * @modified_by:\n * @project： 手动事务\n */\n\npublic class manualaffairtest {\n    public static void main(string[] args) {\n        \n        connection connection = null;\n        statement statement = null;\n        \n        try {\n            \n            class.forname("com.mysql.cj.jdbc.driver");\n            string username = "root";\n            string password = "";\n            string url = "jdbc:mysql://localhost:3306/test?servertimezone=utc";\n            connection = drivermanager.getconnection(url , username , password);\n            \n            //关闭自动事务\n            connection.setautocommit(false);\n            //通道\n            statement = connection.createstatement();\n            \n            //sql操作\n            //新增加条数\n            string sql = "insert into cs (name) values(\'11\');";\n            system.out.println("影响数 : " + statement.executeupdate(sql));\n    \n            system.out.println("事务是否自动模式？"+ connection.getautocommit());\n            \n            //手动提交\n            connection.commit();\n            \n        } catch (exception throwables) {\n            //异常回滚\n            try {\n                connection.rollback();\n            } catch (sqlexception e) {\n                e.printstacktrace();\n            }\n        } finally {\n            try {\n                 if (statement != null){\n                    statement.cancel();\n                }\n                if (connection != null) {\n                    connection.close();\n                }\n            } catch (sqlexception throwables) {\n                throwables.printstacktrace();\n            }\n        }\n        \n    }\n}\n\n\n/*\n影响数 : 1\n事务是否自动模式？false\n*/\n\n\n\n# savepoints存档\n\n（返回*）\n\nimport java.sql.*;\n\n/**\n * @author: 柏竹\n * @description: 一个简洁主义...\n * @date_created_in: 2021-03-18 22:18\n * @modified_by:\n * @project：savepoints存档测试\n */\npublic class savepointstest {\n    public static void main(string[] args) {\n        connection connection = null;\n        statement statement = null;\n        savepoint archiveno1 = null;\n    \n        try {\n        \n            class.forname("com.mysql.cj.jdbc.driver");\n            string username = "root";\n            string password = "";\n            string url = "jdbc:mysql://localhost:3306/test?servertimezone=utc";\n            connection = drivermanager.getconnection(url , username , password);\n        \n            //关闭自动事务\n            connection.setautocommit(false);\n            //通道\n            statement = connection.createstatement();\n        \n            //sql操作\n            //新增加条数\n            system.out.println("影响数 : " + statement.executeupdate("insert into cs (name) values(\'22a\');"));\n            //以上是sql完成操作\n            archiveno1 = connection.setsavepoint("archiveno1");\n            system.out.println("影响数 : " + statement.executeupdate("insert into cs (name) values(\'22b\');"));\n    \n            system.out.println(3/0);\n    \n            //手动提交\n            connection.commit();\n        \n        } catch (exception throwables) {\n            //异常回滚\n            try {\n                connection.rollback(archiveno1);\n                connection.commit();\n            } catch (sqlexception e) {\n                e.printstacktrace();\n            }\n        } finally {\n            try {\n                if (connection != null) {\n                    connection.close();\n                }\n            } catch (sqlexception throwables) {\n                throwables.printstacktrace();\n            }\n        }\n    }\n}\n\n\n\n# sql批处理\n\n（返回*）\n\n数据库 test库 cs表\n\nno（int 主键 自增）   name（varchar 标签名）\n···             ···\n\nstatement通道实现批量处理\n\nimport java.sql.connection;\nimport java.sql.drivermanager;\nimport java.sql.sqlexception;\nimport java.sql.statement;\n\n/**\n * @author: 柏竹\n * @description: 一个简洁主义...\n * @date_created_in: 2021-03-19 20:49\n * @modified_by:\n * @project： statement通道实现批量处理\n */\npublic class statementtest {\n    public static void main(string[] args) {\n        connection connection = null;\n        statement statement = null;\n    \n        try {\n            class.forname("com.mysql.cj.jdbc.driver");\n            string username = "root";\n            string password = "";\n            string url = "jdbc:mysql://localhost:3306/test?servertimezone=utc";\n            connection = drivermanager.getconnection(url , username , password);\n        \n            //关闭自动事务\n            connection.setautocommit(false);\n            //通道\n            statement = connection.createstatement();\n        \n            //sql操作\n            //新增加条数\n            string sql1 = "insert into cs (name) values(\'柏竹a\');";\n            statement.addbatch(sql1);\n            string sql2 = "insert into cs (name) values(\'柏竹b\');";\n            statement.addbatch(sql2);\n            string sql3 = "insert into cs (name) values(\'柏竹c\');";\n            statement.addbatch(sql3);\n            string sql4 = "insert into cs (name) values(\'柏竹d\');";\n            statement.addbatch(sql4);\n            string sql5 = "insert into cs (name) values(\'柏竹e\');";\n            statement.addbatch(sql5);\n        \n            //批量执行sql语句\n            int[] ints = statement.executebatch();\n        \n            for (int tmp : ints) {\n                system.out.println("anint : " + tmp);\n            }\n        \n            //手动提交\n            connection.commit();\n        \n        } catch (exception throwables) {\n            //异常回滚\n            try {\n                if (connection != null) {\n                    connection.rollback();\n                }\n            } catch (sqlexception e) {\n                e.printstacktrace();\n            }\n        } finally {\n            try {\n                if (connection != null) {\n                    connection.close();\n                }\n                if (statement != null){\n                    statement.cancel();\n                }\n            } catch (sqlexception throwables) {\n                throwables.printstacktrace();\n            }\n        }\n    }\n}\n\n\npreparedstatement通道实现批量处理\n\nimport java.sql.connection;\nimport java.sql.drivermanager;\nimport java.sql.preparedstatement;\nimport java.sql.sqlexception;\n\n/**\n * @author: 柏竹\n * @description: 一个简洁主义...\n * @date_created_in: 2021-03-19 21:23\n * @modified_by:\n * @project： preparedstatement通道实现批量处理\n */\npublic class preparedstatementtest {\n    public static void main(string[] args) {\n        connection connection = null;\n        preparedstatement pps = null;\n        \n        try {\n            class.forname("com.mysql.cj.jdbc.driver");\n            string username = "root";\n            string password = "";\n            string url = "jdbc:mysql://localhost:3306/test?servertimezone=utc";\n            connection = drivermanager.getconnection(url , username , password);\n            \n            //关闭自动事务\n            connection.setautocommit(false);\n            //通道\n            string sql = "insert into cs (name) values(?);";\n            pps = connection.preparestatement(sql);\n            \n            //sql操作\n            //新增加条数\n            pps.setstring(1,"柏竹a");\n            pps.addbatch();\n            pps.setstring(1,"柏竹b");\n            pps.addbatch();\n            pps.setstring(1,"柏竹c");\n            pps.addbatch();\n            pps.setstring(1,"柏竹d");\n            pps.addbatch();\n            pps.setstring(1,"柏竹e");\n            pps.addbatch();\n            \n            //批量执行sql语句\n            int[] ints = pps.executebatch();\n            \n            for (int tmp : ints) {\n                system.out.println("anint : " + tmp);\n            }\n            \n            //手动提交\n            connection.commit();\n            \n        } catch (exception throwables) {\n            //异常回滚\n            try {\n                if (connection != null) {\n                    connection.rollback();\n                }\n            } catch (sqlexception e) {\n                e.printstacktrace();\n            }\n        } finally {\n            try {\n                if (connection != null) {\n                    connection.close();\n                }\n                if (pps != null){\n                    pps.cancel();\n                }\n            } catch (sqlexception throwables) {\n                throwables.printstacktrace();\n            }\n        }\n    }\n}\n\n\n\n# jdbc整合应用\n\n项目链接下载',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"队列",frontmatter:{title:"队列",author:"柏竹",permalink:"/backend/iis6im",date:"2020-02-18T00:00:00.000Z",categories:["后端"],tags:["数据结构","Java"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/06.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.%E9%98%9F%E5%88%97.html",relativePath:"01.后端/06.数据结构/01.队列.md",key:"v-450e1b5c",path:"/backend/iis6im/",headers:[{level:2,title:"循环队列",slug:"循环队列",normalizedTitle:"循环队列",charIndex:3327}],headersStr:"循环队列",content:'# 队列\n\n队列（queue），是一种特殊的线性表，是运算受到限制的一种线性表，只允许在表的 一端进行插入，而在另一端进行删除元素的线性表。操作方式 先进先出\n\n> 队尾： 队列进口 队头： 队列出口 进队： 插入队列 出队： 删除队列\n\n\n\n\n\n队列的基本操作类型\n\n> 初始化、入队、出队、清空队列、队列是否为空、获取队头元素、获取所有元素···等\n\n例子：\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\nclass MyQueue{\n    //队列\n    private List queue = null;\n    //头索引\n    private int Head;\n    private final int MAX = 100;\n    \n    //初始化（1）\n    public MyQueue(){\n        queue = new ArrayList();\n        this.Head = 0;\n    }\n    \n    //入队（2）\n    public boolean AddQueue(Object data){\n        if (queue == null || queue.size() >= MAX){\n            return false;\n        }\n        queue.add(data);\n        return true;\n    }\n    \n    //出队（3）\n    public boolean DeQueue(){\n        if (queue == null || queue.size() <= 0){\n            return false;\n        }\n        //出队后置空\n        queue.set(this.Head , null);\n        this.Head++;\n        return true;\n    }\n    \n    //清空队列（4）\n    public boolean DestoryQueue(){\n        for (int i = 0; i < queue.size(); i++) {\n            queue.remove(queue.get(this.Head));\n        }\n        System.gc();\n        return true;\n    }\n    \n    //队列是否为空（5）\n    public boolean isEmpty(){\n        return this.Head >= queue.size();\n    }\n    \n    //获取队头元素（6）\n    public Object GetHead(){\n        return queue.get(this.Head);\n    }\n    \n    //获取所有元素（7）\n    public Object[] arrayQueue(){\n        Object[] array = new Object[queue.size()];\n        Iterator it = queue.iterator();\n        int n = 0;\n        while (it.hasNext()){\n            Object tmp = it.next();\n            if (tmp != null){\n                array[n] = tmp;\n                n++; }\n        }\n        //防空值\n        Object[] array2 = new Object[n];\n        for (int i = 0; i < n ; i++) {\n            array2[i] = array[i];\n        }\n        return array2;\n    }\n    \n}\n\npublic class Demo {\n    public static void main(String[] args) {\n        MyQueue queue = new MyQueue();\n        \n        //是否为空队\n        System.out.println("队列是否为空："+queue.isEmpty());\n        \n        //入队\n        System.out.println("\\n=========入队数据···\\n");\n        queue.AddQueue(1);\n        queue.AddQueue("Sanscan12");\n        queue.AddQueue(22.3);\n        queue.AddQueue(new Object());\n        queue.AddQueue(555);\n        \n        //是否为空队\n        System.out.println("队列是否为空："+queue.isEmpty());\n        \n        //获取队列\n        System.out.println("\\n=========遍历队列");\n        for (Object tmp : queue.arrayQueue()){\n            System.out.println(tmp);\n        }\n        \n        //出队操作 X2\n        System.out.println("\\n=========出队操作 *2\\n");\n        queue.DeQueue();\n        queue.DeQueue();\n    \n        //获取队列\n        System.out.println("\\n=========遍历队列");\n        for (Object tmp : queue.arrayQueue()){\n            System.out.println(tmp);\n        }\n        \n        //获取队头元素值\n        System.out.println("\\n=========获取队头元素值");\n        System.out.println(queue.GetHead());\n    \n        //清空队列\n        System.out.println("\\n=========清空队列\\n");\n        queue.DestoryQueue();\n    \n        //是否为空队\n        System.out.println("队列是否为空："+queue.isEmpty());\n        \n    }\n}\n\n\n/**\n\n队列是否为空：true\n\n=========入队数据···\n\n队列是否为空：false\n\n=========遍历队列\n1\nSanscan12\n22.3\njava.lang.Object@7cd84586\n555\n\n=========出队操作 *2\n\n\n=========遍历队列\n22.3\njava.lang.Object@7cd84586\n555\n\n=========获取队头元素值\n22.3\n\n=========清空队列\n\n队列是否为空：true\n\n*/\n\n\n\n# 循环队列\n\n循环队列是将队 列头 和 尾 的位置连接起来形成空间循环，一旦队列满了，就不能插入元素，即使在队列前面仍有空间。重复利用空间\n\n例子：\n\ninterface Method {\n    //入队\n    boolean Add(Object data);\n    //出队\n    boolean DeQueue();\n    //是否为空\n    boolean isEmpty();\n    //获取头\n    Object GetHeadvalue();\n    int GetHead();\n    //获取尾\n    Object GetTailvalue();\n    int GetTail();\n    //总长\n    int GetSize();\n    //返回所有元素\n    Object[] ArrayQueue();\n}\n\nclass MyCircularQueue implements Method{\n    private Object[] queue;\n    private static int head , tail ,size;\n    \n    public MyCircularQueue(int max){\n        queue = new Object[max+1];\n        head = 0;\n        tail = 0;\n        size = 0;\n    }\n    \n    //入队\n    @Override\n    public boolean Add(Object data){\n        \n        if ((tail+1)%queue.length == head){\n            return false;\n        }\n        \n        queue[tail] = data ;\n        size++;\n        tail = (tail + 1) % queue.length;\n        \n        return true;\n    }\n    \n    //出队\n    @Override\n    public boolean DeQueue(){\n        if (isEmpty()){\n            return false;\n        }\n        \n        queue[head] = null;\n        head = (head + 1) % queue.length;\n        size--;\n        \n        return true;\n    }\n    \n    //判断是否为空\n    @Override\n    public boolean isEmpty(){\n        if (head == tail){\n            return true;\n        }\n        return false;\n    }\n    \n    //判断是否为满\n    public boolean isFull(){\n        if(queue.length-1 == size){\n            return true;\n        }\n        return false;\n    }\n    \n    //获取头元素 。队列为空返回null\n    @Override\n    public Object GetHeadvalue(){\n        return queue[head];\n    }\n    \n    @Override\n    public int GetHead() {\n        return head;\n    }\n    \n    //获取尾元素 。队列为空返回null\n    @Override\n    public Object GetTailvalue(){\n        return queue[tail-1];\n    }\n    \n    @Override\n    public int GetTail() {\n        return tail;\n    }\n    \n    @Override\n    public int GetSize(){\n        return size;\n    }\n    \n    @Override\n    public Object[] ArrayQueue() {\n        return queue;\n    }\n    \n}\n\npublic class Demo2 {\n    public static void main(String[] args) {\n        MyCircularQueue queue = new MyCircularQueue(5);\n    \n        System.out.println("是否空？"+queue.isEmpty());\n        \n        System.out.println("入队 *5：");\n        System.out.println(queue.Add(123));\n        System.out.println(queue.Add(3.14));\n        System.out.println(queue.Add(new Object()));\n        System.out.println(queue.Add("Sanscan12"));\n        System.out.println(queue.Add("2223333"));\n        \n        \n        System.out.println("===================");\n        System.out.println("遍历：");\n        for(Object tmp : queue.ArrayQueue()){\n            System.out.println(tmp);\n        }\n        System.out.println();\n        System.out.println("队列是否空？"+queue.isEmpty());\n        System.out.println("队列是否满？"+queue.isFull());\n        System.out.println("队列总长："+queue.GetSize());\n        System.out.println("头索引："+queue.GetHead()+"\\t值："+queue.GetHeadvalue());\n        System.out.println("尾索引："+queue.GetTail()+"\\t值："+queue.GetTailvalue());\n        \n        System.out.println("===================");\n    \n        System.out.println("\\n出队 *3\\n");\n        System.out.println(queue.DeQueue());\n        System.out.println(queue.DeQueue());\n        System.out.println(queue.DeQueue());\n    \n        System.out.println("\\n入队 *5\\n");\n        System.out.println(queue.Add(1111));\n    \n        System.out.println(queue.Add(2222));\n        System.out.println(queue.Add(3333));\n        System.out.println(queue.Add(4444));\n        System.out.println(queue.Add(5555));\n    \n        System.out.println("===================");\n        System.out.println("遍历：");\n        for(Object tmp : queue.ArrayQueue()){\n            System.out.println(tmp);\n        }\n        System.out.println();\n        System.out.println("队列是否空？"+queue.isEmpty());\n        System.out.println("队列是否满？"+queue.isFull());\n        System.out.println("队列总长："+queue.GetSize());\n        System.out.println("头索引："+queue.GetHead()+"\\t值："+queue.GetHeadvalue());\n        System.out.println("尾索引："+queue.GetTail()+"\\t值："+queue.GetTailvalue());\n    \n        System.out.println("===================");\n        \n    }\n}\n\n\n/**\n\n是否空？true\n入队 *5：\ntrue\ntrue\ntrue\ntrue\ntrue\n===================\n遍历：\n123\n3.14\njava.lang.Object@30dae81\nSanscan12\n2223333\nnull\n\n队列是否空？false\n队列是否满？true\n队列总长：5\n头索引：0\t值：123\n尾索引：5\t值：2223333\n===================\n\n出队 *3\n\ntrue\ntrue\ntrue\n\n入队 *5\n\ntrue\ntrue\ntrue\nfalse\nfalse\n===================\n遍历：\n2222\n3333\nnull\nSanscan12\n2223333\n1111\n\n队列是否空？false\n队列是否满？true\n队列总长：5\n头索引：3\t值：Sanscan12\n尾索引：2\t值：3333\n===================\n\n*/\n',normalizedContent:'# 队列\n\n队列（queue），是一种特殊的线性表，是运算受到限制的一种线性表，只允许在表的 一端进行插入，而在另一端进行删除元素的线性表。操作方式 先进先出\n\n> 队尾： 队列进口 队头： 队列出口 进队： 插入队列 出队： 删除队列\n\n\n\n\n\n队列的基本操作类型\n\n> 初始化、入队、出队、清空队列、队列是否为空、获取队头元素、获取所有元素···等\n\n例子：\n\nimport java.util.arraylist;\nimport java.util.iterator;\nimport java.util.list;\n\nclass myqueue{\n    //队列\n    private list queue = null;\n    //头索引\n    private int head;\n    private final int max = 100;\n    \n    //初始化（1）\n    public myqueue(){\n        queue = new arraylist();\n        this.head = 0;\n    }\n    \n    //入队（2）\n    public boolean addqueue(object data){\n        if (queue == null || queue.size() >= max){\n            return false;\n        }\n        queue.add(data);\n        return true;\n    }\n    \n    //出队（3）\n    public boolean dequeue(){\n        if (queue == null || queue.size() <= 0){\n            return false;\n        }\n        //出队后置空\n        queue.set(this.head , null);\n        this.head++;\n        return true;\n    }\n    \n    //清空队列（4）\n    public boolean destoryqueue(){\n        for (int i = 0; i < queue.size(); i++) {\n            queue.remove(queue.get(this.head));\n        }\n        system.gc();\n        return true;\n    }\n    \n    //队列是否为空（5）\n    public boolean isempty(){\n        return this.head >= queue.size();\n    }\n    \n    //获取队头元素（6）\n    public object gethead(){\n        return queue.get(this.head);\n    }\n    \n    //获取所有元素（7）\n    public object[] arrayqueue(){\n        object[] array = new object[queue.size()];\n        iterator it = queue.iterator();\n        int n = 0;\n        while (it.hasnext()){\n            object tmp = it.next();\n            if (tmp != null){\n                array[n] = tmp;\n                n++; }\n        }\n        //防空值\n        object[] array2 = new object[n];\n        for (int i = 0; i < n ; i++) {\n            array2[i] = array[i];\n        }\n        return array2;\n    }\n    \n}\n\npublic class demo {\n    public static void main(string[] args) {\n        myqueue queue = new myqueue();\n        \n        //是否为空队\n        system.out.println("队列是否为空："+queue.isempty());\n        \n        //入队\n        system.out.println("\\n=========入队数据···\\n");\n        queue.addqueue(1);\n        queue.addqueue("sanscan12");\n        queue.addqueue(22.3);\n        queue.addqueue(new object());\n        queue.addqueue(555);\n        \n        //是否为空队\n        system.out.println("队列是否为空："+queue.isempty());\n        \n        //获取队列\n        system.out.println("\\n=========遍历队列");\n        for (object tmp : queue.arrayqueue()){\n            system.out.println(tmp);\n        }\n        \n        //出队操作 x2\n        system.out.println("\\n=========出队操作 *2\\n");\n        queue.dequeue();\n        queue.dequeue();\n    \n        //获取队列\n        system.out.println("\\n=========遍历队列");\n        for (object tmp : queue.arrayqueue()){\n            system.out.println(tmp);\n        }\n        \n        //获取队头元素值\n        system.out.println("\\n=========获取队头元素值");\n        system.out.println(queue.gethead());\n    \n        //清空队列\n        system.out.println("\\n=========清空队列\\n");\n        queue.destoryqueue();\n    \n        //是否为空队\n        system.out.println("队列是否为空："+queue.isempty());\n        \n    }\n}\n\n\n/**\n\n队列是否为空：true\n\n=========入队数据···\n\n队列是否为空：false\n\n=========遍历队列\n1\nsanscan12\n22.3\njava.lang.object@7cd84586\n555\n\n=========出队操作 *2\n\n\n=========遍历队列\n22.3\njava.lang.object@7cd84586\n555\n\n=========获取队头元素值\n22.3\n\n=========清空队列\n\n队列是否为空：true\n\n*/\n\n\n\n# 循环队列\n\n循环队列是将队 列头 和 尾 的位置连接起来形成空间循环，一旦队列满了，就不能插入元素，即使在队列前面仍有空间。重复利用空间\n\n例子：\n\ninterface method {\n    //入队\n    boolean add(object data);\n    //出队\n    boolean dequeue();\n    //是否为空\n    boolean isempty();\n    //获取头\n    object getheadvalue();\n    int gethead();\n    //获取尾\n    object gettailvalue();\n    int gettail();\n    //总长\n    int getsize();\n    //返回所有元素\n    object[] arrayqueue();\n}\n\nclass mycircularqueue implements method{\n    private object[] queue;\n    private static int head , tail ,size;\n    \n    public mycircularqueue(int max){\n        queue = new object[max+1];\n        head = 0;\n        tail = 0;\n        size = 0;\n    }\n    \n    //入队\n    @override\n    public boolean add(object data){\n        \n        if ((tail+1)%queue.length == head){\n            return false;\n        }\n        \n        queue[tail] = data ;\n        size++;\n        tail = (tail + 1) % queue.length;\n        \n        return true;\n    }\n    \n    //出队\n    @override\n    public boolean dequeue(){\n        if (isempty()){\n            return false;\n        }\n        \n        queue[head] = null;\n        head = (head + 1) % queue.length;\n        size--;\n        \n        return true;\n    }\n    \n    //判断是否为空\n    @override\n    public boolean isempty(){\n        if (head == tail){\n            return true;\n        }\n        return false;\n    }\n    \n    //判断是否为满\n    public boolean isfull(){\n        if(queue.length-1 == size){\n            return true;\n        }\n        return false;\n    }\n    \n    //获取头元素 。队列为空返回null\n    @override\n    public object getheadvalue(){\n        return queue[head];\n    }\n    \n    @override\n    public int gethead() {\n        return head;\n    }\n    \n    //获取尾元素 。队列为空返回null\n    @override\n    public object gettailvalue(){\n        return queue[tail-1];\n    }\n    \n    @override\n    public int gettail() {\n        return tail;\n    }\n    \n    @override\n    public int getsize(){\n        return size;\n    }\n    \n    @override\n    public object[] arrayqueue() {\n        return queue;\n    }\n    \n}\n\npublic class demo2 {\n    public static void main(string[] args) {\n        mycircularqueue queue = new mycircularqueue(5);\n    \n        system.out.println("是否空？"+queue.isempty());\n        \n        system.out.println("入队 *5：");\n        system.out.println(queue.add(123));\n        system.out.println(queue.add(3.14));\n        system.out.println(queue.add(new object()));\n        system.out.println(queue.add("sanscan12"));\n        system.out.println(queue.add("2223333"));\n        \n        \n        system.out.println("===================");\n        system.out.println("遍历：");\n        for(object tmp : queue.arrayqueue()){\n            system.out.println(tmp);\n        }\n        system.out.println();\n        system.out.println("队列是否空？"+queue.isempty());\n        system.out.println("队列是否满？"+queue.isfull());\n        system.out.println("队列总长："+queue.getsize());\n        system.out.println("头索引："+queue.gethead()+"\\t值："+queue.getheadvalue());\n        system.out.println("尾索引："+queue.gettail()+"\\t值："+queue.gettailvalue());\n        \n        system.out.println("===================");\n    \n        system.out.println("\\n出队 *3\\n");\n        system.out.println(queue.dequeue());\n        system.out.println(queue.dequeue());\n        system.out.println(queue.dequeue());\n    \n        system.out.println("\\n入队 *5\\n");\n        system.out.println(queue.add(1111));\n    \n        system.out.println(queue.add(2222));\n        system.out.println(queue.add(3333));\n        system.out.println(queue.add(4444));\n        system.out.println(queue.add(5555));\n    \n        system.out.println("===================");\n        system.out.println("遍历：");\n        for(object tmp : queue.arrayqueue()){\n            system.out.println(tmp);\n        }\n        system.out.println();\n        system.out.println("队列是否空？"+queue.isempty());\n        system.out.println("队列是否满？"+queue.isfull());\n        system.out.println("队列总长："+queue.getsize());\n        system.out.println("头索引："+queue.gethead()+"\\t值："+queue.getheadvalue());\n        system.out.println("尾索引："+queue.gettail()+"\\t值："+queue.gettailvalue());\n    \n        system.out.println("===================");\n        \n    }\n}\n\n\n/**\n\n是否空？true\n入队 *5：\ntrue\ntrue\ntrue\ntrue\ntrue\n===================\n遍历：\n123\n3.14\njava.lang.object@30dae81\nsanscan12\n2223333\nnull\n\n队列是否空？false\n队列是否满？true\n队列总长：5\n头索引：0\t值：123\n尾索引：5\t值：2223333\n===================\n\n出队 *3\n\ntrue\ntrue\ntrue\n\n入队 *5\n\ntrue\ntrue\ntrue\nfalse\nfalse\n===================\n遍历：\n2222\n3333\nnull\nsanscan12\n2223333\n1111\n\n队列是否空？false\n队列是否满？true\n队列总长：5\n头索引：3\t值：sanscan12\n尾索引：2\t值：3333\n===================\n\n*/\n',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"二叉树",frontmatter:{title:"二叉树",author:"柏竹",permalink:"/backend/7g3bqt",date:"2020-02-18T00:00:00.000Z",categories:["后端"],tags:["数据结构","Java"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/06.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02.%E4%BA%8C%E5%8F%89%E6%A0%91.html",relativePath:"01.后端/06.数据结构/02.二叉树.md",key:"v-59358ae3",path:"/backend/7g3bqt/",headers:[{level:2,title:"二叉树种类",slug:"二叉树种类",normalizedTitle:"二叉树种类",charIndex:129},{level:3,title:"斜树",slug:"斜树",normalizedTitle:"斜树",charIndex:139},{level:3,title:"满二叉树",slug:"满二叉树",normalizedTitle:"满二叉树",charIndex:170},{level:3,title:"完全二叉树",slug:"完全二叉树",normalizedTitle:"完全二叉树",charIndex:201},{level:2,title:"二叉树遍历方式",slug:"二叉树遍历方式",normalizedTitle:"二叉树遍历方式",charIndex:292},{level:2,title:"前序遍历",slug:"前序遍历",normalizedTitle:"前序遍历",charIndex:310},{level:2,title:"中序遍历",slug:"中序遍历",normalizedTitle:"中序遍历",charIndex:400},{level:2,title:"后序遍历",slug:"后序遍历",normalizedTitle:"后序遍历",charIndex:490}],headersStr:"二叉树种类 斜树 满二叉树 完全二叉树 二叉树遍历方式 前序遍历 中序遍历 后序遍历",content:"# 二叉树\n\n二叉树是树的一种，每个节点最多可具有两个子树，即结点的度最大为 2（结点度：结点拥 有的子树数）\n\n> 数据域： 存储数据的元素 指针域： 存储下个节点的地址\n\n当前根节点的左边全部比根节点小，当前根节点的右边全部比根节点大\n\n图片9\n\n\n# 二叉树种类\n\n\n# 斜树\n\n所有结点都只有左子树，或者右子树\n\n图片11\n\n\n# 满二叉树\n\n所有的分支节点都具有左右节点\n\n图片10\n\n\n# 完全二叉树\n\n若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树\n\n图片12\n\n\n# 二叉树遍历方式\n\n图片13\n\n\n# 前序遍历\n\n先访问根节点，然后遍历左子树，最后遍历右子树（根 > 左 > 右）\n\n根据以上图片进行遍历：1 - 2 - 4 - 5 - 7 - 8 - 3 - 6 - 9\n\n\n# 中序遍历\n\n先遍历左子树，然后访问根节点，然后遍历右子树（左 > 根 > 右）\n\n根据以上图片进行遍历：4 - 2 - 7 - 5 - 8 - 1 - 9 - 6 - 3\n\n\n# 后序遍历\n\n先遍历左子树，然后遍历右子树，最后访问树的根节点（左 > 右 > 根）\n\n根据以上图片进行遍历：4 - 7 - 8 - 5 - 2 - 9 - 6 - 3 - 1",normalizedContent:"# 二叉树\n\n二叉树是树的一种，每个节点最多可具有两个子树，即结点的度最大为 2（结点度：结点拥 有的子树数）\n\n> 数据域： 存储数据的元素 指针域： 存储下个节点的地址\n\n当前根节点的左边全部比根节点小，当前根节点的右边全部比根节点大\n\n图片9\n\n\n# 二叉树种类\n\n\n# 斜树\n\n所有结点都只有左子树，或者右子树\n\n图片11\n\n\n# 满二叉树\n\n所有的分支节点都具有左右节点\n\n图片10\n\n\n# 完全二叉树\n\n若设二叉树的深度为 h，除第 h 层外，其它各层 (1～h-1) 的结点数都达到最大个数，第 h 层所有的结点都连续集中在最左边，这就是完全二叉树\n\n图片12\n\n\n# 二叉树遍历方式\n\n图片13\n\n\n# 前序遍历\n\n先访问根节点，然后遍历左子树，最后遍历右子树（根 > 左 > 右）\n\n根据以上图片进行遍历：1 - 2 - 4 - 5 - 7 - 8 - 3 - 6 - 9\n\n\n# 中序遍历\n\n先遍历左子树，然后访问根节点，然后遍历右子树（左 > 根 > 右）\n\n根据以上图片进行遍历：4 - 2 - 7 - 5 - 8 - 1 - 9 - 6 - 3\n\n\n# 后序遍历\n\n先遍历左子树，然后遍历右子树，最后访问树的根节点（左 > 右 > 根）\n\n根据以上图片进行遍历：4 - 7 - 8 - 5 - 2 - 9 - 6 - 3 - 1",charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Hibernate",frontmatter:{title:"Hibernate",author:"柏竹",permalink:"/backend/k5hxej",date:"2020-02-18T00:00:00.000Z",categories:["后端"],tags:["数据库","框架"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/05.%E6%95%B0%E6%8D%AE%E5%BA%93/03.Hibernate.html",relativePath:"01.后端/05.数据库/03.Hibernate.md",key:"v-69a39f61",path:"/backend/k5hxej/",headers:[{level:2,title:"ORM",slug:"orm",normalizedTitle:"orm",charIndex:333},{level:2,title:"Hibernate架构",slug:"hibernate架构",normalizedTitle:"hibernate架构",charIndex:556},{level:3,title:"配置对象",slug:"配置对象",normalizedTitle:"配置对象",charIndex:572},{level:3,title:"会话工厂对象",slug:"会话工厂对象",normalizedTitle:"会话工厂对象",charIndex:640},{level:3,title:"会话对象",slug:"会话对象",normalizedTitle:"会话对象",charIndex:696},{level:3,title:"事务对象",slug:"事务对象",normalizedTitle:"事务对象",charIndex:783},{level:3,title:"查询对象",slug:"查询对象",normalizedTitle:"查询对象",charIndex:831},{level:3,title:"约束对象",slug:"约束对象",normalizedTitle:"约束对象",charIndex:1180},{level:2,title:"配置属性",slug:"配置属性",normalizedTitle:"配置属性",charIndex:1208},{level:2,title:"映射文件",slug:"映射文件",normalizedTitle:"映射文件",charIndex:2332},{level:2,title:"Hibernate应用",slug:"hibernate应用",normalizedTitle:"hibernate应用",charIndex:3666},{level:3,title:"搭建环境 IDEA",slug:"搭建环境-idea",normalizedTitle:"搭建环境 idea",charIndex:3699},{level:3,title:"连接操作",slug:"连接操作",normalizedTitle:"连接操作",charIndex:3806},{level:2,title:"注解",slug:"注解",normalizedTitle:"注解",charIndex:1636},{level:2,title:"反向工程",slug:"反向工程",normalizedTitle:"反向工程",charIndex:7572},{level:2,title:"关联映射",slug:"关联映射",normalizedTitle:"关联映射",charIndex:7960},{level:3,title:"一对多",slug:"一对多",normalizedTitle:"一对多",charIndex:7741},{level:3,title:"多对多",slug:"多对多",normalizedTitle:"多对多",charIndex:7747},{level:2,title:"高级查询",slug:"高级查询",normalizedTitle:"高级查询",charIndex:14827},{level:3,title:"Query",slug:"query",normalizedTitle:"query",charIndex:851},{level:3,title:"Criteria",slug:"criteria",normalizedTitle:"criteria",charIndex:1186},{level:2,title:"缓存机制",slug:"缓存机制",normalizedTitle:"缓存机制",charIndex:114},{level:3,title:"一级缓存",slug:"一级缓存",normalizedTitle:"一级缓存",charIndex:26337},{level:3,title:"二级缓存",slug:"二级缓存",normalizedTitle:"二级缓存",charIndex:112},{level:2,title:"Hibernate问题",slug:"hibernate问题",normalizedTitle:"hibernate问题",charIndex:26464}],headersStr:"ORM Hibernate架构 配置对象 会话工厂对象 会话对象 事务对象 查询对象 约束对象 配置属性 映射文件 Hibernate应用 搭建环境 IDEA 连接操作 注解 反向工程 关联映射 一对多 多对多 高级查询 Query Criteria 缓存机制 一级缓存 二级缓存 Hibernate问题",content:'# Hibernate\n\nHibernate 将 Java对象与数据库表之间建立起映射关系，并提供了一系列数据访问接口，可随心所欲对库进行操作\n\n好处：\n\n * Dao层开发简单\n * 兼容性好支持大多数主流数据库\n * 有二级缓存机制\n * 省略手动编写SQL语句（自动生成\n\nHibernate 开发包： Hibernate 官网\n\n目录说明：\n\n * documentation：开发文档\n * lib：依赖jar包\n * project：工程实例\n\n学习参考文档：\n\n 1. https://www.w3cschool.cn/hibernate/skzl1idz.html\n 2. http://c.biancheng.net/hibernate/\n\n\n# ORM\n\nORM 是 Object Relational Mapping 的缩写，译为“对象关系映射”，它解决了对象和关系型数据库之间的数据交互问题\n\n库与对象的关系\n\n数据库       类对象\n表         类\n表记录(数据)   对象\n表字段       对象属性\n\nORM缺点\n\n * 学习成本高\n * 自动生成SQL会消耗资源\n * 复杂的SQL难以处理（有时候不如手写SQL\n\n好处上面有了（总之是JDBC使用的优化版\n\n\n# Hibernate架构\n\n\n# 配置对象\n\n用于 连接数据库 / 创建类和表映射关系 的主要 配置文件\n\n默认全局配置文件：hibernate.cfg.xml\n\n\n# 会话工厂对象\n\nSessionFactory对象 用于 分配线程的应用(安全线程)，以防异步错乱的情况\n\n\n# 会话对象\n\nSession对象 用于与数据库的物理连接\n\n详细说明：https://www.w3cschool.cn/hibernate/93tz1ied.html\n\n\n# 事务对象\n\nTransaction对象 每个事务代表 一个单元CRUD操作 (一个以上\n\n\n# 查询对象\n\norg.hibernate.Query对象 用于 自定义SQL / Hibernate语句 查询的数据集\n\n对象获取\n\n==Session.createQuery(String hql);==\n\n常用方法（结果集获取\n\n返回            方法               说明\nR             uniqueResult()   查询结果的单条数据，没有则null\nList<R>       list()           查询结果集以list形式的结果\nIterator<R>   iterate()        查询结果集以迭代器形式的结果\n\n> 注意：list()方法 返回的数据 如果不为 实体对象的属性，那么它返回的是 Object[]数组\n\n\n# 约束对象\n\nCriteria对象 指定查询对象\n\n\n# 配置属性\n\n属性                                  说明\nhibernate.dialect                   配选定指定 库 生成对应的SQL\nhibernate.connection.driver_class   加载 JDBC驱动\nhibernate.connection.url            连接库的url\nhibernate.connection.username       用户名\nhibernate.connection.password       密码\nhibernate.connection.pool_size      连接池中连接的数量\nhibernate.connection.autocommit     允许JDBC自动提交模式\n\nmapping标签\n\n * resource 指定的是需要已经配置好的 ORM映射xml文件\n * class 指定实体对象（用于注解）\n\n示例：\n\n<?xml version="1.0" encoding="utf-8"?>\n<!DOCTYPE hibernate-configuration SYSTEM \n"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">\n\n<hibernate-configuration>\n   <session-factory>\n   <property name="hibernate.dialect">org.hibernate.dialect.MySQLDialect</property>\n   <property name="hibernate.connection.driver_class">com.mysql.jdbc.Driver</property>\n       \n   <property name="hibernate.connection.url">jdbc:mysql://localhost/test</property>\n   <property name="hibernate.connection.username">root</property>\n   <property name="hibernate.connection.password">root123</property>\n\n   <mapping resource="Employee.hbm.xml"/>\n</session-factory>\n</hibernate-configuration> \n\n\n\n# 映射文件\n\n映射文件 主要用于 让配置文件对应对接的映射配置，但也与实体类对接\n\n命名规则： ==<实体类名>.hbm.xml==\n\n标签描述：\n\n * <hibernate-mapping>：根元素的 XML 文件\n\n * <class>：指定 实体类 -> 数据库表 的特定映射\n   \n   * name：实体类（全限定名\n   * table：数据库表名称\n\n * <id>：类属性ID / 表ID字段 关联（唯一！！）\n   \n   * name：类属性名\n   \n   * column：表字段名\n   \n   * type：映射类型\n   \n   * <generator> 自动生成主键值\n     \n     * class：主键自增形式\n       \n       GENERATOR.CLASS值   说明\n       identity           库底层自增机制\n       increment          Hibernate实现自增\n       assigned           字符串主键（算法生成\n       sequence           序列生成主键\n\n * <property>：实体类属性 与 库表字段的匹配\n   \n   * name：类属性名\n   * column：表字段名\n   * type：映射类型\n\n映射的数据类型：https://www.w3cschool.cn/hibernate/fzum1iem.html\n\n示例：\n\n<?xml version="1.0" encoding="utf-8"?>\n<!DOCTYPE hibernate-mapping PUBLIC \n "-//Hibernate/Hibernate Mapping DTD//EN"\n "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"> \n\n<hibernate-mapping>\n   <class name="Employee" table="EMPLOYEE">\n      <meta attribute="class-description">\n         This class contains the employee detail. \n      </meta>\n      <id name="id" type="int" column="id">\n         <generator class="identity"/>\n      </id>\n      <property name="firstName" column="first_name" type="string"/>\n      <property name="lastName" column="last_name" type="string"/>\n      <property name="salary" column="salary" type="int"/>\n   </class>\n</hibernate-mapping>\n\n\n\n# Hibernate应用\n\nHibernate上机操作应用\n\n\n# 搭建环境 IDEA\n\n搭建步骤：\n\n 1. 引入lib\n 2. 连接数据库\n 3. 项目结构 -> 模块 -> 选中项目 ->添加 Hibernate框架 (手动添加/生成 框架需要指定全局配置配置文件)\n\n\n# 连接操作\n\n应用前提：\n\n * 已经包含有 实体类/数据库数据 ，且他们的 实体类属性/数据库表字段 数据类型一致\n * ORM映射关系和全局配置已经完善\n\n\n\n连接步骤：\n\n 1. 读取解析 全局配置文件\n    \n    ==Configuration config = new Configuration().configure();==\n\n 2. 读取解析映射信息，创建SessionFactiory\n    \n    ==SessionFactory sf = conf.buildSessionFactory();==\n\n 3. 获取Session ==Session session = sf.openSession();==\n\n 4. 启动事务\n    \n    ==Transaction tx = session.beginTransaction();==\n\n 5. CRUD操作数据 （通过session进行操作\n\n 6. 提交事务\n\n 7. 关闭资源\n\n应用工具类\n\n> 注意：由于新版使用的是 服务注册的形式 进行应用的，因此步骤可能有不一样\n\npackage com.sans.util;\n\nimport org.hibernate.Session;\nimport org.hibernate.SessionFactory;\nimport org.hibernate.cfg.Configuration;\nimport org.hibernate.service.ServiceRegistry;\nimport org.hibernate.service.ServiceRegistryBuilder;\n\npublic class HibernateUtil {\n    private static ServiceRegistry sr;\n    private static SessionFactory sf;\n    private static ThreadLocal<Session> localThread = new ThreadLocal<>();\n    \n    static {\n        Configuration config = new Configuration().configure();\n        sr = new ServiceRegistryBuilder().applySettings(\n                config.getProperties()).buildServiceRegistry();\n        config.buildSessionFactory(sr);\n        sf = config.buildSessionFactory(sr);\n    }\n    \n    /**\n     * 获取会话\n     */\n    public static Session getSession() {\n        Session session = localThread.get();\n        if (session == null || ! session.isOpen()) {\n            session = sf.openSession();\n            localThread.set(session);\n        }\n        return session;\n    }\n    \n    /**\n     * 关闭会话\n     */\n    public static void close() {\n        Session session = localThread.get();\n        if (session != null) {\n            session.close();\n            localThread.remove();\n            sf.close();\n        }\n    }\n}\n\n\n\n# 注解\n\nHibernate注解 是摆脱了 xml 配置文件的应用\n\n应用前提：\n\n * Hibernate 3.x 以上的注释包\n * 关系jar包：\n    * annotations.jar\n    * hibernate-comons-annotations.jar\n    * ejb3-persistence.jar\n\n\n\n注释                范围   参数                                        说明\n@Entity           类    -                                         标志位实体类 bean\n@Table            类    String name 表名称                           映射表的配置\n                       String catalog 目录\n                       String schema 模式\n                       UniqueConstraint[] uniqueConstraints 约束\n@Id               属性   -                                         主键\n@GeneratedValue   属性   GenerationType strategy 策略                主键自动生成策略（一般默认即可）\n                       String generator\n@Column           属性   String name 允许唯一                          定义属性与字段的细节属性\n                       int length 指定数据长度\n                       boolean nullable 非空\n                       boolean unique 唯一\n\n示例：\n\nSQL：\n\ncreate table EMPLOYEE (\n   id INT NOT NULL auto_increment,\n   first_name VARCHAR(20) default NULL,\n   last_name  VARCHAR(20) default NULL,\n   salary     INT  default NULL,\n   PRIMARY KEY (id)\n);\n\n\n实体对象：\n\nimport javax.persistence.*;\n\n@Entity\n@Table(name = "EMPLOYEE")\npublic class Employee {\n   @Id @GeneratedValue\n   @Column(name = "id")\n   private int id;\n\n   @Column(name = "first_name")\n   private String firstName;\n\n   @Column(name = "last_name")\n   private String lastName;\n\n   @Column(name = "salary")\n   private int salary;  \n\n   public Employee() {}\n   public int getId() {\n      return id;\n   }\n   public void setId( int id ) {\n      this.id = id;\n   }\n   public String getFirstName() {\n      return firstName;\n   }\n   public void setFirstName( String first_name ) {\n      this.firstName = first_name;\n   }\n   public String getLastName() {\n      return lastName;\n   }\n   public void setLastName( String last_name ) {\n      this.lastName = last_name;\n   }\n   public int getSalary() {\n      return salary;\n   }\n   public void setSalary( int salary ) {\n      this.salary = salary;\n   }\n}\n\n\n\n# 反向工程\n\n反向工程操作原意 数据库表 -> 实体类\n\nIDEA反向工程步骤：\n\n**前提：**项目已 引入Hibernate框架\n\n 1. 双击Shift -> 操作项搜索Persistence\n 2. 选中项目右键 -> 生成持久映射\n 3. 指定数据库映射即可\n\n添加 数据构架的映射关系 添加关系映射关系一般用于 ==一对一 / 一对多 / 多对多== 的情况应用\n\n确认必要信息\n\n * 源/目标 特定名称 (指定实体对象的属性名)\n\n * 源/目标 属性类型 （多则集合/少则对象\n\n * 联接列 必须选中 源的表字段/目标的表字段 两者是外键关系（一定要是外键关系\n\n * 多对多情况：需要手动指定联接表(第三表)进行对两表的进行连接\n   \n   需要手动确认4个列 分别为 ==源id / 第三表外键源id / 目标id / 第三表外键目标id==\n\n\n# 关联映射\n\n在关联映射当中有三种形式，分别为：\n\n * 一对一\n * 一对多\n * 多对多\n\n\n# 一对多\n\n一方： 多方 的实体集合 ，通过标签 <set> 完成\n\n多方： 一方 的实体类，通过标签 <many-to-one>\n\n必要标签说明：\n\n<many-to-one>：多对一\n\n * name：关联对象的属性名\n * column：实体类对应的外键表字段名\n * class：关联对象类（全限定名\n\n<set>：一对多\n\n * name：关联对象属性名\n * <key>.column：关联对象的外键名\n * <one-to-many>.class：关联对象类（全限定名\n\n> 一般情况会反向自动生成的xml\n\n联级操作：\n\n<set>.cascade ：联级操作\n\n * delete ：联级删除\n * all ： 联级增删改\n * sace-update ：联级 增加/修改\n\n一对多示例：(部门一 - 员工多)\n\nStaff员工表\n\n字段名      类型        说明     外键\nid       int       -      key\nname     varchar   名称     -\ndeptId   int       部门id   dept.id\n\nDept部门表\n\n字段名    类型        说明     外键\nid     int       -      key\nname   varchar   部门名称   -\n\nStaff员工实体-xml配置\n\n// Staff.java 员工实体对象\npublic class Staff {\n    private int id;\n    private String name;\n    // 主要关系对象\n    private Dept dept;\n    //get、set配置。。。\n｝\n....\n\x3c!-- Staff.hbm.xml 配置 --\x3e \n<hibernate-mapping>\n    \x3c!-- oneToMany.Staff 包路径 / staff 表名 --\x3e \n    <class name="oneToMany.Staff" table="staff">\n        <id name="id" column="id">\n            <generator class="increment"></generator>\n        </id>\n        <property name="name"></property>\n    \t\x3c!--  \n                name: Staff实体类中的dept属性\n                column: 子表中被外键约束修饰的字段名\n\t\t\t\tclass: Staff相关联的Dept类\n        --\x3e\n        <many-to-one name="dept" column="deptId" class="oneToMany.Dept"></many-to-one>\n    </class>\n</hibernate-mapping>\n\n\nDept员工实体-xml配置\n\npublic class Dept {\n    private int id;\n    private String name;\n    // 建议手动创建初始化集合对象\n    private Set<Staff> staffSet = new HashSet<>(0);\n\t// get、set配置。。。\n｝\n....\n\x3c!-- Staff.hbm.xml 配置 --\x3e\n<hibernate-mapping>\n    <class name="oneToMany.Dept" table="dept">\n        <id name="id" column="id">\n            <generator class="increment"></generator>\n        </id>\n        <property name="name"></property>\n    \t\x3c!-- key：子表被外键约束修饰的字段名 --\x3e \n        <set name="staffSet" cascade="all">\n            <key column="deptId"/>\n            <one-to-many class="oneToMany.Staff"/>\n        </set>\n    </class>    \n</hibernate-mapping>\n\n\n测试访问：\n\n// 多对一\n@Test\npublic void add(){\n    // 假设已经获取到了 Session 对象\n    \n    //创建新部门\n    Dept dept = new Dept();\n    dept.setName("er部门");\n\n　　//创建新的职员\n    Staff staff = new Staff();\n    staff.setName("www");\n\n　　//给职员中添加部门\n    staff.setDept(dept);\n        \n　　//给部门中添加职员\n    dept.getStaffSet().add(staff);\n        \n　　//保存部门\n    session.save(dept);\n}\n\n@Test\npublic void del(){\n\t// 假设已经获取到了 Session 对象\n    // 指定查询id : 2\n\tDept dept = (Dept) sesslin.get(Dept.class,2);\n    session.delete(dept);\n  \t\n    // 删除会连同指定相同的id：2的部门一起删除\n}\n\n@Test\npublic void find(){\n    // 假设已经获取到了 Session 对象\n \tDept dept = (Dept) sesslin.get(Dept.class,2);\n    System.out.println(dept);\n    for(Staff staff : detp.getSeaff()){\n        System.out.println(staff);\n    }\n}\n\n\n\n# 多对多\n\n多对多关系 是两表之间对多关系，通常会以第三表为中间作为两表联系的关系表。两张表都只和关系表间建立主外键关系！\n\n<many-to-many>：多对多\n\n * name：关联对象的属性名\n * column：实体类对应的外键表字段名\n * class：关联对象类（全限定名\n\n应用说明：\n\n * 多对多的应用 也需要 cascade 联级操作 的操作\n\n\n\n**多对多示例：**(功能多 - 角色多) （不同角色有不同的功能\n\nMenu菜单表\n\n字段名       类型        说明     外键\nm_id      int       -      key\nm_name    varchar   菜单名称   -\nm_state   int       状态     -\n\nRole角色表\n\n字段名       类型        说明     外键\nr_id      int       -      key\nr_name    varchar   角色名称   -\nr_state   int       状态     -\n\n关系表\n\n字段名    类型    说明     外键\nid     int   -      key\nm_id   int   菜单id   menu.id\nr_id   int   角色id   role.id\n\nRole角色实体-xml配置\n\npublic class Role {\n    private int rId;\n    private String rName;\n    private Integer rState;\n    private Set<Menu> menus = new HashSet<>(0);\n\t// get/set ... \n}\n...\n\x3c!-- Role.hbm.xml 配置 --\x3e\n<hibernate-mapping>\n    \x3c!-- com.sans.pojo.Role 包路径 / role 表名 / hospital 数据库名 --\x3e\n    <class name="com.sans.pojo.Role" table="role" schema="hospital">\n        <id name="rId">\n            <column name="r_id" sql-type="int"/>\n            <generator class="native"/>\n        </id>\n        <property name="rName">\n            <column name="r_name" sql-type="varchar(80)" length="80" not-null="true"/>\n        </property>\n        <property name="rState">\n            <column name="r_state" sql-type="int" not-null="true"/>\n        </property>\n        \x3c!-- 联级操作第三表 需要配置 cascade="all" --\x3e\n        <set name="menus" table="role_menu" cascade="all">\n            \x3c!-- 外键字段 --\x3e\n            <key column="r_id"/>\n            \x3c!-- 集合对应的实体类 --\x3e\n            <many-to-many class="com.sans.pojo.Menu" column="m_id"/>\n        </set>\n    </class>\n</hibernate-mapping>\n\n\nMenu菜单实体-xml配置\n\npublic class Menu {\n    private int mId;\n    private String mName;\n    private Integer mState;\n    private Set<Role> roles = new HashSet<>(0);\n\t// get/set ...\n}\n....\n\x3c!-- Menu.hbm.xml 配置 --\x3e\n<hibernate-mapping>\n    <class name="com.sans.pojo.Menu" table="menu" schema="hospital">\n        <id name="mId">\n            <column name="m_id" sql-type="int"/>\n            <generator class="native"/>\n        </id>\n        <property name="mName">\n            <column name="m_name" sql-type="varchar(80)" length="80" not-null="true"/>\n        </property>\n        <property name="mState">\n            <column name="m_state" sql-type="int" not-null="true"/>\n        </property>\n        \x3c!-- 联级操作第三表 需要配置 cascade="all" --\x3e\n        <set name="roles" table="role_menu" cascade="all">\n            \x3c!-- 外键字段 --\x3e\n            <key column="m_id"/>\n            \x3c!-- 集合对应的实体类 --\x3e\n            <many-to-many class="com.sans.pojo.Role" column="r_id"/>\n        </set>\n    </class>\n</hibernate-mapping>\n\n\n测试：\n\n@Test\npublic void findByMenu() {\n    Session session = HibernateUtil.getSession();\n    Transaction tx = session.beginTransaction();\n    \n    Menu menu = (Menu) session.get(Menu.class , 4);\n    System.out.println("menu : " + menu);\n    System.out.println("menu.roles : " + menu.getRoles());\n    \n    tx.commit();\n    HibernateUtil.close();\n}\n\n@Test\npublic void findByRole() {\n    Session session = HibernateUtil.getSession();\n    Transaction tx = session.beginTransaction();\n    \n    \n    Role role = (Role) session.get(Role.class,1);\n    System.out.println("role : " + role);\n    System.out.println("role.menus : " + role.getMenus());\n    \n    tx.commit();\n    HibernateUtil.close();\n\n}\n\n// 联级添加\n@Test\npublic void add() {\n\n    Session session = HibernateUtil.getSession();\n    Transaction tx = session.beginTransaction();\n    \n    Menu menu = new Menu("xx管理",22);\n    System.out.println("menu : " + menu);\n    \n    Role role1 = new Role("医生",1);\n    Role role2 = new Role("主管",1);\n    \n    menu.getRoles().add(role1);\n    menu.getRoles().add(role2);\n    \n    session.save(menu);\n    \n    tx.commit();\n    session.close();\n}\n\n// 联级删除\n@Test\npublic void del() {\n    Session session = HibernateUtil.getSession();\n    Transaction tx = session.beginTransaction();\n    \n    // 根据指定的 Role.id进行删除\n    Role role = new Role();\n    role.setrId(39);\n    \n    // 指定 Menu.id进行删除\n    // Menu menu = new Menu();\n    // menu.setmId(23);\n    \n    session.delete(role);\n    \n    tx.commit();\n    HibernateUtil.close();\n}\n\n\n\n# 高级查询\n\nHibernate 框架 提供了两个用于查询的对象分别为 Query、Criteria对象\n\n> Criteria对象 应用起来方法较多，自行了解：\n> \n> https://www.w3cschool.cn/hibernate/ugov1ie8.html\n\n\n# Query\n\nquery查询方式 依靠自行编写的 hql语句进行查询数据\n\nquery对象获取\n\n==Session.createQuery(String hql)==\n\nquery常用方法\n\n获取结果集方法\n\n返回            方法               说明\nR             uniqueResult()   查询结果的单条数据，没有则null\nList<R>       list()           查询结果集以list形式的结果\nIterator<R>   iterate()        查询结果集以迭代器形式的结果\n\n> **注意：**list()方法 返回的数据 如果不为 实体对象的属性，那么它返回的是 Object[]数组\n\n其他方法\n\n返回      方法                                   说明\nQuery   setXX( String/int , XX) (XX为数据类型名)   填充hql语句的 数据/占位符\nQuery   setFirstResult(int firstResult)      设置 查询起始行数\nQuery   setMaxResults(int maxResults)        设置 查询最大行数\n\n更多方法可以在自行查看源码\n\nquery查询示例\n\n示例说明：\n\n * 仅展现功能代码块\n * 两表关系为 一对多 (一部门 - 多员工)\n\n\n\n**数据库表**\n\ndept部门表\n\n字段名      类型        说明    外键\ndeptno   int       id    key\ndname    varchar   部门名   -\nloc      varhcar   区     -\n\nemp员工表\n\n字段名      类型             说明     外键\nempno    int            id     key\nename    varchar        员工名称   -\nsal      decimal （浮点型   工资     -\ndeptno   int            部门id   dept.deptno\n\npublic class Demo {\n\n    // 对象查询\n    @Test\n    public void test01() {\n        // 查 部门对象\n        String hql = "from Dept";\n        Session session = HibernateUtil.getSession();\n        Query query = session.createQuery(hql);\n        List<Dept> list = query.list();\n        for (Dept dept : list) {\n            System.out.println("dept : " + dept);\n        }\n    }\n    \n    // 属性查询\n    @Test\n    public void test02() {\n        // 查 指定部门\n        String hql = "select loc,deptno from Dept";\n        Session session = HibernateUtil.getSession();\n        Query query = session.createQuery(hql);\n        List<Object[]> list = query.list();\n        for (Object[] row : list) {\n            System.out.println(row[0] + "\\t - \\t" + row[1]);\n        }\n        HibernateUtil.close();\n    }\n    \n    // 约束查询1\n    @Test\n    public void test03() {\n        String hql = "from Dept where dname = ?";\n        Session session = HibernateUtil.getSession();\n        Transaction tx = session.beginTransaction();\n        Query query = session.createQuery(hql);\n        \n        query.setString(0 , "会计部");\n        \n        List<Dept> list = query.list();\n        for (Dept dept : list) {\n            System.out.println(dept);\n        }\n        \n        tx.commit();\n        HibernateUtil.close();\n    }\n    \n    // 约束查询2\n    @Test\n    public void test04() {\n        String hql = "from Dept where dname = :name ";\n        Session session = HibernateUtil.getSession();\n        Transaction tx = session.beginTransaction();\n        Query query = session.createQuery(hql);\n        query.setString("name" , "会计部");\n        List<Dept> list = query.list();\n        for (Dept dept : list) {\n            System.out.println(dept);\n        }\n        tx.commit();\n        HibernateUtil.close();\n    }\n    \n    // 模糊查询\n    @Test\n    public void test11() {\n        String hql = "from Emp where ename like :name";\n        Session session = HibernateUtil.getSession();\n        Transaction tx = session.beginTransaction();\n        Query query = session.createQuery(hql);\n        \n        // 注意：不能含有单引号直接引用\n        String name = "张";\n        query.setString("name","%"+name+"%");\n        List<Emp> list = query.list();\n        for (Emp emp : list) {\n            System.out.println(emp);\n        }\n    \n        tx.commit();\n        HibernateUtil.close();\n    }\n    \n    // 聚合查询\n    @Test\n    public void test05() {\n        String hql = "select count(*) from Dept";\n        Session session = HibernateUtil.getSession();\n        Transaction tx = session.beginTransaction();\n        Query query = session.createQuery(hql);\n        \n        Long count = (Long) query.uniqueResult();\n        System.out.println("count : " + count);\n        \n        tx.commit();\n        HibernateUtil.close();\n    }\n    \n    // 分页查询\n    @Test\n    public void test06() {\n        String hql = "from Emp";\n        Session session = HibernateUtil.getSession();\n        Transaction tx = session.beginTransaction();\n        Query query = session.createQuery(hql);\n    \n        int index = 2;\n        int pageSize = 5;\n        // 指定 起始位置 和 总量\n        query.setFirstResult((index - 1) * pageSize);\n        query.setMaxResults(pageSize);\n        List<Emp> list = query.list();\n        for (Emp e : list) {\n            System.out.println(e);\n        }\n    \n        tx.commit();\n        HibernateUtil.close();\n    }\n    \n    // 内连接\n    @Test\n    public void test07() {\n        String hql = "from Emp e inner join e.dept";\n        Session session = HibernateUtil.getSession();\n        Transaction tx = session.beginTransaction();\n        Query query = session.createQuery(hql);\n    \n        // 将 emp的外键 deptno结合 dept 连接查询\n        List<Object[]> list = query.list();\n        for (Object[] row : list) {\n            Emp emp = (Emp) row[0];\n            Dept dept = (Dept) row[1];\n            System.out.println("==========");\n            System.out.println("emp : " + emp);\n            System.out.println("dept : " + dept);\n        }\n    \n        tx.commit();\n        HibernateUtil.close();\n    }\n    \n    // 追切内连接\n    // 解决封装的问题\n    @Test\n    public void test08() {\n        String hql = "from Emp e inner join fetch e.dept";\n        Session session = HibernateUtil.getSession();\n        Transaction tx = session.beginTransaction();\n        Query query = session.createQuery(hql);\n        \n        List<Emp> list = query.list();\n        for (Emp emp : list) {\n            System.out.println(emp);\n        }\n        \n        tx.commit();\n        HibernateUtil.close();\n    }\n    \n    // 左外连接\n    @Test\n    public void test09() {\n        String hql = "from Dept d left outer join d.emps";\n        Session session = HibernateUtil.getSession();\n        Transaction tx = session.beginTransaction();\n        Query query = session.createQuery(hql);\n        \n        List<Object[]> list = query.list();\n        for (Object[] row : list) {\n            Dept dept = (Dept) row[0];\n            Emp emp = (Emp) row[1];\n            System.out.println("dept : " + dept.getDname());\n            if (emp != null) {\n                System.out.println(" | "+emp);\n            }else{\n                System.out.println(" | 无员工");\n            }\n        }\n        \n        tx.commit();\n        HibernateUtil.close();\n    }\n    \n    // 追切左连接\n    @Test\n    public void test10() {\n        String hql = "select distinct d from Dept d left outer join fetch d.emps";\n        Session session = HibernateUtil.getSession();\n        Transaction tx = session.beginTransaction();\n        Query query = session.createQuery(hql);\n        \n        List<Dept> list = query.list();\n        for (Dept dept : list) {\n            System.out.println("dept : " + dept.getDname());\n            Set<Emp> emps = dept.getEmps();\n            if (emps != null && emps.size() > 0) {\n                for (Emp emp : emps) {\n                    System.out.println("\\t" + emp.getEname());\n                }\n            } else {\n                System.out.println("\\t无员工");\n            }\n            \n        }\n        \n        tx.commit();\n        HibernateUtil.close();\n    }\n\n}\n\n\n\n# Criteria\n\norg.hibernate.Criteria是 面向对象的方式在进行数据查询，无需手写hql语句\n\n特点：\n\n * 面向对象查询\n * 摆脱hql语句拼接的应用\n\nCriteria对象获取\n\n==Session.createCriteria(Class Bean)==\n\n常用方法\n\n获取结果集\n\n返回       方法               说明\nList     list()           获取结果集列表\nObject   uniqueResult()   获取单个结果，没有则null\n\n查询约束\n\n返回          方法                                       参数              说明\nCriterion   add(Criterion criterion)                 约束criterion对象   添加 约束条件\nCriterion   setMaxResults(int maxResults)            行最大值            设置 查询最大行数\nCriterion   setFirstResult(int firstResult)          行起始值            设置 查询起始行数\nCriterion   createCriteria(String associationPath)   属性数据集名称         添加数据集 内连接\n\n> org.hibernate.criterion.Criterion约束对象（一般应用传递约束\n\norg.hibernate.criterion.Restrictions标准约束对象\n\nRestrictions对象 内置封装了常用约束静态方法\n\n常用约束方法\n\n返回          方法                                                   说明\nCriterion   idEq(Object value)                                   比较id\nCriterion   eq(String propertyName, Object value)                比较指定属性\nCriterion   like(String propertyName, Object value)              模糊指定属性\nCriterion   ilike(String propertyName, Object value)             模糊指定属性（省略大小写\nCriterion   and(Criterion lhs, Criterion rhs)                    合并约束（同时满足）\nCriterion   or(Criterion lhs, Criterion rhs)                     满足约束（其中满足）\nCriterion   not(Criterion expression)                            约束取反（满足取反）\nCriterion   between(String propertyName, Object lo, Object hi)   选区范围值\n....        ....                                                 ....\n\n> 方法比较多 自行查询API\n\norg.hibernate.criterion.Example实例对象约束\n\nExample对象 内置实例对象查询的方法一般情况直接写入实例对象即可\n\n// sfrom emp\nList results = session.createCriteria(Emp.class)\n      \t\t\t.add( Example.create(emp).ignoreCase())\n      \t\t\t.list();\n\n\n示例：\n\n数据库表\n\ndept部门表\n\n字段名      类型        说明    外键\ndeptno   int       id    key\ndname    varchar   部门名   -\nloc      varhcar   区     -\n\nemp员工表\n\n字段名      类型             说明     外键\nempno    int            id     key\nename    varchar        员工名称   -\nsal      decimal （浮点型   工资     -\ndeptno   int            部门id   dept.deptno\n\n> PS：由于员工的工资属性sal 应用的是 BigDecimal 数据类型\n\n// 普通类表查询\n@Test\npublic void test01() {\n    Session session = HibernateUtil.getSession();\n    Transaction tx = session.beginTransaction();\n    \n    Criteria cr = session.createCriteria(Emp.class);\n    List<Emp> list = cr.list();\n    for (Emp emp : list) {\n        System.out.println(emp);\n    }\n    \n    tx.commit();\n    HibernateUtil.close();\n}\n\n// 约束查询\n@Test\npublic void test02() {\n    Session session = HibernateUtil.getSession();\n    Transaction tx = session.beginTransaction();\n\n    Criteria cr = session.createCriteria(Emp.class);\n    // 约束查 大于等于\n    cr.add(Restrictions.ge("sal",new BigDecimal(5000)));\n    List<Emp> list = cr.list();\n    for (Emp emp : list) {\n        System.out.println(emp);\n    }\n    \n    tx.commit();\n    HibernateUtil.close();\n}\n\n\n// 实例查询\n@Test\npublic void test03() {\n    Session session = HibernateUtil.getSession();\n    Transaction tx = session.beginTransaction();\n    \n    Criteria cr = session.createCriteria(Emp.class);\n\n    Emp emp = new Emp();\n    emp.setJob("CLERK");\n\n    cr.add(Example.create(emp));\n    List<Emp> list = cr.list();\n    for (Emp e : list) {\n        System.out.println(e);\n    }\n    \n    tx.commit();\n    HibernateUtil.close();\n}\n\n// 链式内连接查询\n@Test\npublic void test04() {\n    Session session = HibernateUtil.getSession();\n    Transaction tx = session.beginTransaction();\n    \n    List<Dept> depts =\n            session.createCriteria(Dept.class)\n                    .add(Restrictions.eq("dname","cqc"))\n                    .createCriteria("emps")\n                    .add(Restrictions.eq("ename","j4"))\n                    .list();\n    for (Dept dept : depts) {\n        System.out.println(dept);\n    }\n    \n    tx.commit();\n    HibernateUtil.close();\n}\n\n// 表达式and约束查询\n@Test\npublic void test05() {\n    Session session = HibernateUtil.getSession();\n    Transaction tx = session.beginTransaction();\n    \n    // 查工资大于5k 且 职位为 CLERK\n    Criterion crSal = Restrictions.gt("sal",new BigDecimal(5000));\n    Criterion crJob = Restrictions.eq("job","CLERK");\n\n    List<Emp> emps =\n    session.createCriteria(Emp.class)\n            .add(Restrictions.and(crSal,crJob))\n            .list();\n\n    for (Emp emp : emps) {\n        System.out.println(emp);\n    }\n    \n    tx.commit();\n    HibernateUtil.close();\n}\n\n\n\n# 缓存机制\n\n\n# 一级缓存\n\nHibernate一级缓存是强制性的缓存，在 Session层(会话)\n\n**清空缓存条件：**Session关闭、数据更变\n\n\n# 二级缓存\n\nHibernate一级缓存是选择性的缓存，主要负责跨会话缓存对象。\n\n需要直接配置策略\n\n\n# Hibernate问题\n\n 1. hql语句 问题\n    \n    * hql语句中的 表名的首字母一定要大写 （因：与类名一致，否则找不着\n    * 遵守数据库命名规则\n\n 2. 联级操作 问题\n    \n    * 要手动添加 <set>.cascade属性/<generator>.classid自增策略 的应用（因：反向生成不会生成\n    \n    * 在联级添加数据时，尽可能避免指定外键id值添加数据（因：id值约束可能影响数据的添加\n    \n    * 在联级添加数据时，一方 配置的 <set>.inverse属性为true ，会产生二级数据的外键id为空，解决方式方案：将含有主键的一方设为 关系维护方即可\n      \n      原因: 以上的设置是 将 一方的 关系维护 交给多方管理,那么多方 在插入数据时会 根据对象的联级关系进行插入的，而一方的主键id生成在写入数据库之后生成的，因此二级的外键id为空\n    \n    * 在联级删除 多的一方，<set>.cascade属性值不能为none\n    \n    * 在联级删除 单的一方时，不能含有该属性cascade\n\n 3. 反向生成 问题\n    \n    * 反向生成xml，不会生成 <generator>.classid自增策略（因：id可能会相同导致异常\n    * 反向生成实体对象，实体对象的 对多关系 的 集合数据 需要初始化 （因：不初始化联级操作可能会出现异常\n\n 4. 对多数据 问题\n    \n    * 多对一 查询：<many-to-one>标签 添加 ==insert="false" update="false"==属性（因：在查询中可能会出现重复列的问题\n    * 多对多 删除：多对多含有关系表的情况下，只要一方的数据被删除完，另一方还会存在数据指定的是双方的外键id（因：两表的外键约束的在第三方的关系表中，因此两表的是互补干扰的！',normalizedContent:'# hibernate\n\nhibernate 将 java对象与数据库表之间建立起映射关系，并提供了一系列数据访问接口，可随心所欲对库进行操作\n\n好处：\n\n * dao层开发简单\n * 兼容性好支持大多数主流数据库\n * 有二级缓存机制\n * 省略手动编写sql语句（自动生成\n\nhibernate 开发包： hibernate 官网\n\n目录说明：\n\n * documentation：开发文档\n * lib：依赖jar包\n * project：工程实例\n\n学习参考文档：\n\n 1. https://www.w3cschool.cn/hibernate/skzl1idz.html\n 2. http://c.biancheng.net/hibernate/\n\n\n# orm\n\norm 是 object relational mapping 的缩写，译为“对象关系映射”，它解决了对象和关系型数据库之间的数据交互问题\n\n库与对象的关系\n\n数据库       类对象\n表         类\n表记录(数据)   对象\n表字段       对象属性\n\norm缺点\n\n * 学习成本高\n * 自动生成sql会消耗资源\n * 复杂的sql难以处理（有时候不如手写sql\n\n好处上面有了（总之是jdbc使用的优化版\n\n\n# hibernate架构\n\n\n# 配置对象\n\n用于 连接数据库 / 创建类和表映射关系 的主要 配置文件\n\n默认全局配置文件：hibernate.cfg.xml\n\n\n# 会话工厂对象\n\nsessionfactory对象 用于 分配线程的应用(安全线程)，以防异步错乱的情况\n\n\n# 会话对象\n\nsession对象 用于与数据库的物理连接\n\n详细说明：https://www.w3cschool.cn/hibernate/93tz1ied.html\n\n\n# 事务对象\n\ntransaction对象 每个事务代表 一个单元crud操作 (一个以上\n\n\n# 查询对象\n\norg.hibernate.query对象 用于 自定义sql / hibernate语句 查询的数据集\n\n对象获取\n\n==session.createquery(string hql);==\n\n常用方法（结果集获取\n\n返回            方法               说明\nr             uniqueresult()   查询结果的单条数据，没有则null\nlist<r>       list()           查询结果集以list形式的结果\niterator<r>   iterate()        查询结果集以迭代器形式的结果\n\n> 注意：list()方法 返回的数据 如果不为 实体对象的属性，那么它返回的是 object[]数组\n\n\n# 约束对象\n\ncriteria对象 指定查询对象\n\n\n# 配置属性\n\n属性                                  说明\nhibernate.dialect                   配选定指定 库 生成对应的sql\nhibernate.connection.driver_class   加载 jdbc驱动\nhibernate.connection.url            连接库的url\nhibernate.connection.username       用户名\nhibernate.connection.password       密码\nhibernate.connection.pool_size      连接池中连接的数量\nhibernate.connection.autocommit     允许jdbc自动提交模式\n\nmapping标签\n\n * resource 指定的是需要已经配置好的 orm映射xml文件\n * class 指定实体对象（用于注解）\n\n示例：\n\n<?xml version="1.0" encoding="utf-8"?>\n<!doctype hibernate-configuration system \n"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">\n\n<hibernate-configuration>\n   <session-factory>\n   <property name="hibernate.dialect">org.hibernate.dialect.mysqldialect</property>\n   <property name="hibernate.connection.driver_class">com.mysql.jdbc.driver</property>\n       \n   <property name="hibernate.connection.url">jdbc:mysql://localhost/test</property>\n   <property name="hibernate.connection.username">root</property>\n   <property name="hibernate.connection.password">root123</property>\n\n   <mapping resource="employee.hbm.xml"/>\n</session-factory>\n</hibernate-configuration> \n\n\n\n# 映射文件\n\n映射文件 主要用于 让配置文件对应对接的映射配置，但也与实体类对接\n\n命名规则： ==<实体类名>.hbm.xml==\n\n标签描述：\n\n * <hibernate-mapping>：根元素的 xml 文件\n\n * <class>：指定 实体类 -> 数据库表 的特定映射\n   \n   * name：实体类（全限定名\n   * table：数据库表名称\n\n * <id>：类属性id / 表id字段 关联（唯一！！）\n   \n   * name：类属性名\n   \n   * column：表字段名\n   \n   * type：映射类型\n   \n   * <generator> 自动生成主键值\n     \n     * class：主键自增形式\n       \n       generator.class值   说明\n       identity           库底层自增机制\n       increment          hibernate实现自增\n       assigned           字符串主键（算法生成\n       sequence           序列生成主键\n\n * <property>：实体类属性 与 库表字段的匹配\n   \n   * name：类属性名\n   * column：表字段名\n   * type：映射类型\n\n映射的数据类型：https://www.w3cschool.cn/hibernate/fzum1iem.html\n\n示例：\n\n<?xml version="1.0" encoding="utf-8"?>\n<!doctype hibernate-mapping public \n "-//hibernate/hibernate mapping dtd//en"\n "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"> \n\n<hibernate-mapping>\n   <class name="employee" table="employee">\n      <meta attribute="class-description">\n         this class contains the employee detail. \n      </meta>\n      <id name="id" type="int" column="id">\n         <generator class="identity"/>\n      </id>\n      <property name="firstname" column="first_name" type="string"/>\n      <property name="lastname" column="last_name" type="string"/>\n      <property name="salary" column="salary" type="int"/>\n   </class>\n</hibernate-mapping>\n\n\n\n# hibernate应用\n\nhibernate上机操作应用\n\n\n# 搭建环境 idea\n\n搭建步骤：\n\n 1. 引入lib\n 2. 连接数据库\n 3. 项目结构 -> 模块 -> 选中项目 ->添加 hibernate框架 (手动添加/生成 框架需要指定全局配置配置文件)\n\n\n# 连接操作\n\n应用前提：\n\n * 已经包含有 实体类/数据库数据 ，且他们的 实体类属性/数据库表字段 数据类型一致\n * orm映射关系和全局配置已经完善\n\n\n\n连接步骤：\n\n 1. 读取解析 全局配置文件\n    \n    ==configuration config = new configuration().configure();==\n\n 2. 读取解析映射信息，创建sessionfactiory\n    \n    ==sessionfactory sf = conf.buildsessionfactory();==\n\n 3. 获取session ==session session = sf.opensession();==\n\n 4. 启动事务\n    \n    ==transaction tx = session.begintransaction();==\n\n 5. crud操作数据 （通过session进行操作\n\n 6. 提交事务\n\n 7. 关闭资源\n\n应用工具类\n\n> 注意：由于新版使用的是 服务注册的形式 进行应用的，因此步骤可能有不一样\n\npackage com.sans.util;\n\nimport org.hibernate.session;\nimport org.hibernate.sessionfactory;\nimport org.hibernate.cfg.configuration;\nimport org.hibernate.service.serviceregistry;\nimport org.hibernate.service.serviceregistrybuilder;\n\npublic class hibernateutil {\n    private static serviceregistry sr;\n    private static sessionfactory sf;\n    private static threadlocal<session> localthread = new threadlocal<>();\n    \n    static {\n        configuration config = new configuration().configure();\n        sr = new serviceregistrybuilder().applysettings(\n                config.getproperties()).buildserviceregistry();\n        config.buildsessionfactory(sr);\n        sf = config.buildsessionfactory(sr);\n    }\n    \n    /**\n     * 获取会话\n     */\n    public static session getsession() {\n        session session = localthread.get();\n        if (session == null || ! session.isopen()) {\n            session = sf.opensession();\n            localthread.set(session);\n        }\n        return session;\n    }\n    \n    /**\n     * 关闭会话\n     */\n    public static void close() {\n        session session = localthread.get();\n        if (session != null) {\n            session.close();\n            localthread.remove();\n            sf.close();\n        }\n    }\n}\n\n\n\n# 注解\n\nhibernate注解 是摆脱了 xml 配置文件的应用\n\n应用前提：\n\n * hibernate 3.x 以上的注释包\n * 关系jar包：\n    * annotations.jar\n    * hibernate-comons-annotations.jar\n    * ejb3-persistence.jar\n\n\n\n注释                范围   参数                                        说明\n@entity           类    -                                         标志位实体类 bean\n@table            类    string name 表名称                           映射表的配置\n                       string catalog 目录\n                       string schema 模式\n                       uniqueconstraint[] uniqueconstraints 约束\n@id               属性   -                                         主键\n@generatedvalue   属性   generationtype strategy 策略                主键自动生成策略（一般默认即可）\n                       string generator\n@column           属性   string name 允许唯一                          定义属性与字段的细节属性\n                       int length 指定数据长度\n                       boolean nullable 非空\n                       boolean unique 唯一\n\n示例：\n\nsql：\n\ncreate table employee (\n   id int not null auto_increment,\n   first_name varchar(20) default null,\n   last_name  varchar(20) default null,\n   salary     int  default null,\n   primary key (id)\n);\n\n\n实体对象：\n\nimport javax.persistence.*;\n\n@entity\n@table(name = "employee")\npublic class employee {\n   @id @generatedvalue\n   @column(name = "id")\n   private int id;\n\n   @column(name = "first_name")\n   private string firstname;\n\n   @column(name = "last_name")\n   private string lastname;\n\n   @column(name = "salary")\n   private int salary;  \n\n   public employee() {}\n   public int getid() {\n      return id;\n   }\n   public void setid( int id ) {\n      this.id = id;\n   }\n   public string getfirstname() {\n      return firstname;\n   }\n   public void setfirstname( string first_name ) {\n      this.firstname = first_name;\n   }\n   public string getlastname() {\n      return lastname;\n   }\n   public void setlastname( string last_name ) {\n      this.lastname = last_name;\n   }\n   public int getsalary() {\n      return salary;\n   }\n   public void setsalary( int salary ) {\n      this.salary = salary;\n   }\n}\n\n\n\n# 反向工程\n\n反向工程操作原意 数据库表 -> 实体类\n\nidea反向工程步骤：\n\n**前提：**项目已 引入hibernate框架\n\n 1. 双击shift -> 操作项搜索persistence\n 2. 选中项目右键 -> 生成持久映射\n 3. 指定数据库映射即可\n\n添加 数据构架的映射关系 添加关系映射关系一般用于 ==一对一 / 一对多 / 多对多== 的情况应用\n\n确认必要信息\n\n * 源/目标 特定名称 (指定实体对象的属性名)\n\n * 源/目标 属性类型 （多则集合/少则对象\n\n * 联接列 必须选中 源的表字段/目标的表字段 两者是外键关系（一定要是外键关系\n\n * 多对多情况：需要手动指定联接表(第三表)进行对两表的进行连接\n   \n   需要手动确认4个列 分别为 ==源id / 第三表外键源id / 目标id / 第三表外键目标id==\n\n\n# 关联映射\n\n在关联映射当中有三种形式，分别为：\n\n * 一对一\n * 一对多\n * 多对多\n\n\n# 一对多\n\n一方： 多方 的实体集合 ，通过标签 <set> 完成\n\n多方： 一方 的实体类，通过标签 <many-to-one>\n\n必要标签说明：\n\n<many-to-one>：多对一\n\n * name：关联对象的属性名\n * column：实体类对应的外键表字段名\n * class：关联对象类（全限定名\n\n<set>：一对多\n\n * name：关联对象属性名\n * <key>.column：关联对象的外键名\n * <one-to-many>.class：关联对象类（全限定名\n\n> 一般情况会反向自动生成的xml\n\n联级操作：\n\n<set>.cascade ：联级操作\n\n * delete ：联级删除\n * all ： 联级增删改\n * sace-update ：联级 增加/修改\n\n一对多示例：(部门一 - 员工多)\n\nstaff员工表\n\n字段名      类型        说明     外键\nid       int       -      key\nname     varchar   名称     -\ndeptid   int       部门id   dept.id\n\ndept部门表\n\n字段名    类型        说明     外键\nid     int       -      key\nname   varchar   部门名称   -\n\nstaff员工实体-xml配置\n\n// staff.java 员工实体对象\npublic class staff {\n    private int id;\n    private string name;\n    // 主要关系对象\n    private dept dept;\n    //get、set配置。。。\n｝\n....\n\x3c!-- staff.hbm.xml 配置 --\x3e \n<hibernate-mapping>\n    \x3c!-- onetomany.staff 包路径 / staff 表名 --\x3e \n    <class name="onetomany.staff" table="staff">\n        <id name="id" column="id">\n            <generator class="increment"></generator>\n        </id>\n        <property name="name"></property>\n    \t\x3c!--  \n                name: staff实体类中的dept属性\n                column: 子表中被外键约束修饰的字段名\n\t\t\t\tclass: staff相关联的dept类\n        --\x3e\n        <many-to-one name="dept" column="deptid" class="onetomany.dept"></many-to-one>\n    </class>\n</hibernate-mapping>\n\n\ndept员工实体-xml配置\n\npublic class dept {\n    private int id;\n    private string name;\n    // 建议手动创建初始化集合对象\n    private set<staff> staffset = new hashset<>(0);\n\t// get、set配置。。。\n｝\n....\n\x3c!-- staff.hbm.xml 配置 --\x3e\n<hibernate-mapping>\n    <class name="onetomany.dept" table="dept">\n        <id name="id" column="id">\n            <generator class="increment"></generator>\n        </id>\n        <property name="name"></property>\n    \t\x3c!-- key：子表被外键约束修饰的字段名 --\x3e \n        <set name="staffset" cascade="all">\n            <key column="deptid"/>\n            <one-to-many class="onetomany.staff"/>\n        </set>\n    </class>    \n</hibernate-mapping>\n\n\n测试访问：\n\n// 多对一\n@test\npublic void add(){\n    // 假设已经获取到了 session 对象\n    \n    //创建新部门\n    dept dept = new dept();\n    dept.setname("er部门");\n\n　　//创建新的职员\n    staff staff = new staff();\n    staff.setname("www");\n\n　　//给职员中添加部门\n    staff.setdept(dept);\n        \n　　//给部门中添加职员\n    dept.getstaffset().add(staff);\n        \n　　//保存部门\n    session.save(dept);\n}\n\n@test\npublic void del(){\n\t// 假设已经获取到了 session 对象\n    // 指定查询id : 2\n\tdept dept = (dept) sesslin.get(dept.class,2);\n    session.delete(dept);\n  \t\n    // 删除会连同指定相同的id：2的部门一起删除\n}\n\n@test\npublic void find(){\n    // 假设已经获取到了 session 对象\n \tdept dept = (dept) sesslin.get(dept.class,2);\n    system.out.println(dept);\n    for(staff staff : detp.getseaff()){\n        system.out.println(staff);\n    }\n}\n\n\n\n# 多对多\n\n多对多关系 是两表之间对多关系，通常会以第三表为中间作为两表联系的关系表。两张表都只和关系表间建立主外键关系！\n\n<many-to-many>：多对多\n\n * name：关联对象的属性名\n * column：实体类对应的外键表字段名\n * class：关联对象类（全限定名\n\n应用说明：\n\n * 多对多的应用 也需要 cascade 联级操作 的操作\n\n\n\n**多对多示例：**(功能多 - 角色多) （不同角色有不同的功能\n\nmenu菜单表\n\n字段名       类型        说明     外键\nm_id      int       -      key\nm_name    varchar   菜单名称   -\nm_state   int       状态     -\n\nrole角色表\n\n字段名       类型        说明     外键\nr_id      int       -      key\nr_name    varchar   角色名称   -\nr_state   int       状态     -\n\n关系表\n\n字段名    类型    说明     外键\nid     int   -      key\nm_id   int   菜单id   menu.id\nr_id   int   角色id   role.id\n\nrole角色实体-xml配置\n\npublic class role {\n    private int rid;\n    private string rname;\n    private integer rstate;\n    private set<menu> menus = new hashset<>(0);\n\t// get/set ... \n}\n...\n\x3c!-- role.hbm.xml 配置 --\x3e\n<hibernate-mapping>\n    \x3c!-- com.sans.pojo.role 包路径 / role 表名 / hospital 数据库名 --\x3e\n    <class name="com.sans.pojo.role" table="role" schema="hospital">\n        <id name="rid">\n            <column name="r_id" sql-type="int"/>\n            <generator class="native"/>\n        </id>\n        <property name="rname">\n            <column name="r_name" sql-type="varchar(80)" length="80" not-null="true"/>\n        </property>\n        <property name="rstate">\n            <column name="r_state" sql-type="int" not-null="true"/>\n        </property>\n        \x3c!-- 联级操作第三表 需要配置 cascade="all" --\x3e\n        <set name="menus" table="role_menu" cascade="all">\n            \x3c!-- 外键字段 --\x3e\n            <key column="r_id"/>\n            \x3c!-- 集合对应的实体类 --\x3e\n            <many-to-many class="com.sans.pojo.menu" column="m_id"/>\n        </set>\n    </class>\n</hibernate-mapping>\n\n\nmenu菜单实体-xml配置\n\npublic class menu {\n    private int mid;\n    private string mname;\n    private integer mstate;\n    private set<role> roles = new hashset<>(0);\n\t// get/set ...\n}\n....\n\x3c!-- menu.hbm.xml 配置 --\x3e\n<hibernate-mapping>\n    <class name="com.sans.pojo.menu" table="menu" schema="hospital">\n        <id name="mid">\n            <column name="m_id" sql-type="int"/>\n            <generator class="native"/>\n        </id>\n        <property name="mname">\n            <column name="m_name" sql-type="varchar(80)" length="80" not-null="true"/>\n        </property>\n        <property name="mstate">\n            <column name="m_state" sql-type="int" not-null="true"/>\n        </property>\n        \x3c!-- 联级操作第三表 需要配置 cascade="all" --\x3e\n        <set name="roles" table="role_menu" cascade="all">\n            \x3c!-- 外键字段 --\x3e\n            <key column="m_id"/>\n            \x3c!-- 集合对应的实体类 --\x3e\n            <many-to-many class="com.sans.pojo.role" column="r_id"/>\n        </set>\n    </class>\n</hibernate-mapping>\n\n\n测试：\n\n@test\npublic void findbymenu() {\n    session session = hibernateutil.getsession();\n    transaction tx = session.begintransaction();\n    \n    menu menu = (menu) session.get(menu.class , 4);\n    system.out.println("menu : " + menu);\n    system.out.println("menu.roles : " + menu.getroles());\n    \n    tx.commit();\n    hibernateutil.close();\n}\n\n@test\npublic void findbyrole() {\n    session session = hibernateutil.getsession();\n    transaction tx = session.begintransaction();\n    \n    \n    role role = (role) session.get(role.class,1);\n    system.out.println("role : " + role);\n    system.out.println("role.menus : " + role.getmenus());\n    \n    tx.commit();\n    hibernateutil.close();\n\n}\n\n// 联级添加\n@test\npublic void add() {\n\n    session session = hibernateutil.getsession();\n    transaction tx = session.begintransaction();\n    \n    menu menu = new menu("xx管理",22);\n    system.out.println("menu : " + menu);\n    \n    role role1 = new role("医生",1);\n    role role2 = new role("主管",1);\n    \n    menu.getroles().add(role1);\n    menu.getroles().add(role2);\n    \n    session.save(menu);\n    \n    tx.commit();\n    session.close();\n}\n\n// 联级删除\n@test\npublic void del() {\n    session session = hibernateutil.getsession();\n    transaction tx = session.begintransaction();\n    \n    // 根据指定的 role.id进行删除\n    role role = new role();\n    role.setrid(39);\n    \n    // 指定 menu.id进行删除\n    // menu menu = new menu();\n    // menu.setmid(23);\n    \n    session.delete(role);\n    \n    tx.commit();\n    hibernateutil.close();\n}\n\n\n\n# 高级查询\n\nhibernate 框架 提供了两个用于查询的对象分别为 query、criteria对象\n\n> criteria对象 应用起来方法较多，自行了解：\n> \n> https://www.w3cschool.cn/hibernate/ugov1ie8.html\n\n\n# query\n\nquery查询方式 依靠自行编写的 hql语句进行查询数据\n\nquery对象获取\n\n==session.createquery(string hql)==\n\nquery常用方法\n\n获取结果集方法\n\n返回            方法               说明\nr             uniqueresult()   查询结果的单条数据，没有则null\nlist<r>       list()           查询结果集以list形式的结果\niterator<r>   iterate()        查询结果集以迭代器形式的结果\n\n> **注意：**list()方法 返回的数据 如果不为 实体对象的属性，那么它返回的是 object[]数组\n\n其他方法\n\n返回      方法                                   说明\nquery   setxx( string/int , xx) (xx为数据类型名)   填充hql语句的 数据/占位符\nquery   setfirstresult(int firstresult)      设置 查询起始行数\nquery   setmaxresults(int maxresults)        设置 查询最大行数\n\n更多方法可以在自行查看源码\n\nquery查询示例\n\n示例说明：\n\n * 仅展现功能代码块\n * 两表关系为 一对多 (一部门 - 多员工)\n\n\n\n**数据库表**\n\ndept部门表\n\n字段名      类型        说明    外键\ndeptno   int       id    key\ndname    varchar   部门名   -\nloc      varhcar   区     -\n\nemp员工表\n\n字段名      类型             说明     外键\nempno    int            id     key\nename    varchar        员工名称   -\nsal      decimal （浮点型   工资     -\ndeptno   int            部门id   dept.deptno\n\npublic class demo {\n\n    // 对象查询\n    @test\n    public void test01() {\n        // 查 部门对象\n        string hql = "from dept";\n        session session = hibernateutil.getsession();\n        query query = session.createquery(hql);\n        list<dept> list = query.list();\n        for (dept dept : list) {\n            system.out.println("dept : " + dept);\n        }\n    }\n    \n    // 属性查询\n    @test\n    public void test02() {\n        // 查 指定部门\n        string hql = "select loc,deptno from dept";\n        session session = hibernateutil.getsession();\n        query query = session.createquery(hql);\n        list<object[]> list = query.list();\n        for (object[] row : list) {\n            system.out.println(row[0] + "\\t - \\t" + row[1]);\n        }\n        hibernateutil.close();\n    }\n    \n    // 约束查询1\n    @test\n    public void test03() {\n        string hql = "from dept where dname = ?";\n        session session = hibernateutil.getsession();\n        transaction tx = session.begintransaction();\n        query query = session.createquery(hql);\n        \n        query.setstring(0 , "会计部");\n        \n        list<dept> list = query.list();\n        for (dept dept : list) {\n            system.out.println(dept);\n        }\n        \n        tx.commit();\n        hibernateutil.close();\n    }\n    \n    // 约束查询2\n    @test\n    public void test04() {\n        string hql = "from dept where dname = :name ";\n        session session = hibernateutil.getsession();\n        transaction tx = session.begintransaction();\n        query query = session.createquery(hql);\n        query.setstring("name" , "会计部");\n        list<dept> list = query.list();\n        for (dept dept : list) {\n            system.out.println(dept);\n        }\n        tx.commit();\n        hibernateutil.close();\n    }\n    \n    // 模糊查询\n    @test\n    public void test11() {\n        string hql = "from emp where ename like :name";\n        session session = hibernateutil.getsession();\n        transaction tx = session.begintransaction();\n        query query = session.createquery(hql);\n        \n        // 注意：不能含有单引号直接引用\n        string name = "张";\n        query.setstring("name","%"+name+"%");\n        list<emp> list = query.list();\n        for (emp emp : list) {\n            system.out.println(emp);\n        }\n    \n        tx.commit();\n        hibernateutil.close();\n    }\n    \n    // 聚合查询\n    @test\n    public void test05() {\n        string hql = "select count(*) from dept";\n        session session = hibernateutil.getsession();\n        transaction tx = session.begintransaction();\n        query query = session.createquery(hql);\n        \n        long count = (long) query.uniqueresult();\n        system.out.println("count : " + count);\n        \n        tx.commit();\n        hibernateutil.close();\n    }\n    \n    // 分页查询\n    @test\n    public void test06() {\n        string hql = "from emp";\n        session session = hibernateutil.getsession();\n        transaction tx = session.begintransaction();\n        query query = session.createquery(hql);\n    \n        int index = 2;\n        int pagesize = 5;\n        // 指定 起始位置 和 总量\n        query.setfirstresult((index - 1) * pagesize);\n        query.setmaxresults(pagesize);\n        list<emp> list = query.list();\n        for (emp e : list) {\n            system.out.println(e);\n        }\n    \n        tx.commit();\n        hibernateutil.close();\n    }\n    \n    // 内连接\n    @test\n    public void test07() {\n        string hql = "from emp e inner join e.dept";\n        session session = hibernateutil.getsession();\n        transaction tx = session.begintransaction();\n        query query = session.createquery(hql);\n    \n        // 将 emp的外键 deptno结合 dept 连接查询\n        list<object[]> list = query.list();\n        for (object[] row : list) {\n            emp emp = (emp) row[0];\n            dept dept = (dept) row[1];\n            system.out.println("==========");\n            system.out.println("emp : " + emp);\n            system.out.println("dept : " + dept);\n        }\n    \n        tx.commit();\n        hibernateutil.close();\n    }\n    \n    // 追切内连接\n    // 解决封装的问题\n    @test\n    public void test08() {\n        string hql = "from emp e inner join fetch e.dept";\n        session session = hibernateutil.getsession();\n        transaction tx = session.begintransaction();\n        query query = session.createquery(hql);\n        \n        list<emp> list = query.list();\n        for (emp emp : list) {\n            system.out.println(emp);\n        }\n        \n        tx.commit();\n        hibernateutil.close();\n    }\n    \n    // 左外连接\n    @test\n    public void test09() {\n        string hql = "from dept d left outer join d.emps";\n        session session = hibernateutil.getsession();\n        transaction tx = session.begintransaction();\n        query query = session.createquery(hql);\n        \n        list<object[]> list = query.list();\n        for (object[] row : list) {\n            dept dept = (dept) row[0];\n            emp emp = (emp) row[1];\n            system.out.println("dept : " + dept.getdname());\n            if (emp != null) {\n                system.out.println(" | "+emp);\n            }else{\n                system.out.println(" | 无员工");\n            }\n        }\n        \n        tx.commit();\n        hibernateutil.close();\n    }\n    \n    // 追切左连接\n    @test\n    public void test10() {\n        string hql = "select distinct d from dept d left outer join fetch d.emps";\n        session session = hibernateutil.getsession();\n        transaction tx = session.begintransaction();\n        query query = session.createquery(hql);\n        \n        list<dept> list = query.list();\n        for (dept dept : list) {\n            system.out.println("dept : " + dept.getdname());\n            set<emp> emps = dept.getemps();\n            if (emps != null && emps.size() > 0) {\n                for (emp emp : emps) {\n                    system.out.println("\\t" + emp.getename());\n                }\n            } else {\n                system.out.println("\\t无员工");\n            }\n            \n        }\n        \n        tx.commit();\n        hibernateutil.close();\n    }\n\n}\n\n\n\n# criteria\n\norg.hibernate.criteria是 面向对象的方式在进行数据查询，无需手写hql语句\n\n特点：\n\n * 面向对象查询\n * 摆脱hql语句拼接的应用\n\ncriteria对象获取\n\n==session.createcriteria(class bean)==\n\n常用方法\n\n获取结果集\n\n返回       方法               说明\nlist     list()           获取结果集列表\nobject   uniqueresult()   获取单个结果，没有则null\n\n查询约束\n\n返回          方法                                       参数              说明\ncriterion   add(criterion criterion)                 约束criterion对象   添加 约束条件\ncriterion   setmaxresults(int maxresults)            行最大值            设置 查询最大行数\ncriterion   setfirstresult(int firstresult)          行起始值            设置 查询起始行数\ncriterion   createcriteria(string associationpath)   属性数据集名称         添加数据集 内连接\n\n> org.hibernate.criterion.criterion约束对象（一般应用传递约束\n\norg.hibernate.criterion.restrictions标准约束对象\n\nrestrictions对象 内置封装了常用约束静态方法\n\n常用约束方法\n\n返回          方法                                                   说明\ncriterion   ideq(object value)                                   比较id\ncriterion   eq(string propertyname, object value)                比较指定属性\ncriterion   like(string propertyname, object value)              模糊指定属性\ncriterion   ilike(string propertyname, object value)             模糊指定属性（省略大小写\ncriterion   and(criterion lhs, criterion rhs)                    合并约束（同时满足）\ncriterion   or(criterion lhs, criterion rhs)                     满足约束（其中满足）\ncriterion   not(criterion expression)                            约束取反（满足取反）\ncriterion   between(string propertyname, object lo, object hi)   选区范围值\n....        ....                                                 ....\n\n> 方法比较多 自行查询api\n\norg.hibernate.criterion.example实例对象约束\n\nexample对象 内置实例对象查询的方法一般情况直接写入实例对象即可\n\n// sfrom emp\nlist results = session.createcriteria(emp.class)\n      \t\t\t.add( example.create(emp).ignorecase())\n      \t\t\t.list();\n\n\n示例：\n\n数据库表\n\ndept部门表\n\n字段名      类型        说明    外键\ndeptno   int       id    key\ndname    varchar   部门名   -\nloc      varhcar   区     -\n\nemp员工表\n\n字段名      类型             说明     外键\nempno    int            id     key\nename    varchar        员工名称   -\nsal      decimal （浮点型   工资     -\ndeptno   int            部门id   dept.deptno\n\n> ps：由于员工的工资属性sal 应用的是 bigdecimal 数据类型\n\n// 普通类表查询\n@test\npublic void test01() {\n    session session = hibernateutil.getsession();\n    transaction tx = session.begintransaction();\n    \n    criteria cr = session.createcriteria(emp.class);\n    list<emp> list = cr.list();\n    for (emp emp : list) {\n        system.out.println(emp);\n    }\n    \n    tx.commit();\n    hibernateutil.close();\n}\n\n// 约束查询\n@test\npublic void test02() {\n    session session = hibernateutil.getsession();\n    transaction tx = session.begintransaction();\n\n    criteria cr = session.createcriteria(emp.class);\n    // 约束查 大于等于\n    cr.add(restrictions.ge("sal",new bigdecimal(5000)));\n    list<emp> list = cr.list();\n    for (emp emp : list) {\n        system.out.println(emp);\n    }\n    \n    tx.commit();\n    hibernateutil.close();\n}\n\n\n// 实例查询\n@test\npublic void test03() {\n    session session = hibernateutil.getsession();\n    transaction tx = session.begintransaction();\n    \n    criteria cr = session.createcriteria(emp.class);\n\n    emp emp = new emp();\n    emp.setjob("clerk");\n\n    cr.add(example.create(emp));\n    list<emp> list = cr.list();\n    for (emp e : list) {\n        system.out.println(e);\n    }\n    \n    tx.commit();\n    hibernateutil.close();\n}\n\n// 链式内连接查询\n@test\npublic void test04() {\n    session session = hibernateutil.getsession();\n    transaction tx = session.begintransaction();\n    \n    list<dept> depts =\n            session.createcriteria(dept.class)\n                    .add(restrictions.eq("dname","cqc"))\n                    .createcriteria("emps")\n                    .add(restrictions.eq("ename","j4"))\n                    .list();\n    for (dept dept : depts) {\n        system.out.println(dept);\n    }\n    \n    tx.commit();\n    hibernateutil.close();\n}\n\n// 表达式and约束查询\n@test\npublic void test05() {\n    session session = hibernateutil.getsession();\n    transaction tx = session.begintransaction();\n    \n    // 查工资大于5k 且 职位为 clerk\n    criterion crsal = restrictions.gt("sal",new bigdecimal(5000));\n    criterion crjob = restrictions.eq("job","clerk");\n\n    list<emp> emps =\n    session.createcriteria(emp.class)\n            .add(restrictions.and(crsal,crjob))\n            .list();\n\n    for (emp emp : emps) {\n        system.out.println(emp);\n    }\n    \n    tx.commit();\n    hibernateutil.close();\n}\n\n\n\n# 缓存机制\n\n\n# 一级缓存\n\nhibernate一级缓存是强制性的缓存，在 session层(会话)\n\n**清空缓存条件：**session关闭、数据更变\n\n\n# 二级缓存\n\nhibernate一级缓存是选择性的缓存，主要负责跨会话缓存对象。\n\n需要直接配置策略\n\n\n# hibernate问题\n\n 1. hql语句 问题\n    \n    * hql语句中的 表名的首字母一定要大写 （因：与类名一致，否则找不着\n    * 遵守数据库命名规则\n\n 2. 联级操作 问题\n    \n    * 要手动添加 <set>.cascade属性/<generator>.classid自增策略 的应用（因：反向生成不会生成\n    \n    * 在联级添加数据时，尽可能避免指定外键id值添加数据（因：id值约束可能影响数据的添加\n    \n    * 在联级添加数据时，一方 配置的 <set>.inverse属性为true ，会产生二级数据的外键id为空，解决方式方案：将含有主键的一方设为 关系维护方即可\n      \n      原因: 以上的设置是 将 一方的 关系维护 交给多方管理,那么多方 在插入数据时会 根据对象的联级关系进行插入的，而一方的主键id生成在写入数据库之后生成的，因此二级的外键id为空\n    \n    * 在联级删除 多的一方，<set>.cascade属性值不能为none\n    \n    * 在联级删除 单的一方时，不能含有该属性cascade\n\n 3. 反向生成 问题\n    \n    * 反向生成xml，不会生成 <generator>.classid自增策略（因：id可能会相同导致异常\n    * 反向生成实体对象，实体对象的 对多关系 的 集合数据 需要初始化 （因：不初始化联级操作可能会出现异常\n\n 4. 对多数据 问题\n    \n    * 多对一 查询：<many-to-one>标签 添加 ==insert="false" update="false"==属性（因：在查询中可能会出现重复列的问题\n    * 多对多 删除：多对多含有关系表的情况下，只要一方的数据被删除完，另一方还会存在数据指定的是双方的外键id（因：两表的外键约束的在第三方的关系表中，因此两表的是互补干扰的！',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"链表",frontmatter:{title:"链表",author:"柏竹",permalink:"/backend/k43waq",date:"2020-02-18T00:00:00.000Z",categories:["后端"],tags:["数据结构","Java"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/06.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.%E9%93%BE%E8%A1%A8.html",relativePath:"01.后端/06.数据结构/04.链表.md",key:"v-5a6df113",path:"/backend/k43waq/",headers:[{level:2,title:"单向链表",slug:"单向链表",normalizedTitle:"单向链表",charIndex:100},{level:2,title:"双向链表",slug:"双向链表",normalizedTitle:"双向链表",charIndex:6406},{level:2,title:"循环链表",slug:"循环链表",normalizedTitle:"循环链表",charIndex:11592},{level:3,title:"单向循环链表",slug:"单向循环链表",normalizedTitle:"单向循环链表",charIndex:11647},{level:3,title:"双向循环链表",slug:"双向循环链表",normalizedTitle:"双向循环链表",charIndex:11750}],headersStr:"单向链表 双向链表 循环链表 单向循环链表 双向循环链表",content:'# 链表\n\n链表（linked list）,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时 i 动态生成\n\n> 数据域： 存储数据的元素 指针域： 存储下个节点的地址\n\n\n# 单向链表\n\n由各个内存结构通过一个 Next 指针链接在一起组成，每一个内存结构都存在后继内存结构(链尾除外），内存结构由数据域和 Next 指针域组成\n\n\n\nMain ：（执行类）\n\npublic class Main {\n    public static void main(String[] args) {\n        \n        //实例 操作对象\n        MyLink myLink = new MyLink();\n        \n        //初始化链表数据\n        // 参数： name ， id\n        Node[] staff = {\n                new Node(121,"小爱" , "00001"),\n                new Node(112,"可怡"  , "00023"),\n                new Node(233,"小黑" , "33123")\n        };\n        \n        //添加链表\n        for(Node tmp : staff){\n            myLink.addLast(tmp);\n        }\n        \n        //添加单链 （最后）\n        myLink.addLast(new Node(232 , "智乃" ,"44221"));\n        \n        //插入单链（索引）  在 "可怡" 节点 链后添加 "黑猫" 节点\n        myLink.addByValue(112 , new Node(234,"黑猫" , "00444"));\n        \n        // 节点值为121  "可怡" 删除\n        myLink.removeNode(112);\n        \n        //查询数据\n        System.out.println("查询节点值 234 的数据 ： ["+myLink.getNode(234)+"]");\n        \n        // 遍历链表\n        System.out.println("=================");\n        for (Node tmp : myLink.getNodeAll()){\n            System.out.println(tmp.toString());\n        }\n        System.out.println("=================");\n        \n    }\n}\n\n\nNode ：（单链节点类）\n\n/**\n * 单列节点\n * 链表中的节点，\n * data   代表节点的值\n * next   指向下一个节点的引用\n * @author Administrator\n */\npublic class Node {\n    \n    /**数据域 （员工数据）\n     * name - 姓名\n     * id - ID号\n     * */\n    String name;\n    String id;\n    \n    /**指针域 （链表数据）\n     * data - 节点的对象，即内容\n     * next - 节点的引用\n     */\n    int data;\n    Node next = null;\n    \n    //构造方法\n    \n    public Node() {\n    }\n    \n    public Node(int data) {\n        this.data = data;\n    }\n    \n    public Node(int data , Node next) {\n        this.data = data;\n        this.next = next;\n    }\n    \n    public Node(String name , String id) {\n        this.name = name;\n        this.id = id;\n    }\n    \n    public Node(int data , String name , String id) {\n        this.data = data;\n        this.name = name;\n        this.id = id;\n    }\n    \n    public Node(int data , Node next , String name , String id ) {\n        this.name = name;\n        this.id = id;\n        this.data = data;\n        this.next = next;\n    }\n    \n    public void setName(String name) {\n        this.name = name;\n    }\n    public void setId(String id) {\n        this.id = id;\n    }\n    \n    @Override\n    public String toString() {\n        return "Node{" +\n                "name=\'" + name + \'\\\'\' +\n                ", id=\'" + id + \'\\\'\' +\n                ", data=" + data +\n                // ", next=" + next +\n                \'}\';\n    }\n    \n}\n\n\nMyLink ：（链表操作类）\n\npublic class MyLink {\n    //头节点\n    Node head = null;\n    \n    /**\n     * 链表尾部添加节点\n     * @param d 节点值\n     * @return 是否成功\n     */\n    public boolean addLast(int d){\n        //实例节点\n        Node newNode = new Node(d);\n        //第一次创建的链头\n        if (head == null){\n            head = newNode;\n            return true;\n        }\n        Node tmp = head;\n        //遍历链表 循环直到最后 Node.next = null 空的节点引用\n        while (tmp.next != null){\n            //往后移一个节点，指向下一个节点\n            tmp = tmp.next;\n        }\n        //在最后面null节点添加新节点\n        tmp.next = newNode;\n        return true;\n    }\n    \n    /**\n     * 链表尾部添加节点\n     * @param node 节点对象\n     * @return 是否成功\n     */\n    public boolean addLast(Node node){\n        //第一次创建的链头\n        if (head == null){\n            head = node;\n            return false;\n        }\n        Node tmp = head;\n        //遍历链表 循环直到最后 Node.next = null 空的节点引用\n        while (tmp.next != null){\n            //往后移一个节点，指向下一个节点\n            tmp = tmp.next;\n        }\n        //在最后面null节点添加新节点\n        tmp.next = node;\n        return true;\n    }\n    \n    /**\n     *  指定值 后面添加节点\n     * @param value 节点值\n     * @param node 单节点\n     */\n    public boolean addByValue(int value , Node node){\n        Node tmp = head;\n        //第一次添加则无效\n        if (tmp == null){\n            return false;\n        }\n        //遍历链表\n        while(tmp != null){\n            //data 节点内容 相同为止\n            if(tmp.data == value){\n                //插入\n                //更改指向\n                node.next = tmp.next;\n                //节点的下一位\n                tmp.next = node;\n                return true;\n            }\n            //指向下一节点\n            tmp = tmp.next;\n        }\n        return false;\n    }\n    \n    /**\n     *  删除节点\n     * @param value\n     * @return 是否成功\n     */\n    public boolean removeNode(int value){\n        if (head == null){\n            return false;\n        }\n        //如果要删除头 ，将头的下一个覆盖即可\n        if (head.data == value){\n            head = head.next;\n            return true;\n        }\n        Node tmp = head;\n        //遍历链表\n        while (tmp.next != null){\n            if (tmp.next.data == value){\n                //该节点被 上节点连接至 下下节点\n                tmp.next = tmp.next.next;\n                return true;\n            }\n            tmp = tmp.next;\n        }\n        return false;\n    }\n    \n    /**\n     * 获取指定节点\n     * @param value\n     * @return\n     */\n    public Node getNode(int value){\n        if (head.data == value){\n            return head;\n        }\n        Node tmp = head;\n        while (tmp != null){\n            if (tmp.data == value){\n                return tmp;\n            }\n            tmp = tmp.next;\n        }\n        return null;\n    }\n    \n    /**\n     * 获取链表全部\n     * @return\n     */\n    public Node[] getNodeAll(){\n        if (head == null){\n            return null;\n        }\n        Node tmp = head;\n        Node[] arrayNode = new Node[size()];\n        int i = 0;\n        while (tmp != null){\n            arrayNode[i++] = tmp;\n            tmp = tmp.next;\n        }\n        return arrayNode;\n    }\n    \n    /**\n     * 获取链表长\n     * @return\n     */\n    public int size(){\n        Node tmp  = head;\n        int size = 0;\n        while (tmp != null){\n            size++;\n            tmp = tmp.next;\n        }\n        return size;\n    }\n    \n    /**\n     * 是否为空\n     * @return\n     */\n    public boolean isEmpty(){\n        return head == null;\n    }\n    \n    /**\n     *  获取 头节点\n     * @return\n     */\n    public Node getHead(){\n        return head;\n    }\n    \n    /**\n     * 获取 尾节点\n     * @return\n     */\n    public Node getTail(){\n        if (head == null){\n            return head;\n        }\n        Node tmp = head;\n        while (tmp.next != null){\n            tmp = tmp.next;\n        }\n        return tmp;\n    }\n}\n\n\n学习来源分享链接：点击\n\n\n# 双向链表\n\n由各个内存结构通过指针 Next 和指针 Prev 链接在一 起组成，每一个内存结构都存在前驱内存结构和后继内存结构(链头没有前驱，链尾没有后继），内存结构由数据域、指针域 （Prev , Next）组成\n\n详细图解\n\n\n\n\n\nMain 执行类：\n\npublic class Main {\n    public static void main(String[] args) {\n        \n        MyLink myLink = new MyLink();\n\n        Node[] staff = {\n                new Node(111 ,1),\n                new Node(222 , 2),\n                new Node(444 , 4),\n        };\n        \n        for (Node tmp : staff){\n            myLink.addLast(tmp);\n        }\n        //添加节点值\n        myLink.addLast(555);\n        \n        //插入链表 指定 date 222 后面添加 节点值 333\n        myLink.addByValue(222 , new Node(333,3));\n        \n        //删除链表 指定 date 222 删除\n        myLink.removeNode(222);\n\n        /*以下是打印操作 ， 可以自定选择\n        \t打印形式可更改 Node类 中的 toString方法 进行打印\n        */\n\t\n        System.out.println(myLink.getByNode(555));\n        System.out.println();\n       \n        //System.out.println(myLink.getTail().getPrev());\n        System.out.println(myLink.getHead());\n        System.out.println("===============");\n        System.out.println(myLink.getTail());\n        //System.out.println(myLink.getHead().getNext());\n\n        System.out.println();\n        System.out.println("size = "+ myLink.size());\n        \n    }\n}\n\n\nMyLink 操作类：\n\npublic class MyLink {\n    \n    Node head = null;\n    \n    /**\n     * 添加链表（节点值）\n     * @param d\n     */\n    public void addLast(int d){\n        Node newNode = new Node(d);\n        if (head == null){\n            head = newNode;\n            return;\n        }\n        Node tmp  = head;\n        while (tmp.next != null){\n            tmp = tmp.next;\n        }\n        tmp.next = newNode;\n        //指向后面\n        newNode.prev = tmp;\n    }\n    \n    /**\n     * 添加链表（节点）\n     * @param node\n     */\n    public void addLast(Node node){\n        if (head == null){\n            head = node;\n            return;\n        }\n        Node tmp  = head;\n        while (tmp.next != null){\n            tmp = tmp.next;\n        }\n        tmp.next = node;\n        node.prev = tmp;\n    }\n    \n    /**\n     * 插入节点\n     * 指定节点值 value 的后面添加 节点\n     * @param value\n     * @param node\n     * @return\n     */\n    public boolean addByValue(int value , Node node){\n        if (head == null){\n            return false;\n        }\n        Node tmp = head;\n        while (tmp != null){\n            if (tmp.date ==value){\n                //反向链 处理\n                tmp.next.prev = node;\n                node.prev = tmp;\n                \n                node.next = tmp.next;\n                tmp.next = node;\n                return true;\n            }\n            tmp = tmp.next;\n        }\n        return false;\n    }\n    \n    /**\n     * 删除指定节点\n     * @return\n     */\n    public boolean removeNode(int value){\n        if (size() == 0 || head == null){\n            return false;\n        }\n        Node tmp = head;\n        while (tmp.next != null){\n            if (tmp.next.date == value){\n                tmp.next.next.prev = tmp;\n                //next 跳过指向\n                tmp.next = tmp.next.next;\n                return true;\n            }\n            tmp = tmp.next;\n        }\n        return false;\n    }\n    \n    /**\n     * 获取链表长\n     * @return\n     */\n    public int size(){\n        Node tmp = head;\n        int size = 0;\n        while (tmp != null){\n            size++;\n            tmp = tmp.next;\n        }\n        return size;\n    }\n    \n    /**\n     * 获取 指定节点\n     * @param date\n     * @return\n     */\n    public Node getByNode(int date){\n        Node tmp = head;\n        while (tmp != null){\n            if (tmp.date == date){\n                return tmp;\n            }\n            tmp = tmp.next;\n        }\n        return null;\n    }\n    \n    /**\n     *  获取 头节点\n     * @return\n     */\n    public Node getHead(){\n        return head;\n    }\n    \n    /**\n     * 获取 尾节点\n     * @return\n     */\n    public Node getTail(){\n        if (head == null){\n            return head;\n        }\n        Node tmp = head;\n        while (tmp.next != null){\n            tmp = tmp.next;\n        }\n        return tmp;\n    }\n}\n\n\nNode 单链类：\n\nimport java.util.Objects;\n\npublic class Node {\n    \n    //数据域 （内容自定义）\n    String name;\n    int id;\n    \n    /**指针域\n     *  date - 节点值（数据类型自定义）\n     *  prev - 节头 引用\n     *  next - 节尾 引用\n     */\n    int date;\n    Node prev;\n    Node next;\n    \n    \n    public Node(int date) {\n        this.date = date;\n    }\n    \n    public Node(int date, Node prev, Node next) {\n        this.date = date;\n        this.prev = prev;\n        this.next = next;\n    }\n    \n    public Node(String name, int id, int date, Node prev, Node next) {\n        this.name = name;\n        this.id = id;\n        this.date = date;\n        this.prev = prev;\n        this.next = next;\n    }\n    \n    public Node(int date , int id) {\n        this.id = id;\n        this.date = date;\n    }\n    \n    public boolean equals(int d) {\n        return date == d;\n    }\n    \n    //输出属性 next 或 prev 二选一\n    @Override\n    public String toString() {\n        return "Node{" +\n                //"id=" + id +\n                "date=" + date +\n                //", next= "+next+\n                ", prev="+prev+\n                \'}\';\n    }\n    \n    @Override\n    public int hashCode() {\n        return Objects.hash(date);\n    }\n}\n\n\n\n# 循环链表\n\n循环链表没有链头和链尾的说法，因为是闭环的，所以每一个内存结构都可以充当链头 和链尾\n\n\n\n\n# 单向循环链表\n\n由各个内存结构通过一个指针 Next 链接在一起组成，每一个内存结构都存在后继内存结构，内存结构由数据域和 Next 指针域组成\n\n链尾的 Next 指针直接指向链头，形成一个闭环\n\n\n# 双向循环链表\n\n由各个内存结构通过指针 Next 和指针 Prev 链接在一起组成，每一个内存结构都存在前驱内存结构和后继内存结构，内存结构由 数据域、Prev 指针域和 Next 指针域组成\n\n链尾的 Next 指针指向链头，再把链头的 Prev 指针指向链尾，形成一个闭环\n\n闭环我就不多写了，头尾连接即可',normalizedContent:'# 链表\n\n链表（linked list）,由一系列结点node（链表中每一个元素称为结点）组成，结点可以在运行时 i 动态生成\n\n> 数据域： 存储数据的元素 指针域： 存储下个节点的地址\n\n\n# 单向链表\n\n由各个内存结构通过一个 next 指针链接在一起组成，每一个内存结构都存在后继内存结构(链尾除外），内存结构由数据域和 next 指针域组成\n\n\n\nmain ：（执行类）\n\npublic class main {\n    public static void main(string[] args) {\n        \n        //实例 操作对象\n        mylink mylink = new mylink();\n        \n        //初始化链表数据\n        // 参数： name ， id\n        node[] staff = {\n                new node(121,"小爱" , "00001"),\n                new node(112,"可怡"  , "00023"),\n                new node(233,"小黑" , "33123")\n        };\n        \n        //添加链表\n        for(node tmp : staff){\n            mylink.addlast(tmp);\n        }\n        \n        //添加单链 （最后）\n        mylink.addlast(new node(232 , "智乃" ,"44221"));\n        \n        //插入单链（索引）  在 "可怡" 节点 链后添加 "黑猫" 节点\n        mylink.addbyvalue(112 , new node(234,"黑猫" , "00444"));\n        \n        // 节点值为121  "可怡" 删除\n        mylink.removenode(112);\n        \n        //查询数据\n        system.out.println("查询节点值 234 的数据 ： ["+mylink.getnode(234)+"]");\n        \n        // 遍历链表\n        system.out.println("=================");\n        for (node tmp : mylink.getnodeall()){\n            system.out.println(tmp.tostring());\n        }\n        system.out.println("=================");\n        \n    }\n}\n\n\nnode ：（单链节点类）\n\n/**\n * 单列节点\n * 链表中的节点，\n * data   代表节点的值\n * next   指向下一个节点的引用\n * @author administrator\n */\npublic class node {\n    \n    /**数据域 （员工数据）\n     * name - 姓名\n     * id - id号\n     * */\n    string name;\n    string id;\n    \n    /**指针域 （链表数据）\n     * data - 节点的对象，即内容\n     * next - 节点的引用\n     */\n    int data;\n    node next = null;\n    \n    //构造方法\n    \n    public node() {\n    }\n    \n    public node(int data) {\n        this.data = data;\n    }\n    \n    public node(int data , node next) {\n        this.data = data;\n        this.next = next;\n    }\n    \n    public node(string name , string id) {\n        this.name = name;\n        this.id = id;\n    }\n    \n    public node(int data , string name , string id) {\n        this.data = data;\n        this.name = name;\n        this.id = id;\n    }\n    \n    public node(int data , node next , string name , string id ) {\n        this.name = name;\n        this.id = id;\n        this.data = data;\n        this.next = next;\n    }\n    \n    public void setname(string name) {\n        this.name = name;\n    }\n    public void setid(string id) {\n        this.id = id;\n    }\n    \n    @override\n    public string tostring() {\n        return "node{" +\n                "name=\'" + name + \'\\\'\' +\n                ", id=\'" + id + \'\\\'\' +\n                ", data=" + data +\n                // ", next=" + next +\n                \'}\';\n    }\n    \n}\n\n\nmylink ：（链表操作类）\n\npublic class mylink {\n    //头节点\n    node head = null;\n    \n    /**\n     * 链表尾部添加节点\n     * @param d 节点值\n     * @return 是否成功\n     */\n    public boolean addlast(int d){\n        //实例节点\n        node newnode = new node(d);\n        //第一次创建的链头\n        if (head == null){\n            head = newnode;\n            return true;\n        }\n        node tmp = head;\n        //遍历链表 循环直到最后 node.next = null 空的节点引用\n        while (tmp.next != null){\n            //往后移一个节点，指向下一个节点\n            tmp = tmp.next;\n        }\n        //在最后面null节点添加新节点\n        tmp.next = newnode;\n        return true;\n    }\n    \n    /**\n     * 链表尾部添加节点\n     * @param node 节点对象\n     * @return 是否成功\n     */\n    public boolean addlast(node node){\n        //第一次创建的链头\n        if (head == null){\n            head = node;\n            return false;\n        }\n        node tmp = head;\n        //遍历链表 循环直到最后 node.next = null 空的节点引用\n        while (tmp.next != null){\n            //往后移一个节点，指向下一个节点\n            tmp = tmp.next;\n        }\n        //在最后面null节点添加新节点\n        tmp.next = node;\n        return true;\n    }\n    \n    /**\n     *  指定值 后面添加节点\n     * @param value 节点值\n     * @param node 单节点\n     */\n    public boolean addbyvalue(int value , node node){\n        node tmp = head;\n        //第一次添加则无效\n        if (tmp == null){\n            return false;\n        }\n        //遍历链表\n        while(tmp != null){\n            //data 节点内容 相同为止\n            if(tmp.data == value){\n                //插入\n                //更改指向\n                node.next = tmp.next;\n                //节点的下一位\n                tmp.next = node;\n                return true;\n            }\n            //指向下一节点\n            tmp = tmp.next;\n        }\n        return false;\n    }\n    \n    /**\n     *  删除节点\n     * @param value\n     * @return 是否成功\n     */\n    public boolean removenode(int value){\n        if (head == null){\n            return false;\n        }\n        //如果要删除头 ，将头的下一个覆盖即可\n        if (head.data == value){\n            head = head.next;\n            return true;\n        }\n        node tmp = head;\n        //遍历链表\n        while (tmp.next != null){\n            if (tmp.next.data == value){\n                //该节点被 上节点连接至 下下节点\n                tmp.next = tmp.next.next;\n                return true;\n            }\n            tmp = tmp.next;\n        }\n        return false;\n    }\n    \n    /**\n     * 获取指定节点\n     * @param value\n     * @return\n     */\n    public node getnode(int value){\n        if (head.data == value){\n            return head;\n        }\n        node tmp = head;\n        while (tmp != null){\n            if (tmp.data == value){\n                return tmp;\n            }\n            tmp = tmp.next;\n        }\n        return null;\n    }\n    \n    /**\n     * 获取链表全部\n     * @return\n     */\n    public node[] getnodeall(){\n        if (head == null){\n            return null;\n        }\n        node tmp = head;\n        node[] arraynode = new node[size()];\n        int i = 0;\n        while (tmp != null){\n            arraynode[i++] = tmp;\n            tmp = tmp.next;\n        }\n        return arraynode;\n    }\n    \n    /**\n     * 获取链表长\n     * @return\n     */\n    public int size(){\n        node tmp  = head;\n        int size = 0;\n        while (tmp != null){\n            size++;\n            tmp = tmp.next;\n        }\n        return size;\n    }\n    \n    /**\n     * 是否为空\n     * @return\n     */\n    public boolean isempty(){\n        return head == null;\n    }\n    \n    /**\n     *  获取 头节点\n     * @return\n     */\n    public node gethead(){\n        return head;\n    }\n    \n    /**\n     * 获取 尾节点\n     * @return\n     */\n    public node gettail(){\n        if (head == null){\n            return head;\n        }\n        node tmp = head;\n        while (tmp.next != null){\n            tmp = tmp.next;\n        }\n        return tmp;\n    }\n}\n\n\n学习来源分享链接：点击\n\n\n# 双向链表\n\n由各个内存结构通过指针 next 和指针 prev 链接在一 起组成，每一个内存结构都存在前驱内存结构和后继内存结构(链头没有前驱，链尾没有后继），内存结构由数据域、指针域 （prev , next）组成\n\n详细图解\n\n\n\n\n\nmain 执行类：\n\npublic class main {\n    public static void main(string[] args) {\n        \n        mylink mylink = new mylink();\n\n        node[] staff = {\n                new node(111 ,1),\n                new node(222 , 2),\n                new node(444 , 4),\n        };\n        \n        for (node tmp : staff){\n            mylink.addlast(tmp);\n        }\n        //添加节点值\n        mylink.addlast(555);\n        \n        //插入链表 指定 date 222 后面添加 节点值 333\n        mylink.addbyvalue(222 , new node(333,3));\n        \n        //删除链表 指定 date 222 删除\n        mylink.removenode(222);\n\n        /*以下是打印操作 ， 可以自定选择\n        \t打印形式可更改 node类 中的 tostring方法 进行打印\n        */\n\t\n        system.out.println(mylink.getbynode(555));\n        system.out.println();\n       \n        //system.out.println(mylink.gettail().getprev());\n        system.out.println(mylink.gethead());\n        system.out.println("===============");\n        system.out.println(mylink.gettail());\n        //system.out.println(mylink.gethead().getnext());\n\n        system.out.println();\n        system.out.println("size = "+ mylink.size());\n        \n    }\n}\n\n\nmylink 操作类：\n\npublic class mylink {\n    \n    node head = null;\n    \n    /**\n     * 添加链表（节点值）\n     * @param d\n     */\n    public void addlast(int d){\n        node newnode = new node(d);\n        if (head == null){\n            head = newnode;\n            return;\n        }\n        node tmp  = head;\n        while (tmp.next != null){\n            tmp = tmp.next;\n        }\n        tmp.next = newnode;\n        //指向后面\n        newnode.prev = tmp;\n    }\n    \n    /**\n     * 添加链表（节点）\n     * @param node\n     */\n    public void addlast(node node){\n        if (head == null){\n            head = node;\n            return;\n        }\n        node tmp  = head;\n        while (tmp.next != null){\n            tmp = tmp.next;\n        }\n        tmp.next = node;\n        node.prev = tmp;\n    }\n    \n    /**\n     * 插入节点\n     * 指定节点值 value 的后面添加 节点\n     * @param value\n     * @param node\n     * @return\n     */\n    public boolean addbyvalue(int value , node node){\n        if (head == null){\n            return false;\n        }\n        node tmp = head;\n        while (tmp != null){\n            if (tmp.date ==value){\n                //反向链 处理\n                tmp.next.prev = node;\n                node.prev = tmp;\n                \n                node.next = tmp.next;\n                tmp.next = node;\n                return true;\n            }\n            tmp = tmp.next;\n        }\n        return false;\n    }\n    \n    /**\n     * 删除指定节点\n     * @return\n     */\n    public boolean removenode(int value){\n        if (size() == 0 || head == null){\n            return false;\n        }\n        node tmp = head;\n        while (tmp.next != null){\n            if (tmp.next.date == value){\n                tmp.next.next.prev = tmp;\n                //next 跳过指向\n                tmp.next = tmp.next.next;\n                return true;\n            }\n            tmp = tmp.next;\n        }\n        return false;\n    }\n    \n    /**\n     * 获取链表长\n     * @return\n     */\n    public int size(){\n        node tmp = head;\n        int size = 0;\n        while (tmp != null){\n            size++;\n            tmp = tmp.next;\n        }\n        return size;\n    }\n    \n    /**\n     * 获取 指定节点\n     * @param date\n     * @return\n     */\n    public node getbynode(int date){\n        node tmp = head;\n        while (tmp != null){\n            if (tmp.date == date){\n                return tmp;\n            }\n            tmp = tmp.next;\n        }\n        return null;\n    }\n    \n    /**\n     *  获取 头节点\n     * @return\n     */\n    public node gethead(){\n        return head;\n    }\n    \n    /**\n     * 获取 尾节点\n     * @return\n     */\n    public node gettail(){\n        if (head == null){\n            return head;\n        }\n        node tmp = head;\n        while (tmp.next != null){\n            tmp = tmp.next;\n        }\n        return tmp;\n    }\n}\n\n\nnode 单链类：\n\nimport java.util.objects;\n\npublic class node {\n    \n    //数据域 （内容自定义）\n    string name;\n    int id;\n    \n    /**指针域\n     *  date - 节点值（数据类型自定义）\n     *  prev - 节头 引用\n     *  next - 节尾 引用\n     */\n    int date;\n    node prev;\n    node next;\n    \n    \n    public node(int date) {\n        this.date = date;\n    }\n    \n    public node(int date, node prev, node next) {\n        this.date = date;\n        this.prev = prev;\n        this.next = next;\n    }\n    \n    public node(string name, int id, int date, node prev, node next) {\n        this.name = name;\n        this.id = id;\n        this.date = date;\n        this.prev = prev;\n        this.next = next;\n    }\n    \n    public node(int date , int id) {\n        this.id = id;\n        this.date = date;\n    }\n    \n    public boolean equals(int d) {\n        return date == d;\n    }\n    \n    //输出属性 next 或 prev 二选一\n    @override\n    public string tostring() {\n        return "node{" +\n                //"id=" + id +\n                "date=" + date +\n                //", next= "+next+\n                ", prev="+prev+\n                \'}\';\n    }\n    \n    @override\n    public int hashcode() {\n        return objects.hash(date);\n    }\n}\n\n\n\n# 循环链表\n\n循环链表没有链头和链尾的说法，因为是闭环的，所以每一个内存结构都可以充当链头 和链尾\n\n\n\n\n# 单向循环链表\n\n由各个内存结构通过一个指针 next 链接在一起组成，每一个内存结构都存在后继内存结构，内存结构由数据域和 next 指针域组成\n\n链尾的 next 指针直接指向链头，形成一个闭环\n\n\n# 双向循环链表\n\n由各个内存结构通过指针 next 和指针 prev 链接在一起组成，每一个内存结构都存在前驱内存结构和后继内存结构，内存结构由 数据域、prev 指针域和 next 指针域组成\n\n链尾的 next 指针指向链头，再把链头的 prev 指针指向链尾，形成一个闭环\n\n闭环我就不多写了，头尾连接即可',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"栈",frontmatter:{title:"栈",author:"柏竹",permalink:"/backend/2zy34y",date:"2020-02-18T00:00:00.000Z",categories:["后端"],tags:["数据结构","Java"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/06.%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03.%E6%A0%88.html",relativePath:"01.后端/06.数据结构/03.栈.md",key:"v-8c5b9946",path:"/backend/2zy34y/",headers:[{level:2,title:"有效括号",slug:"有效括号",normalizedTitle:"有效括号",charIndex:1528}],headersStr:"有效括号",content:"# 栈\n\n栈（stack）,又称堆栈，是限定仅在表尾进行插入和删除操作的线性表，操作方式 后进先出\n\n> 栈顶： 删除、插入端 栈底： 非删除、插入端 入栈： 插入 出栈： 删除 空栈： 无元素\n\n\n\n\n\n栈的基本操作\n\n> 初始化栈、出栈、入栈、判断空栈、获取栈顶··\n\n例子：\n\nimport java.util.*;\nimport java.util.List;\n\nclass MyStacks<E>{\n    \n    private List<E> data = null;\n    \n    /**初始化*/\n    public MyStacks(){\n        data = new ArrayList<E>();\n    }\n    \n    /**入栈*/\n    public void Add(E newdata){\n        data.add(newdata);\n    }\n    \n    /**出栈*/\n    public boolean Retreat(){\n        if(data.isEmpty()){\n            return false;\n        }\n        data.remove(data.size()-1);\n        return true;\n    }\n    \n    /**判断是否空*/\n    public boolean isEmpty(){\n        return data.isEmpty();\n    }\n    \n    //获取头数据\n    public E Gettop(){\n        return data.get(data.size()-1);\n    }\n}\n\npublic class Demo {\n    public static void main(String[] args) {\n        MyStacks<Integer> ms = new MyStacks<>();\n        \n        //判断是否空\n        System.out.println(\"是否为空：\"+ms.isEmpty());\n        \n        //添加\n        System.out.println(\"\\n添加数据····\\n\");\n        for (int i = 1; i <= 5; i++) {\n//            ms.Add(\"Student No.\"+i);\n            ms.Add(i);\n        }\n        \n        //获取头\n        System.out.println(\"获取头：\"+ms.Gettop());\n        \n        //删除\n        System.out.println(\"\\n删除 *2\\n\");\n        ms.Retreat();\n        ms.Retreat();\n    \n        //获取头\n        System.out.println(\"获取头：\"+ms.Gettop());\n        \n        //判断是否空\n        System.out.println(\"是否为空：\"+ms.isEmpty());\n        \n    }\n}\n\n\n/**\n\n是否为空：true\n\n添加数据····\n\n获取头：5\n\n删除 *2\n\n获取头：3\n是否为空：false\n\n*/\n\n\n\n# 有效括号\n\nLeetCode习题\n\n给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。\n\n有效字符串需满足：\n\n * 左括号必须用相同类型的右括号闭合。\n * 左括号必须以正确的顺序闭合。\n\n注意空字符串可被认为是有效字符串。\n\nimport java.util.HashMap;\nimport java.util.Stack;\n\npublic class Solution {\n    public boolean isValid(String s){\n        \n        HashMap<Character,Character> map = new HashMap<>();\n        //堆栈类\n        Stack<Character> S = new Stack<>();\n        \n        // <K  , V>\n        map.put(')','(');\n        map.put(']','[');\n        map.put('}','{');\n        \n        for (int i = 0; i < s.length(); i++) {\n            \n            char c = s.charAt(i);\n            //判断是否存在 ( [ {\n            if ( map.containsValue(c) ){\n                //获取( [ { 入栈\n                S.add(c);\n            }else{\n                \n                //空则结束\n                if (S.size() == 0){\n                    return false; }\n                //从栈中取出并删除对象\n                char tmp = S.pop();\n                //通过K【) ] } 】找 V【 ( [ { 】 匹配 栈中的 ( [ {\n                if (map.get(c) != tmp){\n                    return false; }\n            }\n        }\n        return S.empty();\n    }\n    public static void main(String[] args) {\n        Solution s = new Solution();\n        System.out.println(s.isValid(\"{[]}\"));\n    }\n}\n\n\n/**\n\ntrue\n\n*/\n",normalizedContent:"# 栈\n\n栈（stack）,又称堆栈，是限定仅在表尾进行插入和删除操作的线性表，操作方式 后进先出\n\n> 栈顶： 删除、插入端 栈底： 非删除、插入端 入栈： 插入 出栈： 删除 空栈： 无元素\n\n\n\n\n\n栈的基本操作\n\n> 初始化栈、出栈、入栈、判断空栈、获取栈顶··\n\n例子：\n\nimport java.util.*;\nimport java.util.list;\n\nclass mystacks<e>{\n    \n    private list<e> data = null;\n    \n    /**初始化*/\n    public mystacks(){\n        data = new arraylist<e>();\n    }\n    \n    /**入栈*/\n    public void add(e newdata){\n        data.add(newdata);\n    }\n    \n    /**出栈*/\n    public boolean retreat(){\n        if(data.isempty()){\n            return false;\n        }\n        data.remove(data.size()-1);\n        return true;\n    }\n    \n    /**判断是否空*/\n    public boolean isempty(){\n        return data.isempty();\n    }\n    \n    //获取头数据\n    public e gettop(){\n        return data.get(data.size()-1);\n    }\n}\n\npublic class demo {\n    public static void main(string[] args) {\n        mystacks<integer> ms = new mystacks<>();\n        \n        //判断是否空\n        system.out.println(\"是否为空：\"+ms.isempty());\n        \n        //添加\n        system.out.println(\"\\n添加数据····\\n\");\n        for (int i = 1; i <= 5; i++) {\n//            ms.add(\"student no.\"+i);\n            ms.add(i);\n        }\n        \n        //获取头\n        system.out.println(\"获取头：\"+ms.gettop());\n        \n        //删除\n        system.out.println(\"\\n删除 *2\\n\");\n        ms.retreat();\n        ms.retreat();\n    \n        //获取头\n        system.out.println(\"获取头：\"+ms.gettop());\n        \n        //判断是否空\n        system.out.println(\"是否为空：\"+ms.isempty());\n        \n    }\n}\n\n\n/**\n\n是否为空：true\n\n添加数据····\n\n获取头：5\n\n删除 *2\n\n获取头：3\n是否为空：false\n\n*/\n\n\n\n# 有效括号\n\nleetcode习题\n\n给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串，判断字符串是否有效。\n\n有效字符串需满足：\n\n * 左括号必须用相同类型的右括号闭合。\n * 左括号必须以正确的顺序闭合。\n\n注意空字符串可被认为是有效字符串。\n\nimport java.util.hashmap;\nimport java.util.stack;\n\npublic class solution {\n    public boolean isvalid(string s){\n        \n        hashmap<character,character> map = new hashmap<>();\n        //堆栈类\n        stack<character> s = new stack<>();\n        \n        // <k  , v>\n        map.put(')','(');\n        map.put(']','[');\n        map.put('}','{');\n        \n        for (int i = 0; i < s.length(); i++) {\n            \n            char c = s.charat(i);\n            //判断是否存在 ( [ {\n            if ( map.containsvalue(c) ){\n                //获取( [ { 入栈\n                s.add(c);\n            }else{\n                \n                //空则结束\n                if (s.size() == 0){\n                    return false; }\n                //从栈中取出并删除对象\n                char tmp = s.pop();\n                //通过k【) ] } 】找 v【 ( [ { 】 匹配 栈中的 ( [ {\n                if (map.get(c) != tmp){\n                    return false; }\n            }\n        }\n        return s.empty();\n    }\n    public static void main(string[] args) {\n        solution s = new solution();\n        system.out.println(s.isvalid(\"{[]}\"));\n    }\n}\n\n\n/**\n\ntrue\n\n*/\n",charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Redis",frontmatter:{title:"Redis",author:"柏竹",permalink:"/backend/ldn760",date:"2020-02-18T00:00:00.000Z",categories:["后端"],tags:["数据库"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/05.%E6%95%B0%E6%8D%AE%E5%BA%93/05.Redis.html",relativePath:"01.后端/05.数据库/05.Redis.md",key:"v-e9724afe",path:"/backend/ldn760/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:12},{level:2,title:"Redis基础",slug:"redis基础",normalizedTitle:"redis基础",charIndex:221},{level:3,title:"数据类型",slug:"数据类型",normalizedTitle:"数据类型",charIndex:233},{level:3,title:"常用命令",slug:"常用命令",normalizedTitle:"常用命令",charIndex:1454},{level:3,title:"事务",slug:"事务",normalizedTitle:"事务",charIndex:4812},{level:3,title:"订阅",slug:"订阅",normalizedTitle:"订阅",charIndex:5056},{level:3,title:"持久化",slug:"持久化",normalizedTitle:"持久化",charIndex:5509},{level:4,title:"RDB持久化",slug:"rdb持久化",normalizedTitle:"rdb持久化",charIndex:5571},{level:4,title:"AOF持久化",slug:"aof持久化",normalizedTitle:"aof持久化",charIndex:6352},{level:4,title:"RDB与AOF区别",slug:"rdb与aof区别",normalizedTitle:"rdb与aof区别",charIndex:7654},{level:3,title:"主从复制",slug:"主从复制",normalizedTitle:"主从复制",charIndex:7918},{level:3,title:"哨兵模式",slug:"哨兵模式",normalizedTitle:"哨兵模式",charIndex:8575},{level:3,title:"集群",slug:"集群",normalizedTitle:"集群",charIndex:9418},{level:3,title:"分布式锁",slug:"分布式锁",normalizedTitle:"分布式锁",charIndex:12166},{level:2,title:"实战技巧",slug:"实战技巧",normalizedTitle:"实战技巧",charIndex:12532},{level:3,title:"Key缓存设计",slug:"key缓存设计",normalizedTitle:"key缓存设计",charIndex:12541},{level:3,title:"Redis 模拟百万数据",slug:"redis-模拟百万数据",normalizedTitle:"redis 模拟百万数据",charIndex:12640},{level:3,title:"缓存预存储",slug:"缓存预存储",normalizedTitle:"缓存预存储",charIndex:12716},{level:4,title:"定时触发",slug:"定时触发",normalizedTitle:"定时触发",charIndex:12800},{level:4,title:"手动触发",slug:"手动触发",normalizedTitle:"手动触发",charIndex:12942},{level:2,title:"Java实现",slug:"java实现",normalizedTitle:"java实现",charIndex:12951},{level:3,title:"SpringBoot",slug:"springboot",normalizedTitle:"springboot",charIndex:12962},{level:4,title:"自定义序列化器",slug:"自定义序列化器",normalizedTitle:"自定义序列化器",charIndex:14546},{level:3,title:"Jedis连接",slug:"jedis连接",normalizedTitle:"jedis连接",charIndex:15106},{level:4,title:"连接服务器",slug:"连接服务器",normalizedTitle:"连接服务器",charIndex:15291},{level:4,title:"连接池",slug:"连接池",normalizedTitle:"连接池",charIndex:15681},{level:4,title:"集群",slug:"集群-2",normalizedTitle:"集群",charIndex:9418},{level:3,title:"Lettuce",slug:"lettuce",normalizedTitle:"lettuce",charIndex:17986},{level:3,title:"Redisson",slug:"redisson",normalizedTitle:"redisson",charIndex:18026},{level:4,title:"快速入门",slug:"快速入门",normalizedTitle:"快速入门",charIndex:18165},{level:4,title:"定时任务",slug:"定时任务",normalizedTitle:"定时任务",charIndex:19364},{level:4,title:"续约锁",slug:"续约锁",normalizedTitle:"续约锁",charIndex:20954},{level:2,title:"Q&A",slug:"q-a",normalizedTitle:"q&amp;a",charIndex:null},{level:3,title:"缓存问题",slug:"缓存问题",normalizedTitle:"缓存问题",charIndex:21964},{level:4,title:"缓存雪崩",slug:"缓存雪崩",normalizedTitle:"缓存雪崩",charIndex:22117},{level:4,title:"缓存穿透",slug:"缓存穿透",normalizedTitle:"缓存穿透",charIndex:22846},{level:4,title:"缓存击穿",slug:"缓存击穿",normalizedTitle:"缓存击穿",charIndex:23574},{level:3,title:"分布式锁问题",slug:"分布式锁问题",normalizedTitle:"分布式锁问题",charIndex:23755},{level:4,title:"死锁",slug:"死锁",normalizedTitle:"死锁",charIndex:23765},{level:4,title:"JVM锁和分布式锁",slug:"jvm锁和分布式锁",normalizedTitle:"jvm锁和分布式锁",charIndex:23823},{level:4,title:"续约锁",slug:"续约锁-2",normalizedTitle:"续约锁",charIndex:20954}],headersStr:"概述 Redis基础 数据类型 常用命令 事务 订阅 持久化 RDB持久化 AOF持久化 RDB与AOF区别 主从复制 哨兵模式 集群 分布式锁 实战技巧 Key缓存设计 Redis 模拟百万数据 缓存预存储 定时触发 手动触发 Java实现 SpringBoot 自定义序列化器 Jedis连接 连接服务器 连接池 集群 Lettuce Redisson 快速入门 定时任务 续约锁 Q&A 缓存问题 缓存雪崩 缓存穿透 缓存击穿 分布式锁问题 死锁 JVM锁和分布式锁 续约锁",content:'# Redis\n\n\n# 概述\n\nREmote DIctionary Server(Redis) 是一个由 Salvatore Sanfilippo 写的 key-value 存储系统，是跨平台的非关系型数据库\n\nRedis 是一个开源的使用 ANSI C 语言编写、遵守 BSD 协议、支持网络、可基于内存、分布式、可选持久性的键值对(Key-Value)存储数据库，并提供多种语言的 API\n\nRedis 通常被称为数据结构服务器\n\n\n# Redis基础\n\n\n# 数据类型\n\nRedis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)\n\n数据类型              数据类型存储的值                                       说明\nString（字符串）       字符串、整数、浮点数                                     字符串增加；求子串\n                                                                 整数、浮点数 计算自增..\nList（列表）          链表、每个节点都含有一个字符串                                支持 链表头尾 插入弹出\n                                                                 偏移剪切\n                                                                 查询、删除 指定节点\nSet（集合）           集合中的每个元素都是一个字符串，且他们都是唯一的                       可 增删查 元素，\n                                                                 检测元素是否存在集合\n                                                                 计算集合 交、并、差集 等\n                                                                 随机读取元素\nHash（哈希散列表）       Java中的 Map类 ，<K , V>                           可 增删改查 键值对\n                                                                 可获取所有键值对\nZset（有序集合）        有序集合，可能包含 字符串、整数、浮点数、分值(score)、元素（排列有分值大小决定）   可 增删改查 元素\n                                                                 根据分值范围或成员 获取对应元素\nHyperLogLog（基数）   计算重复的值，确定存储数量                                  只提供基数运算，不提供返回功能\n\n\n# 常用命令\n\nRedis 命令用于在 redis 服务上执行操作\n\n基本类型操作\n\n说明                                      命令\n赋值                                      SET key value\n取值                                      GET key\n多键值赋值                                   MSET key value [key value ...]\n多取值                                     MGET key [key ...]\n字符串数值操作                                 \n递增+1                                    INCR key\n递减-1                                    DECR key\n指定增加                                    INCRBY key increment\n指定减少                                    DECRBY key decrem\nHash散列                                  \nHash赋值                                  HSET key field value\nHash取值                                  HGET key field\nHash多赋值                                 HMSET key field value [field value]\n获取所有字段值                                 HGETALL key\nList队列                                  \n列表左增                                    LPUSH key value [value ...]\n列表左弹                                    LPOP key\n列表右增                                    RPUSH key value [value ...]\n列表右弹                                    RPOP key\n列表总数                                    LLEN key\n查列表                                     LRANGE key start stop\nSet集合（无序不可重复）                           \n添加元素                                    SADD key member [menber ...]\n删除元素                                    SREM key member [member ...]\n获取所有元素                                  SMEMBERS key\n查 元素 是否存在集合(ruturn 0/1 => falet/ture)   SISMEMBER key member\nZset有序集合（可排序，唯一性）                       \n添加元素                                    ZADD key score member [score member ...]\n获取元素                                    ZSCORE key member\n删除元素                                    ZREM key member [menber ...]\n查 根据 数值进行排列（默认降序）                       ZREVRANGE key start stop [WITHSCORES]\nWITHSCORES：查 键、值\n元素 递增/递减 (支持正负)                         ZINCRBY key increment member\nHyoperLogLog命令                          \n添加元素                                    PFADD key element [element ...]\n获取指定 HyperLogLog 基数估算值                  PFCOUNT key [key ...]\n将多个 HyperLogLog 合并为一个 HyperLogLog       PFMERGE destkey sourcekey [sourcekey ...]\n生命周期                                    \n设置key生存周期（秒）                            EXPIRE key seconds\n查看剩下生存时间                                TTL key\n清除生存时间                                  PERSIST key\n其他命令                                    \n查所有key                                  KEYS *\n查所有以user开头的key                          KEYS user *\n确认key是否存在(ruturn 0/1 => falet/ture)     EXISTS key\n删除key                                   DEL key\n重命名key                                  RENAME oldkey newkey\n获取key值类型                                TYPE key\n获取服务器信息                                 INFO\nkey移动至指定数据库                             MOVE key db\n切换数据库                                   SELECT index\n停止服务器                                   SHUTDOWN\n关闭服务连接                                  QUIT\n删除当前数据库中的所有key                          FLUSHDB\n删除所有数据库中的所有                             FLUSHALL\n\nHyoperLogLog命令\n\n随机化的算法，以少量内存提供集合唯一的元素数量的近似值\n\n可接受多个元素作为输入，并给出输入元素的基数估算值\n\n> 基数：集合中不同元素的数量。 例如{\'Sanscan\',\'Bobo\',\'Sanscan\',\'Tomy\',\'Sanscan\'}的基数为3\n> \n> 估算值：算法给出的基数并非精确，有些许偏差，但 会控制在范围内\n\n命令参考：\n\n * https://redis.io/commands\n * http://doc.redisfans.com/index.html\n\n\n# 事务\n\nRedis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：\n\n * 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客 户端发送来的命令请求所打断\n * 事务中的命令要么全部被执行，要么全部都不执行\n\n事务阶段：\n\n>  1. 开始事务\n>  2. 命令入队\n>  3. 执行事务\n\n事务命令\n\n命令        描述\nMULTI     开始事务\nDISCARD   取消事务\nEXEC      结束事务\n\n\n# 订阅\n\nRedis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息\n\n实现方式：\n\n>  * 开启本地 Redis 服务，开启两个 redis-cli 客户端\n>  * 第一个 redis-cli 客户端输入 SUBSCRIBE runoobChat，意思是订阅 runoobChat 频道\n>  * 第二个 redis-cli 客户端输入 PUBLISH runoobChat "Redis PUBLISH test" 往 runoobChat 频道发送消息，这个时候在第一个 redis-cli 客户端就会看到由第二个 redis-cli 客户端发送的测试消息\n\n订阅命令\n\n命令                                 说明\nPSUBSCRIBE pattern [pattern ...]   订阅一个或多个频道\nPUBLISH channel message            将信息发送指定频道\n\n\n# 持久化\n\nRedis值放在内存中，为防止突然断电等特殊情况的发生，需要对数据进行持久化备份。即将内存数据保存到硬盘。\n\n# RDB持久化\n\nRDB 是以二进制文件，是在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复\n\nRDB 默认开启， redis.conf文件 中的具体配置参数如下：\n\n#dbfilename：持久化数据存储在本地的文件\ndbfilename dump.rdb\n#dir：持久化数据存储在本地的路径，如果是在/redis/redis-5.0.5/src下启动的redis-cli，则数据会存储在当前\nsrc目录下\ndir ./\n##snapshot触发的时机，save\n##如下为900秒后，至少有一个变更操作，才会snapshot\n##对于此值的设置，需要谨慎，评估系统的变更操作密集程度\n##可以通过“save”来关闭snapshot功能\n#save时间，以下分别表示更改了1个key时间隔900s进行持久化存储；更改了10个key300s进行存储；更改10000个\nkey60s进行存储。\nsave 900 1\nsave 300 10\nsave 60 10000\n##当snapshot时出现错误无法继续时，是否阻塞客户端“变更操作”，“错误”可能因为磁盘已满/磁盘故障/OS级别异常等\nstop-writes-on-bgsave-error yes\n##是否启用rdb文件压缩，默认为“yes”，压缩往往意味着“额外的cpu消耗”，同时也意味这较小的文件尺寸以及较短的网\n络传输时间\nrdbcompression yes\n\n\n触发机制（snapshots）\n\n> 写入扳机： 根据写入 key的个数 进行触发 （一个key快照需要900s） 默认情况：1 -> 900s ；300 -> 300s ； 10000 -> 60s\n> \n> 数据更新方式： 每次 触发写入扳机 都会替换上次持久化好的文件\n\n# AOF持久化\n\nAOF是将 “操作 + 数据” 以格式化指令的方式追加到操作日志文件的尾部，通过append操作进行写入文件，才进行实际数据更变\n\n当需要恢复数据时直接读取此日志文件，还原所有的操作过程，AOF文件内容是字符串，便于阅读。\n\nAOF 默认关闭， redis.conf文件 中的具体配置参数如下：\n\n开启方法：appendonly yes\n\n##此选项为aof功能的开关，默认为“no”，可以通过“yes”来开启aof功能\n##只有在“yes”下，aof重写/文件同步等特性才会生效\nappendonly yes\n##指定aof文件名称\nappendfilename appendonly.aof\n##指定aof操作中文件同步策略，有三个合法值：always everysec no,默认为everysec\nappendfsync everysec\n##在aof-rewrite期间，appendfsync是否暂缓文件同步，"no"表示“不暂缓”，“yes”表示“暂缓”，默认为“no”\nno-appendfsync-on-rewrite no\n##aof文件rewrite触发的最小文件尺寸(mb,gb),只有大于此aof文件大于此尺寸是才会触发rewrite，默认“64mb”，建\n议“512mb”\nauto-aof-rewrite-min-size 64mb\n##相对于“上一次”rewrite，本次rewrite触发时aof文件应该增长的百分比。\n##每一次rewrite之后，redis都会记录下此时“新aof”文件的大小(例如A)，那么当aof文件增长到A*(1 + p)之后\n##触发下一次rewrite，每一次aof记录的添加，都会检测当前aof文件的尺寸。\nauto-aof-rewrite-percentage 100\n\n\n文件同步策略（appendfsync）\n\n> 配置原因：AOF 是文件操作，对于变更操作比较密集的 server，那么必将造成磁盘 IO 的负荷加。linux文件操作运用了 延迟写入 的形式，并非每次 写入(write) 都会执行 实际写入 操作，而是写入 缓存(buffer) 中，当 缓存(buffer) 中的数据都达指定 值(阀值) ，才会触发 实际写入 操作。\n> \n> 解决方案：可以得知 redis 提供 appendfsync配置 3 个 文件同步策略 选项：\n> \n>  * always：每一条 aof 记录都立即同步到文件，这是最安全的方式，也以为更多的磁盘操作和阻塞延迟，是 IO 开支 较大\n>  * everysec：每秒同步一次，性能和安全都比较中庸的方式，也是 redis 推荐的方式。如果遇到物理服务器故障，有 可能导致最近一秒内 aof 记录丢失(可能为部分丢失)\n>  * no：redis 并不直接调用文件同步，而是交给操作系统来处理，操作系统可以根据 buffer 填充情况 / 通道空闲时间 等择机触发同步；这是一种普通的文件操作方式。性能较好，在物理服务器故障时，数据丢失量会因 OS 配置有关\n\n# RDB与AOF区别\n\nRDB\n\n> 使用单独子进程来进行持久化，主进程不会进行任何 IO 操作\n> \n> 发生故障 将会丢失数据指定存储时长的 key值（根据存储 key的数量 控制时长）\n> \n> 数据内容形式 二进制\n\nAOF\n\n> IO 操作会有 1s 的时长进行 实际写入\n> \n> 发生故障 将会丢失数据发生故障前1s的数据\n> \n> 数据形式 字符串\n\n       RDB   AOF\n加载速度   快     慢\n容量大小   小     大\n丢失概率   高     低\n内容可读   否     是\n\n\n# 主从复制\n\n主从复制 是指将 一台Redis服务器(主)，拷贝到其他的Redis服务器(从)；主从广西只是数据的单向复制，由主节点到从节点\n\n主从复制作用\n\n * 故障恢复：主节点发生故障，由从节点提供服务，直至主节点修复\n * 数据冗余：实现数据同步备份，持久化之外的数据备份方式\n\n主从复制原理\n\n>  1. 从机通过配置的 replicaof参数 ，从节点完成主节点 ip 和 port 的保存后，向发送replicaof命令 的客户端直接返回OK\n>  2. 连接后从节点先主节点发送 SYNC命令，主节点收到命令立即执行保存快照(持久化文件)，并将 缓存的持久化文件 和 缓存写命令 发送给从节点 ，开始同步\n>  3. 从节点收到响应，执行 缓存的持久化文件 和 缓存写命令\n\n实现步骤\n\n主机无需配置\n\n 1. 复制出一个从机 （将 redis文件 夹拷贝）\n 2. 修改从机配置文件 redis.conf 参数replicaof ：主机ip + 主机端口\n 3. 修改从机配置文件 redis.conf 参数port ：从机端口(自定义)\n 4. 清除从机所有的持久化文件\n 5. 启动从机 （注意启动端口）\n\n注意\n\n>  * 主机发生增删改操作，那么从机会自动将数据同步到从机中\n>  * 从机不能执行写操作,只能读\n>  * 如果主机宕机，从机执行 SLAVEOF NO ONE命令，提升为为主机继续服务；主机修复后，主机执行 SLAVEOF host port 命令，将其恢复主机\n\n\n# 哨兵模式\n\n哨兵模式(Sentinel) 是 由一个或多个Sentinel组成的 Sentinel系统 可以监视服务器的上线状态\n\n哨兵模式作用\n\n * 系统监控：独立的进程(哨兵) 对系统实时监控\n * 故障切换：主服务器发生故障，会自动将从服务器转为主服务器进行服务（权重）\n\n实现步骤 （Linux实现）\n\n 1. 从 redis源码配置 中复制 redis-5.0.5/sentinel.conf (这是我的实例)\n\n 2. 粘贴至 任意服务器节点的 bin 目录下\n\n 3. 配置 sentinel.conf 中文件 sentinel monitor参数 sentinel monitor <master-name> <ip> <redis-port> <quorum> 例如：sentinel monitor mymaster 192.168.74.131 6380 1\n\n 4. 指定文件写入日志中，在当前 bin 中 执行以下命令 ./redis-sentinel ./sentinel.conf >sent.log &\n\n 5. 启动 主从服务器\n\n 6. 启动哨兵监控进程，在bin上级目录 执行以下命令 ./redis-server redis.conf --sentinel\n\n 7. 查看 哨兵进程，执行以下命令 ps -aux|grep redis\n    \n    测试：杀死进程 KILL 9 pid 模拟宕机\n\n注意\n\n>  * 第三步配置参数的 <master-name> 。如果使用 自定义名称 其他配置参数对应的名称也 需要更改为对应的 自定义名称（否则无效）\n>  * 启动哨兵的时候，修改了哨兵的配置文件。如果需要再次启动哨兵，需要删除myid唯一标示\n>  * 哨兵切换 主从服务器 的同时，也会修改 redis.conf 的主从配置文件\n>  * 主服务器 故障修复后，需要手动调至 主服务器 SLAVEOF host port\n\n\n# 集群\n\nRedis集群是通过添加服务器的数量，提供相同的服务，从而让服务器达到一个稳定、高效的状态\n\nredis-cluste集群方案\n\nRedis-Cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接\n\n\n\n结构及特点说明\n\n 1. 所有redis节点都是彼此互联。内部使用二进制协议优化传输速率\n 2. 客户端(client)与redis节点是直连的，无需中间层，client只需连接任意一个redis节点即可应用\n 3. 集群把所有 物理节点映射到 [0-16383] 槽点上，当 Redis集群 存储一个 key-value 时，key 使用 CRC16 算法 算出结果，然后用 结果 对 16384 求余数，最终得到的值 将决定 key放到哪个桶中\n 4. 当 Redis-Cluster 中任意 master 挂掉，且当前 master 没有 slave ，则 Redis-Cluster 为 fail 状态 。 （但 slot映射 不完全进入 fail状态）\n 5. 当 Redis-Cluster 中 master 挂掉一半以上，则 Redis-Cluster 为 fail 状态\n\nslot映射\n\n\n\n集群搭建 （Linux实现）\n\n\n\n 1.  新建集群目录，以下是个人用例\n     \n     [root@bozhuNo1 myapps]# mkdir redis-cluster\n\n 2.  在 集群 目录下，创建节点目录（复制redis节点），上图已经实例（先配置一个，剩下复制... ）\n     \n     [root@localhost myapps]# cp redis/ redis-cluster/7001 -r\n     [root@localhost myapps]# cd redis-cluster/7001\n     [root@localhost 7001]# ll\n     drwxr-xr-x. 2 root root 4096 7月 1 10:22 bin\n     -rw-r--r--. 1 root root 3446 7月 1 10:22 dump.rdb\n     -rw-r--r--. 1 root root 41404 7月 1 10:22 redis.conf\n     \n\n 3.  删除节点根目录下的 持久化文件 appendonly.aof dump.rdb\n\n 4.  支持集群，设置 节点根目录下的 redis.conf 配置文件 ，Cluster-enable 参数 设为 yes （默认注释了）\n\n 5.  配置端口，设置 节点根目录下的 redis.conf 配置文件 ，port 参数 设置 端口号 （我们测试的端口范围：[7001-7006]）\n\n 6.  完成一个 redis节点 后 ，剩下节点需要复制粘贴，步骤2开始\n\n 7.  完成6个 redis节点 后，启动所有节点服务。启动脚本辅助启动6个节点\n     \n     # vim startall.sh\n     \n     cd 7001\n     ./bin/redis-server ./redis.conf\n     cd ..\n     cd 7002\n     ./bin/redis-server ./redis.conf\n     cd ..\n     cd 7003\n     ./bin/redis-server ./redis.conf\n     cd ..\n     cd 7004\n     ./bin/redis-server ./redis.conf\n     cd ..\n     cd 7005\n     ./bin/redis-server ./redis.conf\n     cd ..\n     cd 7006\n     ./bin/redis-server ./redis.conf\n     cd ..\n     \n\n 8.  设置 脚本启动权限 chmod u+x startall.sh\n\n 9.  启动 节点进程服务 ./startall.sh\n\n 10. 创建集群 redis-cli --cluster create ip:port ip:port --cluster-replicas 1 （以下是本人应用实例）\n     \n     [root@bozhuNo1 bin]# cd /home/bozhu/myapps/redis-cluster/7001/bin\n     [root@bozhuNo1 bin]# ./redis-cli --cluster create 192.168.74.131:7001 192.168.74.131:7002 192.168.74.131:7003 192.168.74.131:7004 192.168.74.131:7005 192.168.74.131:7006  --cluster-replicas 1\n     >>> Performing hash slots allocation on 6 nodes...\n     Master[0] -> Slots 0 - 5460\n     Master[1] -> Slots 5461 - 10922\n     Master[2] -> Slots 10923 - 16383\n     Adding replica 192.168.74.131:7005 to 192.168.74.131:7001\n     Adding replica 192.168.74.131:7006 to 192.168.74.131:7002\n     Adding replica 192.168.74.131:7004 to 192.168.74.131:7003\n     ···\n     [OK] All 16384 slots covered.\n     \n     \n     PS：创建前需要关闭防火墙； redis 5.0.5中使用 redis-cli --cluster 替代 redis-trib.rb\n\n 11. 连接集群（-c：指定是集群连接）\n     \n     [root@localhost 7001]# ./bin/redis-cli -h 192.168.74.131 -p 7001 -c\n     \n\n查询集群信息：cluster info ；查看集群中节点信息：cluster nodes\n\n\n# 分布式锁\n\n点击了解线程同步\n\n分布式锁是多个服务器在同一系统中可服务器多个进程对资源的访问\n\nRedis为单进程 单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对Redis的连接并不存在竞争 关系。redis也可实现分布式锁\n\n意图 : 节省资源空间\n\n应用满足条件\n\n 1. 系统是一个分布式的系统\n 2. 资源共享（各个系统访问同一数据库）\n 3. 同步访问（多个进程同时访问同一个资源）\n\nredis分布式锁命令\n\nSETNX ==SETNX key value== key存在 , 不做操作 ; key不存在则设值\n\nGETSET ==GETSET key value== 先获取key对应的旧值，且新值覆盖替换旧值\n\n> 注意事项 :\n> \n>  * 用完锁一定要释放\n>  * 锁一定要加过期时间\n\n\n# 实战技巧\n\n\n# Key缓存设计\n\n独立设计 Key\n\n例如 :\n\nsystemId:moduleId:func\n\nsans:user:recommed:userId\n\n> key设置一定要有过期时间!!!\n\n\n# Redis 模拟百万数据\n\n 1. 库插入百万条数据\n 2. redis存储定时10s过期\n 3. 循环刷新测试用时\n\n\n\n> 肉眼可见的速度\n\n\n# 缓存预存储\n\n按照不同场景进行提前缓存数据\n\n意义 : 降低服务器压力\n\n注意 :\n\n * 缓存空间不能太大 , 预留其他缓存\n * 缓存数据周期 控制失效时间\n\n# 定时触发\n\n场景 : 定时每天为用户推送列表/\n\n**方案 : **\n\n 1. Spring Scheduler (Spring boot 内置)\n 2. Quartz (独立框架)\n 3. XXL-Job 分布式任务调度平台 (UI+SDK)\n\n推荐学习 : XXL-Job\n\n# 手动触发\n\n\n# Java实现\n\n\n# SpringBoot\n\n应用现成的\n\n 1. pom引入\n    \n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-data-redis</artifactId>\n    </dependency>\n    \n\n 2. 配置 Reids地址\n    \n    # redis 配置 (端口/地址/Reids库位置)\n    spring:\n        redis:\n            port: 6379\n            host: localhost\n            database: 0\n    \n\n 3. 引入Bean RedisTemplate\n    \n    @Resource\n    private RedisTemplate redisTemplate;\n    \n\n 4. 测试 CRUD\n    \n    @Resource\n    private RedisTemplate redisTemplate;\n    \n    @Test\n    public void add() {\n        ValueOperations ops = redisTemplate.opsForValue();\n    \n        ops.set("String","Sans");\n        String[] stat = {"zs1","zs2"};\n        ops.set("List",Arrays.toString(stat));\n        ops.set("Int",666);\n        ops.set("double",6.6);\n        User user = new User();\n        user.setId(9);\n        user.setUsername("Sans111");\n        ops.set("user",user);\n    }\n    \n    @Test\n    public void show() {\n        ValueOperations ops = redisTemplate.opsForValue();\n        System.out.println("String =>" + ops.get("String"));\n        System.out.println("List =>" + ops.get("List"));\n        System.out.println("Int =>" + ops.get("Int"));\n        System.out.println("double =>" + ops.get("double"));\n        System.out.println("user =>" + ops.get("user"));\n    }\n    \n    @Test\n    public void del() {\n        redisTemplate.delete("String");\n        redisTemplate.delete("List");\n        redisTemplate.delete("Int");\n        redisTemplate.delete("double");\n        redisTemplate.delete("user");\n    }\n    \n\n> set方法重用可直接进行覆盖\n\n# 自定义序列化器\n\n默认的序列化Key值可能在某些工具查看可能乱码 , 因此 需要自定义配置下\n\n> 默认采用的是Jdk自带的序列化工具\n\nRedisConfig配置类\n\n@Configuration\npublic class RidesConfig {\n    @Bean\n    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory connectionFactory) {\n        RedisTemplate<String, Object> redisTemplate = new RedisTemplate<>();\n        // 设置 序列化器\n        redisTemplate.setKeySerializer(RedisSerializer.string());\n        // 设置 连接工厂\n        redisTemplate.setConnectionFactory(connectionFactory);\n        return redisTemplate;\n    }\n}\n\n\n> 以上配置能够解决序列化Key值乱码问题!(工具查看可以看出是乱码)\n\n\n# Jedis连接\n\n环境\n\n下载 jedis.jar 下载jar包\n\n> Maven项目 ，导入依赖\n> \n> <dependency>\n> \t<groupId>redis.clients</groupId>\n> \t<artifactId>jedis</artifactId>\n> \t<version>2.9.0</version>\n> </dependency>\n\n# 连接服务器\n\n 1. 实例对象连接\n    \n    Jedis jedis = new Jedis(“ip地址”, 端口号);//建立链接\n    \n\n 2. 实现应用\n    \n    public static void main(String[] args) {\n    \tJedis jedis=new Jedis("192.168.197.129",6379);\n    \t// 如果 Redis 服务设置了密码，需要下面这行，没有就不需要\n        // jedis.auth("123456"); \n    \tjedis.set("java001","java工程师");\n    \tString java001 = jedis.get("java001");\n    \tSystem.out.println(java001);\n    }\n    \n\n# 连接池\n\npublic class ConnectionTest {\n    public static void main(String[] args) {\n        JedisPoolConfig config = new JedisPoolConfig();\n        //最大连接数\n        config.setMaxTotal(30);\n        //最大空闲数\n        config.setMaxIdle(10);\n        //获取连接池\n        JedisPool jedisPool = new JedisPool(config,"192.168.74.131",6379);\n        Jedis jedis = null;\n    \n        try {\n            jedis = jedisPool.getResource();\n            jedis.set("name","张三");\n            String name = jedis.get("name");\n            System.out.println("name : " + name);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }finally {\n            if (jedis != null) {\n                jedis.close();\n            }\n            if (jedisPool != null) {\n                jedisPool.close();\n            }\n        }\n    \n    }\n}\n\n\n# 集群\n\nPS：如果redis重启，需要将redis中生成的dump.rdb和nodes.conf文件删除，然后再重启。\n\npublic class Demo {\n    public static void main(String[] args) {\n        \n        // 创建连接\n        Set<HostAndPort> nodes = new HashSet<HostAndPort>();\n        nodes.add(new HostAndPort("192.168.74.131",7001));\n        nodes.add(new HostAndPort("192.168.74.131",7002));\n        nodes.add(new HostAndPort("192.168.74.131",7003));\n        nodes.add(new HostAndPort("192.168.74.131",7004));\n        nodes.add(new HostAndPort("192.168.74.131",7005));\n        nodes.add(new HostAndPort("192.168.74.131",7006));\n    \n        // 集群搭建\n        JedisCluster cluster = null;\n        cluster = new JedisCluster(nodes);\n    \n        // 执行JedisCluster对象中的方法，方法和redis指令一一对应\n        cluster.set("name","柏竹");\n        String name = cluster.get("name");\n        System.out.println("name : " + name);\n    \n        //存储List数据到列表中\n        cluster.lpush("site-list", "java");\n        cluster.lpush("site-list", "c");\n        cluster.lpush("site-list", "mysql");\n        List<String> stringList = cluster.lrange("site-list",0,2);\n        System.out.println("=============");\n        for (String s : stringList) {\n            System.out.println(s);\n        }\n    \n        //关闭集群 JedisCluster对象\n        try {\n            if (cluster != null) {\n                cluster.close();\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }finally {\n            System.out.println("集群测试完成！！！");\n        }\n    \n    }\n}\n\n\n\n# Lettuce\n\n高阶操作 Reids (复杂 , 异步 , 连接池)\n\n\n# Redisson\n\n介绍 : https://github.com/redisson/redisson\n\n版本 : https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter\n\n# 快速入门\n\n 1. 引入依赖\n    \n    <dependency>\n        <groupId>org.springframework.session</groupId>\n        <artifactId>spring-session-data-redis</artifactId>\n    </dependency>\n    \n    \n    > 版本迭代快 , 非SprinBoot谨慎选择Redisson版本\n\n 2. 写入配置\n    \n    @Bean\n    public RedissonClient redissonClient() {\n        // 创建配置\n        Config config = new Config();\n        String redisAddress = String.format("redis:127.0.0.1:6379");\n        config.useSingleServer()\n        \t.setAddress(redisAddress)\n        \t.setDatabase(0);\n    \n        // 创建实例\n        RedissonClient redissonClient = Redisson.create(config);\n        return redissonClient;\n    }\n    \n\n 3. 测试应用\n    \n    @Resource\n    private RedissonClient redissonClient;@Test\n    public void redissonTest() {\n        // JVM 本地操作\n        List<Object> list = new ArrayList<>();\n        list.add("sasn");\n        System.out.println("list.get(0) = " + list.get(0));\n    \n        // reids 操作\n        // RLIST 继承了 List特性\n        RList<Object> rList = redissonClient.getList("test-list");\n        rList.add("123123");\n        System.out.println("rList.get(0) = " + rList.get(0));\n    \n        // Redisson 其他集合...\n        //redissonClient.getMap("test-map");\n    }\n    \n\n# 定时任务\n\n意图 : 每天提前更新的缓存数据 , 防止数据在高峰期抢占资源\n\n注意 :\n\n * 线程等待时间为0 , 多个线程只能抢一次\n * 释放锁前提需要判断是否是本线程的锁否则跳过\n * 释放锁是在 try-catch 中的 finally中进行检查释放 (防止中途代码异常)\n\n**代码示例 : **\n\n定时任务采用 Springboot内置 @EnableScheduling 和 采用Redisson分布式锁 实现\n\n多台服务的情况下 , 每天凌晨12点 加载定时任务 , 多个服务只能一个服务进行执行任务 (避免不必要的资源浪费)\n\n@Resource\nprivate RedissonClient redissonClient;\n\n@Scheduled(cron = "0 0 0 * * *")\npublic void doCacheRecommendUser() {\n    RLock lock = redissonClient.getLock("sans:precachejob:docache:lock");\n    /*\n      参数\n      1. 等待获取(0无需等待)\n      2. 过期时长\n      3. 时间单位\n     */\n    try {\n        // 只有一个线程获取到锁\n        if (lock.tryLock(0, 30000, TimeUnit.MILLISECONDS)) {\n            System.out.println("lockName op :" + Thread.currentThread().getName());\n            for (Long userId : mainUserList) {\n                String redisKey = String.format("sans:user:recommend:%s", userId);\n                ValueOperations<String, Object> ops = redisTemplate.opsForValue();\n                QueryWrapper<User> qw = new QueryWrapper<>();\n                Page<User> userPage = userService.page(new Page<>(1, 20), qw);\n                try {\n                    ops.set(redisKey, userPage, 1, TimeUnit.DAYS);\n                } catch (Exception e) {\n                    log.error("redis set key");\n                }\n            }\n        }\n    } catch (InterruptedException e) {\n        log.error("doCacheRecommendUser error " + e.getMessage());\n    } finally {\n        if (lock.isHeldByCurrentThread()) {\n            lock.unlock();\n            System.out.println("lockName ed :" + Thread.currentThread().getName());\n        }\n    }\n}\n\n\n# 续约锁\n\n监听线程 , 如方法未执行完 , 会帮你重置 reids锁的过期时间\n\n@Autowired \nprivate RedissonClient redisson; //自动装配RedissonClient\nRLock lock = redisson.getLock("onelock"); //获取锁\nlock.lock(); //加锁\nlock.unlock(); //释放锁\n\n\n主要通过方法 ==lock.tryLock(0, -1, TimeUnit.MILLISECONDS)==\n\n> 方法参数说明 : 1参数 等待获取锁时长 , 2参数 锁过期时长 , 3参数 时间单位\n> \n> 续约锁需要指定 2参数为 -1 , Redisson自动设为 续约模式 , 直到线程执行完成并释放锁\n\n注意 :\n\n * 过期时间必须定义为 -1\n * 监听当前线程 , 默认过期时间为30s , 每 10s 续期一次\n * 如果线程挂掉(debug模式也会误认宕机) , 则不会续期\n * tryLock()方法必须要用try-catch包括并且在finally中进行释放锁(防止异常后能够进行释放锁)\n\n**代码示例 : **\n\n/**\n * 看门狗机制测试\n */\n@Test\npublic void redissonLookDoorDog() {\n    RLock lock = redissonClient.getLock("sans:precachejob:docache:lock");\n    System.out.println("start");\n    try {\n        if (lock.tryLock(0, -1, TimeUnit.MILLISECONDS)) {\n            Thread.sleep(300000);\n        }\n    } catch (InterruptedException e) {\n        System.out.println(e.getMessage());\n    } finally {\n        // 只能释放本身线程的锁(以防释放其他线程的锁)\n        if (lock.isHeldByCurrentThread()) lock.unlock();\n    }\n}\n\n\n\n# Q&A\n\n\n# 缓存问题\n\n缓存是在第一次加载的数据进行复用，将数据存放指定地点以便下次加载使用。可防止多访问同一 数据库 而产生的堵塞，也能减轻 数据库 的压力！\n\nJava缓存\n\n * 虚拟机缓存（ehcache、JBoss Cache）\n * 分布式缓存（redis、memcache）\n * 数据库缓存\n\n\n\n# 缓存雪崩\n\n**Q : **原有缓存失效（或者未加载到缓存中），因此 访问过程会跨越缓存直接访问 数据库，这一过程很有可能会导致 数据库 宕机（CPU、内存 高负载）\n\nA : 原有缓存失效后，可通过 加锁 或 队列 进行控制 数据库的线程数量。失效期间 尽快修复 缓存，否则 用户访问会堵塞\n\n加锁\n\npublic Users getByUsers(Long id) {\n\t// 1.先查询redis\n\tString key = this.getClass().getName() + "-" + Thread.currentThread().getStackTrace()[1].getMethodName()+ "-id:" + id;\n\tString userJson = redisService.getString(key);\n\tif (!StringUtils.isEmpty(userJson)) {\n\t\tUsers users = JSONObject.parseObject(userJson, Users.class);\n\t\treturn users;\n\t}\n\tUsers user = null;\n\ttry {\n\t\tlock.lock();\n\t\t// 查询db\n\t\tuser = userMapper.getUser(id);\n\t\tredisService.setSet(key, JSONObject.toJSONString(user));\n\t} catch (Exception e) {\n        \n\t} finally {\n\t\tlock.unlock(); // 释放锁\n\t}\n\treturn user;\n}\n\n\n# 缓存穿透\n\n**Q : **当用户查询指定数据 且 数据库 中恰好也没有，此时缓存自然也不会有。这样就导致 重复查询 都会访问数据库，类似的查询都会绕过缓存直接查数据库！\n\nA :\n\n * 如果首次 数据库 访问查询的数据为空，可直接设置一个默认值进行缓存，这样下次有相同的访问，就不会继续访问 数据库\n * 也可把空结果，进行缓存，这样下次有相同的访问，就不会继续访问 数据库\n\npublic String getByUsers2(Long id) {\n\t// 1.先查询redis\n\tString key = this.getClass().getName() + "-" + Thread.currentThread().getStackTrace()\n[1].getMethodName()+ "-id:" + id;\n\tString userName = redisService.getString(key);\n\tif (!StringUtils.isEmpty(userName)) {\n\t\treturn userName;\n\t}\n\tSystem.out.println("######开始发送数据库DB请求########");\n\tUsers user = userMapper.getUser(id);\n\tString value = null;\n\tif (user == null) {\n\t\t// 标识为null\n\t\tvalue = "";\n\t} else {\n\t\tvalue = user.getName();\n\t}\n\tredisService.setString(key, value);\n\treturn value;\n}\n\n\n# 缓存击穿\n\n**Q : ** 在某一时间点 突然以超高并发进行访问 过期的key，导致 缓存被击穿 . 突然高频访问的key 称为 热点数据\n\n**A : **\n\n * 使用锁，单机 synchronized 、lock 等，分布式用 分布式锁\n * 缓存过期时间不设置，而是设置在key对应的value里。如果检测到存的时间超过过期时间则异步更新缓存\n\n\n# 分布式锁问题\n\n# 死锁\n\n**Q : ** setnx命令 , 未释放资源\n\n**A : **\n\n * 设值过期\n * 关闭锁\n\n# JVM锁和分布式锁\n\n      JVM锁       分布式锁\n锁范围   JVM中的多线程   多个JVM\n实现于   Java       Redis/MySQL/Zookeeper/等\n\nJVM应用的范围过于局限 , 因此需要分布式扩大锁的范围\n\n# 续约锁\n\nQ : 如果锁所执行的方法时间过长 , 锁提前过期 , 导致他人占用?\n\nA : 续约锁的时长进行加时\n\n> 续约锁的目的主要是防止锁长时间占用问题 , 达到节省资源\n\nQ2 : 释放锁的时候 , 先前判断出是自己的锁 , 由于执行时间过长导致期间锁过期了 , 此时被其他节点所占用 , 因此方法很有可能会将别的节点锁进行释放! (以下伪代码示例)\n\n// 此时判断为A锁含有过期\nif(get lock == A){\n    // 执行过程....(漫长\n    del lock; // 释放锁(此时锁可能不为A)\n}\n\n\nA2 : Redis + lua脚本 实现',normalizedContent:'# redis\n\n\n# 概述\n\nremote dictionary server(redis) 是一个由 salvatore sanfilippo 写的 key-value 存储系统，是跨平台的非关系型数据库\n\nredis 是一个开源的使用 ansi c 语言编写、遵守 bsd 协议、支持网络、可基于内存、分布式、可选持久性的键值对(key-value)存储数据库，并提供多种语言的 api\n\nredis 通常被称为数据结构服务器\n\n\n# redis基础\n\n\n# 数据类型\n\nredis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)\n\n数据类型              数据类型存储的值                                       说明\nstring（字符串）       字符串、整数、浮点数                                     字符串增加；求子串\n                                                                 整数、浮点数 计算自增..\nlist（列表）          链表、每个节点都含有一个字符串                                支持 链表头尾 插入弹出\n                                                                 偏移剪切\n                                                                 查询、删除 指定节点\nset（集合）           集合中的每个元素都是一个字符串，且他们都是唯一的                       可 增删查 元素，\n                                                                 检测元素是否存在集合\n                                                                 计算集合 交、并、差集 等\n                                                                 随机读取元素\nhash（哈希散列表）       java中的 map类 ，<k , v>                           可 增删改查 键值对\n                                                                 可获取所有键值对\nzset（有序集合）        有序集合，可能包含 字符串、整数、浮点数、分值(score)、元素（排列有分值大小决定）   可 增删改查 元素\n                                                                 根据分值范围或成员 获取对应元素\nhyperloglog（基数）   计算重复的值，确定存储数量                                  只提供基数运算，不提供返回功能\n\n\n# 常用命令\n\nredis 命令用于在 redis 服务上执行操作\n\n基本类型操作\n\n说明                                      命令\n赋值                                      set key value\n取值                                      get key\n多键值赋值                                   mset key value [key value ...]\n多取值                                     mget key [key ...]\n字符串数值操作                                 \n递增+1                                    incr key\n递减-1                                    decr key\n指定增加                                    incrby key increment\n指定减少                                    decrby key decrem\nhash散列                                  \nhash赋值                                  hset key field value\nhash取值                                  hget key field\nhash多赋值                                 hmset key field value [field value]\n获取所有字段值                                 hgetall key\nlist队列                                  \n列表左增                                    lpush key value [value ...]\n列表左弹                                    lpop key\n列表右增                                    rpush key value [value ...]\n列表右弹                                    rpop key\n列表总数                                    llen key\n查列表                                     lrange key start stop\nset集合（无序不可重复）                           \n添加元素                                    sadd key member [menber ...]\n删除元素                                    srem key member [member ...]\n获取所有元素                                  smembers key\n查 元素 是否存在集合(ruturn 0/1 => falet/ture)   sismember key member\nzset有序集合（可排序，唯一性）                       \n添加元素                                    zadd key score member [score member ...]\n获取元素                                    zscore key member\n删除元素                                    zrem key member [menber ...]\n查 根据 数值进行排列（默认降序）                       zrevrange key start stop [withscores]\nwithscores：查 键、值\n元素 递增/递减 (支持正负)                         zincrby key increment member\nhyoperloglog命令                          \n添加元素                                    pfadd key element [element ...]\n获取指定 hyperloglog 基数估算值                  pfcount key [key ...]\n将多个 hyperloglog 合并为一个 hyperloglog       pfmerge destkey sourcekey [sourcekey ...]\n生命周期                                    \n设置key生存周期（秒）                            expire key seconds\n查看剩下生存时间                                ttl key\n清除生存时间                                  persist key\n其他命令                                    \n查所有key                                  keys *\n查所有以user开头的key                          keys user *\n确认key是否存在(ruturn 0/1 => falet/ture)     exists key\n删除key                                   del key\n重命名key                                  rename oldkey newkey\n获取key值类型                                type key\n获取服务器信息                                 info\nkey移动至指定数据库                             move key db\n切换数据库                                   select index\n停止服务器                                   shutdown\n关闭服务连接                                  quit\n删除当前数据库中的所有key                          flushdb\n删除所有数据库中的所有                             flushall\n\nhyoperloglog命令\n\n随机化的算法，以少量内存提供集合唯一的元素数量的近似值\n\n可接受多个元素作为输入，并给出输入元素的基数估算值\n\n> 基数：集合中不同元素的数量。 例如{\'sanscan\',\'bobo\',\'sanscan\',\'tomy\',\'sanscan\'}的基数为3\n> \n> 估算值：算法给出的基数并非精确，有些许偏差，但 会控制在范围内\n\n命令参考：\n\n * https://redis.io/commands\n * http://doc.redisfans.com/index.html\n\n\n# 事务\n\nredis 事务可以一次执行多个命令， 并且带有以下两个重要的保证：\n\n * 事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客 户端发送来的命令请求所打断\n * 事务中的命令要么全部被执行，要么全部都不执行\n\n事务阶段：\n\n>  1. 开始事务\n>  2. 命令入队\n>  3. 执行事务\n\n事务命令\n\n命令        描述\nmulti     开始事务\ndiscard   取消事务\nexec      结束事务\n\n\n# 订阅\n\nredis 发布订阅 (pub/sub) 是一种消息通信模式：发送者 (pub) 发送消息，订阅者 (sub) 接收消息\n\n实现方式：\n\n>  * 开启本地 redis 服务，开启两个 redis-cli 客户端\n>  * 第一个 redis-cli 客户端输入 subscribe runoobchat，意思是订阅 runoobchat 频道\n>  * 第二个 redis-cli 客户端输入 publish runoobchat "redis publish test" 往 runoobchat 频道发送消息，这个时候在第一个 redis-cli 客户端就会看到由第二个 redis-cli 客户端发送的测试消息\n\n订阅命令\n\n命令                                 说明\npsubscribe pattern [pattern ...]   订阅一个或多个频道\npublish channel message            将信息发送指定频道\n\n\n# 持久化\n\nredis值放在内存中，为防止突然断电等特殊情况的发生，需要对数据进行持久化备份。即将内存数据保存到硬盘。\n\n# rdb持久化\n\nrdb 是以二进制文件，是在某个时间点将数据写入一个临时文件，持久化结束后，用这个临时文件替换上次持久化的文件，达到数据恢复\n\nrdb 默认开启， redis.conf文件 中的具体配置参数如下：\n\n#dbfilename：持久化数据存储在本地的文件\ndbfilename dump.rdb\n#dir：持久化数据存储在本地的路径，如果是在/redis/redis-5.0.5/src下启动的redis-cli，则数据会存储在当前\nsrc目录下\ndir ./\n##snapshot触发的时机，save\n##如下为900秒后，至少有一个变更操作，才会snapshot\n##对于此值的设置，需要谨慎，评估系统的变更操作密集程度\n##可以通过“save”来关闭snapshot功能\n#save时间，以下分别表示更改了1个key时间隔900s进行持久化存储；更改了10个key300s进行存储；更改10000个\nkey60s进行存储。\nsave 900 1\nsave 300 10\nsave 60 10000\n##当snapshot时出现错误无法继续时，是否阻塞客户端“变更操作”，“错误”可能因为磁盘已满/磁盘故障/os级别异常等\nstop-writes-on-bgsave-error yes\n##是否启用rdb文件压缩，默认为“yes”，压缩往往意味着“额外的cpu消耗”，同时也意味这较小的文件尺寸以及较短的网\n络传输时间\nrdbcompression yes\n\n\n触发机制（snapshots）\n\n> 写入扳机： 根据写入 key的个数 进行触发 （一个key快照需要900s） 默认情况：1 -> 900s ；300 -> 300s ； 10000 -> 60s\n> \n> 数据更新方式： 每次 触发写入扳机 都会替换上次持久化好的文件\n\n# aof持久化\n\naof是将 “操作 + 数据” 以格式化指令的方式追加到操作日志文件的尾部，通过append操作进行写入文件，才进行实际数据更变\n\n当需要恢复数据时直接读取此日志文件，还原所有的操作过程，aof文件内容是字符串，便于阅读。\n\naof 默认关闭， redis.conf文件 中的具体配置参数如下：\n\n开启方法：appendonly yes\n\n##此选项为aof功能的开关，默认为“no”，可以通过“yes”来开启aof功能\n##只有在“yes”下，aof重写/文件同步等特性才会生效\nappendonly yes\n##指定aof文件名称\nappendfilename appendonly.aof\n##指定aof操作中文件同步策略，有三个合法值：always everysec no,默认为everysec\nappendfsync everysec\n##在aof-rewrite期间，appendfsync是否暂缓文件同步，"no"表示“不暂缓”，“yes”表示“暂缓”，默认为“no”\nno-appendfsync-on-rewrite no\n##aof文件rewrite触发的最小文件尺寸(mb,gb),只有大于此aof文件大于此尺寸是才会触发rewrite，默认“64mb”，建\n议“512mb”\nauto-aof-rewrite-min-size 64mb\n##相对于“上一次”rewrite，本次rewrite触发时aof文件应该增长的百分比。\n##每一次rewrite之后，redis都会记录下此时“新aof”文件的大小(例如a)，那么当aof文件增长到a*(1 + p)之后\n##触发下一次rewrite，每一次aof记录的添加，都会检测当前aof文件的尺寸。\nauto-aof-rewrite-percentage 100\n\n\n文件同步策略（appendfsync）\n\n> 配置原因：aof 是文件操作，对于变更操作比较密集的 server，那么必将造成磁盘 io 的负荷加。linux文件操作运用了 延迟写入 的形式，并非每次 写入(write) 都会执行 实际写入 操作，而是写入 缓存(buffer) 中，当 缓存(buffer) 中的数据都达指定 值(阀值) ，才会触发 实际写入 操作。\n> \n> 解决方案：可以得知 redis 提供 appendfsync配置 3 个 文件同步策略 选项：\n> \n>  * always：每一条 aof 记录都立即同步到文件，这是最安全的方式，也以为更多的磁盘操作和阻塞延迟，是 io 开支 较大\n>  * everysec：每秒同步一次，性能和安全都比较中庸的方式，也是 redis 推荐的方式。如果遇到物理服务器故障，有 可能导致最近一秒内 aof 记录丢失(可能为部分丢失)\n>  * no：redis 并不直接调用文件同步，而是交给操作系统来处理，操作系统可以根据 buffer 填充情况 / 通道空闲时间 等择机触发同步；这是一种普通的文件操作方式。性能较好，在物理服务器故障时，数据丢失量会因 os 配置有关\n\n# rdb与aof区别\n\nrdb\n\n> 使用单独子进程来进行持久化，主进程不会进行任何 io 操作\n> \n> 发生故障 将会丢失数据指定存储时长的 key值（根据存储 key的数量 控制时长）\n> \n> 数据内容形式 二进制\n\naof\n\n> io 操作会有 1s 的时长进行 实际写入\n> \n> 发生故障 将会丢失数据发生故障前1s的数据\n> \n> 数据形式 字符串\n\n       rdb   aof\n加载速度   快     慢\n容量大小   小     大\n丢失概率   高     低\n内容可读   否     是\n\n\n# 主从复制\n\n主从复制 是指将 一台redis服务器(主)，拷贝到其他的redis服务器(从)；主从广西只是数据的单向复制，由主节点到从节点\n\n主从复制作用\n\n * 故障恢复：主节点发生故障，由从节点提供服务，直至主节点修复\n * 数据冗余：实现数据同步备份，持久化之外的数据备份方式\n\n主从复制原理\n\n>  1. 从机通过配置的 replicaof参数 ，从节点完成主节点 ip 和 port 的保存后，向发送replicaof命令 的客户端直接返回ok\n>  2. 连接后从节点先主节点发送 sync命令，主节点收到命令立即执行保存快照(持久化文件)，并将 缓存的持久化文件 和 缓存写命令 发送给从节点 ，开始同步\n>  3. 从节点收到响应，执行 缓存的持久化文件 和 缓存写命令\n\n实现步骤\n\n主机无需配置\n\n 1. 复制出一个从机 （将 redis文件 夹拷贝）\n 2. 修改从机配置文件 redis.conf 参数replicaof ：主机ip + 主机端口\n 3. 修改从机配置文件 redis.conf 参数port ：从机端口(自定义)\n 4. 清除从机所有的持久化文件\n 5. 启动从机 （注意启动端口）\n\n注意\n\n>  * 主机发生增删改操作，那么从机会自动将数据同步到从机中\n>  * 从机不能执行写操作,只能读\n>  * 如果主机宕机，从机执行 slaveof no one命令，提升为为主机继续服务；主机修复后，主机执行 slaveof host port 命令，将其恢复主机\n\n\n# 哨兵模式\n\n哨兵模式(sentinel) 是 由一个或多个sentinel组成的 sentinel系统 可以监视服务器的上线状态\n\n哨兵模式作用\n\n * 系统监控：独立的进程(哨兵) 对系统实时监控\n * 故障切换：主服务器发生故障，会自动将从服务器转为主服务器进行服务（权重）\n\n实现步骤 （linux实现）\n\n 1. 从 redis源码配置 中复制 redis-5.0.5/sentinel.conf (这是我的实例)\n\n 2. 粘贴至 任意服务器节点的 bin 目录下\n\n 3. 配置 sentinel.conf 中文件 sentinel monitor参数 sentinel monitor <master-name> <ip> <redis-port> <quorum> 例如：sentinel monitor mymaster 192.168.74.131 6380 1\n\n 4. 指定文件写入日志中，在当前 bin 中 执行以下命令 ./redis-sentinel ./sentinel.conf >sent.log &\n\n 5. 启动 主从服务器\n\n 6. 启动哨兵监控进程，在bin上级目录 执行以下命令 ./redis-server redis.conf --sentinel\n\n 7. 查看 哨兵进程，执行以下命令 ps -aux|grep redis\n    \n    测试：杀死进程 kill 9 pid 模拟宕机\n\n注意\n\n>  * 第三步配置参数的 <master-name> 。如果使用 自定义名称 其他配置参数对应的名称也 需要更改为对应的 自定义名称（否则无效）\n>  * 启动哨兵的时候，修改了哨兵的配置文件。如果需要再次启动哨兵，需要删除myid唯一标示\n>  * 哨兵切换 主从服务器 的同时，也会修改 redis.conf 的主从配置文件\n>  * 主服务器 故障修复后，需要手动调至 主服务器 slaveof host port\n\n\n# 集群\n\nredis集群是通过添加服务器的数量，提供相同的服务，从而让服务器达到一个稳定、高效的状态\n\nredis-cluste集群方案\n\nredis-cluster采用无中心结构，每个节点保存数据和整个集群状态,每个节点都和其他所有节点连接\n\n\n\n结构及特点说明\n\n 1. 所有redis节点都是彼此互联。内部使用二进制协议优化传输速率\n 2. 客户端(client)与redis节点是直连的，无需中间层，client只需连接任意一个redis节点即可应用\n 3. 集群把所有 物理节点映射到 [0-16383] 槽点上，当 redis集群 存储一个 key-value 时，key 使用 crc16 算法 算出结果，然后用 结果 对 16384 求余数，最终得到的值 将决定 key放到哪个桶中\n 4. 当 redis-cluster 中任意 master 挂掉，且当前 master 没有 slave ，则 redis-cluster 为 fail 状态 。 （但 slot映射 不完全进入 fail状态）\n 5. 当 redis-cluster 中 master 挂掉一半以上，则 redis-cluster 为 fail 状态\n\nslot映射\n\n\n\n集群搭建 （linux实现）\n\n\n\n 1.  新建集群目录，以下是个人用例\n     \n     [root@bozhuno1 myapps]# mkdir redis-cluster\n\n 2.  在 集群 目录下，创建节点目录（复制redis节点），上图已经实例（先配置一个，剩下复制... ）\n     \n     [root@localhost myapps]# cp redis/ redis-cluster/7001 -r\n     [root@localhost myapps]# cd redis-cluster/7001\n     [root@localhost 7001]# ll\n     drwxr-xr-x. 2 root root 4096 7月 1 10:22 bin\n     -rw-r--r--. 1 root root 3446 7月 1 10:22 dump.rdb\n     -rw-r--r--. 1 root root 41404 7月 1 10:22 redis.conf\n     \n\n 3.  删除节点根目录下的 持久化文件 appendonly.aof dump.rdb\n\n 4.  支持集群，设置 节点根目录下的 redis.conf 配置文件 ，cluster-enable 参数 设为 yes （默认注释了）\n\n 5.  配置端口，设置 节点根目录下的 redis.conf 配置文件 ，port 参数 设置 端口号 （我们测试的端口范围：[7001-7006]）\n\n 6.  完成一个 redis节点 后 ，剩下节点需要复制粘贴，步骤2开始\n\n 7.  完成6个 redis节点 后，启动所有节点服务。启动脚本辅助启动6个节点\n     \n     # vim startall.sh\n     \n     cd 7001\n     ./bin/redis-server ./redis.conf\n     cd ..\n     cd 7002\n     ./bin/redis-server ./redis.conf\n     cd ..\n     cd 7003\n     ./bin/redis-server ./redis.conf\n     cd ..\n     cd 7004\n     ./bin/redis-server ./redis.conf\n     cd ..\n     cd 7005\n     ./bin/redis-server ./redis.conf\n     cd ..\n     cd 7006\n     ./bin/redis-server ./redis.conf\n     cd ..\n     \n\n 8.  设置 脚本启动权限 chmod u+x startall.sh\n\n 9.  启动 节点进程服务 ./startall.sh\n\n 10. 创建集群 redis-cli --cluster create ip:port ip:port --cluster-replicas 1 （以下是本人应用实例）\n     \n     [root@bozhuno1 bin]# cd /home/bozhu/myapps/redis-cluster/7001/bin\n     [root@bozhuno1 bin]# ./redis-cli --cluster create 192.168.74.131:7001 192.168.74.131:7002 192.168.74.131:7003 192.168.74.131:7004 192.168.74.131:7005 192.168.74.131:7006  --cluster-replicas 1\n     >>> performing hash slots allocation on 6 nodes...\n     master[0] -> slots 0 - 5460\n     master[1] -> slots 5461 - 10922\n     master[2] -> slots 10923 - 16383\n     adding replica 192.168.74.131:7005 to 192.168.74.131:7001\n     adding replica 192.168.74.131:7006 to 192.168.74.131:7002\n     adding replica 192.168.74.131:7004 to 192.168.74.131:7003\n     ···\n     [ok] all 16384 slots covered.\n     \n     \n     ps：创建前需要关闭防火墙； redis 5.0.5中使用 redis-cli --cluster 替代 redis-trib.rb\n\n 11. 连接集群（-c：指定是集群连接）\n     \n     [root@localhost 7001]# ./bin/redis-cli -h 192.168.74.131 -p 7001 -c\n     \n\n查询集群信息：cluster info ；查看集群中节点信息：cluster nodes\n\n\n# 分布式锁\n\n点击了解线程同步\n\n分布式锁是多个服务器在同一系统中可服务器多个进程对资源的访问\n\nredis为单进程 单线程模式，采用队列模式将并发访问变成串行访问，且多客户端对redis的连接并不存在竞争 关系。redis也可实现分布式锁\n\n意图 : 节省资源空间\n\n应用满足条件\n\n 1. 系统是一个分布式的系统\n 2. 资源共享（各个系统访问同一数据库）\n 3. 同步访问（多个进程同时访问同一个资源）\n\nredis分布式锁命令\n\nsetnx ==setnx key value== key存在 , 不做操作 ; key不存在则设值\n\ngetset ==getset key value== 先获取key对应的旧值，且新值覆盖替换旧值\n\n> 注意事项 :\n> \n>  * 用完锁一定要释放\n>  * 锁一定要加过期时间\n\n\n# 实战技巧\n\n\n# key缓存设计\n\n独立设计 key\n\n例如 :\n\nsystemid:moduleid:func\n\nsans:user:recommed:userid\n\n> key设置一定要有过期时间!!!\n\n\n# redis 模拟百万数据\n\n 1. 库插入百万条数据\n 2. redis存储定时10s过期\n 3. 循环刷新测试用时\n\n\n\n> 肉眼可见的速度\n\n\n# 缓存预存储\n\n按照不同场景进行提前缓存数据\n\n意义 : 降低服务器压力\n\n注意 :\n\n * 缓存空间不能太大 , 预留其他缓存\n * 缓存数据周期 控制失效时间\n\n# 定时触发\n\n场景 : 定时每天为用户推送列表/\n\n**方案 : **\n\n 1. spring scheduler (spring boot 内置)\n 2. quartz (独立框架)\n 3. xxl-job 分布式任务调度平台 (ui+sdk)\n\n推荐学习 : xxl-job\n\n# 手动触发\n\n\n# java实现\n\n\n# springboot\n\n应用现成的\n\n 1. pom引入\n    \n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-data-redis</artifactid>\n    </dependency>\n    \n\n 2. 配置 reids地址\n    \n    # redis 配置 (端口/地址/reids库位置)\n    spring:\n        redis:\n            port: 6379\n            host: localhost\n            database: 0\n    \n\n 3. 引入bean redistemplate\n    \n    @resource\n    private redistemplate redistemplate;\n    \n\n 4. 测试 crud\n    \n    @resource\n    private redistemplate redistemplate;\n    \n    @test\n    public void add() {\n        valueoperations ops = redistemplate.opsforvalue();\n    \n        ops.set("string","sans");\n        string[] stat = {"zs1","zs2"};\n        ops.set("list",arrays.tostring(stat));\n        ops.set("int",666);\n        ops.set("double",6.6);\n        user user = new user();\n        user.setid(9);\n        user.setusername("sans111");\n        ops.set("user",user);\n    }\n    \n    @test\n    public void show() {\n        valueoperations ops = redistemplate.opsforvalue();\n        system.out.println("string =>" + ops.get("string"));\n        system.out.println("list =>" + ops.get("list"));\n        system.out.println("int =>" + ops.get("int"));\n        system.out.println("double =>" + ops.get("double"));\n        system.out.println("user =>" + ops.get("user"));\n    }\n    \n    @test\n    public void del() {\n        redistemplate.delete("string");\n        redistemplate.delete("list");\n        redistemplate.delete("int");\n        redistemplate.delete("double");\n        redistemplate.delete("user");\n    }\n    \n\n> set方法重用可直接进行覆盖\n\n# 自定义序列化器\n\n默认的序列化key值可能在某些工具查看可能乱码 , 因此 需要自定义配置下\n\n> 默认采用的是jdk自带的序列化工具\n\nredisconfig配置类\n\n@configuration\npublic class ridesconfig {\n    @bean\n    public redistemplate<string, object> redistemplate(redisconnectionfactory connectionfactory) {\n        redistemplate<string, object> redistemplate = new redistemplate<>();\n        // 设置 序列化器\n        redistemplate.setkeyserializer(redisserializer.string());\n        // 设置 连接工厂\n        redistemplate.setconnectionfactory(connectionfactory);\n        return redistemplate;\n    }\n}\n\n\n> 以上配置能够解决序列化key值乱码问题!(工具查看可以看出是乱码)\n\n\n# jedis连接\n\n环境\n\n下载 jedis.jar 下载jar包\n\n> maven项目 ，导入依赖\n> \n> <dependency>\n> \t<groupid>redis.clients</groupid>\n> \t<artifactid>jedis</artifactid>\n> \t<version>2.9.0</version>\n> </dependency>\n\n# 连接服务器\n\n 1. 实例对象连接\n    \n    jedis jedis = new jedis(“ip地址”, 端口号);//建立链接\n    \n\n 2. 实现应用\n    \n    public static void main(string[] args) {\n    \tjedis jedis=new jedis("192.168.197.129",6379);\n    \t// 如果 redis 服务设置了密码，需要下面这行，没有就不需要\n        // jedis.auth("123456"); \n    \tjedis.set("java001","java工程师");\n    \tstring java001 = jedis.get("java001");\n    \tsystem.out.println(java001);\n    }\n    \n\n# 连接池\n\npublic class connectiontest {\n    public static void main(string[] args) {\n        jedispoolconfig config = new jedispoolconfig();\n        //最大连接数\n        config.setmaxtotal(30);\n        //最大空闲数\n        config.setmaxidle(10);\n        //获取连接池\n        jedispool jedispool = new jedispool(config,"192.168.74.131",6379);\n        jedis jedis = null;\n    \n        try {\n            jedis = jedispool.getresource();\n            jedis.set("name","张三");\n            string name = jedis.get("name");\n            system.out.println("name : " + name);\n        } catch (exception e) {\n            e.printstacktrace();\n        }finally {\n            if (jedis != null) {\n                jedis.close();\n            }\n            if (jedispool != null) {\n                jedispool.close();\n            }\n        }\n    \n    }\n}\n\n\n# 集群\n\nps：如果redis重启，需要将redis中生成的dump.rdb和nodes.conf文件删除，然后再重启。\n\npublic class demo {\n    public static void main(string[] args) {\n        \n        // 创建连接\n        set<hostandport> nodes = new hashset<hostandport>();\n        nodes.add(new hostandport("192.168.74.131",7001));\n        nodes.add(new hostandport("192.168.74.131",7002));\n        nodes.add(new hostandport("192.168.74.131",7003));\n        nodes.add(new hostandport("192.168.74.131",7004));\n        nodes.add(new hostandport("192.168.74.131",7005));\n        nodes.add(new hostandport("192.168.74.131",7006));\n    \n        // 集群搭建\n        jediscluster cluster = null;\n        cluster = new jediscluster(nodes);\n    \n        // 执行jediscluster对象中的方法，方法和redis指令一一对应\n        cluster.set("name","柏竹");\n        string name = cluster.get("name");\n        system.out.println("name : " + name);\n    \n        //存储list数据到列表中\n        cluster.lpush("site-list", "java");\n        cluster.lpush("site-list", "c");\n        cluster.lpush("site-list", "mysql");\n        list<string> stringlist = cluster.lrange("site-list",0,2);\n        system.out.println("=============");\n        for (string s : stringlist) {\n            system.out.println(s);\n        }\n    \n        //关闭集群 jediscluster对象\n        try {\n            if (cluster != null) {\n                cluster.close();\n            }\n        } catch (ioexception e) {\n            e.printstacktrace();\n        }finally {\n            system.out.println("集群测试完成！！！");\n        }\n    \n    }\n}\n\n\n\n# lettuce\n\n高阶操作 reids (复杂 , 异步 , 连接池)\n\n\n# redisson\n\n介绍 : https://github.com/redisson/redisson\n\n版本 : https://github.com/redisson/redisson/tree/master/redisson-spring-boot-starter\n\n# 快速入门\n\n 1. 引入依赖\n    \n    <dependency>\n        <groupid>org.springframework.session</groupid>\n        <artifactid>spring-session-data-redis</artifactid>\n    </dependency>\n    \n    \n    > 版本迭代快 , 非sprinboot谨慎选择redisson版本\n\n 2. 写入配置\n    \n    @bean\n    public redissonclient redissonclient() {\n        // 创建配置\n        config config = new config();\n        string redisaddress = string.format("redis:127.0.0.1:6379");\n        config.usesingleserver()\n        \t.setaddress(redisaddress)\n        \t.setdatabase(0);\n    \n        // 创建实例\n        redissonclient redissonclient = redisson.create(config);\n        return redissonclient;\n    }\n    \n\n 3. 测试应用\n    \n    @resource\n    private redissonclient redissonclient;@test\n    public void redissontest() {\n        // jvm 本地操作\n        list<object> list = new arraylist<>();\n        list.add("sasn");\n        system.out.println("list.get(0) = " + list.get(0));\n    \n        // reids 操作\n        // rlist 继承了 list特性\n        rlist<object> rlist = redissonclient.getlist("test-list");\n        rlist.add("123123");\n        system.out.println("rlist.get(0) = " + rlist.get(0));\n    \n        // redisson 其他集合...\n        //redissonclient.getmap("test-map");\n    }\n    \n\n# 定时任务\n\n意图 : 每天提前更新的缓存数据 , 防止数据在高峰期抢占资源\n\n注意 :\n\n * 线程等待时间为0 , 多个线程只能抢一次\n * 释放锁前提需要判断是否是本线程的锁否则跳过\n * 释放锁是在 try-catch 中的 finally中进行检查释放 (防止中途代码异常)\n\n**代码示例 : **\n\n定时任务采用 springboot内置 @enablescheduling 和 采用redisson分布式锁 实现\n\n多台服务的情况下 , 每天凌晨12点 加载定时任务 , 多个服务只能一个服务进行执行任务 (避免不必要的资源浪费)\n\n@resource\nprivate redissonclient redissonclient;\n\n@scheduled(cron = "0 0 0 * * *")\npublic void docacherecommenduser() {\n    rlock lock = redissonclient.getlock("sans:precachejob:docache:lock");\n    /*\n      参数\n      1. 等待获取(0无需等待)\n      2. 过期时长\n      3. 时间单位\n     */\n    try {\n        // 只有一个线程获取到锁\n        if (lock.trylock(0, 30000, timeunit.milliseconds)) {\n            system.out.println("lockname op :" + thread.currentthread().getname());\n            for (long userid : mainuserlist) {\n                string rediskey = string.format("sans:user:recommend:%s", userid);\n                valueoperations<string, object> ops = redistemplate.opsforvalue();\n                querywrapper<user> qw = new querywrapper<>();\n                page<user> userpage = userservice.page(new page<>(1, 20), qw);\n                try {\n                    ops.set(rediskey, userpage, 1, timeunit.days);\n                } catch (exception e) {\n                    log.error("redis set key");\n                }\n            }\n        }\n    } catch (interruptedexception e) {\n        log.error("docacherecommenduser error " + e.getmessage());\n    } finally {\n        if (lock.isheldbycurrentthread()) {\n            lock.unlock();\n            system.out.println("lockname ed :" + thread.currentthread().getname());\n        }\n    }\n}\n\n\n# 续约锁\n\n监听线程 , 如方法未执行完 , 会帮你重置 reids锁的过期时间\n\n@autowired \nprivate redissonclient redisson; //自动装配redissonclient\nrlock lock = redisson.getlock("onelock"); //获取锁\nlock.lock(); //加锁\nlock.unlock(); //释放锁\n\n\n主要通过方法 ==lock.trylock(0, -1, timeunit.milliseconds)==\n\n> 方法参数说明 : 1参数 等待获取锁时长 , 2参数 锁过期时长 , 3参数 时间单位\n> \n> 续约锁需要指定 2参数为 -1 , redisson自动设为 续约模式 , 直到线程执行完成并释放锁\n\n注意 :\n\n * 过期时间必须定义为 -1\n * 监听当前线程 , 默认过期时间为30s , 每 10s 续期一次\n * 如果线程挂掉(debug模式也会误认宕机) , 则不会续期\n * trylock()方法必须要用try-catch包括并且在finally中进行释放锁(防止异常后能够进行释放锁)\n\n**代码示例 : **\n\n/**\n * 看门狗机制测试\n */\n@test\npublic void redissonlookdoordog() {\n    rlock lock = redissonclient.getlock("sans:precachejob:docache:lock");\n    system.out.println("start");\n    try {\n        if (lock.trylock(0, -1, timeunit.milliseconds)) {\n            thread.sleep(300000);\n        }\n    } catch (interruptedexception e) {\n        system.out.println(e.getmessage());\n    } finally {\n        // 只能释放本身线程的锁(以防释放其他线程的锁)\n        if (lock.isheldbycurrentthread()) lock.unlock();\n    }\n}\n\n\n\n# q&a\n\n\n# 缓存问题\n\n缓存是在第一次加载的数据进行复用，将数据存放指定地点以便下次加载使用。可防止多访问同一 数据库 而产生的堵塞，也能减轻 数据库 的压力！\n\njava缓存\n\n * 虚拟机缓存（ehcache、jboss cache）\n * 分布式缓存（redis、memcache）\n * 数据库缓存\n\n\n\n# 缓存雪崩\n\n**q : **原有缓存失效（或者未加载到缓存中），因此 访问过程会跨越缓存直接访问 数据库，这一过程很有可能会导致 数据库 宕机（cpu、内存 高负载）\n\na : 原有缓存失效后，可通过 加锁 或 队列 进行控制 数据库的线程数量。失效期间 尽快修复 缓存，否则 用户访问会堵塞\n\n加锁\n\npublic users getbyusers(long id) {\n\t// 1.先查询redis\n\tstring key = this.getclass().getname() + "-" + thread.currentthread().getstacktrace()[1].getmethodname()+ "-id:" + id;\n\tstring userjson = redisservice.getstring(key);\n\tif (!stringutils.isempty(userjson)) {\n\t\tusers users = jsonobject.parseobject(userjson, users.class);\n\t\treturn users;\n\t}\n\tusers user = null;\n\ttry {\n\t\tlock.lock();\n\t\t// 查询db\n\t\tuser = usermapper.getuser(id);\n\t\tredisservice.setset(key, jsonobject.tojsonstring(user));\n\t} catch (exception e) {\n        \n\t} finally {\n\t\tlock.unlock(); // 释放锁\n\t}\n\treturn user;\n}\n\n\n# 缓存穿透\n\n**q : **当用户查询指定数据 且 数据库 中恰好也没有，此时缓存自然也不会有。这样就导致 重复查询 都会访问数据库，类似的查询都会绕过缓存直接查数据库！\n\na :\n\n * 如果首次 数据库 访问查询的数据为空，可直接设置一个默认值进行缓存，这样下次有相同的访问，就不会继续访问 数据库\n * 也可把空结果，进行缓存，这样下次有相同的访问，就不会继续访问 数据库\n\npublic string getbyusers2(long id) {\n\t// 1.先查询redis\n\tstring key = this.getclass().getname() + "-" + thread.currentthread().getstacktrace()\n[1].getmethodname()+ "-id:" + id;\n\tstring username = redisservice.getstring(key);\n\tif (!stringutils.isempty(username)) {\n\t\treturn username;\n\t}\n\tsystem.out.println("######开始发送数据库db请求########");\n\tusers user = usermapper.getuser(id);\n\tstring value = null;\n\tif (user == null) {\n\t\t// 标识为null\n\t\tvalue = "";\n\t} else {\n\t\tvalue = user.getname();\n\t}\n\tredisservice.setstring(key, value);\n\treturn value;\n}\n\n\n# 缓存击穿\n\n**q : ** 在某一时间点 突然以超高并发进行访问 过期的key，导致 缓存被击穿 . 突然高频访问的key 称为 热点数据\n\n**a : **\n\n * 使用锁，单机 synchronized 、lock 等，分布式用 分布式锁\n * 缓存过期时间不设置，而是设置在key对应的value里。如果检测到存的时间超过过期时间则异步更新缓存\n\n\n# 分布式锁问题\n\n# 死锁\n\n**q : ** setnx命令 , 未释放资源\n\n**a : **\n\n * 设值过期\n * 关闭锁\n\n# jvm锁和分布式锁\n\n      jvm锁       分布式锁\n锁范围   jvm中的多线程   多个jvm\n实现于   java       redis/mysql/zookeeper/等\n\njvm应用的范围过于局限 , 因此需要分布式扩大锁的范围\n\n# 续约锁\n\nq : 如果锁所执行的方法时间过长 , 锁提前过期 , 导致他人占用?\n\na : 续约锁的时长进行加时\n\n> 续约锁的目的主要是防止锁长时间占用问题 , 达到节省资源\n\nq2 : 释放锁的时候 , 先前判断出是自己的锁 , 由于执行时间过长导致期间锁过期了 , 此时被其他节点所占用 , 因此方法很有可能会将别的节点锁进行释放! (以下伪代码示例)\n\n// 此时判断为a锁含有过期\nif(get lock == a){\n    // 执行过程....(漫长\n    del lock; // 释放锁(此时锁可能不为a)\n}\n\n\na2 : redis + lua脚本 实现',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Mybatis",frontmatter:{title:"Mybatis",author:"柏竹",permalink:"/backend/zi2hq0",date:"2020-02-18T00:00:00.000Z",categories:["后端"],tags:["数据库","框架"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/05.%E6%95%B0%E6%8D%AE%E5%BA%93/04.MyBatis.html",relativePath:"01.后端/05.数据库/04.MyBatis.md",key:"v-71eb58e1",path:"/backend/zi2hq0/",headers:[{level:2,title:"首次应用",slug:"首次应用",normalizedTitle:"首次应用",charIndex:730},{level:2,title:"Mybatis对象",slug:"mybatis对象",normalizedTitle:"mybatis对象",charIndex:6719},{level:3,title:"Resources",slug:"resources",normalizedTitle:"resources",charIndex:5786},{level:3,title:"SqlSessionFactoryBuilder",slug:"sqlsessionfactorybuilder",normalizedTitle:"sqlsessionfactorybuilder",charIndex:5939},{level:3,title:"SqlSessionFactory",slug:"sqlsessionfactory",normalizedTitle:"sqlsessionfactory",charIndex:5849},{level:3,title:"SqlSessio",slug:"sqlsessio",normalizedTitle:"sqlsessio",charIndex:5849},{level:2,title:"MyBatis构架",slug:"mybatis构架",normalizedTitle:"mybatis构架",charIndex:9032},{level:2,title:"MyBatis日志",slug:"mybatis日志",normalizedTitle:"mybatis日志",charIndex:9647},{level:2,title:"MyBatis全局配置",slug:"mybatis全局配置",normalizedTitle:"mybatis全局配置",charIndex:10414},{level:3,title:"配置内容",slug:"配置内容",normalizedTitle:"配置内容",charIndex:10643},{level:3,title:"properties",slug:"properties",normalizedTitle:"properties",charIndex:1221},{level:3,title:"settings",slug:"settings",normalizedTitle:"settings",charIndex:10275},{level:3,title:"typeAliases",slug:"typealiases",normalizedTitle:"typealiases",charIndex:10737},{level:3,title:"Mappers",slug:"mappers",normalizedTitle:"mappers",charIndex:15121},{level:2,title:"Mapper动态代理",slug:"mapper动态代理",normalizedTitle:"mapper动态代理",charIndex:15644},{level:2,title:"parameterType输入",slug:"parametertype输入",normalizedTitle:"parametertype输入",charIndex:20404},{level:3,title:"传递多个参数",slug:"传递多个参数",normalizedTitle:"传递多个参数",charIndex:20424},{level:3,title:"#{} 和 ${} 区别",slug:"和-区别",normalizedTitle:"#{} 和 ${} 区别",charIndex:23162},{level:2,title:"resultType输出",slug:"resulttype输出",normalizedTitle:"resulttype输出",charIndex:23822},{level:2,title:"动态SQL",slug:"动态sql",normalizedTitle:"动态sql",charIndex:26914},{level:2,title:"MyBatis映射关系",slug:"mybatis映射关系",normalizedTitle:"mybatis映射关系",charIndex:32986},{level:3,title:"对一 映射关系",slug:"对一-映射关系",normalizedTitle:"对一 映射关系",charIndex:33061},{level:3,title:"对多映射关系",slug:"对多映射关系",normalizedTitle:"对多映射关系",charIndex:38723},{level:2,title:"MyBatis延迟加载",slug:"mybatis延迟加载",normalizedTitle:"mybatis延迟加载",charIndex:46101},{level:2,title:"MyBatis缓存",slug:"mybatis缓存",normalizedTitle:"mybatis缓存",charIndex:57338},{level:3,title:"一级缓存",slug:"一级缓存",normalizedTitle:"一级缓存",charIndex:57474},{level:3,title:"二级缓存",slug:"二级缓存",normalizedTitle:"二级缓存",charIndex:46423},{level:4,title:"二级缓存其他设置",slug:"二级缓存其他设置",normalizedTitle:"二级缓存其他设置",charIndex:65310},{level:2,title:"反向工程",slug:"反向工程",normalizedTitle:"反向工程",charIndex:66237},{level:3,title:"项目生成",slug:"项目生成",normalizedTitle:"项目生成",charIndex:66368},{level:3,title:"Maven项目",slug:"maven项目",normalizedTitle:"maven项目",charIndex:66375},{level:2,title:"分页插件",slug:"分页插件",normalizedTitle:"分页插件",charIndex:83754},{level:2,title:"MyBatis问题",slug:"mybatis问题",normalizedTitle:"mybatis问题",charIndex:84998},{level:3,title:"线程优化",slug:"线程优化",normalizedTitle:"线程优化",charIndex:85012},{level:3,title:"Sql语句字段调配问题",slug:"sql语句字段调配问题",normalizedTitle:"sql语句字段调配问题",charIndex:92996},{level:4,title:"库添加获取id问题",slug:"库添加获取id问题",normalizedTitle:"库添加获取id问题",charIndex:93011},{level:3,title:"映射问题",slug:"映射问题",normalizedTitle:"映射问题",charIndex:97876},{level:4,title:"数据库列名与实体类属性不匹配问题",slug:"数据库列名与实体类属性不匹配问题",normalizedTitle:"数据库列名与实体类属性不匹配问题",charIndex:97884},{level:3,title:"分页问题",slug:"分页问题",normalizedTitle:"分页问题",charIndex:99739}],headersStr:"首次应用 Mybatis对象 Resources SqlSessionFactoryBuilder SqlSessionFactory SqlSessio MyBatis构架 MyBatis日志 MyBatis全局配置 配置内容 properties settings typeAliases Mappers Mapper动态代理 parameterType输入 传递多个参数 #{} 和 ${} 区别 resultType输出 动态SQL MyBatis映射关系 对一 映射关系 对多映射关系 MyBatis延迟加载 MyBatis缓存 一级缓存 二级缓存 二级缓存其他设置 反向工程 项目生成 Maven项目 分页插件 MyBatis问题 线程优化 Sql语句字段调配问题 库添加获取id问题 映射问题 数据库列名与实体类属性不匹配问题 分页问题",content:'# Mybatis\n\nMyBatis 是一个开源、轻量级的数据持久化框架，是 JDBC 和 Hibernate 的替代方案。MyBatis 内部封装了 JDBC，简化了加载驱动、创建连接、创建 statement 等繁杂过程，只需关注 SQL 语句即可\n\n> 数据持久化是将内存中的 数据模型 转换为 存储模型，以及将 存储模型 转换为 内存中数据模型 的统称。 例如，文件的存储、数据的读取以及对数据表的增删改查等都是数据持久化操作\n\nORM 是一种数据持久化技术，它在对象模型和关系型数据库之间建立起对应关系，解决了实体类和数据库表映射的问题，并且提供了一种机制，通过 JavaBean 对象去操作数据库表中的数据。\n\n * Object： java对象\n * Relation： 关系，库中的表\n * Mapping： 映射\n\n参考文档：mybatis – MyBatis 3\n\nMybatis 和 Hibernate区别\n\n        MYBATEIS   HIBERNATE\n学习门槛    低          高\n查询语言    sql        hql\nORM架构   半映射        完整映射\n资源损耗    低          高\n查询自由度   高          低\n移植兼容    差          好\n\n总结\n\n * Hibernate功能强大，数据库无关性好，O/R映射能力强。前提Hibernate要精通，否则用起来很累\n * Hibernate 学习知识点多，精通门槛高。例如 怎么设计O/R映射，在性能和对象模型之间如何权衡取得平衡，以及怎样用好Hibernate方面需要经验和能力都很强才行\n\n\n# 首次应用\n\n> 前提：\n> \n>  * 引入 mybatis架构依赖 mysql-connector-java底层连接依赖 junit代码测试\n>  * 数据库表中的列名称 与 实体类属性的名称 相同\n\n项目结构\n\n  .\n  |\n  ├── src\n  |    ├── main\n  |\t   |\t├── java\n  |\t   |\t|\t  └── com\n  |\t   |    |   \t   ├── dao\n  |    |    |          |\t├── TeamDao\n  |    |    |          |    └── TeamDaoImpl\n  |\t   |\t|\t  \t   ├── pojo\n  |\t   |\t|\t  \t   |\t├── Team\n  |\t   |\t|\t\t   |\t└── Team.xml\n  |\t   |    | \t\t   └── utils\t\t\n  |\t   |    |    \t   \t\t└── MybatisUtil\n  |\t   |\t└──\tresources\n  |\t   |\t\t    ├── log4j.properties\n  |\t   |\t\t\t└── mybatis.xml\n  |\t  test\n  |    └── ...\n  └── pom.xml\n\n\n 1. 引入依赖 ==pom.xml==\n    \n    <dependency>\n        <groupId>org.mybatis</groupId>\n        <artifactId>mybatis</artifactId>\n        <version>3.5.6</version>\n    </dependency>\n    <dependency>\n        <groupId>mysql</groupId>\n        <artifactId>mysql-connector-java</artifactId>\n        <version>8.0.23</version>\n    </dependency>\n    <dependency>\n        <groupId>junit</groupId>\n        <artifactId>junit</artifactId>\n        <version>4.12</version>\n        <scope>test</scope>\n    </dependency>\n    \n    \n    > jar包说明：\n    > \n    >  * mybatis\n    >  * jdbc\n    >  * 测试环境\n\n 2. 创建 ==Team实体类== 与 ==mybatis库team表数据==\n    \n    CREATE TABLE `team` (\n    \t`teamId` int NOT NULL AUTO_INCREMENT COMMENT \'球队ID\',\n    \t`teamName` varchar(50) DEFAULT NULL COMMENT \'球队名称\',\n    \t`location` varchar(50) DEFAULT NULL COMMENT \'球队位置\',\n    \t`createTime` date DEFAULT NULL COMMENT \'球队建立时间\',\n    \tPRIMARY KEY (`teamId`)\n    ) ENGINE=InnoDB AUTO_INCREMENT=1003 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\n    \n    \n    package com.pojo;\n    \n    import java.util.Date;\n    \n    public class Team {\n        private Integer teamId;\n        private String teamName;\n        private String location;\n        private Date createTme;\n        \n        /*省略setter和getter方法*/\n        \n        @Override\n        public String toString() {\n            return "Team{" +\n                    "teamId=" + teamId +\n                    ", teamName=\'" + teamName + \'\\\'\' +\n                    ", location=\'" + location + \'\\\'\' +\n                    ", createTme=" + createTme +\n                    \'}\';\n        }\n    }\n    \n    \n\n 3. 配置 连接文件 ==mybatis.xml==（用于连接数据库）\n    \n    <?xml version="1.0" encoding="UTF-8" ?>\n    <!DOCTYPE configuration\n            PUBLIC "-//mybatis.org//DTD Config 3.0//EN"\n            "http://mybatis.org/dtd/mybatis-3-config.dtd">\n    <configuration>\n        \x3c!--配置 mybatis 环境--\x3e\n        <environments default="development">\n            \x3c!--id:数据源的名称--\x3e\n            <environment id="development">\n                \x3c!--事务类型：使用 JDBC 事务,使用 Connection 的提交和回滚--\x3e\n                <transactionManager type="JDBC"/>\n                \x3c!--数据源 dataSource：创建数据库 Connection 对象\n                type: POOLED 使用数据库的连接池\n                --\x3e\n                <dataSource type="POOLED">\n                    \x3c!--连接数据库的四大参数\n                    注意 加载驱动是 MySQL8以上，否则 driver和url 都不一样，可参考学过的JDBC--\x3e\n                    <property name="driver" value="com.mysql.cj.jdbc.Driver"/>\n                    <property name="url" value="jdbc:mysql://127.0.0.1:3306/mybatis?\n    useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=GMT"/>\n                    <property name="username" value="root"/>\n                    <property name="password" value="root"/>\n                </dataSource>\n            </environment>\n        </environments>\n    \n        \x3c!-- 注册映射文件 --\x3e\n        <mappers>\n            <mapper resource="com/pojo/Team.xml"/>\n        </mappers>\n    </configuration>\n    \n    \n    > 注意：\n    > \n    >  * <dataSource>标签 中主要配置数据库通信，必要的有 加载驱动/连接URL/账号/密码\n    >  * <mappers>.<mapper>.resource属性 必须指定正确的映射文件（否则注册不了\n\n 4. 配置 映射文件 ==Team.xml==（映射实体类与库中列的数据）\n    \n    <?xml version="1.0" encoding="UTF-8" ?>\n    <!DOCTYPE mapper\n            PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n            "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n    \x3c!-- namespace= "名称必须与映射的类的名字一致，是完全限定名" --\x3e\n    <mapper namespace="com.pojo.Team">\n        \x3c!-- id="自定义名称，id不能重复；相当于dao中的方法名称"\n        resultType="使用的要求：实体类中的属性名与表中的列名一致"\n        --\x3e\n        <select id="findAll" resultType="com.pojo.Team">\n            select * from team\n        </select>\n    </mapper>\n    \n    \n    > 注意：\n    > \n    >  * <mapper>.namespace属性 必须映射正确的实体类（完全限定名\n    >  * <select>.resultType属性 返回集中 一列记录实例的 对象/数据类型\n    >  * <select>.id属性 用于Session指定指定SQL的操作（该属性不能存在重复值\n\n 5. 配置 映射文件的扫描 ==pom.xml==\n    \n    <build>\n        <resources>\n            <resource>\n                \x3c!--所有目录--\x3e\n                <directory>src/main/java</directory>\n                <includes>\n                    \x3c!--包括目录 .properties, .xml 文件都会扫描到！！--\x3e\n                    <include>**/*.properties</include>\n                    <include>**/*.xml</include>\n                </includes>\n                <filtering>false</filtering>\n            </resource>\n        </resources>\n        <plugins>\n            ···\n        </plugins>\n    </build>\n    \n\n 6. 测试查询\n    \n    @Test\n    public void test() throws IOException {\n        // 1. 读取 mybatis配置文件\n        Reader reader = Resources.getResourceAsReader("mybatis.xml");\n        // 2. 创建 SqlSessionFactoryd对象 ， 目的 获取 sqlsession\n        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);\n        // 3. 创建可执行SQL语句的 SqlSession\n        SqlSession sqlSession = sqlSessionFactory.openSession();\n        // 4. 执行 SQL语句\n        List<Team> teamList = sqlSession.selectList("com.pojo.Team.findAll");\n        // 5. 遍历结果\n        System.out.println("遍历结果：");\n        teamList.forEach(System.out::println);\n        // 6. 释放资源\n        sqlSession.close();\n    }\n    \n    /* 执行结果\n    \n    遍历结果：\n    Team{teamId=1, teamName=\'张三\', location=\'上海\', createTme=null}\n    Team{teamId=2, teamName=\'李四\', location=\'深圳\', createTme=null}\n    Team{teamId=3, teamName=\'王五\', location=\'南京\', createTme=null} \n    Team{teamId=4, teamName=\'赵六\', location=\'广州\', createTme=null}\n    Team{teamId=5, teamName=\'小七\', location=\'南宁\', createTme=null}\n    \n    */\n    \n\n\n# Mybatis对象\n\n\n# Resources\n\n==org.apache.ibatis.io.Resources类==\n\n用于读取资源文件。有很多方法通过加载并解析资源文件，返回不同类型的 IO 流对象\n\n\n# SqlSessionFactoryBuilder\n\n==org.apache.ibatis.session.SqlSessionFactoryBuilder类==\n\nSqlSessionFactory 的创建，需要使用 SqlSessionFactoryBuilder对象的build()方法 。事实上使用SqlSessionFactoryBuilder的原因是将SqlSessionFactory这个复杂对象的创建交由Builder来执行，也就是使用了建造者设计模式\n\n> 建造者模式（又称生成器模式）：是一种对象的创建模式。可以将一个产品的 内部表象 与 产品的生成过程 分割开来，从而可以使一个建造过程生成具有 不同的内部表象的产品(将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示)，这样用户只需指定需要建造的类型就可以得到具体产品，而不需要了解具体的建造过程和细节。\n> \n> 在建造者模式中，角色分指导者(Director)与建造者(Builder)： 用户联系指导者，指导者指挥建造者，最后得到产品，建造者模式可以强制实行 一种分步骤进行的建造过程\n\n\n# SqlSessionFactory\n\n==org.apache.ibatis.session.SqlSessionFactory接口==\n\n创建 SqlSession 需要使用 SqlSessionFactory接口的 openSession()方法，该方法重载的数量较多，因此只需关注主要应用的以下三个传参数据即可：\n\n * 事务处理： 在session作用域中 ，是否使用自动提交？（autoCommit）\n * 数据库连接： 在 MyBatis中，是否使用自己提供的连接？（connection）\n * 语句执行： 在 MyBatis中，是否复用 PreparedStatement 通道进行 批处理？\n\n参数名          类型             说明\nautoCommit   boolean        true事务自动提交，否则关闭\nconnection   Connection     应用自己提供的连接\nexecType     ExecutorType   ExecutorType枚举定义定义了三个值\n                            SIMPLE：为每个语句的执行创建一个新的预处理语句\n                            REUSE：执行器会复用预处理语句\n                            BATCH：执行器会批量执行所有更新语句\n\n> **注意：**如果调用了无参的 openSession()方法，则该Session会默认具备以下特性：\n> \n>  * 事务作用域将会开启（不自动提交）\n>  * 将由当前环境配置的 DataSource 实例中获取 Connection 对象 （DataSource指定的是 数据库的配置数据及创建数据库获取的连接）\n>  * 事务隔离级别将会使用 驱动/数据源 的默认设置\n>  * 预处理语句不会被复用，也不会批量处理更新\n\n\n# SqlSessio\n\n==org.apache.ibatis.session.SqlSession接口==\n\nSqlSession接口对象 用于执行持久化操作。一个 SqlSession 对应着一次数据库会话\n\nSqlSessio为 线程不安全的，所以每次数据库会话结束前，立马调用 close()方法 将其关闭。再次需要会话，再次创建\n\nSQL语句写法以及形式有多种，而SqlSessio对象将它们归类封装成了方法 CURD(增删改查) 4中类型（支持自动装箱或包装类）、JavaBean、POJO 或 Map\n\n<T> T selectOne(String statement, Object parameter)\n<E> List<E> selectList(String statement, Object parameter)\n<T> Cursor<T> selectCursor(String statement, Object parameter)\n<K,V> Map<K,V> selectMap(String statement, Object parameter, String mapKey)\nint insert(String statement, Object parameter)\nint update(String statement, Object parameter)\nint delete(String statement, Object parameter)\n\n\n> 说明：\n> \n>  * insert、update、delete 方法返回值为影响的行数\n>  * selectOne：返回一个 对象/null ；selectList：返回多个 对象/null\n>  * 游标（Cursor）与列表（List）返回的结果相同，不同的是，游标借助迭代器实现了数据的惰性加载\n>  * selectMap()方法 ，它会将返回的对象的其中一个属性作为 key值，将对象作为 value值\n\n\n# MyBatis构架\n\n\n\n 1. Mybatis.xml文件是mybatis框架的全局配置文件，配置了mybatis框架运行的环境等信息\n 2. Mapperxx.xml是SQL的映射文件，文件中配置了所有的操作数据库的sql语句，这些文件需要在全局配置文件中加载\n 3. 通过mybatis环境等配置信息构建SqlSessionFactroy ，相当于是产生连接池\n 4. 由会话工厂创建SqlSession即会 （连接），操作数据库需要通过SqlSession进行的\n 5. Mybatis底层自定义了Executor执行器的接口操作数据库，Executor接口有两个实现，一个基本的执行器，一个是缓存的执行器\n 6. Mapped statement 也是mybatis框架一个底层的封装对象，包装了mybatis配置信息以及sql映射信息。Mapperxx.xml文件中的一个SQL语句对应一个Mapped statement对象，sql的id就是Mapped statement的id\n 7. Mapped statement对SQL执行输入参数的定义，输入参数包括HashMap、基本类型、pojo,Executor通过Mapped statemen在执行SQL语句 前将输入java对象映射到sql语句中，执行完毕SQL之后，输出映射就是JDBC编码中的对preparedStatement 执行结果的定义\n\n\n# MyBatis日志\n\n日志能够更准确了解运行时的详细信息\n\n> 实现步骤：\n> \n>  1. 添加依赖 log4j\n>  2. 创建日志配置文件 log4j.properties\n>  3. 在mybatis.xml 配置文件添加日志配置\n\n依赖添加 (jar)\n\n<dependency>\n\t<groupId>log4j</groupId>\n\t<artifactId>log4j</artifactId>\n\t<version>1.2.17</version>\n</dependency>\n\n\n创建日志配置文件 log4j.properties\n\n## Global logging configuration info warning error  选择日志呈现种类\nlog4j.rootLogger=DEBUG,stdout\n## Console output...\nlog4j.appender.stdout=org.apache.log4j.ConsoleAppender\nlog4j.appender.stdout.layout=org.apache.log4j.PatternLayout\nlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] - %m%n\n\n\n在mybatis.xml 配置文件添加日志配置\n\n<configuration>\n\x3c!--    日志配置--\x3e\n    <settings>\n        <setting name="logImpl" value="LOG4J"/>\n    </settings>\n    ·····\n</configuration>\n\n\n> 注意：settings标签 添加在该配置子标签中的第一个！\n\n\n# MyBatis全局配置\n\n之前应用的 全局配置文件 mybatis.xml ，头文件作为使用约束的前提\n\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE configuration\n        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"\n        "http://mybatis.org/dtd/mybatis-3-config.dtd">\n\n\n\n# 配置内容\n\nMyBatis 行为设置和属性信息，全局配置文件的结构如下：\n\nconfiguration（配置）\n\n * properties（属性）\n * settings（设置）\n * typeAliases（类型别名）\n * typeHandlers（类型处理器）\n * objectFactory（对象工厂）\n * plugins（插件）\n * environments（环境配置）\n   * environment（环境变量）\n     * transactionManager（事务管理器）\n     * dataSource（数据源）\n * databaseIdProvider（数据库厂商标识）\n * mappers（映射器）\n\n> 以上的配置顺序一定一定要遵循顺序进行配置，否则会失效\n\n\n# properties\n\nproperties标签 可在外部进行配置，并可以进行动态替换。properties标签 在 configuration标签里的 下一节点\n\n * properties子元素配置\n * 外部属性文件配置\n\n以连接 数据库 的四个参数数据为例子\n\nproperties子元素配置\n\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE configuration\n        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"\n        "http://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n\x3c!--    引入配置文件--\x3e\n    <properties>\n        <property name="driver" value="com.mysql.cj.jdbc.Driver"/>\n        <property name="url" value="jdbc:mysql://127.0.0.1:3306/mybatis?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=GMT"/>\n        <property name="username" value="root"/>\n        <property name="password" value="root"/>\n    </properties>\n\t····\n            <dataSource type="POOLED">\n                \x3c!--连接数据库的四大参数\n                注意数据库版本使用的是 MySQL8以上，如果是mysql5的话，driver和url都不一样，参考学过的JDBC--\x3e\n                <property name="driver" value="${driver}"/>\n                <property name="url" value="${url}"/>\n                <property name="username" value="${username}"/>\n                <property name="password" value="${password}"/>\n            </dataSource>\n\t····\n</configuration>\n\n\n外部属性文件配置 jdbc.properties\n\njdbc.driver=com.mysql.cj.jdbc.Driver\njdbc.url=jdbc:mysql://127.0.0.1:3306/mybatis?useUnicode=true&characterEncoding=utf-8&useSSL=false&serverTimezone=GMT\njdbc.username=root\njdbc.password=root\n\n\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE configuration\n        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"\n        "http://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n\x3c!--    引入配置文件--\x3e\n    <properties resource="jdbc.properties"/>\n\t····\n            <dataSource type="POOLED">\n                \x3c!--连接数据库的四大参数\n                注意数据库版本使用的是 MySQL8以上，如果是mysql5的话，driver和url都不一样，参考学过的JDBC--\x3e\n                <property name="driver" value="${jdbc.driver}"/>\n                <property name="url" value="${jdbc.url}"/>\n                <property name="username" value="${jdbc.username}"/>\n                <property name="password" value="${jdbc.password}"/>\n            </dataSource>\n\t····\n</configuration>\n\n\n\n# settings\n\nMyBatis 中极为重要的调整设置，它们会改变 MyBatis 的运行时行为。例如：日志、等...（以上实例有应用就不赘述了）\n\n\x3c!--配置日志--\x3e\n<settings>\n\t<setting name="logImpl" value="LOG4J"/>\n</settings\n\n\n\n# typeAliases\n\n类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。typeAliases标签 在 settings标签 的下一节点\n\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE configuration\n        PUBLIC "-//mybatis.org//DTD Config 3.0//EN"\n        "http://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n\t···\n\x3c!--    日志配置--\x3e\n    <settings>\n        <setting name="logImpl" value="LOG4J"/>\n    </settings>\n\x3c!--    自定义别名--\x3e\n    <typeAliases>\n        \x3c!--对单个实体类--\x3e\n        <typeAlias type="com.pojo.Team" alias="Team"/>\n        \x3c!--批量定义别名：类似于扫描（首字母支持大小写）--\x3e\n        <package name="com.pojo"/>\n    </typeAliases>\n    ···\n</configuration>\n\n\n在应用于 映射文件 里 的 parameterType、resultType 、...等属性\n\n\x3c!--查询所有--\x3e\n<select id="findAll" resultType="Team">\n    select * from team;\n</select>\n\x3c!--添加--\x3e\n<insert id="add" parameterType="Team">\n    INSERT INTO `mybatis`.`team`(`teamName`, `location`, `createTime`) VALUES (#{teamName}, #{location}, #{createTime})\n</insert>\n\x3c!--查询所有2--\x3e\n<select id="queryAll3" resultType="Team2">\n    select teamId \'team_id\',teamName \'team_name\',location,createTime from team\n</select>\n\x3c!--查单列单条数据--\x3e\n<select id="queryTotal" resultType="int">\n    select count(teamId) from team\n</select>\n\x3c!--查多列单条数据--\x3e\n<select id="queryMap" resultType="map">\n    select min(teamId) \'min\',max(teamId) \'max\' from team\n</select>\n\n\n其他别名\n\n别名           映射的类型\n_byte        byte\n_long        long\n_short       short\n_int         int\n_integer     int\n_double      double\n_float       float\n_boolean     boolean\nstring       String\nbyte         Byte\nlong         Long\nshort        Short\nint          Integer\ninteger      Integer\ndouble       Double\nfloat        Float\nboolean      Boolean\ndate         Date\ndecimal      BigDecimal\nbigdecimal   BigDecimal\nobject       Object\nmap          Map\nhashmap      HashMap\nlist         List\narraylist    ArrayList\ncollection   Collection\niterator     Iterator\n\n\n# Mappers\n\nMyBatis 执行 SQL映射语句 前提需要告诉 MyBatis 映射文件路径在哪里，从而实现执行SQL语句\n\n配置形式：\n\n * 使用 相对于类路径的资源 引用\n * 使用 映射器接口实现类 的完全限定类名\n * 使用 包类的映射器接口实现全部注册为映射器（推荐）\n\n\x3c!-- 注册映射文件 --\x3e\n<mappers>\n    \x3c!-- \n\t\t相对于类路径的资源 引用 \n\t\t使用相对于类路径的资源,从 classpath 路径查找文件\n\t--\x3e\n    <mapper resource="com/mapper/TeamMapper.xml"/>\n    \x3c!-- \n\t\t使用的mapper接口的完全限定名 \n\t\t要求：接口和映射文件同包同名\n\t--\x3e\n    <mapper class="com.mapper.GameRecordMapper"/>\n    \x3c!-- \n\t\t指定包下的 所有Mapper接口 \n\t\t注意：此种方法要求 Mapper接口名称和 mapper 映射文件名称相同，且在同一个目录中。\n\t--\x3e\n    <package name="com.mapper"/>\n</mappers>\n\n\n\n# Mapper动态代理\n\n前面定义的 Dao接口和Dao实现类 没有实质性的工作意义，因此我们弃用Dao，可通过 SqlSession 的相关 API 定位到映射文件 mapper 中相应 id 的 SQL 语句，真正对 DB 进行操作的工作其实是由框架通过 mapper 中的 SQL 完成的，该形式被称为 ==Mapper接口 的动态代理方式==\n\n> 要点说明：\n> \n>  * Mapper 动态代理方式无需实现 Dao 接口。接口是由 MyBatis 结合映射文件自动生成的动态代理实现的\n>  * Mapper(映射) 文件里 sql语句中的标签id值 必须对应 接口中的方法名 一致\n>  * resources配置文件夹，在idea开发工具不能跨级进行创建，必须手动逐级创建路径\n>  * Mapper(映射) 在resources配置 文件夹中的路径必须 与 接口中的完全限定名 一致\n>  * SqlSession对象 需要通过 getMapper(Class<T> type)方法 获取代理对象，可获取指定接口的实现类对象\n>  * Mapper(映射) 文件里 mapper标签的namespace属性值 需要指定 接口的完全限定名\n>  * 每次添加映射 都需要去 mybatis.xml 的 mappers标签 进行添加注册映射文件\n>  * 进行 增删改 时需要 MybatisUtil工具类 获取SqlSession对象 进行提交\n\n实例应用\n\n项目结构\n\n  .\n  |\n  ├── src\n  |    ├── main\n  |\t   |\t├── java\n  |\t   |\t|\t  └── com\n  |\t   |    |   \t   ├── mapper\n  |    |    |          |    └── TeamMapper\n  |\t   |\t|\t  \t   ├── pojo\n  |\t   |\t|\t\t   |\t└── Team\n  |\t   |    | \t\t   └── utils\t\t\n  |\t   |    |    \t   \t\t└── MybatisUtil\n  |\t   |\t└──\tresources\n  |\t   |\t\t    ├── log4j.properties\n  |\t   |\t\t\t├── mybatis.xml\n  |    |\t\t\t└── com\n  |    |\t\t\t\t └── mapper\n  |    |\t\t\t\t  \t   └── TeamMapper.xml\n  |\t  test\t\n  |    └── ...\n  └── pom.xml\n\n\n创建 ==TeamMapper接口==\n\npackage com.mapper;\n\nimport com.pojo.Team;\n\nimport java.util.List;\n\npublic interface TeamMapper {\n    List<Team> findAll();\n    Team queryById(int id);\n    Team queryByName(String name);\n    int add(Team team);\n    int update(Team newTeam);\n    int delById(int id);\n    int delByName(String name);\n}\n\n\n创建 ==TeamMapper.xml映射配置文件==\n\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE mapper\n        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n\x3c!--namespace="名称必须与映射的类的名字一致，是完全限定名"--\x3e\n<mapper namespace="com.mapper.TeamMapper">\n\n    \x3c!--\n    id="自定义名称，id不能重复；相当于dao中的方法名称"\n    resultType="使用的要求：实体类中的属性名与表中的列名一致"\n    --\x3e\n\x3c!--    查询所有--\x3e\n    <select id="findAll" resultType="com.pojo.Team">\n        select * from team;\n    </select>\n\n\x3c!--    查询指定--\x3e\n    <select id="queryById" resultType="com.pojo.Team">\n        select * from team where teamId=#{teamId}\n    </select>\n    <select id="queryByName" resultType="com.pojo.Team">\n        select * from team where teamName=#{teamName}\n    </select>\n\n    \x3c!--\n    parameterType="指定对象作为参数"\n    #{对象属性名}\n    --\x3e\n\x3c!--    添加数据--\x3e\n    <insert id="add" parameterType="com.pojo.Team">\n        INSERT INTO `mybatis`.`team`(`teamName`, `location`, `createTime`) VALUES (#{teamName}, #{location}, #{createTime})\n    </insert>\n\n\x3c!--    修改数据--\x3e\n    <update id="update"  parameterType="com.pojo.Team">\n        UPDATE `team` SET teamName=#{teamName},location=#{location} WHERE teamId=#{teamId}\n    </update>\n\n\x3c!--    删除数据--\x3e\n    <delete id="delById" parameterType="com.pojo.Team">\n        DELETE FROM `mybatis`.`team` WHERE `teamId` = #{id}\n    </delete>\n    <delete id="delByName" parameterType="com.pojo.Team">\n        DELETE  FROM `mybatis`.`team` WHERE `teamName` = #{name}\n    </delete>\n\n</mapper>\n\n\n在 ==mybatis.xml配置文件== 中注册映射文件\n\n<configuration> \n    ·····\n\t\x3c!-- 注册映射文件 --\x3e\n    <mappers>\n\t\t·····\n        <mapper resource="com/mapper/TeamMapper.xml"/>\n    </mappers>\n</configuration>\n\n\n测试：\n\nimport com.mapper.TeamMapper;\nimport com.pojo.Team;\nimport com.utils.MybatisUtil;\nimport org.junit.Test;\n\nimport java.util.Date;\nimport java.util.List;\n\npublic class TeamMapperTest {\n    \n    //前提 接口的方法名 与 映射sql 标签的id值 相同！！！\n    private TeamMapper teamMapper = MybatisUtil.getSqlSession().getMapper(TeamMapper.class);\n    \n    @Test\n    public void findAll(){\n        List<Team> all = teamMapper.findAll();\n        all.forEach(System.out::println);\n    }\n    \n    @Test\n    public void queryById(){\n        Team team = teamMapper.queryById(2);\n        System.out.println("team : " + team);\n    }\n    \n    @Test\n    public void queryByName(){\n        Team team = teamMapper.queryByName("火箭");\n        System.out.println("team : " + team);\n    }\n    \n    @Test\n    public void add(){\n        Team team = new Team("公牛","洛杉矶",new Date());\n        int add = teamMapper.add(team);\n        MybatisUtil.getSqlSession().commit();\n        System.out.println("add : " + add);\n    }\n    \n    @Test\n    public void update() {\n        Team team = teamMapper.queryById(1009);\n        team.setTeamName("老鸽");\n        team.setLocation("南京");\n        int update = teamMapper.update(team);\n        MybatisUtil.getSqlSession().commit();\n        System.out.println("update : " + update);\n    }\n    \n    @Test\n    public void delById() {\n        int i = teamMapper.delById(1009);\n        MybatisUtil.getSqlSession().commit();\n        System.out.println("i : " + i);\n    }\n    \n    @Test\n    public void delByName() {\n        int i = teamMapper.delByName("公牛");\n        MybatisUtil.getSqlSession().comit();\n        System.out.println("i : " + i);\n    }\n    \n}\n\n\n\n# parameterType输入\n\n\n# 传递多个参数\n\nparameterType 指定值是接口中方法参数的类型，类型必须是完全限定名 或 别名。该属性非必须，因为Mybatis框架能自行判断具 体传入语句的参数\n\nMybatis 提供以下 3 种方式，实现给映射器传递多个参数：\n\n * 方法直接传递参数\n * 使用注解传递参数\n * 使用 Map传递参数\n\n> 应用说明：\n> \n>  * 方法直接传递参数 进行传递 不同mybatis版本传递参数 在sql应用不一样\n>    \n>    * mybatis3.3之前：使用 #{0}、#{1}、...\n>    * mybatis3.3之后：使用 #{arg0},#{arg1}、... 或者 #{param1}、#{param2}、...\n> \n>  * sql语句中 的 大小于号 不能使用 ，需要 转义符 < : &lt;\n>    \n>    > ：&gt;\n> \n>  * 使用@Param注解后，只能应用 自定的注解名称\n\n多参数应用\n\n修改 ==TeamMapper接口== 添加sql执行的方法\n\npackage com.mapper;\n\nimport com.pojo.Team;\nimport org.apache.ibatis.annotations.Param;\n\nimport java.util.List;\nimport java.util.Map;\n\npublic interface TeamMapper {\n    ····\n    \n    List<Team> queryByRange1(int min , int max);\n    List<Team> queryByRange2(int min , int max);\n    List<Team> queryByRange3(@Param("min") int min ,@Param("max") int max);\n    List<Team> queryByRange4(Map<String,Object> map);\n}\n\n\n修改 ==TeamMapper.xml映射文件== 添加sql语句\n\n\x3c!--arg 应用--\x3e\n<select id="queryByRange1" resultType="com.pojo.Team">\n    select * from team where teamId>=#{arg0} and teamId &lt;= ${arg1}\n</select>\n\x3c!--param 应用--\x3e\n<select id="queryByRange2" resultType="com.pojo.Team">\n    select * from team where teamId>=#{param1} and teamId &lt;= ${param2}\n</select>\n\x3c!--注解别名 应用--\x3e\n<select id="queryByRange3" resultType="com.pojo.Team">\n    select * from team where teamId>=#{min} and teamId &lt;= ${max}\n</select>\n\x3c!--Map 应用--\x3e\n\x3c!--    传参 #{} Map集合中的 Key保持一致--\x3e\n<select id="queryByRange4" resultType="com.pojo.Team">\n    select * from team where teamId>=#{min} and teamId &lt;= ${max}\n</select>\n\n\n测试：\n\nimport com.mapper.TeamMapper;\nimport com.pojo.Team;\nimport com.utils.MybatisUtil;\nimport org.junit.Test;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n//多参数传递应用\npublic class multiParameterTest {\n    \n    private TeamMapper teamMapper = MybatisUtil.getSqlSession().getMapper(TeamMapper.class);\n    \n    //arg 应用\n    @Test\n    public void test01() {\n        List<Team> teamList = teamMapper.queryByRange1(1 , 6);\n        teamList.forEach(team -> System.out.println(team));\n    }\n    \n    //param 应用\n    @Test\n    public void tset02() {\n        List<Team> teamList = teamMapper.queryByRange2(1 , 6);\n        teamList.forEach(team -> System.out.println(team));\n    }\n    \n    //接口参数名 应用 (需在接口方法中的参数定义名)\n    @Test\n    public void tset03() {\n        List<Team> teamList = teamMapper.queryByRange3(1 , 6);\n        teamList.forEach(team -> System.out.println(team));\n    }\n    \n    //Map传递 应用\n    @Test\n    public void tset04() {\n        Map<String,Object> map  = new HashMap<>();\n        map.put("min",1);\n        map.put("max",6);\n        List<Team> teamList = teamMapper.queryByRange4(map);\n        teamList.forEach(team -> System.out.println(team));\n    }\n\n}\n\n\n\n# #{} 和 ${} 区别\n\n#{}：表示一个占位符，通知Mybatis 使用实际的参数值代替\n\n${}：表示字符串原样替换，通知Mybatis 使用 $包含的“字符串”替换所在位置\n\n示例：\n\n配置接口方法\n\npublic interface TeamMapper {\n \t···\n    Team queryByType(\n        @Param("type") \n        String type,\n        @Param("data") \n        Object data);\n}\n\n\n映射文件\n\n<select id="queryByType" resultType="com.pojo.Team">\n    select * from team where ${type}=#{data}\n</select>\n\n\n测试（前提库有相应信息）\n\n@Test\npublic void queryByType() {\n    //teamId、teamName\n    Team team1 = teamMapper.queryByType("teamId",1017);\n    Team team2 = teamMapper.queryByType("teamName","Sanscan12");\n    System.out.println("team1 : " + team1);\n    System.out.println("team2 : " + team2);\n}\n\n\n\n# resultType输出\n\n----------------------------------------\n\nresultType 执行 sql 得到 ResultSet 转换的类型，使用类型的完全限定名 或 别名。如果返回的是集合，设置的是集合元素的类型，而不是集合本身。resultType 和 resultMap， 不能同时使用。\n\n可通过以下方式进行映射输出：\n\n * 输出java基本属性类型\n * 输出Map类型\n * 输出pojo类型\n * 输出自定义resultMap类型\n\n> 应用说明：\n> \n>  * resultMap 专门用于数据库中的列和实体类不匹配的情况下使用\n>  * resultMap 是 自己编写表中的列名 与 实体类中的属性 的映射（他们不匹配的前提下需要自行匹配映射）\n\n应用\n\n修改 ==TeamMapper接口== 添加sql执行的方法\n\npackage com.mapper;\n\nimport com.pojo.Team;\nimport org.apache.ibatis.annotations.Param;\n\nimport java.util.List;\nimport java.util.Map;\n\npublic interface TeamMapper {\n    ····\n    \n    int queryTotal();\n    Map<String,Object> queryMap();\n    List<Map<String, Object>> queryMapList();\n    List<Team> queryAll2();\n}\n\n\n修改 ==TeamMapper.xml映射文件== 添加sql语句\n\n\x3c!--    查单列单条数据 基本类型输出--\x3e\n    <select id="queryTotal" resultType="java.lang.Integer">\n        select count(teamId) from team\n    </select>\n\x3c!--    查多列单条数据 Map类型输出--\x3e\n    <select id="queryMap" resultType="java.util.HashMap">\n        select min(teamId) \'min\',max(teamId) \'max\' from team\n    </select>\n\x3c!--    查多列多条数据 List<Map>类型输出--\x3e\n    <select id="queryMapList" resultType="java.util.HashMap">\n        select teamName,location from team\n    </select>\n\x3c!--\n\tresultMap是 自己编写表中的列名 与 实体类中的属性 的映射（他们不匹配的前提下需要自行匹配映射）\n\t\tid: resultMap的名称，要求唯一\n\t\ttype: 期待要映射为java的类型\n\tid 主键列 ; result 其余列\n\t\tcolumn: 数据库中的列名，不区分大小写\n\t\tproperty: 实体类中的属性名，区分大小写\n\t\tjavaType: 实体类中对应的属性类型\n\t\tjdbcType: 数据库中column类型（一般忽略）\n--\x3e\n\x3c!--    resultMap数据类型 自定义映射输出--\x3e\n    <select id="queryAll2" resultMap="baseResultMap">\n        select * from team\n    </select>\n    <resultMap id="baseResultMap" type="com.pojo.Team">\n        <id column="teamId" property="teamId" javaType="java.lang.Integer"/>\n        <result column="teamName" property="teamName" javaType="java.lang.String"/>\n        <result column="location" property="location" javaType="java.lang.String"/>\n\x3c!--        <result column="createTime" property="createTime" javaType="java.util.Date"/>--\x3e\n    </resultMap>\n\n\n测试\n\nimport com.mapper.TeamMapper;\nimport com.pojo.Team;\nimport com.utils.MybatisUtil;\nimport org.junit.Test;\n\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n//多参数传递应用\npublic class multiParameterTest {\n    \n    private TeamMapper teamMapper = MybatisUtil.getSqlSession().getMapper(TeamMapper.class);\n    \n    //映射输出形式\n    \n    //查单列单条数据\n    @Test\n    public void queryTotal() {\n        int i = teamMapper.queryTotal();\n        System.out.println("i : " + i);\n    }\n    \n    //查多列单条数据\n    @Test\n    public void queryMap() {\n        Map<String, Object> stringObjectMap = teamMapper.queryMap();\n        System.out.println(stringObjectMap);\n    }\n    \n    //查多列多条数据\n    @Test\n    public void queryMapList() {\n        List<Map<String, Object>> mapList = teamMapper.queryMapList();\n        for (Map<String, Object> stringObjectMap : mapList) {\n            System.out.println(stringObjectMap);\n        }\n    }\n    \n    //处理自定义类型数据\n    @Test\n    public void queryAll2() {\n        List<Team> teamList = teamMapper.queryAll2();\n        teamList.forEach(team -> System.out.println(team));\n    }\n    \n}\n\n\n\n# 动态SQL\n\n动态 SQL 是 MyBatis 的强大特性之一。在 JDBC 或其它类似的框架中，需要手动拼接 SQL 语句，避免了 在不同条件下拼接 SQL 语句的困难\n\n动态SQL应用到的元素\n\n * <choose>：多条件分支\n   \n   * <when>：判断是否满足 test (boolean)：表达式\n   * <otherwise>：都不满足条件\n\n * <foreach>：遍历语句 collection (colection)：遍历集合 item (Object)：迭代对象 separator (String)：迭代分割符 open (String)：循环开头 close (String)：循环结尾\n\n * <where>：查询约束\n   \n   * <if>：是否添加语句\n     \n     test (boolean)：表达式\n\n * <set>：编辑约束\n   \n   * <if>：是否添加语句\n     \n     test (boolean)：表达式\n\n> test属性：多个表达式定义的时候 需要使用 and、or\n\n应用\n\n应用前提：\n\n * 有库信息\n * 映射文件已注册（扫描包）\n\n表结构\n\n字段名      类型\ndeptno   int\ndname    varchar\nloc      varchar\n\n创建 ==com.pojo.Dept实体对象==\n\npublic class Dept {\n    private int deptno;\n    private String dname;\n    private String loc;\n   \n    //省略 get、set、toString、构造 方法\n}\n\n\n创建 ==com.mapper.DeptMapper接口==\n\npublic interface DeptMapper {\n    // CRUD\n    int add(@Param("depts") Collection<Dept> depts);\n    int del(Dept dept);\n    int update(Dept dept);\n    List<Dept> findByLike(Dept dept);\n}\n\n\n创建 ==DeptMapper.xml映射文件==\n\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE mapper\n        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n\x3c!-- namespace= "名称必须与映射的类的名字一致，是完全限定名" --\x3e\n<mapper namespace="com.sans.mapper.DeptMapper">\n\n    \x3c!-- CRUD 动态SQL\n        列表添加 for\n        删除 where=>if\n        修改 set=>if\n        查 choose=>...\n    --\x3e\n\n    \x3c!-- 列表添加 for\n      sql示例：INSERT INTO dept(dname, loc) VALUES (?,?) , (?,?) [, ...]\n        标签属性说明：\n          collection：指定集合\n          item：集合中的每个迭代对象\n          separator：每次迭代之间的分隔符\n          open：循环语句 以指定字符为 开头\n          close：循环语句 以指定字符为 结束\n    --\x3e\n    <insert id="add" parameterType="collection">\n        INSERT INTO dept(dname, loc) VALUES\n        <foreach collection="depts" item="dept" separator=",">\n            (#{dept.dname},#{dept.loc})\n        </foreach>\n    </insert>\n\n    \x3c!-- 删除 where=>if\n        sql示例1：DELETE FROM dept WHERE deptno = ?\n        sql示例2：DELETE FROM dept WHERE dname = ?\n        sql示例3：DELETE FROM dept WHERE deptno = ? AND dname = ?\n     --\x3e\n    <delete id="del" parameterType="com.sans.pojo.Dept" >\n        DELETE FROM dept\n        <where>\n            <if test="deptno != 0">\n                AND deptno = #{deptno}\n            </if>\n            <if test="dname != null and dname != \'\'">\n                AND dname = #{dname}\n            </if>\n        </where>\n    </delete>\n\n    \x3c!-- 修改 set=>if\n        sql示例1：UPDATE dept SET dname = ? where deptno = ?\n        sql示例2：UPDATE dept SET loc = ? where deptno = ?\n        sql示例3：UPDATE dept SET dname = ? , loc = ? where deptno = ?\n     --\x3e\n    <update id="update" parameterType="com.sans.pojo.Dept" >\n        UPDATE dept\n        <set>\n            <if test="dname != null and dname != \'\'">\n                  dname = #{dname}\n            </if>\n            <if test="loc != null and loc != \'\'">\n                <if test="dname != null and dname != \'\'">,</if>\n                 loc = #{loc}\n            </if>\n        </set>\n        where deptno = #{deptno}\n    </update>\n\n    \x3c!-- 查 choose=>...\n        sql示例1：select * from dept where 1=1 and dname like \'%会%\'\n        sql示例2：select * from dept where 1=1 and loc like \'%总%\'\n        sql示例3：select * from dept where 1=1 and deptno = ?\n        标签说明：\n            choose：指定分支\n            when：条件分支节点\n            otherwise：都未满足条件\n    --\x3e\n    <select id="findByLike" parameterType="com.sans.pojo.Dept" resultType="com.sans.pojo.Dept">\n        select * from dept where 1=1\n        <choose>\n            <when test="dname != null and dname != \'\'">\n                and dname like \'%${dname}%\'\n            </when>\n            <when test="loc != null and loc != \'\'">\n                and loc like \'%${loc}%\'\n            </when>\n            <otherwise>\n                and deptno = #{deptno}\n            </otherwise>\n        </choose>\n    </select>\n\n    <select id="findAll" resultType="com.sans.pojo.Dept">\n        select * from dept\n    </select>\n\n</mapper>\n\n\n测试\n\npackage com.sans;\n\nimport com.sans.mapper.DeptMapper;\nimport com.sans.pojo.Dept;\nimport com.sans.utils.MyBatisUtil;\nimport org.apache.ibatis.session.SqlSession;\nimport org.junit.Test;\n\nimport java.util.*;\n\npublic class Demo {\n    \n    /** SQL动态查询\n     *      列表添加 for\n     *      删除 where => if\n     *      修改 set => if\n     *      查 choose => .\n     */\n    \n    SqlSession session = MyBatisUtil.getSession();\n    \n    @Test\n    public void addTest() {\n        DeptMapper mapper = session.getMapper(DeptMapper.class);\n        \n        /** 集合 测试\n         *  意图 ： foreach标签 指定集合类型遍历区别\n         *  - List 兼容\n         *  - Set 兼容\n         *  - Map 不兼容\n         */\n        \n        // List 测试\n        // List<Dept> list = new ArrayList<>();\n        // list.add(new Dept("会计部1","汇总"));\n        // list.add(new Dept("会计部2","汇总"));\n        // list.add(new Dept("会计部3","汇总"));\n        \n        // set 测试\n        Set<Dept> set = new HashSet<>();\n        set.add(new Dept("会计部1","汇总"));\n        // set.add(new Dept("会计部2","汇总"));\n        // set.add(new Dept("会计部3","汇总"));\n    \n        int add = mapper.add(set);\n        // session.commit();\n        System.out.println("add : " + add);\n    }\n    \n    @Test\n    public void delTest() {\n        DeptMapper mapper = session.getMapper(DeptMapper.class);\n        Dept dept = new Dept();\n        // dept.setDeptno(189);\n        dept.setDname("会计部1");\n        int del = mapper.del(dept);\n        // session.commit();\n        System.out.println("del : " + del);\n    }\n    \n    @Test\n    public void updateTest() {\n        DeptMapper mapper = session.getMapper(DeptMapper.class);\n        Dept d = new Dept();\n        d.setDeptno(5);\n        d.setDname("张三");\n        d.setLoc("李四");\n        int update = mapper.update(d);\n        // session.commit();\n        System.out.println("update : " + update);\n    \n    }\n    \n    \n    @Test\n    public void findByTypeTest() {\n        DeptMapper mapper = session.getMapper(DeptMapper.class);\n        Dept d = new Dept();\n        // d.setDname("会");\n        // d.setLoc("总");\n        d.setDeptno(5);\n        mapper.findByLike(d).forEach(System.out::println);\n    }\n}\n\n\n\n# MyBatis映射关系\n\n在MySQL中，当两表之间存在着主从关系，那么从表有个外键 对应 主表的主键 ！\n\n以下是可能出现映射关系的情况：\n\n * 对一 映射关系\n * 对多 映射关系\n\n\n# 对一 映射关系\n\n对一关系映射形式：\n\n * 一对一\n * 一对多\n\n一对多映射接收封装方式引用 Mapper映射封装（需要搭配扩展封装 一方对象\n\n实现应用\n\n> 前提：\n> \n>  * 分清对象的 主从关系 ，特别是查询的主对象\n>  * 全局配置文件 已注册 映射文件\n>  * 反向生成映射配置\n>  * 确定好数据表\n\n数据库 表\n\nDept 部门表\n\n字段名      类型        说明     关系键\ndeptno   int       id     key\ndname    varchar   部门名称   \nloc      varchar   部门地址   \n\nEmp 员工表\n\n字段名        类型         说明     关系键\nempno      int        id     key\nename      varchar    员工名    \njob        varchar    职位     \nmgr        int               \nhiredate   datetime   入职时间   \nsal        decimal    出售     \ncomm       decimal    佣金     \ndeptno     int        部门id   dept.deptno\njobno      int        职位id   job.jobno\n\n一对多示例\n\n实体类Emp\n\npublic class Emp {\n    private Integer empno;\n    private String ename;\n    private String job;\n    private Integer mgr;\n    private Date hiredate;\n    private double sal;\n    private double comm;\n    private Integer deptno;\n    private Integer jobno;\n    \n    private Dept dept;\n    \n    // 省略 get、set、toString、构造 方法\n}\n\n\n实体类Dept\n\npublic class Dept {\n    private Integer deptno;\n    private String dname;\n    private String loc;\n    \n    // 省略 get、set、toString、构造 方法\n}\n\n\n映射接口EmpMapper\n\npublic interface EmpMapper {\n    // .... 省略 反向生成的 标配CRUD操作\n    \n    // 内连接多查询 搭配 官方约束容器查询\n    List<Emp> selectByExampleJoinDept(EmpExample example);\n}\n\n\n映射文件EmpMapper.xml\n\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >\n<mapper namespace="com.sans.mapper.EmpMapper">\n    \n\t\x3c!-- .... 省略非关键代码 --\x3e\n    \n    \x3c!-- 反向生成 约束容器的代码 --\x3e\n    <sql id="Example_Where_Clause">\n        <where>\n            <foreach collection="oredCriteria" item="criteria" separator="or">\n                <if test="criteria.valid">\n                    <trim prefix="(" suffix=")" prefixOverrides="and">\n                        <foreach collection="criteria.criteria" item="criterion">\n                            <choose>\n                                <when test="criterion.noValue">\n                                    and ${criterion.condition}\n                                </when>\n                                <when test="criterion.singleValue">\n                                    and ${criterion.condition} #{criterion.value}\n                                </when>\n                                <when test="criterion.betweenValue">\n                                    and ${criterion.condition} #{criterion.value} and #{criterion.secondValue}\n                                </when>\n                                <when test="criterion.listValue">\n                                    and ${criterion.condition}\n                                    <foreach collection="criterion.value" item="listItem" open="(" close=")"\n                                             separator=",">\n                                        #{listItem}\n                                    </foreach>\n                                </when>\n                            </choose>\n                        </foreach>\n                    </trim>\n                </if>\n            </foreach>\n        </where>\n    </sql>\n\n    \x3c!-- .... 省略非关键代码 --\x3e\n    \n    \x3c!-- 手配Map映射 扩展对象进行封装 --\x3e\n    \x3c!-- <resultMap>标签 属性说明\n \t\tid: 自定义Map映射结果集名\n\t\ttype：指定查询的主对象\n\t--\x3e\n    <resultMap id="EmpExpandMap" type="com.sans.pojo.Emp">\n        \x3c!-- 查询结果及映射 属性/字段 配置\n\t\t\tcolumn：指定数据库查询结果的字段\n\t\t\tproperty：指定实体类属性对应的字段\n\t\t\tjdbcType：属性/字段 类型 （注意语法\n\t\t--\x3e\n        <id column="empno" property="empno" jdbcType="INTEGER"/>\n        <result column="ename" property="ename" jdbcType="VARCHAR"/>\n        <result column="job" property="job" jdbcType="VARCHAR"/>\n        <result column="mgr" property="mgr" jdbcType="INTEGER"/>\n        <result column="hiredate" property="hiredate" jdbcType="TIMESTAMP"/>\n        <result column="sal" property="sal" jdbcType="DECIMAL"/>\n        <result column="comm" property="comm" jdbcType="DECIMAL"/>\n        <result column="deptno" property="deptno" jdbcType="INTEGER"/>\n        <result column="jobno" property="jobno" jdbcType="INTEGER"/>\n        \x3c!-- <association>标签 属性说明\n \t\t\tproperty：指定查询的从对象 \n\t\t\tjavaType：指定从对象的实体对象\n \t\t--\x3e\n        <association property="dept" javaType="com.sans.pojo.Dept">\n            <id column="deptno" property="deptno" jdbcType="INTEGER"/>\n            <result column="dname" property="dname" jdbcType="VARCHAR"/>\n            <result column="loc" property="loc" jdbcType="VARCHAR"/>\n        </association>\n    </resultMap>\n\n    \x3c!--  应用 Emp扩展类\n        sql实例1：select emp.* , dept.* from emp, dept where emp.deptno = emp.deptno\n        sql实例2：select emp.* , dept.* from emp, dept WHERE ( ename like ? ) and emp.deptno = emp.deptno\n    --\x3e\n    <select id="selectByExampleJoinDept" resultMap="EmpExpandMap"\n            parameterType="com.sans.pojo.EmpExample">\n        select emp.* , dept.*\n            from emp, dept\n        \x3c!-- where 约束 --\x3e\n        <if test="_parameter != null">\n            <include refid="Example_Where_Clause"/>\n           \t\x3c!-- 筛选 --\x3e\n            and emp.deptno = emp.dept\n        </if>\n        \x3c!-- 筛选 --\x3e\n        <if test="_parameter == null">\n            where emp.deptno = emp.deptno\n        </if>\n    </select>\n\n</mapper>\n\n\n测试\n\n/** 一对多测试\n *   由于 一对一 较于简单 且应用场景不多，因此不写了\n *\n *   一对多是 主要应用测试\n */\n\n@Test\npublic void oneToMany() {\n\n    EmpMapper mapper = MyBatisUtil.getSession().getMapper(EmpMapper.class);\n    EmpExample example = new EmpExample();\n    EmpExample.Criteria criteria = example.createCriteria();\n    criteria.andEnameLike("%j%");\n    List<Emp> emps = mapper.selectByExampleJoinDept(example);\n    \n    emps.forEach(o -> {\n        System.out.println(o+" => "+o.getDept());\n    });\n    \n}\n\n\n\n# 对多映射关系\n\n多对多关系之间的建立需要 第三方表的建立才能进行联系\n\n实现应用\n\n> 以下的 多对多形式分别用了 中间表查询 和 对多关系查询 两种方式\n\n数据库 表\n\nDept 部门表\n\n字段名      类型        说明     关系键\ndeptno   int       id     key\ndname    varchar   部门名称   \nloc      varchar   部门地址   \n\nEmp 员工表\n\n字段名        类型         说明     关系键\nempno      int        id     key\nename      varchar    员工名    \njob        varchar    职位     \nmgr        int               \nhiredate   datetime   入职时间   \nsal        decimal    出售     \ncomm       decimal    佣金     \ndeptno     int        部门id   dept.deptno\njobno      int        职位id   job.jobno\n\nJob 职位表\n\n字段名      类型        说明    关系键\njobno    int       id    key\njanme    varchar   职位名   \nremark   varcahr   备注    \n\n> 这三张表 的关系：可以看似为 多个职位对应多个部门 ，而他们的练习包含有 员工表\n\n实体类Emp\n\npublic class Emp {\n    private Integer empno;\n    private String ename;\n    private String job;\n    private Integer mgr;\n    private Date hiredate;\n    private double sal;\n    private double comm;\n    private Integer deptno;\n    private Integer jobno;\n    \n    // dept 多对一关系\n    private Dept beanDept;\n    // job 多对一关系\n    private Job beanJob;\n    \n    // 省略 get、set、toString、构造 方法\n}\n\n\n实体类Dept\n\npublic class Dept {\n    private Integer deptno;\n    private String dname;\n    private String loc;\n    \n    private List<Job> jobs;\n    \n    // 省略 get、set、toString、构造 方法\n}\n\n\n实体类Job\n\npublic class Job {\n    private Integer jobno;\n    private String jname;\n    private String remark;\n    \n    private List<Dept> dpets;\n    \n    // 省略 get、set、toString、构造 方法\n}\n\n\nEmpMapper接口\n\npublic interface EmpMapper {\n    // .... 省略 反向生成的 标配CRUD操作\n    \n    // 通过中间表进行查询 两表信息\n    List<Emp> selectByExampleJoinDateAndJob(EmpExample example);\n}\n\n\nEmpMapper.xml\n\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >\n<mapper namespace="com.sans.mapper.EmpMapper">\n    <resultMap id="BaseResultMap" type="com.sans.pojo.Emp">\n        <id column="empno" property="empno" jdbcType="INTEGER"/>\n        <result column="ename" property="ename" jdbcType="VARCHAR"/>\n        <result column="job" property="job" jdbcType="VARCHAR"/>\n        <result column="mgr" property="mgr" jdbcType="INTEGER"/>\n        <result column="hiredate" property="hiredate" jdbcType="TIMESTAMP"/>\n        <result column="sal" property="sal" jdbcType="DECIMAL"/>\n        <result column="comm" property="comm" jdbcType="DECIMAL"/>\n        <result column="deptno" property="deptno" jdbcType="INTEGER"/>\n        <result column="jobno" property="jobno" jdbcType="INTEGER"/>\n    </resultMap>\n    \n\t\x3c!-- .... 省略非关键代码 --\x3e\n\n    \x3c!-- 通过中间表查 两表的关系 --\x3e\n    <resultMap id="EmpAndDeptAndJobMap" type="com.sans.pojo.Emp" extends="BaseResultMap">\n        <association property="beanDept" javaType="com.sans.pojo.Dept">\n            <id column="deptno" property="deptno" jdbcType="INTEGER"/>\n            <result column="dname" property="dname" jdbcType="VARCHAR"/>\n            <result column="loc" property="loc" jdbcType="VARCHAR"/>\n        </association>\n        <association property="beanJob" javaType="com.sans.pojo.Job">\n            <id column="jobno" property="jobno" jdbcType="INTEGER"/>\n            <result column="jname" property="jname" jdbcType="VARCHAR"/>\n            <result column="remark" property="remark" jdbcType="VARCHAR"/>\n        </association>\n    </resultMap>\n\n    \x3c!-- 多对多 --\x3e\n    <select id="selectByExampleJoinDateAndJob" resultMap="EmpAndDeptAndJobMap"\n            parameterType="com.sans.pojo.EmpExample">\n        SELECT\n            emp.*,dname,loc , jname,remark\n        FROM\n            dept,job,emp\n        <if test="_parameter != null">\n            <include refid="Example_Where_Clause"/>\n            AND dept.deptno = emp.deptno AND job.jobno = emp.jobno\n        </if>\n        <if test="_parameter == null">\n            WHERE dept.deptno = emp.deptno AND job.jobno = emp.jobno\n        </if>\n    </select>\n    \n</mapper>\n\n\nDeptMapper\n\npublic interface DeptMapper {\n    \n    // .... 省略 反向生成的 标配CRUD操作\n    \n    // 直接多对多 查询\n    List<Dept> DeptAndJobByExample(DeptExample example);\n}\n\n\nDeptMapper.xml\n\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >\n<mapper namespace="com.sans.mapper.DeptMapper">\n    <resultMap id="BaseResultMap" type="com.sans.pojo.Dept">\n        <id column="deptno" property="deptno" jdbcType="INTEGER"/>\n        <result column="dname" property="dname" jdbcType="VARCHAR"/>\n        <result column="loc" property="loc" jdbcType="VARCHAR"/>\n    </resultMap>\n    \n    \x3c!-- .... 省略非关键代码 --\x3e\n\n    \x3c!-- \n\t\t<BaseResultMap>.extends: 继承已有的属性\n\t\tcollection标签 属性说明\n \t\t\tproperty：实体类中 数据集的属性名\n\t\t\tjavaType：实体类中 属性的类型\n\t\t\tofType：实体类中的 集合泛型类型\n\t\t子标签指定的都是 实体对象单条记录中的属性\n \t--\x3e\n    <resultMap id="DeptAndJobsMap" type="com.sans.pojo.Dept" extends="BaseResultMap">\n        <collection property="jobs" javaType="java.util.ArrayList" ofType="com.sans.pojo.Job">\n            <id column="jobno" property="jobno" javaType="int"/>\n            <result column="jname" property="jname" javaType="String"/>\n        </collection>\n    </resultMap>\n\n    \x3c!-- 查询部门涉及到的职位有哪些\n        sql示例1：SELECT emp.*,dname,loc , jname,remark FROM dept , job , emp WHERE\n                    dept.deptno = emp.deptno AND job.jobno = emp.jobno\n        sql示例2：SELECT emp.*,dname,loc , jname,remark FROM dept , job , emp WHERE\n                    ( dname like ? ) AND dept.deptno = emp.deptno AND job.jobno = emp.jobno\n     --\x3e\n    <select id="DeptAndJobByExample" resultMap="DeptAndJobsMap"\n            parameterType="com.sans.pojo.DeptExample">\n        SELECT emp.*,dname,loc , jname,remark FROM\n            dept , job , emp\n        <if test="_parameter != null">\n            <include refid="Example_Where_Clause"/>\n            AND dept.deptno = emp.deptno AND job.jobno = emp.jobno\n        </if>\n        <if test="_parameter == null">\n            WHERE dept.deptno = emp.deptno AND job.jobno = emp.jobno\n        </if>\n    </select>\n\n</mapper>\n\n\nJobMapper\n\nJobMapper.xml\n\n> 这两个用于铺垫使用，反向生成后，未更变！\n\n测试\n\npublic class AnyToMany {\n    \n    /** 对多关系\n     *   两表的对多关系 需要 第三方 中间表建立关系，因此必须包含有中间表\n     *   查询方式：\n     *      - 以中间表作为主表 进行对两表 连接查询\n     *      - 以对多的任意一个为主表 进行对多 连接查询\n     */\n    \n    // 中间表作为主表 进行连接查询\n    @Test\n    public void brokerOfFirstTableTest() {\n        EmpMapper mapper = MyBatisUtil.getSession().getMapper(EmpMapper.class);\n    \n        // 配置约束容器\n        EmpExample example = new EmpExample();\n        EmpExample.Criteria criteria = example.createCriteria();\n        criteria.andEnameLike("%j%");\n        \n        List<Emp> emps = mapper.selectByExampleJoinDateAndJob(example);\n        emps.forEach(o -> {\n            System.out.println(o+"\\n\\t"+o.getBeanDept()+"\\n\\t"+o.getBeanJob());\n        });\n        \n    }\n    \n    // 任意表为主表 进行连接查询\n    @Test\n    public void anyOfFirstTableTest() {\n        DeptMapper mapper = MyBatisUtil.getSession().getMapper(DeptMapper.class);\n    \n        // 配置约束容器\n        DeptExample example = new DeptExample();\n        DeptExample.Criteria criteria = example.createCriteria();\n        criteria.andDnameLike("%m%");\n    \n        List<Dept> depts = mapper.DeptAndJobByExample(example);\n        \n        depts.forEach( o -> {\n            System.out.println(o);\n            o.getJobs().forEach(job -> {\n                System.out.println("\\t"+job);\n            });\n        });\n        \n    }\n    \n}\n\n\n\n# MyBatis延迟加载\n\n延迟加载在调用的时候加载的查询数据\n\n配置\n\n<configuration>\n    ....\n\t<settings>\n\t    \x3c!-- 日志配置 --\x3e\n\t    <setting name="logImpl" value="LOG4J"/>\n\t\n\t    \x3c!-- 打开延迟加载 的开关 --\x3e\n\t    <setting name="lazyLoadingEnabled" value="true"/>\n\t    \x3c!-- 将积极加载改为消极加载即按需要加载 --\x3e\n\t    <setting name="aggressiveLazyLoading" value="false"/>\n\t    \x3c!-- 启动二级缓存\n\t    <setting name="cacheEnabled" value="true"/>--\x3e\n\t</settings>\n    ....\n</configuration>\n\n\n> 根据以上应用 Emp 和 Dept 的关系进行应用懒加载\n> \n> 注意：\n> \n>  * Emp实体类中 包含 一方Dept对象\n\nSQL映射\n\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >\n<mapper namespace="com.sans.mapper.EmpMapper">\n    <resultMap id="BaseResultMap" type="com.sans.pojo.Emp">\n        <id column="empno" property="empno" jdbcType="INTEGER"/>\n        <result column="ename" property="ename" jdbcType="VARCHAR"/>\n        <result column="job" property="job" jdbcType="VARCHAR"/>\n        <result column="mgr" property="mgr" jdbcType="INTEGER"/>\n        <result column="hiredate" property="hiredate" jdbcType="TIMESTAMP"/>\n        <result column="sal" property="sal" jdbcType="DECIMAL"/>\n        <result column="comm" property="comm" jdbcType="DECIMAL"/>\n        <result column="deptno" property="deptno" jdbcType="INTEGER"/>\n        <result column="jobno" property="jobno" jdbcType="INTEGER"/>\n    </resultMap>\n    \n    \x3c!-- ... 省略自动生成的非关键代码 --\x3e\n\n    \x3c!-- 懒加载测试 --\x3e\n    <resultMap id="lazyLoadingMap" type="com.sans.pojo.Emp" extends="BaseResultMap">\n        <association property="dept" column="deptno" javaType="com.sans.pojo.Dept"\n            select="com.sans.mapper.DeptMapper.selectByPrimaryKey">\n            <id column="deptno" property="deptno" javaType="int"/>\n            <result column="dname" property="dname" javaType="String"/>\n            <result column="loc" property="loc" javaType="String"/>\n        </association>\n    </resultMap>\n\n    <select id="lazyLoadingSelectAll" resultMap="lazyLoadingMap">\n        select * from emp\n    </select>\n\n</mapper>\n\n\n以下是测试懒加载的效果实例\n\n无懒加载\n\nDEBUG [main] - ==>  Preparing: select * from emp\nDEBUG [main] - ==> Parameters: \nDEBUG [main] - ====>  Preparing: select deptno, dname, loc from dept where deptno = ?\nDEBUG [main] - ====> Parameters: 20(Integer)\nDEBUG [main] - <====      Total: 1\nDEBUG [main] - ====>  Preparing: select deptno, dname, loc from dept where deptno = ?\nDEBUG [main] - ====> Parameters: 30(Integer)\nDEBUG [main] - <====      Total: 1\nDEBUG [main] - ====>  Preparing: select deptno, dname, loc from dept where deptno = ?\nDEBUG [main] - ====> Parameters: 47(Integer)\nDEBUG [main] - <====      Total: 1\nDEBUG [main] - ====>  Preparing: select deptno, dname, loc from dept where deptno = ?\nDEBUG [main] - ====> Parameters: 10(Integer)\nDEBUG [main] - <====      Total: 1\nDEBUG [main] - ====>  Preparing: select deptno, dname, loc from dept where deptno = ?\nDEBUG [main] - ====> Parameters: 13(Integer)\nDEBUG [main] - <====      Total: 1\nDEBUG [main] - ====>  Preparing: select deptno, dname, loc from dept where deptno = ?\nDEBUG [main] - ====> Parameters: 14(Integer)\nDEBUG [main] - <====      Total: 1\nDEBUG [main] - ====>  Preparing: select deptno, dname, loc from dept where deptno = ?\nDEBUG [main] - ====> Parameters: 141(Integer)\nDEBUG [main] - <====      Total: 1\nDEBUG [main] - ====>  Preparing: select deptno, dname, loc from dept where deptno = ?\nDEBUG [main] - ====> Parameters: 140(Integer)\nDEBUG [main] - <====      Total: 1\nDEBUG [main] - ====>  Preparing: select deptno, dname, loc from dept where deptno = ?\nDEBUG [main] - ====> Parameters: 164(Integer)\nDEBUG [main] - <====      Total: 1\nDEBUG [main] - ====>  Preparing: select deptno, dname, loc from dept where deptno = ?\nDEBUG [main] - ====> Parameters: 167(Integer)\nDEBUG [main] - <====      Total: 1\nDEBUG [main] - ====>  Preparing: select deptno, dname, loc from dept where deptno = ?\nDEBUG [main] - ====> Parameters: 1(Integer)\nDEBUG [main] - <====      Total: 1\nDEBUG [main] - <==      Total: 43\n张小三 ==> Dept{deptno=20, dname=\'RESEARCH\', loc=\'DALLAS\'} => RESEARCH\n张小 ==> Dept{deptno=20, dname=\'RESEARCH\', loc=\'DALLAS\'} => RESEARCH\n李四 ==> Dept{deptno=30, dname=\'SALES\', loc=\'CHICAGO\'} => SALES\n旺财2 ==> Dept{deptno=47, dname=\'学术部\', loc=\'B区\'} => 学术部\nzhansan ==> Dept{deptno=20, dname=\'RESEARCH\', loc=\'DALLAS\'} => RESEARCH\nzhansan2 ==> Dept{deptno=20, dname=\'RESEARCH\', loc=\'DALLAS\'} => RESEARCH\nwangwu ==> Dept{deptno=20, dname=\'RESEARCH\', loc=\'DALLAS\'} => RESEARCH\nJason ==> Dept{deptno=10, dname=\'市场部\', loc=\'NEW YORK\'} => 市场部\n王五 ==> Dept{deptno=30, dname=\'SALES\', loc=\'CHICAGO\'} => SALES\n旺财 ==> Dept{deptno=47, dname=\'学术部\', loc=\'B区\'} => 学术部\n王小二 ==> Dept{deptno=30, dname=\'SALES\', loc=\'CHICAGO\'} => SALES\nkkkkk ==> Dept{deptno=20, dname=\'RESEARCH\', loc=\'DALLAS\'} => RESEARCH\nj1 ==> Dept{deptno=13, dname=\'bb\', loc=\'b\'} => bb\nj3 ==> Dept{deptno=14, dname=\'cc\', loc=\'b\'} => cc\nj4 ==> Dept{deptno=141, dname=\'cqc\', loc=\'b\'} => cqc\nj5 ==> Dept{deptno=140, dname=\'cqc\', loc=\'b\'} => cqc\nj6 ==> Dept{deptno=141, dname=\'cqc\', loc=\'b\'} => cqc\nhhh ==> Dept{deptno=20, dname=\'RESEARCH\', loc=\'DALLAS\'} => RESEARCH\nking2 ==> Dept{deptno=30, dname=\'SALES\', loc=\'CHICAGO\'} => SALES\nmm ==> Dept{deptno=20, dname=\'RESEARCH\', loc=\'DALLAS\'} => RESEARCH\n旺 ==> Dept{deptno=20, dname=\'RESEARCH\', loc=\'DALLAS\'} => RESEARCH\n李 ==> Dept{deptno=30, dname=\'SALES\', loc=\'CHICAGO\'} => SALES\nnull ==> Dept{deptno=10, dname=\'市场部\', loc=\'NEW YORK\'} => 市场部\njjj ==> Dept{deptno=164, dname=\'m1\', loc=\'m1\'} => m1\nmmm ==> Dept{deptno=164, dname=\'m1\', loc=\'m1\'} => m1\njjj2 ==> Dept{deptno=167, dname=\'m2\', loc=\'m1\'} => m2\nmmm2 ==> Dept{deptno=167, dname=\'m2\', loc=\'m1\'} => m2\naaa ==> Dept{deptno=47, dname=\'学术部\', loc=\'B区\'} => 学术部\nSMITH ==> Dept{deptno=20, dname=\'RESEARCH\', loc=\'DALLAS\'} => RESEARCH\nALLEN ==> Dept{deptno=30, dname=\'SALES\', loc=\'CHICAGO\'} => SALES\nWARD ==> Dept{deptno=30, dname=\'SALES\', loc=\'CHICAGO\'} => SALES\nJONES ==> Dept{deptno=20, dname=\'RESEARCH\', loc=\'DALLAS\'} => RESEARCH\nMARTIN ==> Dept{deptno=30, dname=\'SALES\', loc=\'CHICAGO\'} => SALES\nBLAKE ==> Dept{deptno=30, dname=\'SALES\', loc=\'CHICAGO\'} => SALES\nCLARK ==> Dept{deptno=10, dname=\'市场部\', loc=\'NEW YORK\'} => 市场部\nSCOTT ==> Dept{deptno=20, dname=\'RESEARCH\', loc=\'DALLAS\'} => RESEARCH\nKING ==> Dept{deptno=10, dname=\'市场部\', loc=\'NEW YORK\'} => 市场部\nTURNER ==> Dept{deptno=30, dname=\'SALES\', loc=\'CHICAGO\'} => SALES\nADAMS ==> Dept{deptno=20, dname=\'RESEARCH\', loc=\'DALLAS\'} => RESEARCH\nJAMES ==> Dept{deptno=30, dname=\'SALES\', loc=\'CHICAGO\'} => SALES\nFORD ==> Dept{deptno=20, dname=\'RESEARCH\', loc=\'DALLAS\'} => RESEARCH\nMILLER ==> Dept{deptno=10, dname=\'市场部\', loc=\'NEW YORK\'} => 市场部\n赵六 ==> Dept{deptno=1, dname=\'会计部\', loc=\'海珠区\'} => 会计部\n\n\n懒加载\n\nDEBUG [main] - ==>  Preparing: select * from emp\nDEBUG [main] - ==> Parameters: \nDEBUG [main] - <==      Total: 43\nDEBUG [main] - ==>  Preparing: select deptno, dname, loc from dept where deptno = ?\nDEBUG [main] - ==> Parameters: 20(Integer)\nDEBUG [main] - <==      Total: 1\n张小三 ==> Dept{deptno=20, dname=\'RESEARCH\', loc=\'DALLAS\'} => RESEARCH\n张小 ==> Dept{deptno=20, dname=\'RESEARCH\', loc=\'DALLAS\'} => RESEARCH\nDEBUG [main] - ==>  Preparing: select deptno, dname, loc from dept where deptno = ?\nDEBUG [main] - ==> Parameters: 30(Integer)\nDEBUG [main] - <==      Total: 1\n李四 ==> Dept{deptno=30, dname=\'SALES\', loc=\'CHICAGO\'} => SALES\nDEBUG [main] - ==>  Preparing: select deptno, dname, loc from dept where deptno = ?\nDEBUG [main] - ==> Parameters: 47(Integer)\nDEBUG [main] - <==      Total: 1\n旺财2 ==> Dept{deptno=47, dname=\'学术部\', loc=\'B区\'} => 学术部\nzhansan ==> Dept{deptno=20, dname=\'RESEARCH\', loc=\'DALLAS\'} => RESEARCH\nzhansan2 ==> Dept{deptno=20, dname=\'RESEARCH\', loc=\'DALLAS\'} => RESEARCH\nwangwu ==> Dept{deptno=20, dname=\'RESEARCH\', loc=\'DALLAS\'} => RESEARCH\nDEBUG [main] - ==>  Preparing: select deptno, dname, loc from dept where deptno = ?\nDEBUG [main] - ==> Parameters: 10(Integer)\nDEBUG [main] - <==      Total: 1\nJason ==> Dept{deptno=10, dname=\'市场部\', loc=\'NEW YORK\'} => 市场部\n王五 ==> Dept{deptno=30, dname=\'SALES\', loc=\'CHICAGO\'} => SALES\n旺财 ==> Dept{deptno=47, dname=\'学术部\', loc=\'B区\'} => 学术部\n王小二 ==> Dept{deptno=30, dname=\'SALES\', loc=\'CHICAGO\'} => SALES\nkkkkk ==> Dept{deptno=20, dname=\'RESEARCH\', loc=\'DALLAS\'} => RESEARCH\nDEBUG [main] - ==>  Preparing: select deptno, dname, loc from dept where deptno = ?\nDEBUG [main] - ==> Parameters: 13(Integer)\nDEBUG [main] - <==      Total: 1\nj1 ==> Dept{deptno=13, dname=\'bb\', loc=\'b\'} => bb\nDEBUG [main] - ==>  Preparing: select deptno, dname, loc from dept where deptno = ?\nDEBUG [main] - ==> Parameters: 14(Integer)\nDEBUG [main] - <==      Total: 1\nj3 ==> Dept{deptno=14, dname=\'cc\', loc=\'b\'} => cc\nDEBUG [main] - ==>  Preparing: select deptno, dname, loc from dept where deptno = ?\nDEBUG [main] - ==> Parameters: 141(Integer)\nDEBUG [main] - <==      Total: 1\nj4 ==> Dept{deptno=141, dname=\'cqc\', loc=\'b\'} => cqc\nDEBUG [main] - ==>  Preparing: select deptno, dname, loc from dept where deptno = ?\nDEBUG [main] - ==> Parameters: 140(Integer)\nDEBUG [main] - <==      Total: 1\nj5 ==> Dept{deptno=140, dname=\'cqc\', loc=\'b\'} => cqc\nj6 ==> Dept{deptno=141, dname=\'cqc\', loc=\'b\'} => cqc\nhhh ==> Dept{deptno=20, dname=\'RESEARCH\', loc=\'DALLAS\'} => RESEARCH\nking2 ==> Dept{deptno=30, dname=\'SALES\', loc=\'CHICAGO\'} => SALES\nmm ==> Dept{deptno=20, dname=\'RESEARCH\', loc=\'DALLAS\'} => RESEARCH\n旺 ==> Dept{deptno=20, dname=\'RESEARCH\', loc=\'DALLAS\'} => RESEARCH\n李 ==> Dept{deptno=30, dname=\'SALES\', loc=\'CHICAGO\'} => SALES\nnull ==> Dept{deptno=10, dname=\'市场部\', loc=\'NEW YORK\'} => 市场部\nDEBUG [main] - ==>  Preparing: select deptno, dname, loc from dept where deptno = ?\nDEBUG [main] - ==> Parameters: 164(Integer)\nDEBUG [main] - <==      Total: 1\njjj ==> Dept{deptno=164, dname=\'m1\', loc=\'m1\'} => m1\nmmm ==> Dept{deptno=164, dname=\'m1\', loc=\'m1\'} => m1\nDEBUG [main] - ==>  Preparing: select deptno, dname, loc from dept where deptno = ?\nDEBUG [main] - ==> Parameters: 167(Integer)\nDEBUG [main] - <==      Total: 1\njjj2 ==> Dept{deptno=167, dname=\'m2\', loc=\'m1\'} => m2\nmmm2 ==> Dept{deptno=167, dname=\'m2\', loc=\'m1\'} => m2\naaa ==> Dept{deptno=47, dname=\'学术部\', loc=\'B区\'} => 学术部\nSMITH ==> Dept{deptno=20, dname=\'RESEARCH\', loc=\'DALLAS\'} => RESEARCH\nALLEN ==> Dept{deptno=30, dname=\'SALES\', loc=\'CHICAGO\'} => SALES\nWARD ==> Dept{deptno=30, dname=\'SALES\', loc=\'CHICAGO\'} => SALES\nJONES ==> Dept{deptno=20, dname=\'RESEARCH\', loc=\'DALLAS\'} => RESEARCH\nMARTIN ==> Dept{deptno=30, dname=\'SALES\', loc=\'CHICAGO\'} => SALES\nBLAKE ==> Dept{deptno=30, dname=\'SALES\', loc=\'CHICAGO\'} => SALES\nCLARK ==> Dept{deptno=10, dname=\'市场部\', loc=\'NEW YORK\'} => 市场部\nSCOTT ==> Dept{deptno=20, dname=\'RESEARCH\', loc=\'DALLAS\'} => RESEARCH\nKING ==> Dept{deptno=10, dname=\'市场部\', loc=\'NEW YORK\'} => 市场部\nTURNER ==> Dept{deptno=30, dname=\'SALES\', loc=\'CHICAGO\'} => SALES\nADAMS ==> Dept{deptno=20, dname=\'RESEARCH\', loc=\'DALLAS\'} => RESEARCH\nJAMES ==> Dept{deptno=30, dname=\'SALES\', loc=\'CHICAGO\'} => SALES\nFORD ==> Dept{deptno=20, dname=\'RESEARCH\', loc=\'DALLAS\'} => RESEARCH\nMILLER ==> Dept{deptno=10, dname=\'市场部\', loc=\'NEW YORK\'} => 市场部\nDEBUG [main] - ==>  Preparing: select deptno, dname, loc from dept where deptno = ?\nDEBUG [main] - ==> Parameters: 1(Integer)\nDEBUG [main] - <==      Total: 1\n赵六 ==> Dept{deptno=1, dname=\'会计部\', loc=\'海珠区\'} => 会计部\n\n\n\n# MyBatis缓存\n\nMyBatis缓存是一般的ORM 框架都会提供的功能，目的就是提升查询的效率和减少数据库的压力。\n\n将经常查询的数据存在缓存（内存）中，用户查询该数据的时候不需要从库上 查询，而是直接从缓存中查询，提高查询效率，解决高并发问题。 MyBatis 也有一级缓存 和 二级缓存，并且预留了集成 第三方缓存的接口\n\n\n# 一级缓存\n\nMybatis自带的 缓存 ，在构造sqlSession对象时内部有个 HashMap 结构存储缓存数据，它的作用域范围是 sqlSession 。如果两次查询用同一个sqlSession进行查询语句，则第一次会通过数据库获取到数据库 ，二次会缓存中获取数据！\n\n> 缓存清除条件：\n> \n>  * session.clearCache()\n>  * session.close()\n>  * 执行 增删改\n>  * 事务回滚\n>  * 事务提交\n\n\n\n应用实例\n\nimport com.pojo.Team;\nimport com.utils.MybatisUtil;\nimport org.apache.ibatis.session.SqlSession;\nimport org.junit.Test;\n\npublic class CacheTest {\n    \n    private SqlSession sqlSession = MybatisUtil.getSqlSession();\n    \n    @Test\n    public void test01() {\n        Team t1 = sqlSession.selectOne("com.mapper.TeamMapper.queryById",1003);\n        System.out.println("t1 : " + t1);\n        Team t2 = sqlSession.selectOne("com.mapper.TeamMapper.queryById",1003);\n        System.out.println("t2 : " + t2);\n        \n        MybatisUtil.close();\n        \n        //换 sqlSession ，刷新缓存\n        sqlSession = MybatisUtil.getSqlSession();\n        Team t3 = sqlSession.selectOne("com.mapper.TeamMapper.queryById",1003);\n        System.out.println("t3 : " + t3);\n        \n        int num = sqlSession.delete("com.mapper.TeamMapper.delById",1000);\n        sqlSession.commit();\n        System.out.println("num : " + num);\n        \n        Team t4 = sqlSession.selectOne("com.mapper.TeamMapper.queryById",1003);\n        sqlSession.close();\n    }\n    \n}\n\n/* 运行结果\n\nDEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@1f760b47]\nDEBUG [main] - ==>  Preparing: select * from team where teamId=?\nDEBUG [main] - ==> Parameters: 1003(Integer)\nDEBUG [main] - <==      Total: 1\nt1 : Team{teamId=1003, teamName=\'老八\', location=\'温州\', createTime=Wed Feb 17 00:00:00 CST 2021}\nt2 : Team{teamId=1003, teamName=\'老八\', location=\'温州\', createTime=Wed Feb 17 00:00:00 CST 2021}\nDEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@1f760b47]\nDEBUG [main] - Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@1f760b47]\nDEBUG [main] - Returned connection 527829831 to pool.\nDEBUG [main] - Opening JDBC Connection\nDEBUG [main] - Checked out connection 527829831 from pool.\nDEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@1f760b47]\nDEBUG [main] - ==>  Preparing: select * from team where teamId=?\nDEBUG [main] - ==> Parameters: 1003(Integer)\nDEBUG [main] - <==      Total: 1\nt3 : Team{teamId=1003, teamName=\'老八\', location=\'温州\', createTime=Wed Feb 17 00:00:00 CST 2021}\nDEBUG [main] - ==>  Preparing: DELETE FROM `mybatis`.`team` WHERE `teamId` = ?\nDEBUG [main] - ==> Parameters: 1000(Integer)\nDEBUG [main] - <==    Updates: 0\nDEBUG [main] - Committing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@1f760b47]\nnum : 0\nDEBUG [main] - ==>  Preparing: select * from team where teamId=?\nDEBUG [main] - ==> Parameters: 1003(Integer)\nDEBUG [main] - <==      Total: 1\nDEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@1f760b47]\nDEBUG [main] - Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@1f760b47]\nDEBUG [main] - Returned connection 527829831 to pool.\n\n*/\n\n\n\n# 二级缓存\n\nMyBatis 二级缓存是全局缓存，作用域超出 SqlSession 范围之外，其作用域是 mapper 的同一命名空间！\n\n两个不同的sqlSession在同一 命名空间 下，执行的sql语句参数相同 ，最终执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据，从而提高性能！\n\n\n\n应用实例\n\n修改配置文件 ==mybatis.xml==\n\n···\n\t<settings>\n\t    \x3c!--    日志配置--\x3e\n\t    <setting name="logImpl" value="LOG4J"/>\n\t    \x3c!--    是否启动二级缓存--\x3e\n\t    <setting name="cacheEnabled" value="true"/>\n\t</settings>\n···\n\n\n修改映射文件 ==TeamMapper.xml==\n\n<mapper namespace="com.mapper.TeamMapper">\n\x3c!--   二级缓存标签--\x3e\n    <cache></cache>\n\t····    \n<mapper/>\n\n\n实体类实现 ==Serializable接口==\n\npackage com.pojo;\n\nimport java.io.Serializable;\nimport java.util.Date;\nimport java.util.List;\n\npublic class Team implements Serializable {\n    \n    private Integer teamId;\n    private String teamName;\n    private String location;\n    private Date createTime;\n    \n    //一对多的体现：一方持有多方的对象\n    private List<Player> playerList1;\n    private List<Player> playerList2;\n  \t\n    //省略 set、get、toString、构造 方法\n    \n}\n\n\n测试\n\nimport com.mapper.TeamMapper;\nimport com.pojo.Team;\nimport com.utils.MybatisUtil;\nimport org.apache.ibatis.session.SqlSession;\nimport org.junit.Test;\n\npublic class CacheTest {\n    \n    @Test\n    public void test02() {\n        //查 数据 保留缓存\n        SqlSession sqlSession1 = MybatisUtil.getSqlSession();\n        Team t1 = sqlSession1.selectOne("com.mapper.TeamMapper.queryById" , 1019);\n        System.out.println("t1 : " + t1);\n        //清空一级缓存，保留二级缓存\n        MybatisUtil.close();\n    \n        //测试 是否保留二级缓存\n        SqlSession sqlSession2 = MybatisUtil.getSqlSession();\n        Team t2 = sqlSession2.selectOne("com.mapper.TeamMapper.queryById" , 1019);\n        System.out.println("t2 : " + t2);\n        MybatisUtil.close();\n    \n        //测试 删除数据 清空二级缓存\n        SqlSession sqlSession3 = MybatisUtil.getSqlSession();\n        //删除不存在的数据（假删除）\n        int i = sqlSession3.delete("com.mapper.TeamMapper.delById" , 10000);\n        System.out.println("i : " + i);\n        sqlSession3.commit();\n        MybatisUtil.close();\n    \n        //测试 是否保留二级缓存\n        SqlSession sqlSession4 = MybatisUtil.getSqlSession();\n        Team t4 = sqlSession4.selectOne("com.mapper.TeamMapper.queryById" , 1019);\n        System.out.println("t4 : " + t4);\n        MybatisUtil.close();\n        \n    }\n    \n}\n\n/*运行结果\n    \nDEBUG [main] - Created connection 292138977.\nDEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@1169afe1]\nDEBUG [main] - ==>  Preparing: select * from team where teamId=?\nDEBUG [main] - ==> Parameters: 1019(Integer)\nDEBUG [main] - <==      Total: 1\nt1 : Team{teamId=1019, teamName=\'哥斯拉\', location=\'华盛顿\', createTime=Sun Jul 25 00:00:00 CST 2021}\nDEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@1169afe1]\nDEBUG [main] - Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@1169afe1]\nDEBUG [main] - Returned connection 292138977 to pool.\n WARN [main] - As you are using functionality that deserializes object streams, it is recommended to define the JEP-290 serial filter. Please refer to https://docs.oracle.com/pls/topic/lookup?ctx=javase15&id=GUID-8296D8E8-2B93-4B9A-856E-0A65AF9B8C66\nDEBUG [main] - Cache Hit Ratio [com.mapper.TeamMapper]: 0.5\nt2 : Team{teamId=1019, teamName=\'哥斯拉\', location=\'华盛顿\', createTime=Sun Jul 25 00:00:00 CST 2021}\nDEBUG [main] - Opening JDBC Connection\nDEBUG [main] - Checked out connection 292138977 from pool.\nDEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@1169afe1]\nDEBUG [main] - ==>  Preparing: DELETE FROM `mybatis`.`team` WHERE `teamId` = ?\nDEBUG [main] - ==> Parameters: 10000(Integer)\nDEBUG [main] - <==    Updates: 0\ni : 0\nDEBUG [main] - Committing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@1169afe1]\nDEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@1169afe1]\nDEBUG [main] - Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@1169afe1]\nDEBUG [main] - Returned connection 292138977 to pool.\nDEBUG [main] - Cache Hit Ratio [com.mapper.TeamMapper]: 0.3333333333333333\nDEBUG [main] - Opening JDBC Connection\nDEBUG [main] - Checked out connection 292138977 from pool.\nDEBUG [main] - Setting autocommit to false on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@1169afe1]\nDEBUG [main] - ==>  Preparing: select * from team where teamId=?\nDEBUG [main] - ==> Parameters: 1019(Integer)\nDEBUG [main] - <==      Total: 1\nt4 : Team{teamId=1019, teamName=\'哥斯拉\', location=\'华盛顿\', createTime=Sun Jul 25 00:00:00 CST 2021}\nDEBUG [main] - Resetting autocommit to true on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@1169afe1]\nDEBUG [main] - Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@1169afe1]\nDEBUG [main] - Returned connection 292138977 to pool.\n    \n*/\n\n\n# 二级缓存其他设置\n\n映射文件中的cache标签\n\n···\t\n\t\x3c!--二级缓存默认配置--\x3e\n\t<cache>\n\t\t<property name="eviction" value="LRU"/>\x3c!--回收策略为LRU--\x3e\n\t\t<property name="flushInterval" value="60000"/>\x3c!--自动刷新时间间隔为60S--\x3e\n\t\t<property name="size" value="1024"/>\x3c!--最多缓存1024个引用对象--\x3e\n\t\t<property name="readOnly" value="true"/>\x3c!--只读--\x3e\n\t</cache>\n···\n\n\n属性              说明\neviction        代表的是缓存回收策略，目前 MyBatis 提供以下策略。\n                LRU：使用较少，移除最长时间不用的对象；\n                FIFO：先进先出，按对象进入缓存的顺序来移除它们；\n                SOFT：软引用，移除基于垃圾回收器状态和软引用规则的对象；\n                WEAK：弱引用，更积极地移除基于垃圾收集器状态和弱引用规则的对象\nflushInterval   刷新间隔时间，单位为毫秒，这里配置的是 100 秒刷新，如果省略该配置，那么只有当 SQL 被执行的时候才会刷新缓存\nsize            引用数目，正整数，代表缓存最多可以存储多少个对象，不宜设置过大。设置过大会导致内存溢出。这里配置的是 1024 个对象\nreadOnly        只读，默认值为 false，意味着缓存数据只能读取而不能修改，这样设置的好处是可以快速读取缓存，缺点是没有办法修改缓存\n\n重用cache标签配置\n\n在命名空间中共享相同的缓存配置和实例，可以使用cache-ref 元素来引用另外一个缓存。引用实例：\n\n···\n\t\x3c!--需要指定 映射文件的位置--\x3e\n\t<cache-ref namespace="com.mapper.TeamMapper" />\n···\n\n\n\n# 反向工程\n\nMybatis 提供逆向生成工具，该工具可以根据 数据库中的表 自动生成单表的 pojo 类、mapper 映射文件和 mapper 接口。大大缩减了开发时间！！（应用前提，不同库表名不建议写相同！）\n\nMyBatis反向生成方式有多种，本次引用了：项目生成 和 Maven项目工具生成\n\n\n# 项目生成\n\n项目到手直接配置 generatorConfig.xml 该文件即可，我们只需要关注以下的配置信息\n\n * <jdbcConnection>：JDBC 库连接\n   * **driverClass：**驱动加载\n   * **connectionURL：**连接URL\n   * **userId：**账号\n   * **password：**密码\n * <javaModelGenerator>.targetPackage：指定生成 实体类路径\n * <sqlMapGenerator>.targetPackage：指定生成 映射文件路径\n * <javaClientGenerator>.targetPackage：指定生成 mapper接口路径\n * <table>.tableName：指定 反向生成 的数据库 表\n\n> 对以上标签详细了解以及配置的信息，可在一下jar包路径了解详细： ==mybatis-generator-core-1.3.2.jar\\org\\mybatis\\generator\\config\\xml\\mybatis-generator-config_1_0.dtd==\n\n依赖包\n\n * log4j-1.2.16.jar（日志\n * mybatis-3.5.6.jar（mybatis\n * mybatis-generator-core-1.3.2.jar （反向工程\n * mysql-connector-java-8.0.16.jar（jdbc\n\n项目生成问题:\n\n * 反向生成项目 不能通过子项目进行应用该项目，否则 反向生成找不到 src 根路径\n * 反向生成项目，配置 指定的包名路径 必须与应用的项目一致 （实例和映射的路径\n\n\n\n示例：\n\ngeneratorConfig.xml配置文件\n\n<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE generatorConfiguration\n  PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"\n  "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">\n\n<generatorConfiguration>\n   <context id="testTables" targetRuntime="MyBatis3">\n      <commentGenerator>\n         \x3c!-- 是否去除自动生成的注释 true：是 ： false:否 --\x3e\n         <property name="suppressAllComments" value="true" />\n      </commentGenerator>\n      \x3c!--数据库连接的信息：驱动类、连接地址、用户名、密码 --\x3e\n       \n      <jdbcConnection\n            driverClass="com.mysql.cj.jdbc.Driver"\n         connectionURL="jdbc:mysql://127.0.0.1:3306/test?\nuseUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT"\n         userId="root"\n         password="root">\n      </jdbcConnection>\n     \n      \x3c!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和 \n         NUMERIC 类型解析为java.math.BigDecimal --\x3e\n      <javaTypeResolver>\n         <property name="forceBigDecimals" value="false" />\n      </javaTypeResolver>\n\n      \x3c!-- targetProject:生成POjO类的位置 --\x3e\n      <javaModelGenerator targetPackage="com.sans.pojo"\n         targetProject=".\\src">\n         \x3c!-- enableSubPackages:是否让schema作为包的后缀 --\x3e\n         <property name="enableSubPackages" value="false" />\n         \x3c!-- 从数据库返回的值被清理前后的空格 --\x3e\n         <property name="trimStrings" value="true" />\n      </javaModelGenerator>\n        \x3c!-- targetProject:mapper映射文件生成的位置 --\x3e\n      <sqlMapGenerator targetPackage="com.sans.mapper"\n         targetProject=".\\src">\n         \x3c!-- enableSubPackages:是否让schema作为包的后缀 --\x3e\n         <property name="enableSubPackages" value="false" />\n      </sqlMapGenerator>\n      \x3c!-- targetPackage：mapper接口生成的位置 --\x3e\n      <javaClientGenerator type="XMLMAPPER"\n         targetPackage="com.sans.mapper"\n         targetProject=".\\src">\n         \x3c!-- enableSubPackages:是否让schema作为包的后缀 --\x3e\n         <property name="enableSubPackages" value="false" />\n      </javaClientGenerator>\n\n      \x3c!-- 指定数据库表    --\x3e\n      <table tableName="emp">\n         \x3c!-- 大小写也一起搬 --\x3e\n         <property name="useActualColumnNames" value="true"/>\n      </table>\n      <table tableName="dept">\n         <property name="useActualColumnNames" value="true"/>\n      </table>\n       \n      \x3c!-- 有些表的字段需要指定java类型\n       <table schema="" tableName="">\n         <columnOverride column="" javaType="" />\n      </table> --\x3e\n   </context>\n</generatorConfiguration>\n\n\nGeneratorSqlmap类 执行入口\n\nimport java.io.File;\nimport java.net.URLDecoder;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.mybatis.generator.api.MyBatisGenerator;\nimport org.mybatis.generator.config.Configuration;\nimport org.mybatis.generator.config.xml.ConfigurationParser;\nimport org.mybatis.generator.internal.DefaultShellCallback;\n\npublic class GeneratorSqlmap {\n   \n   // 指定 逆向工程配置文件\n   private static String configName = "generatorConfig.xml";\n   \n   public void generator() throws Exception{\n\n      List<String> warnings = new ArrayList<>();\n      boolean overwrite = true;\n      \n      // 通过类加载的路径进入查找文件\n      // 中文路径转义\n      String decode = URLDecoder.decode(this.getClass().getClassLoader().getResource(configName).getFile() , "utf-8");\n      System.out.println("decode : " + decode);\n      File configFile = new File(decode);\n      \n      ConfigurationParser cp = new ConfigurationParser(warnings);\n      Configuration config = cp.parseConfiguration(configFile);\n      DefaultShellCallback callback = new DefaultShellCallback(overwrite);\n      MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config,\n            callback, warnings);\n      myBatisGenerator.generate(null);\n\n   } \n   public static void main(String[] args) {\n      try {\n         // 直接指定路径可能会有问题\n         new GeneratorSqlmap().generator();\n      } catch (Exception e) {\n         e.printStackTrace();\n      }\n      \n   }\n\n}\n\n\n执行成功会在指定的路径生成出文件\n\n反向工程应用\n\n直接上测试代码，就不多bb\n\npackage com.sans;\n\nimport com.sans.mapper.DeptMapper;\nimport com.sans.pojo.Dept;\nimport com.sans.pojo.DeptExample;\nimport com.sans.utils.MyBatisUtil;\nimport org.junit.Test;\n\nimport java.util.List;\n\npublic class Demo {\n    \n    /** 反向工程 单表应用测试\n     *  已 Dept对象 示例\n     *  反向生成的接口方法\n     *     // 查询所有条数 （带约束\n     *     int countByExample(DeptExample example);\n     *     // 删除指定数据 （带约束\n     *     int deleteByExample(DeptExample example);\n     *     // 删除指定id\n     *     int deleteByPrimaryKey(Integer deptno);\n     *     // 添加数据 （完全字段添加\n     *     int insert(Dept record);\n     *     // 添加数据 （选择添加字段\n     *     int insertSelective(Dept record);\n     *     // 查询 约束\n     *     List<Dept> selectByExample(DeptExample example);\n     *     // 查询 指定id\n     *     Dept selectByPrimaryKey(Integer deptno);\n     *     // 修改 约束 选择性\n     *     int updateByExampleSelective(@Param("record") Dept record, @Param("example") DeptExample example);\n     *     // 修改 约束\n     *     int updateByExample(@Param("record") Dept record, @Param("example") DeptExample example);\n     *     // 修改 指定id 选择性\n     *     int updateByPrimaryKeySelective(Dept record);\n     *     // 修改 指定id\n     *     int updateByPrimaryKey(Dept record);\n     *\n     *     以上方法 共同信息： id、约束、选择性\n     *\n     *     本次测试围绕：实体约束对象的使用 和 对象属性选择的操作 和 基本的CRUD\n     */\n\n    DeptMapper mapper = MyBatisUtil.getSession().getMapper(DeptMapper.class);\n    \n    // 查询 条数\n    // sql示例：select count(*) from dept\n    @Test\n    public void countTest() {\n        int i = mapper.countByExample(null);\n        System.out.println("i : " + i);\n    }\n    \n    // 查询 普通\n    // sql示例：select deptno, dname, loc from dept\n    @Test\n    public void findTest() {\n        List<Dept> depts = mapper.selectByExample(null);\n        depts.forEach(System.out::println);\n    }\n    \n    // 查询 约束\n    // sql示例：select deptno, dname, loc from dept WHERE ( deptno = 44 ) or( loc like \'天河\' )\n    @Test\n    public void findByExampleTest() {\n        DeptExample example = new DeptExample();\n        // 约束容器\n        DeptExample.Criteria criteria = example.createCriteria();\n        DeptExample.Criteria criteria2 = example.or();\n        criteria.andDeptnoEqualTo(44);\n        criteria2.andLocLike("天河");\n        \n        List<Dept> depts = mapper.selectByExample(example);\n        depts.forEach(System.out::println);\n    }\n    \n    // 添加\n    // sql示例：insert into dept (deptno, dname, loc ) values (null, \'会计部1\', \'汇总\' )\n    @Test\n    public void addTest() {\n        Dept dept = new Dept();\n        dept.setDname("会计部1");\n        dept.setLoc("汇总");\n        int i = mapper.insert(dept);\n        System.out.println(" ["+i+"] ");\n    }\n    \n    // 添加 选择\n    // sql示例：insert into dept ( loc ) values ( \'汇总\' )\n    @Test\n    public void addSSelectiveTest() {\n        Dept dept = new Dept();\n        dept.setLoc("汇总");\n        int i = mapper.insertSelective(dept);\n        System.out.println(" ["+i+"] ");\n    }\n    \n    // 修改 约束 选择\n    // sql示例：update dept SET dname = \'张三\', loc = \'张三2\' WHERE ( deptno = 50 )\n    @Test\n    public void updateTest() {\n        Dept dept = new Dept();\n        dept.setDname("张三");\n        dept.setLoc("张三2");\n        DeptExample example = new DeptExample();\n        DeptExample.Criteria criteria = example.createCriteria();\n        criteria.andDeptnoEqualTo(50);\n        int i = mapper.updateByExampleSelective(dept , example);\n        System.out.println(" ["+i+"] ");\n    }\n    \n}\n\n\n\n# Maven项目\n\nMaven反向生成 需要在 ==pom.xml== 中配置 ==org.mybatis.generator== 插件工具进行生成\n\n应用实现\n\n库数据引入&展示 （库名mybatis）\n\nCREATE TABLE `team` (\n  `teamId` int NOT NULL AUTO_INCREMENT COMMENT \'球队ID\',\n  `teamName` varchar(50) DEFAULT NULL COMMENT \'球队名称\',\n  `location` varchar(50) DEFAULT NULL COMMENT \'球队位置\',\n  `createTime` date DEFAULT NULL COMMENT \'球队建立时间\',\n  PRIMARY KEY (`teamId`)\n) ENGINE=InnoDB AUTO_INCREMENT=1026 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;\n\n\nCREATE TABLE `player` (\n  `playerId` int NOT NULL,\n  `playerName` varchar(100) DEFAULT NULL,\n  `playerNum` int DEFAULT NULL,\n  `teamId` int DEFAULT NULL,\n  PRIMARY KEY (`playerId`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\nCREATE TABLE `gamerecord` (\n  `recordId` varchar(36) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,\n  `homeTeamId` int DEFAULT NULL COMMENT \' 主队id\',\n  `gameDate` datetime DEFAULT NULL COMMENT \'比赛时间\',\n  `score` int DEFAULT NULL COMMENT \'得分\',\n  `visitingTeamId` int DEFAULT NULL COMMENT \'客队id\',\n  PRIMARY KEY (`recordId`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\n配置文件 ==pom.xml==\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n\t\n    ·····\n    <dependencies>\n        \x3c!--mybatis--\x3e\n        <dependency>\n            <groupId>org.mybatis</groupId>\n            <artifactId>mybatis</artifactId>\n            <version>3.5.6</version>\n        </dependency>\n        \x3c!--jdbc--\x3e\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>8.0.23</version>\n        </dependency>\n        \x3c!--测试--\x3e\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n            <scope>test</scope>\n        </dependency>\n        \x3c!--mybatis日志 依赖--\x3e\n        <dependency>\n            <groupId>log4j</groupId>\n            <artifactId>log4j</artifactId>\n            <version>1.2.17</version>\n        </dependency>\n    \t\x3c!--xml解析 依赖--\x3e\n        <dependency>\n            <groupId>org.codehaus.plexus</groupId>\n            <artifactId>plexus-classworlds</artifactId>\n            <version>2.5.2</version>\n        </dependency>\n        \x3c!--xml解析 依赖--\x3e\n        <dependency>\n            <groupId>org.mybatis.generator</groupId>\n            <artifactId>mybatis-generator-core</artifactId>\n            <version>1.3.5</version>\n        </dependency>\n    </dependencies>\n    \n    <build>\n        <plugins>\n            \x3c!--反向生成插件--\x3e\n            <plugin>\n                <groupId>org.mybatis.generator</groupId>\n                <artifactId>mybatis-generator-maven-plugin</artifactId>\n                <version>1.3.5</version>\n                <configuration>\n                    \x3c!--配置文件的路径--\x3e\n                    <configurationFile>src/main/resources/generatorConfig.xml</configurationFile>\n                    <overwrite>true</overwrite>\n                </configuration>\n                <dependencies>\n                    <dependency>\n                        <groupId>org.mybatis.generator</groupId>\n                        <artifactId>mybatis-generator-core</artifactId>\n                        <version>1.3.5</version>\n                    </dependency>\n                </dependencies>\n            </plugin>\n        </plugins>\n    </build>\n\n</project>\n\n\n创建逆向生成配置文件 ==resources/generatorConfig.xml==\n\n<?xml version="1.0" encoding="UTF-8"?>\n<!DOCTYPE generatorConfiguration\n        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"\n        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">\n\n\x3c!-- 配置生成器 --\x3e\n<generatorConfiguration>\n    \x3c!--1、数据库驱动jar:添加自己的jar路径 --\x3e\n    <classPathEntry\n            location="D:\\Maven\\repository\\mysql\\mysql-connector-java\\8.0.23\\mysql-connector-java-8.0.23.jar" />\n    <context id="MyBatis" targetRuntime="MyBatis3">\n        \x3c!--去除注释 --\x3e\n        <commentGenerator>\n            <property name="suppressAllComments" value="true" />\n        </commentGenerator>\n        \x3c!--2、数据库连接 --\x3e\n        <jdbcConnection driverClass="com.mysql.cj.jdbc.Driver"\n                        connectionURL="jdbc:mysql://127.0.0.1:3306/mybatis?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=GMT"\n                        userId="root"\n                        password="root">\n        </jdbcConnection>\n        \x3c!--\n        默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer;\n        为 true时把JDBC DECIMAL和NUMERIC类型解析为java.math.BigDecimal\n            false: Integer\n            true: BigDecimal (双精度浮点型变量double可以处理16位有效数)\n         --\x3e\n        <javaTypeResolver>\n            <property name="forceBigDecimals" value="false" />\n        </javaTypeResolver>\n        \x3c!--3、生成实体类 指定包名 以及生成的地址 （可以自定义地址，但是路径不存在不会自动创建\n        使用Maven生成在target目录下，会自动创建） --\x3e\n        <javaModelGenerator targetPackage="com.pojo"\n                            targetProject="src\\main\\java">\n            <property name="trimStrings" value="true" />\n        </javaModelGenerator>\n        \x3c!--4、生成SQLmapper.xml映射文件 --\x3e\n        <sqlMapGenerator targetPackage="com.mapper"\n                         targetProject="src\\main\\resources">\n        </sqlMapGenerator>\n        \x3c!--5、生成Dao（Mapper）接口文件,--\x3e\n        <javaClientGenerator type="XMLMAPPER"\n                             targetPackage="com.mapper"\n                             targetProject="src\\main\\java">\n        </javaClientGenerator>\n        \x3c!--6、要生成哪些表(更改tableName和domainObjectName就可以) --\x3e\n        \x3c!-- tableName:要生成的表名\n        enableCountByExample:Count语句中加入where条件查询，默认为true开启\n        enableUpdateByExample:Update语句中加入where条件查询，默认为true开启\n        enableDeleteByExample:Delete语句中加入where条件查询，默认为true开启\n        enableSelectByExample:Select多条语句中加入where条件查询，默认为true开启\n        selectByExampleQueryId:Select单个对象语句中加入where条件查询，默认为true开启\n        --\x3e\n\x3c!--        <table tableName="Team"--\x3e\n\x3c!--               enableCountByExample="false"--\x3e\n\x3c!--               enableUpdateByExample="false"--\x3e\n\x3c!--               enableUpdateByPrimaryKey="false"--\x3e\n\x3c!--               enableDeleteByExample="false"--\x3e\n\x3c!--               enableDeleteByPrimaryKey="false"--\x3e\n\x3c!--               enableSelectByExample="false"--\x3e\n\x3c!--               selectByExampleQueryId="false">--\x3e\n\x3c!--            <property name="useActualColumnNames" value="true"/>--\x3e\n\x3c!--        </table>--\x3e\n        <table tableName="team">\n            \x3c!--应用 库中对应的名称 (大小写也搬过去)--\x3e\n            <property name="useActualColumnNames" value="true"/>\n        </table>\n        <table tableName="player">\n            <property name="useActualColumnNames" value="true"/>\n        </table>\n        <table tableName="gamerecord">\n            <property name="useActualColumnNames" value="true"/>\n        </table>\n    </context>\n</generatorConfiguration>\n\n\nMaven插件 反向生成 插件命令行：==mybatis-generator:generate==\n\n\n\n测试（应用测试主要部分，多余就不赘述了）\n\nimport com.mapper.TeamMapper;\nimport com.pojo.Team;\nimport com.pojo.TeamExample;\nimport com.utils.MybatisUtil;\nimport org.junit.Test;\n\nimport java.util.Date;\nimport java.util.List;\n\npublic class TeamTest {\n\n    private TeamMapper teamMapper = MybatisUtil.getSqlSession().getMapper(TeamMapper.class);\n    \n    //查 主键\n    @Test\n    public void test01() {\n        Team team = teamMapper.selectByPrimaryKey(1019);\n        System.out.println("team : " + team);\n    }\n    \n    //查总数 无约束\n    @Test\n    public void test02() {\n        \n        TeamExample example = new TeamExample();\n        //查总数\n        long l = teamMapper.countByExample(example);\n        System.out.println("l : " + l);\n    \n    }\n    \n    //添加\n    @Test\n    public void test03() {\n    \n        Team team = new Team();\n        team.setTeamName("bozhu-test");\n        int insert = teamMapper.insert(team);\n        MybatisUtil.getSqlSession().commit();\n        System.out.println("insert : " + insert);\n    }\n    \n    //动态添加\n    @Test\n    public void test04() {\n        Team team = new Team();\n        team.setTeamName("bozhu-test2");\n        int insert = teamMapper.insertSelective(team);\n        MybatisUtil.getSqlSession().commit();\n        System.out.println("insert : " + insert);\n    }\n    \n    //修改 指定key\n    @Test\n    public void test05() {\n        Team team = teamMapper.selectByPrimaryKey(1026);\n        team.setTeamName("老哥");\n        team.setLocation("bj");\n        team.setCreateTime(new Date());\n        int i = teamMapper.updateByPrimaryKey(team);\n        MybatisUtil.getSqlSession().commit();\n        System.out.println("i : " + i);\n    }\n    \n    //Example约束 应用\n    \n    /**\n     * Example 约束服务\n     *      criteria1容器 约束方法名\n     *          add+约束列+约束方式\n     *          ····\n     *      OR：criteria2容器 约束方法名\n     *          add+约束列+约束方式\n     *          ····\n     */\n    @Test\n    public void test06() {\n        //设置多条件 服务\n        TeamExample example = new TeamExample();\n        // criteria 多条件 容器\n        TeamExample.Criteria criteria = example.createCriteria();\n        // or 添加’或‘运算符 约束\n        TeamExample.Criteria criteria2 = example.or();\n        //为容器添加条件\n        criteria.andTeamIdBetween(1001,1100);\n        criteria2.andTeamIdBetween(1,3);\n        List<Team> teamList = teamMapper.selectByExample(example);\n        teamList.forEach(team -> System.out.println(team));\n    }\n}\n\n\n\n# 分页插件\n\nMybatis分页查询，可直接 通过插件进行 快速实现分页功能！\n\n在配置中添加插件一定一定要遵循标签的顺序 查看顺序\n\n依赖包：\n\n * jsqlparser-0.9.5.jar\n * pagehelper-4.2.1.jar\n\nMybatis全局配置插件\n\n<configuration>\n\t...\n    <plugins>\n        \x3c!-- com.github.pagehelper为PageHelper类所在包名 --\x3e\n        <plugin interceptor="com.github.pagehelper.PageHelper">\n            <property name="dialect" value="mysql" />\n            \x3c!-- 3.3.0版本可用 - 分页参数合理化，默认false禁用 --\x3e\n            \x3c!-- 启用合理化时，如果pageNum<1会查询第一页，如果pageNum>pages会查询最后一页 --\x3e\n            \x3c!-- 禁用合理化时，如果pageNum<1或pageNum>pages会返回空数据 --\x3e\n            <property name="reasonable" value="true" />\n        </plugin>\n    </plugins>\n    ...\n</configuration>\n\n\n测试\n\n@Test\npublic void test() {\n    EmpMapper mapper = MyBatisUtil.getSession().getMapper(EmpMapper.class);\n    \n    int pageNum = 2;\n    int pageSize = 5;\n    \n    // 以下分页代码必须定义在 sql查询前的语句，否则分页查询会失效\n    PageHelper.startPage(pageNum , pageSize);\n    List<Emp> emps = mapper.selectByExample(null);\n    \n    emps.forEach(System.out::println);\n    \n    PageInfo<Emp> page = new PageInfo<>(emps);\n    System.out.println("总记录数：" + page.getTotal());\n    System.out.println("总页数：" + page.getPages());\n    System.out.println("上页：" + page.getPrePage());\n    System.out.println("下页：" + page.getNextPage());\n}\n\n\n\n# MyBatis问题\n\n\n# 线程优化\n\nThreadLocal\n\nThreadLocal是一个线程内部的存储类，可以在指定线程内存储数据，数据存储以后，只有指定线程可以得到存储数据\n\nSqlSession线程是不安全的线程，利用ThreadLocal实现多线程也能独立完成业务，防止SqlSession同时访问并发问题\n\nThreadLocal可看作集合容器 ，里面存放的都是唯一且都是相同的副本，里面存储的对象都是独立的\n\nThreadLocal不是一个线程的本地实现版本，也不是一个Thread。ThreadLocal是为每一个使用该变量的线程都提供一个变量值的副本， 是Java中一种较为特殊的线程绑定机制，是每一个线程都可以独立地改变自己的副本，而不会和其它线程的副本冲突\n\n实现应用\n\n项目结构（在原有的基础上优化）\n\n  .\n  |\n  ├── src\n  |    ├── main\n  |\t   |\t├── java\n  |\t   |\t|\t  └── com\n  |\t   |    |   \t   ├── dao\n  |    |    |          |\t├── TeamDao\n  |    |    |          |    └── TeamDaoImpl\n  |\t   |\t|\t  \t   ├── pojo\n  |\t   |\t|\t  \t   |\t├── Team\n  |\t   |\t|\t\t   |\t└── Team.xml\n  |\t   |    | \t\t   └── utils\t\t\n  |\t   |    |    \t   \t\t└── MybatisUtil\n  |\t   |\t└──\tresources\n  |\t   |\t\t    ├── log4j.properties\n  |\t   |\t\t\t└── mybatis.xml\n  |\t  test\n  |    └── ...\n  └── pom.xml\n\n\n添加映射SQL ==Team.xml==\n\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE mapper\n        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n\x3c!--namespace="名称必须与映射的类的名字一致，是完全限定名"--\x3e\n<mapper namespace="com.pojo.Team">\n\n    \x3c!--\n    id="自定义名称，id不能重复；相当于dao中的方法名称"\n    resultType="使用的要求：实体类中的属性名与表中的列名一致"\n    --\x3e\n\x3c!--    查询所有--\x3e\n    <select id="findAll" resultType="com.pojo.Team">\n        select * from team;\n    </select>\n\n\x3c!--    查询指定--\x3e\n    <select id="findId" resultType="com.pojo.Team">\n        select * from team where teamId=#{teamId}\n    </select>\n    <select id="findName" resultType="com.pojo.Team">\n        select * from team where teamName=#{teamName}\n    </select>\n\n    \x3c!--\n    parameterType="指定对象作为参数"\n    #{对象属性名}\n    --\x3e\n\x3c!--    添加数据--\x3e\n    <insert id="add" parameterType="com.pojo.Team">\n        INSERT INTO `mybatis`.`team`(`teamName`, `location`, `createTime`) VALUES (#{teamName}, #{location}, #{createTime})\n    </insert>\n\n\x3c!--    修改数据--\x3e\n    <update id="updateById"  parameterType="com.pojo.Team">\n        UPDATE `team` SET teamName=#{teamName},location=#{location} WHERE teamId=#{teamId}\n    </update>\n\n\x3c!--    删除数据--\x3e\n    <delete id="deleteById" parameterType="com.pojo.Team">\n        DELETE FROM `mybatis`.`team` WHERE `teamId` = #{id}\n    </delete>\n    <delete id="deleteByName" parameterType="com.pojo.Team">\n        DELETE  FROM `mybatis`.`team` WHERE `teamName` = #{name}\n    </delete>\n\n</mapper>\n\n\n工具类实现 ==MybatisUtil== （应用主要）\n\npackage com.utils;\n\nimport org.apache.ibatis.io.Resources;\nimport org.apache.ibatis.session.SqlSession;\nimport org.apache.ibatis.session.SqlSessionFactory;\nimport org.apache.ibatis.session.SqlSessionFactoryBuilder;\n\nimport java.io.IOException;\nimport java.io.Reader;\n\npublic class MybatisUtil {\n    \n    private static SqlSessionFactory sqlSessionFactory;\n    private static ThreadLocal<SqlSession> sqlSessionThreadLocal = new ThreadLocal<>();\n    \n    static {\n        try {\n            Reader reader = Resources.getResourceAsReader("mybatis.xml");\n            sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n    \n    public static SqlSession getSqlSession(){\n        SqlSession sqlSession = sqlSessionThreadLocal.get();\n        if (sqlSession == null){\n            sqlSession = sqlSessionFactory.openSession();\n            sqlSessionThreadLocal.set(sqlSession);\n        }\n        return sqlSession;\n    }\n    \n    public static void close() {\n        SqlSession sqlSession = sqlSessionThreadLocal.get();\n        if (sqlSession != null) {\n            sqlSession.close();\n            sqlSessionThreadLocal.remove();\n        }\n    }\n    \n}\n\n\n实现dao，创建 ==TeamDaoImpl接口==\n\npackage com.dao;\nimport com.pojo.Team;\nimport java.util.List;\n\npublic interface TeamDaoImpl {\n    public List<Team> findAll();\n    public Team queryById(int id);\n    public Team queryByName(String name);\n    public int add(Team team);\n    public int updateById(int id , Team newTeam);\n    public int updateByName(String name , Team newTeam);\n    public int delById(int id);\n    public int delByName(String name);\n}\n\n\n创建 ==TeamDao实现类== （业务实现）\n\npackage com.dao;\n\nimport com.pojo.Team;\nimport com.utils.MybatisUtil;\nimport org.apache.ibatis.session.SqlSession;\n\nimport java.util.List;\n\npublic class TeamDao implements TeamDaoImpl{\n    \n    @Override\n    public List<Team> findAll() {\n        SqlSession sqlSession = MybatisUtil.getSqlSession();\n        List<Team> teams = sqlSession.selectList("com.pojo.Team.findAll");\n        sqlSession.commit();\n        return teams;\n    }\n    \n    @Override\n    public Team queryById(int id) {\n        SqlSession sqlSession = MybatisUtil.getSqlSession();\n        return sqlSession.selectOne("com.pojo.Team.queryById" , id);\n    }\n    \n    @Override\n    public Team queryByName(String name) {\n        SqlSession sqlSession = MybatisUtil.getSqlSession();\n        return sqlSession.selectOne("com.pojo.Team.queryByName" , name);\n    }\n    \n    @Override\n    public int add(Team team) {\n        SqlSession sqlSession = MybatisUtil.getSqlSession();\n        int num = sqlSession.insert("com.pojo.Team.add",team);\n        sqlSession.commit();\n        return num;\n    }\n    \n    @Override\n    public int updateById(int id ,Team newTeam) {\n        SqlSession sqlSession = MybatisUtil.getSqlSession();\n        Team team = sqlSession.selectOne("com.pojo.Team.queryById" , id);\n        team.setTeamName(newTeam.getTeamName());\n        team.setLocation(newTeam.getLocation());\n        int num = sqlSession.update("com.pojo.Team.updateById" , team);\n        sqlSession.commit();\n        return num;\n    }\n    \n    @Override\n    public int updateByName(String name , Team newTeam) {\n        SqlSession sqlSession = MybatisUtil.getSqlSession();\n        Team team = sqlSession.selectOne("com.pojo.Team.queryByName" , name);\n        team.setTeamName(newTeam.getTeamName());\n        team.setLocation(newTeam.getLocation());\n        int num = sqlSession.update("com.pojo.Team.updateById" , team);\n        sqlSession.commit();\n        return num;\n    }\n    \n    @Override\n    public int delById(int id) {\n        SqlSession sqlSession = MybatisUtil.getSqlSession();\n        int num = sqlSession.delete("com.pojo.Team.deleteById" , id);\n        sqlSession.commit();\n        return num;\n    }\n    \n    @Override\n    public int delByName(String name) {\n        SqlSession sqlSession = MybatisUtil.getSqlSession();\n        int num = sqlSession.delete("com.pojo.Team.deleteByName" , name);\n        sqlSession.commit();\n        return num;\n    }\n    \n}\n\n\n测试类 (前提数据库中要有相应数据)\n\nimport com.dao.TeamDao;\nimport com.dao.TeamDaoImpl;\nimport com.pojo.Team;\nimport org.junit.Test;\n\nimport java.util.Date;\nimport java.util.List;\n\npublic class DaoApp {\n    \n    TeamDaoImpl teamDao = new TeamDao();\n    \n    @Test\n    public void testFindAll() {\n        List<Team> all = teamDao.findAll();\n        all.forEach(team -> System.out.println(team));\n    }\n    \n    @Test\n    public void testQueryById() {\n        Team team = teamDao.queryById(1009);\n        System.out.println("team : " + team);\n    }\n    \n    @Test\n    public void testQueryByName() {\n        Team team = teamDao.queryByName("老八");\n        System.out.println("team : " + team);\n    }\n    \n    @Test\n    public void testAdd() {\n        Team team = new Team("火箭","洛杉矶",new Date());\n        int add = teamDao.add(team);\n        System.out.println("add : " + add);\n    }\n    \n    @Test\n    public void testUpdateById() {\n        Team newTeam = new Team("老鸽","上海");\n        int i = teamDao.updateById(1004 , newTeam);\n        System.out.println("i : " + i);\n    }\n    \n    @Test\n    public void testUpdateByName() {\n        Team newTeam = new Team("法外狂徒","南京");\n        int i = teamDao.updateByName("老鸽" , newTeam);\n        System.out.println("i : " + i);\n    }\n    \n    @Test\n    public void testDelById() {\n        int i = teamDao.delById(1004);\n        System.out.println("i : " + i);\n    }\n    \n    @Test\n    public void testDelByName() {\n        int num = teamDao.delByName("火箭");\n        System.out.println("num : " + num);\n    }\n}\n\n\n\n# Sql语句字段调配问题\n\n# 库添加获取id问题\n\n数据库 在添加对象 的时候 序列 都是也默认形式在 数据库 中进行自增的 ，并且自增后 后端是获取不到该对象的自增数据，因此可通过以下方式进行 自定义添加并获取\n\n> 主要涉及点：\n> \n>  * 配置映射 文件 ，insert标签 中 添加 selectKey标签 进行 对指定列 的值 自定义添加并获取\n>  * selectKey标签属性说明：\n>    * keyProperty：表示自增的id值 赋值 到哪个实体类的属性\n>    * order：AFTER(之后)、BEFORE(之前)两值，表示在sql语句执行 之前 或 之后\n>      * 一般情况 BEFORE 用于 指定id并获取；AFTER 用于 获取自增后的id值\n>    * resultType：表示返回值类型\n\n实现应用\n\n项目结构（在原有的基础上优化）\n\n  .\n  |\n  ├── src\n  |    ├── main\n  |\t   |\t├── java\n  |\t   |\t|\t  └── com\n  |\t   |    |   \t   ├── ···\n  |\t   |\t|\t  \t   ├── pojo\n  |\t   |\t|\t  \t   |\t└── GameRecord\n  |\t   |    | \t\t   └── utils\t\t\n  |\t   |    |    \t   \t\t└── MybatisUtil\n  |\t   |\t└──\tresources\n  |\t   |            ├── com\n  |\t   |            |\t └── mapper\n  |\t   |            |\t\t   ├──GameRecordMapper.xml\n  |\t   |            |\t\t   └──TeamMapper.xml\n  |\t   |\t\t    ├── log4j.properties\n  |\t   |\t\t\t└── mybatis.xml\n  |\t  test\n  |    └── ...\n  └── pom.xml\n\n\n数据库添加表（球队比赛信息）\n\nCREATE TABLE `gamerecord` (\n  `recordId` varchar(36) CHARACTER SET utf8 COLLATE utf8_general_ci NOT NULL,\n  `homeTeamId` int DEFAULT NULL COMMENT \' 主队id\',\n  `gameDate` datetime DEFAULT NULL COMMENT \'比赛时间\',\n  `score` int DEFAULT NULL COMMENT \'得分\',\n  `visitingTeamId` int DEFAULT NULL COMMENT \'客队id\',\n  PRIMARY KEY (`recordId`)\n) ENGINE=InnoDB DEFAULT CHARSET=utf8;\n\n\n实体类对象 ==GameRecord==\n\npackage com.pojo;\n\nimport java.util.Date;\n\n/**\n* ClassName: GameRecord\n* 球队记录实体类\n* @author wanglina\n* @version 1.0\n*/\npublic class GameRecord {\n    private String recordId;\n    private Integer homeTeamId;\n    private Date gameDate;\n    private Integer score;\n    private Integer visitingTeamId;\n    \n\t//省略 set 和 get 方法\n    \n    @Override\n    public String toString() {\n        return "GameRecord{" +\n                "recordId=\'" + recordId + \'\\\'\' +\n                ", homeTeamId=" + homeTeamId +\n                ", gameDate=" + gameDate +\n                ", score=" + score +\n                ", visitingTeamId=" + visitingTeamId +\n                \'}\';\n    }\n}\n\n\n创建接口 ==GameRecordMapper==\n\npackage com.mapper;\n\nimport com.pojo.GameRecord;\n\npublic interface GameRecordMapper {\n    int add(GameRecord gameRecord);\n}\n\n\n添加 ==resources/com/mapper/GameRecordMapper.xml== 配置文件 （order="BEFORE"应用）\n\n<?xml version="1.0" encoding="UTF-8" ?>\n<!DOCTYPE mapper\n        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"\n        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n\x3c!--namespace="名称必须与映射的类的名字一致，是完全限定名"--\x3e\n<mapper namespace="com.mapper.GameRecordMapper">\n\n    \x3c!--\n    新增成功后将自增的ID赋值给参数属性 的 TeamId\n    selectKey标签属性说明：\n        keyProperty：表示自增的id值 赋值 到哪个实体类的属性\n        order：AFTER(之后)、BEFORE(之前)两值，表示在sql语句执行 之前 或 之后\n\t\t\t一般情况 BEFORE 用于 指定id并获取；AFTER 用于 获取自增后的id值\n        resultType：表示返回值类型\n--\x3e\n    <insert id="add" parameterType="com.pojo.GameRecord">\n        <selectKey keyProperty="recordId" order="BEFORE" resultType="java.lang.String">\n            select uuid();\n        </selectKey>\n        INSERT INTO `mybatis`.`gamerecord`(`recordId`, `homeTeamId`, `gameDate`, `score`, `visitingTeamId`)\n            VALUES (#{recordId}, #{homeTeamId}, #{gameDate}, #{score}, #{visitingTeamId})\n    </insert>\n\n</mapper>\n\n\n修改==TeamMapper.xml==文件中的insert标签\n\n<insert id="add" parameterType="com.pojo.Team">\n    <selectKey keyProperty="teamId" order="AFTER" resultType="java.lang.Integer">\n        SELECT LAST_INSERT_ID()\n    </selectKey>\n    INSERT INTO `mybatis`.`team`(`teamName`, `location`, `createTime`) VALUES (#{teamName}, #{location}, #{createTime})\n</insert>\n\n\n在 ==mybatis.xml配置文件== 中注册映射文件\n\n\x3c!-- 注册映射文件 --\x3e\n<mappers>\n\t···\n    <mapper resource="com/mapper/TeamMapper.xml"/>\n    <mapper resource="com/mapper/GameRecordMapper.xml"/>\n</mappers>\n\n\n测试：\n\nimport com.mapper.GameRecordMapper;\nimport com.mapper.TeamMapper;\nimport com.pojo.GameRecord;\nimport com.pojo.Team;\nimport com.utils.MybatisUtil;\nimport org.junit.Test;\n\nimport java.util.Date;\n\n//id自增测试\npublic class id_incrementTest {\n    \n    private TeamMapper teamMapper = MybatisUtil.getSqlSession().getMapper(TeamMapper.class);\n    private GameRecordMapper gameRecordMapper = MybatisUtil.getSqlSession().getMapper(GameRecordMapper.class);\n    \n    @Test\n    public void teamMapper_order_AFTER() {\n        Team team = new Team("哥斯拉","东京",new Date());\n        int add = teamMapper.add(team);\n        MybatisUtil.getSqlSession().commit();\n        System.out.println("add : " + add);\n        System.out.println("team : " + team);\n    }\n    \n    @Test\n    public void gameRecordMapper_order_BEFORE() {\n        GameRecord gameRecord = new GameRecord();\n        gameRecord.setHomeTeamId(1002);\n        gameRecord.setGameDate(new Date());\n        gameRecord.setVisitingTeamId(1001);\n        gameRecord.setScore(90);\n        int add = gameRecordMapper.add(gameRecord);\n        MybatisUtil.getSqlSession().commit();\n        System.out.println("add : " + add);\n        System.out.println("gameRecord : " + gameRecord);\n    }\n    \n}\n\n\n\n# 映射问题\n\n# 数据库列名与实体类属性不匹配问题\n\n一般情况 数据库列名 和 实体类属性名 一样，在以上条件为前提下 MyBatis 会自动匹配数据映射问题\n\n> 解决方案：\n> \n>  1. sql 查询的别名 与 实体类属性名 一致\n>  2. 通过resultMap自行映射\n\n数据库 表 列名\n\n> teamId、teamName、location、createTime\n\n创建 ==Team2实体类==\n\npackage com.pojo;\n\nimport java.util.Date;\n\n/**\n * @author Sans\n */\n//用于映射测试\npublic class Team2 {\n    private Integer team_id;\n    private String team_name;\n    private String location;\n    private Date createTime;\n    \n\t//set和get 省略\n    \n    @Override\n    public String toString() {\n        return "Team2{" +\n                "team_id=" + team_id +\n                ", team_name=\'" + team_name + \'\\\'\' +\n                ", location=\'" + location + \'\\\'\' +\n                ", createTime=" + createTime +\n                \'}\';\n    }\n}\n\n\n==TeamMapper接口方法==\n\npublic interface TeamMapper {\n    List<Team2> queryAll3();\n\tList<Team2> queryAll4();\n}\n\n\n修改 ==TeamMapper.xml映射文件== 添加sql语句\n\n\x3c!--    库列名 与 类属性名 不一致问题--\x3e\n\x3c!--    解决方案1 (别名形式匹配)--\x3e\n<select id="queryAll3" resultType="com.pojo.Team2">\n    select teamId \'team_id\',teamName \'team_name\',location,createTime from team\n</select>\n\x3c!--    解决方案2（自行配置映射）--\x3e\n<select id="queryAll4" resultMap="baseMap">\n    select * from team\n</select>\n<resultMap id="baseMap" type="com.pojo.Team2">\n    <id column="teamId" property="team_id" javaType="java.lang.Integer"/>\n    <result column="teamName" property="team_name" javaType="java.lang.String"/>\n    <result column="location" property="location" javaType="java.lang.String"/>\n    <result column="createTime" property="createTime" javaType="java.util.Date"/>\n</resultMap>\n\n\n测试：\n\n//处理自定义类型数据\n@Test\npublic void queryAll3() {\n    List<Team2> teamList = teamMapper.queryAll3();\n    teamList.forEach(team -> System.out.println(team));\n}\n\n@Test\npublic void queryAll4() {\n    List<Team2> teamList = teamMapper.queryAll4();\n    teamList.forEach(team -> System.out.println(team));\n}\n\n\n\n# 分页问题\n\n查询 处理出来的大量数据需要分页功能浏览大量数据，缓解查询结果带来的压力\n\n注意：\n\n * SQL语句末尾不能添加 分号 ;\n\n应用\n\n添加依赖\n\n\x3c!--        分页应用--\x3e\n<dependency>\n    <groupId>com.github.pagehelper</groupId>\n    <artifactId>pagehelper</artifactId>\n    <version>5.2.1</version>\n</dependency>\n\n\n设置配置文件 ==mybatis.xml== （plugins标签节点 在 environments标签节点 之前）\n\n\x3c!--    配置分页插件--\x3e\n<plugins>\n    <plugin interceptor="com.github.pagehelper.PageInterceptor"/>\n</plugins>\n\n\n测试（在以往的基础上执行）\n\nprivate TeamMapper teamMapper = MybatisUtil.getSqlSession().getMapper(TeamMapper.class);\n\n\n//分页插件应用\n@Test\npublic void pageTest() {\n    PageHelper.startPage(1,3);\n    List<Team> all = teamMapper.findAll();\n    all.forEach(team -> System.out.println(team));\n    System.out.println("其他分页信息：");\n    PageInfo<Team> info = new PageInfo<>(all);\n    System.out.println("当前页："+info.getPageNum());\n    System.out.println("总页数："+info.getPages());\n    System.out.println("前一页："+info.getPrePage());\n    System.out.println("后一页："+info.getNextPage());\n    System.out.println("所有导航页号：");\n    for (int navigatepageNum : info.getNavigatepageNums()) {\n        System.out.println("\\t" + navigatepageNum);\n    }\n}\n\n/* 运行结果\n\nTeam{teamId=1, teamName=\'张三\', location=\'上海\', createTime=Thu Jul 15 00:00:00 CST 2021}\nTeam{teamId=2, teamName=\'李四\', location=\'深圳\', createTime=Wed Jun 02 00:00:00 CST 2021}\nTeam{teamId=3, teamName=\'王五\', location=\'南京\', createTime=Sun Aug 01 00:00:00 CST 2021}\n其他分页信息：\n当前页：1\n总页数：3\n前一页：0\n后一页：2\n所有导航页号：\n\t1\n\t2\n\t3\n\n*/\n',normalizedContent:'# mybatis\n\nmybatis 是一个开源、轻量级的数据持久化框架，是 jdbc 和 hibernate 的替代方案。mybatis 内部封装了 jdbc，简化了加载驱动、创建连接、创建 statement 等繁杂过程，只需关注 sql 语句即可\n\n> 数据持久化是将内存中的 数据模型 转换为 存储模型，以及将 存储模型 转换为 内存中数据模型 的统称。 例如，文件的存储、数据的读取以及对数据表的增删改查等都是数据持久化操作\n\norm 是一种数据持久化技术，它在对象模型和关系型数据库之间建立起对应关系，解决了实体类和数据库表映射的问题，并且提供了一种机制，通过 javabean 对象去操作数据库表中的数据。\n\n * object： java对象\n * relation： 关系，库中的表\n * mapping： 映射\n\n参考文档：mybatis – mybatis 3\n\nmybatis 和 hibernate区别\n\n        mybateis   hibernate\n学习门槛    低          高\n查询语言    sql        hql\norm架构   半映射        完整映射\n资源损耗    低          高\n查询自由度   高          低\n移植兼容    差          好\n\n总结\n\n * hibernate功能强大，数据库无关性好，o/r映射能力强。前提hibernate要精通，否则用起来很累\n * hibernate 学习知识点多，精通门槛高。例如 怎么设计o/r映射，在性能和对象模型之间如何权衡取得平衡，以及怎样用好hibernate方面需要经验和能力都很强才行\n\n\n# 首次应用\n\n> 前提：\n> \n>  * 引入 mybatis架构依赖 mysql-connector-java底层连接依赖 junit代码测试\n>  * 数据库表中的列名称 与 实体类属性的名称 相同\n\n项目结构\n\n  .\n  |\n  ├── src\n  |    ├── main\n  |\t   |\t├── java\n  |\t   |\t|\t  └── com\n  |\t   |    |   \t   ├── dao\n  |    |    |          |\t├── teamdao\n  |    |    |          |    └── teamdaoimpl\n  |\t   |\t|\t  \t   ├── pojo\n  |\t   |\t|\t  \t   |\t├── team\n  |\t   |\t|\t\t   |\t└── team.xml\n  |\t   |    | \t\t   └── utils\t\t\n  |\t   |    |    \t   \t\t└── mybatisutil\n  |\t   |\t└──\tresources\n  |\t   |\t\t    ├── log4j.properties\n  |\t   |\t\t\t└── mybatis.xml\n  |\t  test\n  |    └── ...\n  └── pom.xml\n\n\n 1. 引入依赖 ==pom.xml==\n    \n    <dependency>\n        <groupid>org.mybatis</groupid>\n        <artifactid>mybatis</artifactid>\n        <version>3.5.6</version>\n    </dependency>\n    <dependency>\n        <groupid>mysql</groupid>\n        <artifactid>mysql-connector-java</artifactid>\n        <version>8.0.23</version>\n    </dependency>\n    <dependency>\n        <groupid>junit</groupid>\n        <artifactid>junit</artifactid>\n        <version>4.12</version>\n        <scope>test</scope>\n    </dependency>\n    \n    \n    > jar包说明：\n    > \n    >  * mybatis\n    >  * jdbc\n    >  * 测试环境\n\n 2. 创建 ==team实体类== 与 ==mybatis库team表数据==\n    \n    create table `team` (\n    \t`teamid` int not null auto_increment comment \'球队id\',\n    \t`teamname` varchar(50) default null comment \'球队名称\',\n    \t`location` varchar(50) default null comment \'球队位置\',\n    \t`createtime` date default null comment \'球队建立时间\',\n    \tprimary key (`teamid`)\n    ) engine=innodb auto_increment=1003 default charset=utf8mb4 collate=utf8mb4_0900_ai_ci;\n    \n    \n    package com.pojo;\n    \n    import java.util.date;\n    \n    public class team {\n        private integer teamid;\n        private string teamname;\n        private string location;\n        private date createtme;\n        \n        /*省略setter和getter方法*/\n        \n        @override\n        public string tostring() {\n            return "team{" +\n                    "teamid=" + teamid +\n                    ", teamname=\'" + teamname + \'\\\'\' +\n                    ", location=\'" + location + \'\\\'\' +\n                    ", createtme=" + createtme +\n                    \'}\';\n        }\n    }\n    \n    \n\n 3. 配置 连接文件 ==mybatis.xml==（用于连接数据库）\n    \n    <?xml version="1.0" encoding="utf-8" ?>\n    <!doctype configuration\n            public "-//mybatis.org//dtd config 3.0//en"\n            "http://mybatis.org/dtd/mybatis-3-config.dtd">\n    <configuration>\n        \x3c!--配置 mybatis 环境--\x3e\n        <environments default="development">\n            \x3c!--id:数据源的名称--\x3e\n            <environment id="development">\n                \x3c!--事务类型：使用 jdbc 事务,使用 connection 的提交和回滚--\x3e\n                <transactionmanager type="jdbc"/>\n                \x3c!--数据源 datasource：创建数据库 connection 对象\n                type: pooled 使用数据库的连接池\n                --\x3e\n                <datasource type="pooled">\n                    \x3c!--连接数据库的四大参数\n                    注意 加载驱动是 mysql8以上，否则 driver和url 都不一样，可参考学过的jdbc--\x3e\n                    <property name="driver" value="com.mysql.cj.jdbc.driver"/>\n                    <property name="url" value="jdbc:mysql://127.0.0.1:3306/mybatis?\n    useunicode=true&amp;characterencoding=utf-8&amp;usessl=false&amp;servertimezone=gmt"/>\n                    <property name="username" value="root"/>\n                    <property name="password" value="root"/>\n                </datasource>\n            </environment>\n        </environments>\n    \n        \x3c!-- 注册映射文件 --\x3e\n        <mappers>\n            <mapper resource="com/pojo/team.xml"/>\n        </mappers>\n    </configuration>\n    \n    \n    > 注意：\n    > \n    >  * <datasource>标签 中主要配置数据库通信，必要的有 加载驱动/连接url/账号/密码\n    >  * <mappers>.<mapper>.resource属性 必须指定正确的映射文件（否则注册不了\n\n 4. 配置 映射文件 ==team.xml==（映射实体类与库中列的数据）\n    \n    <?xml version="1.0" encoding="utf-8" ?>\n    <!doctype mapper\n            public "-//mybatis.org//dtd mapper 3.0//en"\n            "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n    \x3c!-- namespace= "名称必须与映射的类的名字一致，是完全限定名" --\x3e\n    <mapper namespace="com.pojo.team">\n        \x3c!-- id="自定义名称，id不能重复；相当于dao中的方法名称"\n        resulttype="使用的要求：实体类中的属性名与表中的列名一致"\n        --\x3e\n        <select id="findall" resulttype="com.pojo.team">\n            select * from team\n        </select>\n    </mapper>\n    \n    \n    > 注意：\n    > \n    >  * <mapper>.namespace属性 必须映射正确的实体类（完全限定名\n    >  * <select>.resulttype属性 返回集中 一列记录实例的 对象/数据类型\n    >  * <select>.id属性 用于session指定指定sql的操作（该属性不能存在重复值\n\n 5. 配置 映射文件的扫描 ==pom.xml==\n    \n    <build>\n        <resources>\n            <resource>\n                \x3c!--所有目录--\x3e\n                <directory>src/main/java</directory>\n                <includes>\n                    \x3c!--包括目录 .properties, .xml 文件都会扫描到！！--\x3e\n                    <include>**/*.properties</include>\n                    <include>**/*.xml</include>\n                </includes>\n                <filtering>false</filtering>\n            </resource>\n        </resources>\n        <plugins>\n            ···\n        </plugins>\n    </build>\n    \n\n 6. 测试查询\n    \n    @test\n    public void test() throws ioexception {\n        // 1. 读取 mybatis配置文件\n        reader reader = resources.getresourceasreader("mybatis.xml");\n        // 2. 创建 sqlsessionfactoryd对象 ， 目的 获取 sqlsession\n        sqlsessionfactory sqlsessionfactory = new sqlsessionfactorybuilder().build(reader);\n        // 3. 创建可执行sql语句的 sqlsession\n        sqlsession sqlsession = sqlsessionfactory.opensession();\n        // 4. 执行 sql语句\n        list<team> teamlist = sqlsession.selectlist("com.pojo.team.findall");\n        // 5. 遍历结果\n        system.out.println("遍历结果：");\n        teamlist.foreach(system.out::println);\n        // 6. 释放资源\n        sqlsession.close();\n    }\n    \n    /* 执行结果\n    \n    遍历结果：\n    team{teamid=1, teamname=\'张三\', location=\'上海\', createtme=null}\n    team{teamid=2, teamname=\'李四\', location=\'深圳\', createtme=null}\n    team{teamid=3, teamname=\'王五\', location=\'南京\', createtme=null} \n    team{teamid=4, teamname=\'赵六\', location=\'广州\', createtme=null}\n    team{teamid=5, teamname=\'小七\', location=\'南宁\', createtme=null}\n    \n    */\n    \n\n\n# mybatis对象\n\n\n# resources\n\n==org.apache.ibatis.io.resources类==\n\n用于读取资源文件。有很多方法通过加载并解析资源文件，返回不同类型的 io 流对象\n\n\n# sqlsessionfactorybuilder\n\n==org.apache.ibatis.session.sqlsessionfactorybuilder类==\n\nsqlsessionfactory 的创建，需要使用 sqlsessionfactorybuilder对象的build()方法 。事实上使用sqlsessionfactorybuilder的原因是将sqlsessionfactory这个复杂对象的创建交由builder来执行，也就是使用了建造者设计模式\n\n> 建造者模式（又称生成器模式）：是一种对象的创建模式。可以将一个产品的 内部表象 与 产品的生成过程 分割开来，从而可以使一个建造过程生成具有 不同的内部表象的产品(将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示)，这样用户只需指定需要建造的类型就可以得到具体产品，而不需要了解具体的建造过程和细节。\n> \n> 在建造者模式中，角色分指导者(director)与建造者(builder)： 用户联系指导者，指导者指挥建造者，最后得到产品，建造者模式可以强制实行 一种分步骤进行的建造过程\n\n\n# sqlsessionfactory\n\n==org.apache.ibatis.session.sqlsessionfactory接口==\n\n创建 sqlsession 需要使用 sqlsessionfactory接口的 opensession()方法，该方法重载的数量较多，因此只需关注主要应用的以下三个传参数据即可：\n\n * 事务处理： 在session作用域中 ，是否使用自动提交？（autocommit）\n * 数据库连接： 在 mybatis中，是否使用自己提供的连接？（connection）\n * 语句执行： 在 mybatis中，是否复用 preparedstatement 通道进行 批处理？\n\n参数名          类型             说明\nautocommit   boolean        true事务自动提交，否则关闭\nconnection   connection     应用自己提供的连接\nexectype     executortype   executortype枚举定义定义了三个值\n                            simple：为每个语句的执行创建一个新的预处理语句\n                            reuse：执行器会复用预处理语句\n                            batch：执行器会批量执行所有更新语句\n\n> **注意：**如果调用了无参的 opensession()方法，则该session会默认具备以下特性：\n> \n>  * 事务作用域将会开启（不自动提交）\n>  * 将由当前环境配置的 datasource 实例中获取 connection 对象 （datasource指定的是 数据库的配置数据及创建数据库获取的连接）\n>  * 事务隔离级别将会使用 驱动/数据源 的默认设置\n>  * 预处理语句不会被复用，也不会批量处理更新\n\n\n# sqlsessio\n\n==org.apache.ibatis.session.sqlsession接口==\n\nsqlsession接口对象 用于执行持久化操作。一个 sqlsession 对应着一次数据库会话\n\nsqlsessio为 线程不安全的，所以每次数据库会话结束前，立马调用 close()方法 将其关闭。再次需要会话，再次创建\n\nsql语句写法以及形式有多种，而sqlsessio对象将它们归类封装成了方法 curd(增删改查) 4中类型（支持自动装箱或包装类）、javabean、pojo 或 map\n\n<t> t selectone(string statement, object parameter)\n<e> list<e> selectlist(string statement, object parameter)\n<t> cursor<t> selectcursor(string statement, object parameter)\n<k,v> map<k,v> selectmap(string statement, object parameter, string mapkey)\nint insert(string statement, object parameter)\nint update(string statement, object parameter)\nint delete(string statement, object parameter)\n\n\n> 说明：\n> \n>  * insert、update、delete 方法返回值为影响的行数\n>  * selectone：返回一个 对象/null ；selectlist：返回多个 对象/null\n>  * 游标（cursor）与列表（list）返回的结果相同，不同的是，游标借助迭代器实现了数据的惰性加载\n>  * selectmap()方法 ，它会将返回的对象的其中一个属性作为 key值，将对象作为 value值\n\n\n# mybatis构架\n\n\n\n 1. mybatis.xml文件是mybatis框架的全局配置文件，配置了mybatis框架运行的环境等信息\n 2. mapperxx.xml是sql的映射文件，文件中配置了所有的操作数据库的sql语句，这些文件需要在全局配置文件中加载\n 3. 通过mybatis环境等配置信息构建sqlsessionfactroy ，相当于是产生连接池\n 4. 由会话工厂创建sqlsession即会 （连接），操作数据库需要通过sqlsession进行的\n 5. mybatis底层自定义了executor执行器的接口操作数据库，executor接口有两个实现，一个基本的执行器，一个是缓存的执行器\n 6. mapped statement 也是mybatis框架一个底层的封装对象，包装了mybatis配置信息以及sql映射信息。mapperxx.xml文件中的一个sql语句对应一个mapped statement对象，sql的id就是mapped statement的id\n 7. mapped statement对sql执行输入参数的定义，输入参数包括hashmap、基本类型、pojo,executor通过mapped statemen在执行sql语句 前将输入java对象映射到sql语句中，执行完毕sql之后，输出映射就是jdbc编码中的对preparedstatement 执行结果的定义\n\n\n# mybatis日志\n\n日志能够更准确了解运行时的详细信息\n\n> 实现步骤：\n> \n>  1. 添加依赖 log4j\n>  2. 创建日志配置文件 log4j.properties\n>  3. 在mybatis.xml 配置文件添加日志配置\n\n依赖添加 (jar)\n\n<dependency>\n\t<groupid>log4j</groupid>\n\t<artifactid>log4j</artifactid>\n\t<version>1.2.17</version>\n</dependency>\n\n\n创建日志配置文件 log4j.properties\n\n## global logging configuration info warning error  选择日志呈现种类\nlog4j.rootlogger=debug,stdout\n## console output...\nlog4j.appender.stdout=org.apache.log4j.consoleappender\nlog4j.appender.stdout.layout=org.apache.log4j.patternlayout\nlog4j.appender.stdout.layout.conversionpattern=%5p [%t] - %m%n\n\n\n在mybatis.xml 配置文件添加日志配置\n\n<configuration>\n\x3c!--    日志配置--\x3e\n    <settings>\n        <setting name="logimpl" value="log4j"/>\n    </settings>\n    ·····\n</configuration>\n\n\n> 注意：settings标签 添加在该配置子标签中的第一个！\n\n\n# mybatis全局配置\n\n之前应用的 全局配置文件 mybatis.xml ，头文件作为使用约束的前提\n\n<?xml version="1.0" encoding="utf-8" ?>\n<!doctype configuration\n        public "-//mybatis.org//dtd config 3.0//en"\n        "http://mybatis.org/dtd/mybatis-3-config.dtd">\n\n\n\n# 配置内容\n\nmybatis 行为设置和属性信息，全局配置文件的结构如下：\n\nconfiguration（配置）\n\n * properties（属性）\n * settings（设置）\n * typealiases（类型别名）\n * typehandlers（类型处理器）\n * objectfactory（对象工厂）\n * plugins（插件）\n * environments（环境配置）\n   * environment（环境变量）\n     * transactionmanager（事务管理器）\n     * datasource（数据源）\n * databaseidprovider（数据库厂商标识）\n * mappers（映射器）\n\n> 以上的配置顺序一定一定要遵循顺序进行配置，否则会失效\n\n\n# properties\n\nproperties标签 可在外部进行配置，并可以进行动态替换。properties标签 在 configuration标签里的 下一节点\n\n * properties子元素配置\n * 外部属性文件配置\n\n以连接 数据库 的四个参数数据为例子\n\nproperties子元素配置\n\n<?xml version="1.0" encoding="utf-8" ?>\n<!doctype configuration\n        public "-//mybatis.org//dtd config 3.0//en"\n        "http://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n\x3c!--    引入配置文件--\x3e\n    <properties>\n        <property name="driver" value="com.mysql.cj.jdbc.driver"/>\n        <property name="url" value="jdbc:mysql://127.0.0.1:3306/mybatis?useunicode=true&amp;characterencoding=utf-8&amp;usessl=false&amp;servertimezone=gmt"/>\n        <property name="username" value="root"/>\n        <property name="password" value="root"/>\n    </properties>\n\t····\n            <datasource type="pooled">\n                \x3c!--连接数据库的四大参数\n                注意数据库版本使用的是 mysql8以上，如果是mysql5的话，driver和url都不一样，参考学过的jdbc--\x3e\n                <property name="driver" value="${driver}"/>\n                <property name="url" value="${url}"/>\n                <property name="username" value="${username}"/>\n                <property name="password" value="${password}"/>\n            </datasource>\n\t····\n</configuration>\n\n\n外部属性文件配置 jdbc.properties\n\njdbc.driver=com.mysql.cj.jdbc.driver\njdbc.url=jdbc:mysql://127.0.0.1:3306/mybatis?useunicode=true&characterencoding=utf-8&usessl=false&servertimezone=gmt\njdbc.username=root\njdbc.password=root\n\n\n<?xml version="1.0" encoding="utf-8" ?>\n<!doctype configuration\n        public "-//mybatis.org//dtd config 3.0//en"\n        "http://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n\x3c!--    引入配置文件--\x3e\n    <properties resource="jdbc.properties"/>\n\t····\n            <datasource type="pooled">\n                \x3c!--连接数据库的四大参数\n                注意数据库版本使用的是 mysql8以上，如果是mysql5的话，driver和url都不一样，参考学过的jdbc--\x3e\n                <property name="driver" value="${jdbc.driver}"/>\n                <property name="url" value="${jdbc.url}"/>\n                <property name="username" value="${jdbc.username}"/>\n                <property name="password" value="${jdbc.password}"/>\n            </datasource>\n\t····\n</configuration>\n\n\n\n# settings\n\nmybatis 中极为重要的调整设置，它们会改变 mybatis 的运行时行为。例如：日志、等...（以上实例有应用就不赘述了）\n\n\x3c!--配置日志--\x3e\n<settings>\n\t<setting name="logimpl" value="log4j"/>\n</settings\n\n\n\n# typealiases\n\n类型别名可为 java 类型设置一个缩写名字。 它仅用于 xml 配置，意在降低冗余的全限定类名书写。typealiases标签 在 settings标签 的下一节点\n\n<?xml version="1.0" encoding="utf-8" ?>\n<!doctype configuration\n        public "-//mybatis.org//dtd config 3.0//en"\n        "http://mybatis.org/dtd/mybatis-3-config.dtd">\n<configuration>\n\t···\n\x3c!--    日志配置--\x3e\n    <settings>\n        <setting name="logimpl" value="log4j"/>\n    </settings>\n\x3c!--    自定义别名--\x3e\n    <typealiases>\n        \x3c!--对单个实体类--\x3e\n        <typealias type="com.pojo.team" alias="team"/>\n        \x3c!--批量定义别名：类似于扫描（首字母支持大小写）--\x3e\n        <package name="com.pojo"/>\n    </typealiases>\n    ···\n</configuration>\n\n\n在应用于 映射文件 里 的 parametertype、resulttype 、...等属性\n\n\x3c!--查询所有--\x3e\n<select id="findall" resulttype="team">\n    select * from team;\n</select>\n\x3c!--添加--\x3e\n<insert id="add" parametertype="team">\n    insert into `mybatis`.`team`(`teamname`, `location`, `createtime`) values (#{teamname}, #{location}, #{createtime})\n</insert>\n\x3c!--查询所有2--\x3e\n<select id="queryall3" resulttype="team2">\n    select teamid \'team_id\',teamname \'team_name\',location,createtime from team\n</select>\n\x3c!--查单列单条数据--\x3e\n<select id="querytotal" resulttype="int">\n    select count(teamid) from team\n</select>\n\x3c!--查多列单条数据--\x3e\n<select id="querymap" resulttype="map">\n    select min(teamid) \'min\',max(teamid) \'max\' from team\n</select>\n\n\n其他别名\n\n别名           映射的类型\n_byte        byte\n_long        long\n_short       short\n_int         int\n_integer     int\n_double      double\n_float       float\n_boolean     boolean\nstring       string\nbyte         byte\nlong         long\nshort        short\nint          integer\ninteger      integer\ndouble       double\nfloat        float\nboolean      boolean\ndate         date\ndecimal      bigdecimal\nbigdecimal   bigdecimal\nobject       object\nmap          map\nhashmap      hashmap\nlist         list\narraylist    arraylist\ncollection   collection\niterator     iterator\n\n\n# mappers\n\nmybatis 执行 sql映射语句 前提需要告诉 mybatis 映射文件路径在哪里，从而实现执行sql语句\n\n配置形式：\n\n * 使用 相对于类路径的资源 引用\n * 使用 映射器接口实现类 的完全限定类名\n * 使用 包类的映射器接口实现全部注册为映射器（推荐）\n\n\x3c!-- 注册映射文件 --\x3e\n<mappers>\n    \x3c!-- \n\t\t相对于类路径的资源 引用 \n\t\t使用相对于类路径的资源,从 classpath 路径查找文件\n\t--\x3e\n    <mapper resource="com/mapper/teammapper.xml"/>\n    \x3c!-- \n\t\t使用的mapper接口的完全限定名 \n\t\t要求：接口和映射文件同包同名\n\t--\x3e\n    <mapper class="com.mapper.gamerecordmapper"/>\n    \x3c!-- \n\t\t指定包下的 所有mapper接口 \n\t\t注意：此种方法要求 mapper接口名称和 mapper 映射文件名称相同，且在同一个目录中。\n\t--\x3e\n    <package name="com.mapper"/>\n</mappers>\n\n\n\n# mapper动态代理\n\n前面定义的 dao接口和dao实现类 没有实质性的工作意义，因此我们弃用dao，可通过 sqlsession 的相关 api 定位到映射文件 mapper 中相应 id 的 sql 语句，真正对 db 进行操作的工作其实是由框架通过 mapper 中的 sql 完成的，该形式被称为 ==mapper接口 的动态代理方式==\n\n> 要点说明：\n> \n>  * mapper 动态代理方式无需实现 dao 接口。接口是由 mybatis 结合映射文件自动生成的动态代理实现的\n>  * mapper(映射) 文件里 sql语句中的标签id值 必须对应 接口中的方法名 一致\n>  * resources配置文件夹，在idea开发工具不能跨级进行创建，必须手动逐级创建路径\n>  * mapper(映射) 在resources配置 文件夹中的路径必须 与 接口中的完全限定名 一致\n>  * sqlsession对象 需要通过 getmapper(class<t> type)方法 获取代理对象，可获取指定接口的实现类对象\n>  * mapper(映射) 文件里 mapper标签的namespace属性值 需要指定 接口的完全限定名\n>  * 每次添加映射 都需要去 mybatis.xml 的 mappers标签 进行添加注册映射文件\n>  * 进行 增删改 时需要 mybatisutil工具类 获取sqlsession对象 进行提交\n\n实例应用\n\n项目结构\n\n  .\n  |\n  ├── src\n  |    ├── main\n  |\t   |\t├── java\n  |\t   |\t|\t  └── com\n  |\t   |    |   \t   ├── mapper\n  |    |    |          |    └── teammapper\n  |\t   |\t|\t  \t   ├── pojo\n  |\t   |\t|\t\t   |\t└── team\n  |\t   |    | \t\t   └── utils\t\t\n  |\t   |    |    \t   \t\t└── mybatisutil\n  |\t   |\t└──\tresources\n  |\t   |\t\t    ├── log4j.properties\n  |\t   |\t\t\t├── mybatis.xml\n  |    |\t\t\t└── com\n  |    |\t\t\t\t └── mapper\n  |    |\t\t\t\t  \t   └── teammapper.xml\n  |\t  test\t\n  |    └── ...\n  └── pom.xml\n\n\n创建 ==teammapper接口==\n\npackage com.mapper;\n\nimport com.pojo.team;\n\nimport java.util.list;\n\npublic interface teammapper {\n    list<team> findall();\n    team querybyid(int id);\n    team querybyname(string name);\n    int add(team team);\n    int update(team newteam);\n    int delbyid(int id);\n    int delbyname(string name);\n}\n\n\n创建 ==teammapper.xml映射配置文件==\n\n<?xml version="1.0" encoding="utf-8" ?>\n<!doctype mapper\n        public "-//mybatis.org//dtd mapper 3.0//en"\n        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n\x3c!--namespace="名称必须与映射的类的名字一致，是完全限定名"--\x3e\n<mapper namespace="com.mapper.teammapper">\n\n    \x3c!--\n    id="自定义名称，id不能重复；相当于dao中的方法名称"\n    resulttype="使用的要求：实体类中的属性名与表中的列名一致"\n    --\x3e\n\x3c!--    查询所有--\x3e\n    <select id="findall" resulttype="com.pojo.team">\n        select * from team;\n    </select>\n\n\x3c!--    查询指定--\x3e\n    <select id="querybyid" resulttype="com.pojo.team">\n        select * from team where teamid=#{teamid}\n    </select>\n    <select id="querybyname" resulttype="com.pojo.team">\n        select * from team where teamname=#{teamname}\n    </select>\n\n    \x3c!--\n    parametertype="指定对象作为参数"\n    #{对象属性名}\n    --\x3e\n\x3c!--    添加数据--\x3e\n    <insert id="add" parametertype="com.pojo.team">\n        insert into `mybatis`.`team`(`teamname`, `location`, `createtime`) values (#{teamname}, #{location}, #{createtime})\n    </insert>\n\n\x3c!--    修改数据--\x3e\n    <update id="update"  parametertype="com.pojo.team">\n        update `team` set teamname=#{teamname},location=#{location} where teamid=#{teamid}\n    </update>\n\n\x3c!--    删除数据--\x3e\n    <delete id="delbyid" parametertype="com.pojo.team">\n        delete from `mybatis`.`team` where `teamid` = #{id}\n    </delete>\n    <delete id="delbyname" parametertype="com.pojo.team">\n        delete  from `mybatis`.`team` where `teamname` = #{name}\n    </delete>\n\n</mapper>\n\n\n在 ==mybatis.xml配置文件== 中注册映射文件\n\n<configuration> \n    ·····\n\t\x3c!-- 注册映射文件 --\x3e\n    <mappers>\n\t\t·····\n        <mapper resource="com/mapper/teammapper.xml"/>\n    </mappers>\n</configuration>\n\n\n测试：\n\nimport com.mapper.teammapper;\nimport com.pojo.team;\nimport com.utils.mybatisutil;\nimport org.junit.test;\n\nimport java.util.date;\nimport java.util.list;\n\npublic class teammappertest {\n    \n    //前提 接口的方法名 与 映射sql 标签的id值 相同！！！\n    private teammapper teammapper = mybatisutil.getsqlsession().getmapper(teammapper.class);\n    \n    @test\n    public void findall(){\n        list<team> all = teammapper.findall();\n        all.foreach(system.out::println);\n    }\n    \n    @test\n    public void querybyid(){\n        team team = teammapper.querybyid(2);\n        system.out.println("team : " + team);\n    }\n    \n    @test\n    public void querybyname(){\n        team team = teammapper.querybyname("火箭");\n        system.out.println("team : " + team);\n    }\n    \n    @test\n    public void add(){\n        team team = new team("公牛","洛杉矶",new date());\n        int add = teammapper.add(team);\n        mybatisutil.getsqlsession().commit();\n        system.out.println("add : " + add);\n    }\n    \n    @test\n    public void update() {\n        team team = teammapper.querybyid(1009);\n        team.setteamname("老鸽");\n        team.setlocation("南京");\n        int update = teammapper.update(team);\n        mybatisutil.getsqlsession().commit();\n        system.out.println("update : " + update);\n    }\n    \n    @test\n    public void delbyid() {\n        int i = teammapper.delbyid(1009);\n        mybatisutil.getsqlsession().commit();\n        system.out.println("i : " + i);\n    }\n    \n    @test\n    public void delbyname() {\n        int i = teammapper.delbyname("公牛");\n        mybatisutil.getsqlsession().comit();\n        system.out.println("i : " + i);\n    }\n    \n}\n\n\n\n# parametertype输入\n\n\n# 传递多个参数\n\nparametertype 指定值是接口中方法参数的类型，类型必须是完全限定名 或 别名。该属性非必须，因为mybatis框架能自行判断具 体传入语句的参数\n\nmybatis 提供以下 3 种方式，实现给映射器传递多个参数：\n\n * 方法直接传递参数\n * 使用注解传递参数\n * 使用 map传递参数\n\n> 应用说明：\n> \n>  * 方法直接传递参数 进行传递 不同mybatis版本传递参数 在sql应用不一样\n>    \n>    * mybatis3.3之前：使用 #{0}、#{1}、...\n>    * mybatis3.3之后：使用 #{arg0},#{arg1}、... 或者 #{param1}、#{param2}、...\n> \n>  * sql语句中 的 大小于号 不能使用 ，需要 转义符 < : &lt;\n>    \n>    > ：&gt;\n> \n>  * 使用@param注解后，只能应用 自定的注解名称\n\n多参数应用\n\n修改 ==teammapper接口== 添加sql执行的方法\n\npackage com.mapper;\n\nimport com.pojo.team;\nimport org.apache.ibatis.annotations.param;\n\nimport java.util.list;\nimport java.util.map;\n\npublic interface teammapper {\n    ····\n    \n    list<team> querybyrange1(int min , int max);\n    list<team> querybyrange2(int min , int max);\n    list<team> querybyrange3(@param("min") int min ,@param("max") int max);\n    list<team> querybyrange4(map<string,object> map);\n}\n\n\n修改 ==teammapper.xml映射文件== 添加sql语句\n\n\x3c!--arg 应用--\x3e\n<select id="querybyrange1" resulttype="com.pojo.team">\n    select * from team where teamid>=#{arg0} and teamid &lt;= ${arg1}\n</select>\n\x3c!--param 应用--\x3e\n<select id="querybyrange2" resulttype="com.pojo.team">\n    select * from team where teamid>=#{param1} and teamid &lt;= ${param2}\n</select>\n\x3c!--注解别名 应用--\x3e\n<select id="querybyrange3" resulttype="com.pojo.team">\n    select * from team where teamid>=#{min} and teamid &lt;= ${max}\n</select>\n\x3c!--map 应用--\x3e\n\x3c!--    传参 #{} map集合中的 key保持一致--\x3e\n<select id="querybyrange4" resulttype="com.pojo.team">\n    select * from team where teamid>=#{min} and teamid &lt;= ${max}\n</select>\n\n\n测试：\n\nimport com.mapper.teammapper;\nimport com.pojo.team;\nimport com.utils.mybatisutil;\nimport org.junit.test;\n\nimport java.util.hashmap;\nimport java.util.list;\nimport java.util.map;\n\n//多参数传递应用\npublic class multiparametertest {\n    \n    private teammapper teammapper = mybatisutil.getsqlsession().getmapper(teammapper.class);\n    \n    //arg 应用\n    @test\n    public void test01() {\n        list<team> teamlist = teammapper.querybyrange1(1 , 6);\n        teamlist.foreach(team -> system.out.println(team));\n    }\n    \n    //param 应用\n    @test\n    public void tset02() {\n        list<team> teamlist = teammapper.querybyrange2(1 , 6);\n        teamlist.foreach(team -> system.out.println(team));\n    }\n    \n    //接口参数名 应用 (需在接口方法中的参数定义名)\n    @test\n    public void tset03() {\n        list<team> teamlist = teammapper.querybyrange3(1 , 6);\n        teamlist.foreach(team -> system.out.println(team));\n    }\n    \n    //map传递 应用\n    @test\n    public void tset04() {\n        map<string,object> map  = new hashmap<>();\n        map.put("min",1);\n        map.put("max",6);\n        list<team> teamlist = teammapper.querybyrange4(map);\n        teamlist.foreach(team -> system.out.println(team));\n    }\n\n}\n\n\n\n# #{} 和 ${} 区别\n\n#{}：表示一个占位符，通知mybatis 使用实际的参数值代替\n\n${}：表示字符串原样替换，通知mybatis 使用 $包含的“字符串”替换所在位置\n\n示例：\n\n配置接口方法\n\npublic interface teammapper {\n \t···\n    team querybytype(\n        @param("type") \n        string type,\n        @param("data") \n        object data);\n}\n\n\n映射文件\n\n<select id="querybytype" resulttype="com.pojo.team">\n    select * from team where ${type}=#{data}\n</select>\n\n\n测试（前提库有相应信息）\n\n@test\npublic void querybytype() {\n    //teamid、teamname\n    team team1 = teammapper.querybytype("teamid",1017);\n    team team2 = teammapper.querybytype("teamname","sanscan12");\n    system.out.println("team1 : " + team1);\n    system.out.println("team2 : " + team2);\n}\n\n\n\n# resulttype输出\n\n----------------------------------------\n\nresulttype 执行 sql 得到 resultset 转换的类型，使用类型的完全限定名 或 别名。如果返回的是集合，设置的是集合元素的类型，而不是集合本身。resulttype 和 resultmap， 不能同时使用。\n\n可通过以下方式进行映射输出：\n\n * 输出java基本属性类型\n * 输出map类型\n * 输出pojo类型\n * 输出自定义resultmap类型\n\n> 应用说明：\n> \n>  * resultmap 专门用于数据库中的列和实体类不匹配的情况下使用\n>  * resultmap 是 自己编写表中的列名 与 实体类中的属性 的映射（他们不匹配的前提下需要自行匹配映射）\n\n应用\n\n修改 ==teammapper接口== 添加sql执行的方法\n\npackage com.mapper;\n\nimport com.pojo.team;\nimport org.apache.ibatis.annotations.param;\n\nimport java.util.list;\nimport java.util.map;\n\npublic interface teammapper {\n    ····\n    \n    int querytotal();\n    map<string,object> querymap();\n    list<map<string, object>> querymaplist();\n    list<team> queryall2();\n}\n\n\n修改 ==teammapper.xml映射文件== 添加sql语句\n\n\x3c!--    查单列单条数据 基本类型输出--\x3e\n    <select id="querytotal" resulttype="java.lang.integer">\n        select count(teamid) from team\n    </select>\n\x3c!--    查多列单条数据 map类型输出--\x3e\n    <select id="querymap" resulttype="java.util.hashmap">\n        select min(teamid) \'min\',max(teamid) \'max\' from team\n    </select>\n\x3c!--    查多列多条数据 list<map>类型输出--\x3e\n    <select id="querymaplist" resulttype="java.util.hashmap">\n        select teamname,location from team\n    </select>\n\x3c!--\n\tresultmap是 自己编写表中的列名 与 实体类中的属性 的映射（他们不匹配的前提下需要自行匹配映射）\n\t\tid: resultmap的名称，要求唯一\n\t\ttype: 期待要映射为java的类型\n\tid 主键列 ; result 其余列\n\t\tcolumn: 数据库中的列名，不区分大小写\n\t\tproperty: 实体类中的属性名，区分大小写\n\t\tjavatype: 实体类中对应的属性类型\n\t\tjdbctype: 数据库中column类型（一般忽略）\n--\x3e\n\x3c!--    resultmap数据类型 自定义映射输出--\x3e\n    <select id="queryall2" resultmap="baseresultmap">\n        select * from team\n    </select>\n    <resultmap id="baseresultmap" type="com.pojo.team">\n        <id column="teamid" property="teamid" javatype="java.lang.integer"/>\n        <result column="teamname" property="teamname" javatype="java.lang.string"/>\n        <result column="location" property="location" javatype="java.lang.string"/>\n\x3c!--        <result column="createtime" property="createtime" javatype="java.util.date"/>--\x3e\n    </resultmap>\n\n\n测试\n\nimport com.mapper.teammapper;\nimport com.pojo.team;\nimport com.utils.mybatisutil;\nimport org.junit.test;\n\nimport java.util.hashmap;\nimport java.util.list;\nimport java.util.map;\n\n//多参数传递应用\npublic class multiparametertest {\n    \n    private teammapper teammapper = mybatisutil.getsqlsession().getmapper(teammapper.class);\n    \n    //映射输出形式\n    \n    //查单列单条数据\n    @test\n    public void querytotal() {\n        int i = teammapper.querytotal();\n        system.out.println("i : " + i);\n    }\n    \n    //查多列单条数据\n    @test\n    public void querymap() {\n        map<string, object> stringobjectmap = teammapper.querymap();\n        system.out.println(stringobjectmap);\n    }\n    \n    //查多列多条数据\n    @test\n    public void querymaplist() {\n        list<map<string, object>> maplist = teammapper.querymaplist();\n        for (map<string, object> stringobjectmap : maplist) {\n            system.out.println(stringobjectmap);\n        }\n    }\n    \n    //处理自定义类型数据\n    @test\n    public void queryall2() {\n        list<team> teamlist = teammapper.queryall2();\n        teamlist.foreach(team -> system.out.println(team));\n    }\n    \n}\n\n\n\n# 动态sql\n\n动态 sql 是 mybatis 的强大特性之一。在 jdbc 或其它类似的框架中，需要手动拼接 sql 语句，避免了 在不同条件下拼接 sql 语句的困难\n\n动态sql应用到的元素\n\n * <choose>：多条件分支\n   \n   * <when>：判断是否满足 test (boolean)：表达式\n   * <otherwise>：都不满足条件\n\n * <foreach>：遍历语句 collection (colection)：遍历集合 item (object)：迭代对象 separator (string)：迭代分割符 open (string)：循环开头 close (string)：循环结尾\n\n * <where>：查询约束\n   \n   * <if>：是否添加语句\n     \n     test (boolean)：表达式\n\n * <set>：编辑约束\n   \n   * <if>：是否添加语句\n     \n     test (boolean)：表达式\n\n> test属性：多个表达式定义的时候 需要使用 and、or\n\n应用\n\n应用前提：\n\n * 有库信息\n * 映射文件已注册（扫描包）\n\n表结构\n\n字段名      类型\ndeptno   int\ndname    varchar\nloc      varchar\n\n创建 ==com.pojo.dept实体对象==\n\npublic class dept {\n    private int deptno;\n    private string dname;\n    private string loc;\n   \n    //省略 get、set、tostring、构造 方法\n}\n\n\n创建 ==com.mapper.deptmapper接口==\n\npublic interface deptmapper {\n    // crud\n    int add(@param("depts") collection<dept> depts);\n    int del(dept dept);\n    int update(dept dept);\n    list<dept> findbylike(dept dept);\n}\n\n\n创建 ==deptmapper.xml映射文件==\n\n<?xml version="1.0" encoding="utf-8" ?>\n<!doctype mapper\n        public "-//mybatis.org//dtd mapper 3.0//en"\n        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n\x3c!-- namespace= "名称必须与映射的类的名字一致，是完全限定名" --\x3e\n<mapper namespace="com.sans.mapper.deptmapper">\n\n    \x3c!-- crud 动态sql\n        列表添加 for\n        删除 where=>if\n        修改 set=>if\n        查 choose=>...\n    --\x3e\n\n    \x3c!-- 列表添加 for\n      sql示例：insert into dept(dname, loc) values (?,?) , (?,?) [, ...]\n        标签属性说明：\n          collection：指定集合\n          item：集合中的每个迭代对象\n          separator：每次迭代之间的分隔符\n          open：循环语句 以指定字符为 开头\n          close：循环语句 以指定字符为 结束\n    --\x3e\n    <insert id="add" parametertype="collection">\n        insert into dept(dname, loc) values\n        <foreach collection="depts" item="dept" separator=",">\n            (#{dept.dname},#{dept.loc})\n        </foreach>\n    </insert>\n\n    \x3c!-- 删除 where=>if\n        sql示例1：delete from dept where deptno = ?\n        sql示例2：delete from dept where dname = ?\n        sql示例3：delete from dept where deptno = ? and dname = ?\n     --\x3e\n    <delete id="del" parametertype="com.sans.pojo.dept" >\n        delete from dept\n        <where>\n            <if test="deptno != 0">\n                and deptno = #{deptno}\n            </if>\n            <if test="dname != null and dname != \'\'">\n                and dname = #{dname}\n            </if>\n        </where>\n    </delete>\n\n    \x3c!-- 修改 set=>if\n        sql示例1：update dept set dname = ? where deptno = ?\n        sql示例2：update dept set loc = ? where deptno = ?\n        sql示例3：update dept set dname = ? , loc = ? where deptno = ?\n     --\x3e\n    <update id="update" parametertype="com.sans.pojo.dept" >\n        update dept\n        <set>\n            <if test="dname != null and dname != \'\'">\n                  dname = #{dname}\n            </if>\n            <if test="loc != null and loc != \'\'">\n                <if test="dname != null and dname != \'\'">,</if>\n                 loc = #{loc}\n            </if>\n        </set>\n        where deptno = #{deptno}\n    </update>\n\n    \x3c!-- 查 choose=>...\n        sql示例1：select * from dept where 1=1 and dname like \'%会%\'\n        sql示例2：select * from dept where 1=1 and loc like \'%总%\'\n        sql示例3：select * from dept where 1=1 and deptno = ?\n        标签说明：\n            choose：指定分支\n            when：条件分支节点\n            otherwise：都未满足条件\n    --\x3e\n    <select id="findbylike" parametertype="com.sans.pojo.dept" resulttype="com.sans.pojo.dept">\n        select * from dept where 1=1\n        <choose>\n            <when test="dname != null and dname != \'\'">\n                and dname like \'%${dname}%\'\n            </when>\n            <when test="loc != null and loc != \'\'">\n                and loc like \'%${loc}%\'\n            </when>\n            <otherwise>\n                and deptno = #{deptno}\n            </otherwise>\n        </choose>\n    </select>\n\n    <select id="findall" resulttype="com.sans.pojo.dept">\n        select * from dept\n    </select>\n\n</mapper>\n\n\n测试\n\npackage com.sans;\n\nimport com.sans.mapper.deptmapper;\nimport com.sans.pojo.dept;\nimport com.sans.utils.mybatisutil;\nimport org.apache.ibatis.session.sqlsession;\nimport org.junit.test;\n\nimport java.util.*;\n\npublic class demo {\n    \n    /** sql动态查询\n     *      列表添加 for\n     *      删除 where => if\n     *      修改 set => if\n     *      查 choose => .\n     */\n    \n    sqlsession session = mybatisutil.getsession();\n    \n    @test\n    public void addtest() {\n        deptmapper mapper = session.getmapper(deptmapper.class);\n        \n        /** 集合 测试\n         *  意图 ： foreach标签 指定集合类型遍历区别\n         *  - list 兼容\n         *  - set 兼容\n         *  - map 不兼容\n         */\n        \n        // list 测试\n        // list<dept> list = new arraylist<>();\n        // list.add(new dept("会计部1","汇总"));\n        // list.add(new dept("会计部2","汇总"));\n        // list.add(new dept("会计部3","汇总"));\n        \n        // set 测试\n        set<dept> set = new hashset<>();\n        set.add(new dept("会计部1","汇总"));\n        // set.add(new dept("会计部2","汇总"));\n        // set.add(new dept("会计部3","汇总"));\n    \n        int add = mapper.add(set);\n        // session.commit();\n        system.out.println("add : " + add);\n    }\n    \n    @test\n    public void deltest() {\n        deptmapper mapper = session.getmapper(deptmapper.class);\n        dept dept = new dept();\n        // dept.setdeptno(189);\n        dept.setdname("会计部1");\n        int del = mapper.del(dept);\n        // session.commit();\n        system.out.println("del : " + del);\n    }\n    \n    @test\n    public void updatetest() {\n        deptmapper mapper = session.getmapper(deptmapper.class);\n        dept d = new dept();\n        d.setdeptno(5);\n        d.setdname("张三");\n        d.setloc("李四");\n        int update = mapper.update(d);\n        // session.commit();\n        system.out.println("update : " + update);\n    \n    }\n    \n    \n    @test\n    public void findbytypetest() {\n        deptmapper mapper = session.getmapper(deptmapper.class);\n        dept d = new dept();\n        // d.setdname("会");\n        // d.setloc("总");\n        d.setdeptno(5);\n        mapper.findbylike(d).foreach(system.out::println);\n    }\n}\n\n\n\n# mybatis映射关系\n\n在mysql中，当两表之间存在着主从关系，那么从表有个外键 对应 主表的主键 ！\n\n以下是可能出现映射关系的情况：\n\n * 对一 映射关系\n * 对多 映射关系\n\n\n# 对一 映射关系\n\n对一关系映射形式：\n\n * 一对一\n * 一对多\n\n一对多映射接收封装方式引用 mapper映射封装（需要搭配扩展封装 一方对象\n\n实现应用\n\n> 前提：\n> \n>  * 分清对象的 主从关系 ，特别是查询的主对象\n>  * 全局配置文件 已注册 映射文件\n>  * 反向生成映射配置\n>  * 确定好数据表\n\n数据库 表\n\ndept 部门表\n\n字段名      类型        说明     关系键\ndeptno   int       id     key\ndname    varchar   部门名称   \nloc      varchar   部门地址   \n\nemp 员工表\n\n字段名        类型         说明     关系键\nempno      int        id     key\nename      varchar    员工名    \njob        varchar    职位     \nmgr        int               \nhiredate   datetime   入职时间   \nsal        decimal    出售     \ncomm       decimal    佣金     \ndeptno     int        部门id   dept.deptno\njobno      int        职位id   job.jobno\n\n一对多示例\n\n实体类emp\n\npublic class emp {\n    private integer empno;\n    private string ename;\n    private string job;\n    private integer mgr;\n    private date hiredate;\n    private double sal;\n    private double comm;\n    private integer deptno;\n    private integer jobno;\n    \n    private dept dept;\n    \n    // 省略 get、set、tostring、构造 方法\n}\n\n\n实体类dept\n\npublic class dept {\n    private integer deptno;\n    private string dname;\n    private string loc;\n    \n    // 省略 get、set、tostring、构造 方法\n}\n\n\n映射接口empmapper\n\npublic interface empmapper {\n    // .... 省略 反向生成的 标配crud操作\n    \n    // 内连接多查询 搭配 官方约束容器查询\n    list<emp> selectbyexamplejoindept(empexample example);\n}\n\n\n映射文件empmapper.xml\n\n<?xml version="1.0" encoding="utf-8" ?>\n<!doctype mapper public "-//mybatis.org//dtd mapper 3.0//en" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >\n<mapper namespace="com.sans.mapper.empmapper">\n    \n\t\x3c!-- .... 省略非关键代码 --\x3e\n    \n    \x3c!-- 反向生成 约束容器的代码 --\x3e\n    <sql id="example_where_clause">\n        <where>\n            <foreach collection="oredcriteria" item="criteria" separator="or">\n                <if test="criteria.valid">\n                    <trim prefix="(" suffix=")" prefixoverrides="and">\n                        <foreach collection="criteria.criteria" item="criterion">\n                            <choose>\n                                <when test="criterion.novalue">\n                                    and ${criterion.condition}\n                                </when>\n                                <when test="criterion.singlevalue">\n                                    and ${criterion.condition} #{criterion.value}\n                                </when>\n                                <when test="criterion.betweenvalue">\n                                    and ${criterion.condition} #{criterion.value} and #{criterion.secondvalue}\n                                </when>\n                                <when test="criterion.listvalue">\n                                    and ${criterion.condition}\n                                    <foreach collection="criterion.value" item="listitem" open="(" close=")"\n                                             separator=",">\n                                        #{listitem}\n                                    </foreach>\n                                </when>\n                            </choose>\n                        </foreach>\n                    </trim>\n                </if>\n            </foreach>\n        </where>\n    </sql>\n\n    \x3c!-- .... 省略非关键代码 --\x3e\n    \n    \x3c!-- 手配map映射 扩展对象进行封装 --\x3e\n    \x3c!-- <resultmap>标签 属性说明\n \t\tid: 自定义map映射结果集名\n\t\ttype：指定查询的主对象\n\t--\x3e\n    <resultmap id="empexpandmap" type="com.sans.pojo.emp">\n        \x3c!-- 查询结果及映射 属性/字段 配置\n\t\t\tcolumn：指定数据库查询结果的字段\n\t\t\tproperty：指定实体类属性对应的字段\n\t\t\tjdbctype：属性/字段 类型 （注意语法\n\t\t--\x3e\n        <id column="empno" property="empno" jdbctype="integer"/>\n        <result column="ename" property="ename" jdbctype="varchar"/>\n        <result column="job" property="job" jdbctype="varchar"/>\n        <result column="mgr" property="mgr" jdbctype="integer"/>\n        <result column="hiredate" property="hiredate" jdbctype="timestamp"/>\n        <result column="sal" property="sal" jdbctype="decimal"/>\n        <result column="comm" property="comm" jdbctype="decimal"/>\n        <result column="deptno" property="deptno" jdbctype="integer"/>\n        <result column="jobno" property="jobno" jdbctype="integer"/>\n        \x3c!-- <association>标签 属性说明\n \t\t\tproperty：指定查询的从对象 \n\t\t\tjavatype：指定从对象的实体对象\n \t\t--\x3e\n        <association property="dept" javatype="com.sans.pojo.dept">\n            <id column="deptno" property="deptno" jdbctype="integer"/>\n            <result column="dname" property="dname" jdbctype="varchar"/>\n            <result column="loc" property="loc" jdbctype="varchar"/>\n        </association>\n    </resultmap>\n\n    \x3c!--  应用 emp扩展类\n        sql实例1：select emp.* , dept.* from emp, dept where emp.deptno = emp.deptno\n        sql实例2：select emp.* , dept.* from emp, dept where ( ename like ? ) and emp.deptno = emp.deptno\n    --\x3e\n    <select id="selectbyexamplejoindept" resultmap="empexpandmap"\n            parametertype="com.sans.pojo.empexample">\n        select emp.* , dept.*\n            from emp, dept\n        \x3c!-- where 约束 --\x3e\n        <if test="_parameter != null">\n            <include refid="example_where_clause"/>\n           \t\x3c!-- 筛选 --\x3e\n            and emp.deptno = emp.dept\n        </if>\n        \x3c!-- 筛选 --\x3e\n        <if test="_parameter == null">\n            where emp.deptno = emp.deptno\n        </if>\n    </select>\n\n</mapper>\n\n\n测试\n\n/** 一对多测试\n *   由于 一对一 较于简单 且应用场景不多，因此不写了\n *\n *   一对多是 主要应用测试\n */\n\n@test\npublic void onetomany() {\n\n    empmapper mapper = mybatisutil.getsession().getmapper(empmapper.class);\n    empexample example = new empexample();\n    empexample.criteria criteria = example.createcriteria();\n    criteria.andenamelike("%j%");\n    list<emp> emps = mapper.selectbyexamplejoindept(example);\n    \n    emps.foreach(o -> {\n        system.out.println(o+" => "+o.getdept());\n    });\n    \n}\n\n\n\n# 对多映射关系\n\n多对多关系之间的建立需要 第三方表的建立才能进行联系\n\n实现应用\n\n> 以下的 多对多形式分别用了 中间表查询 和 对多关系查询 两种方式\n\n数据库 表\n\ndept 部门表\n\n字段名      类型        说明     关系键\ndeptno   int       id     key\ndname    varchar   部门名称   \nloc      varchar   部门地址   \n\nemp 员工表\n\n字段名        类型         说明     关系键\nempno      int        id     key\nename      varchar    员工名    \njob        varchar    职位     \nmgr        int               \nhiredate   datetime   入职时间   \nsal        decimal    出售     \ncomm       decimal    佣金     \ndeptno     int        部门id   dept.deptno\njobno      int        职位id   job.jobno\n\njob 职位表\n\n字段名      类型        说明    关系键\njobno    int       id    key\njanme    varchar   职位名   \nremark   varcahr   备注    \n\n> 这三张表 的关系：可以看似为 多个职位对应多个部门 ，而他们的练习包含有 员工表\n\n实体类emp\n\npublic class emp {\n    private integer empno;\n    private string ename;\n    private string job;\n    private integer mgr;\n    private date hiredate;\n    private double sal;\n    private double comm;\n    private integer deptno;\n    private integer jobno;\n    \n    // dept 多对一关系\n    private dept beandept;\n    // job 多对一关系\n    private job beanjob;\n    \n    // 省略 get、set、tostring、构造 方法\n}\n\n\n实体类dept\n\npublic class dept {\n    private integer deptno;\n    private string dname;\n    private string loc;\n    \n    private list<job> jobs;\n    \n    // 省略 get、set、tostring、构造 方法\n}\n\n\n实体类job\n\npublic class job {\n    private integer jobno;\n    private string jname;\n    private string remark;\n    \n    private list<dept> dpets;\n    \n    // 省略 get、set、tostring、构造 方法\n}\n\n\nempmapper接口\n\npublic interface empmapper {\n    // .... 省略 反向生成的 标配crud操作\n    \n    // 通过中间表进行查询 两表信息\n    list<emp> selectbyexamplejoindateandjob(empexample example);\n}\n\n\nempmapper.xml\n\n<?xml version="1.0" encoding="utf-8" ?>\n<!doctype mapper public "-//mybatis.org//dtd mapper 3.0//en" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >\n<mapper namespace="com.sans.mapper.empmapper">\n    <resultmap id="baseresultmap" type="com.sans.pojo.emp">\n        <id column="empno" property="empno" jdbctype="integer"/>\n        <result column="ename" property="ename" jdbctype="varchar"/>\n        <result column="job" property="job" jdbctype="varchar"/>\n        <result column="mgr" property="mgr" jdbctype="integer"/>\n        <result column="hiredate" property="hiredate" jdbctype="timestamp"/>\n        <result column="sal" property="sal" jdbctype="decimal"/>\n        <result column="comm" property="comm" jdbctype="decimal"/>\n        <result column="deptno" property="deptno" jdbctype="integer"/>\n        <result column="jobno" property="jobno" jdbctype="integer"/>\n    </resultmap>\n    \n\t\x3c!-- .... 省略非关键代码 --\x3e\n\n    \x3c!-- 通过中间表查 两表的关系 --\x3e\n    <resultmap id="empanddeptandjobmap" type="com.sans.pojo.emp" extends="baseresultmap">\n        <association property="beandept" javatype="com.sans.pojo.dept">\n            <id column="deptno" property="deptno" jdbctype="integer"/>\n            <result column="dname" property="dname" jdbctype="varchar"/>\n            <result column="loc" property="loc" jdbctype="varchar"/>\n        </association>\n        <association property="beanjob" javatype="com.sans.pojo.job">\n            <id column="jobno" property="jobno" jdbctype="integer"/>\n            <result column="jname" property="jname" jdbctype="varchar"/>\n            <result column="remark" property="remark" jdbctype="varchar"/>\n        </association>\n    </resultmap>\n\n    \x3c!-- 多对多 --\x3e\n    <select id="selectbyexamplejoindateandjob" resultmap="empanddeptandjobmap"\n            parametertype="com.sans.pojo.empexample">\n        select\n            emp.*,dname,loc , jname,remark\n        from\n            dept,job,emp\n        <if test="_parameter != null">\n            <include refid="example_where_clause"/>\n            and dept.deptno = emp.deptno and job.jobno = emp.jobno\n        </if>\n        <if test="_parameter == null">\n            where dept.deptno = emp.deptno and job.jobno = emp.jobno\n        </if>\n    </select>\n    \n</mapper>\n\n\ndeptmapper\n\npublic interface deptmapper {\n    \n    // .... 省略 反向生成的 标配crud操作\n    \n    // 直接多对多 查询\n    list<dept> deptandjobbyexample(deptexample example);\n}\n\n\ndeptmapper.xml\n\n<?xml version="1.0" encoding="utf-8" ?>\n<!doctype mapper public "-//mybatis.org//dtd mapper 3.0//en" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >\n<mapper namespace="com.sans.mapper.deptmapper">\n    <resultmap id="baseresultmap" type="com.sans.pojo.dept">\n        <id column="deptno" property="deptno" jdbctype="integer"/>\n        <result column="dname" property="dname" jdbctype="varchar"/>\n        <result column="loc" property="loc" jdbctype="varchar"/>\n    </resultmap>\n    \n    \x3c!-- .... 省略非关键代码 --\x3e\n\n    \x3c!-- \n\t\t<baseresultmap>.extends: 继承已有的属性\n\t\tcollection标签 属性说明\n \t\t\tproperty：实体类中 数据集的属性名\n\t\t\tjavatype：实体类中 属性的类型\n\t\t\toftype：实体类中的 集合泛型类型\n\t\t子标签指定的都是 实体对象单条记录中的属性\n \t--\x3e\n    <resultmap id="deptandjobsmap" type="com.sans.pojo.dept" extends="baseresultmap">\n        <collection property="jobs" javatype="java.util.arraylist" oftype="com.sans.pojo.job">\n            <id column="jobno" property="jobno" javatype="int"/>\n            <result column="jname" property="jname" javatype="string"/>\n        </collection>\n    </resultmap>\n\n    \x3c!-- 查询部门涉及到的职位有哪些\n        sql示例1：select emp.*,dname,loc , jname,remark from dept , job , emp where\n                    dept.deptno = emp.deptno and job.jobno = emp.jobno\n        sql示例2：select emp.*,dname,loc , jname,remark from dept , job , emp where\n                    ( dname like ? ) and dept.deptno = emp.deptno and job.jobno = emp.jobno\n     --\x3e\n    <select id="deptandjobbyexample" resultmap="deptandjobsmap"\n            parametertype="com.sans.pojo.deptexample">\n        select emp.*,dname,loc , jname,remark from\n            dept , job , emp\n        <if test="_parameter != null">\n            <include refid="example_where_clause"/>\n            and dept.deptno = emp.deptno and job.jobno = emp.jobno\n        </if>\n        <if test="_parameter == null">\n            where dept.deptno = emp.deptno and job.jobno = emp.jobno\n        </if>\n    </select>\n\n</mapper>\n\n\njobmapper\n\njobmapper.xml\n\n> 这两个用于铺垫使用，反向生成后，未更变！\n\n测试\n\npublic class anytomany {\n    \n    /** 对多关系\n     *   两表的对多关系 需要 第三方 中间表建立关系，因此必须包含有中间表\n     *   查询方式：\n     *      - 以中间表作为主表 进行对两表 连接查询\n     *      - 以对多的任意一个为主表 进行对多 连接查询\n     */\n    \n    // 中间表作为主表 进行连接查询\n    @test\n    public void brokeroffirsttabletest() {\n        empmapper mapper = mybatisutil.getsession().getmapper(empmapper.class);\n    \n        // 配置约束容器\n        empexample example = new empexample();\n        empexample.criteria criteria = example.createcriteria();\n        criteria.andenamelike("%j%");\n        \n        list<emp> emps = mapper.selectbyexamplejoindateandjob(example);\n        emps.foreach(o -> {\n            system.out.println(o+"\\n\\t"+o.getbeandept()+"\\n\\t"+o.getbeanjob());\n        });\n        \n    }\n    \n    // 任意表为主表 进行连接查询\n    @test\n    public void anyoffirsttabletest() {\n        deptmapper mapper = mybatisutil.getsession().getmapper(deptmapper.class);\n    \n        // 配置约束容器\n        deptexample example = new deptexample();\n        deptexample.criteria criteria = example.createcriteria();\n        criteria.anddnamelike("%m%");\n    \n        list<dept> depts = mapper.deptandjobbyexample(example);\n        \n        depts.foreach( o -> {\n            system.out.println(o);\n            o.getjobs().foreach(job -> {\n                system.out.println("\\t"+job);\n            });\n        });\n        \n    }\n    \n}\n\n\n\n# mybatis延迟加载\n\n延迟加载在调用的时候加载的查询数据\n\n配置\n\n<configuration>\n    ....\n\t<settings>\n\t    \x3c!-- 日志配置 --\x3e\n\t    <setting name="logimpl" value="log4j"/>\n\t\n\t    \x3c!-- 打开延迟加载 的开关 --\x3e\n\t    <setting name="lazyloadingenabled" value="true"/>\n\t    \x3c!-- 将积极加载改为消极加载即按需要加载 --\x3e\n\t    <setting name="aggressivelazyloading" value="false"/>\n\t    \x3c!-- 启动二级缓存\n\t    <setting name="cacheenabled" value="true"/>--\x3e\n\t</settings>\n    ....\n</configuration>\n\n\n> 根据以上应用 emp 和 dept 的关系进行应用懒加载\n> \n> 注意：\n> \n>  * emp实体类中 包含 一方dept对象\n\nsql映射\n\n<?xml version="1.0" encoding="utf-8" ?>\n<!doctype mapper public "-//mybatis.org//dtd mapper 3.0//en" "http://mybatis.org/dtd/mybatis-3-mapper.dtd" >\n<mapper namespace="com.sans.mapper.empmapper">\n    <resultmap id="baseresultmap" type="com.sans.pojo.emp">\n        <id column="empno" property="empno" jdbctype="integer"/>\n        <result column="ename" property="ename" jdbctype="varchar"/>\n        <result column="job" property="job" jdbctype="varchar"/>\n        <result column="mgr" property="mgr" jdbctype="integer"/>\n        <result column="hiredate" property="hiredate" jdbctype="timestamp"/>\n        <result column="sal" property="sal" jdbctype="decimal"/>\n        <result column="comm" property="comm" jdbctype="decimal"/>\n        <result column="deptno" property="deptno" jdbctype="integer"/>\n        <result column="jobno" property="jobno" jdbctype="integer"/>\n    </resultmap>\n    \n    \x3c!-- ... 省略自动生成的非关键代码 --\x3e\n\n    \x3c!-- 懒加载测试 --\x3e\n    <resultmap id="lazyloadingmap" type="com.sans.pojo.emp" extends="baseresultmap">\n        <association property="dept" column="deptno" javatype="com.sans.pojo.dept"\n            select="com.sans.mapper.deptmapper.selectbyprimarykey">\n            <id column="deptno" property="deptno" javatype="int"/>\n            <result column="dname" property="dname" javatype="string"/>\n            <result column="loc" property="loc" javatype="string"/>\n        </association>\n    </resultmap>\n\n    <select id="lazyloadingselectall" resultmap="lazyloadingmap">\n        select * from emp\n    </select>\n\n</mapper>\n\n\n以下是测试懒加载的效果实例\n\n无懒加载\n\ndebug [main] - ==>  preparing: select * from emp\ndebug [main] - ==> parameters: \ndebug [main] - ====>  preparing: select deptno, dname, loc from dept where deptno = ?\ndebug [main] - ====> parameters: 20(integer)\ndebug [main] - <====      total: 1\ndebug [main] - ====>  preparing: select deptno, dname, loc from dept where deptno = ?\ndebug [main] - ====> parameters: 30(integer)\ndebug [main] - <====      total: 1\ndebug [main] - ====>  preparing: select deptno, dname, loc from dept where deptno = ?\ndebug [main] - ====> parameters: 47(integer)\ndebug [main] - <====      total: 1\ndebug [main] - ====>  preparing: select deptno, dname, loc from dept where deptno = ?\ndebug [main] - ====> parameters: 10(integer)\ndebug [main] - <====      total: 1\ndebug [main] - ====>  preparing: select deptno, dname, loc from dept where deptno = ?\ndebug [main] - ====> parameters: 13(integer)\ndebug [main] - <====      total: 1\ndebug [main] - ====>  preparing: select deptno, dname, loc from dept where deptno = ?\ndebug [main] - ====> parameters: 14(integer)\ndebug [main] - <====      total: 1\ndebug [main] - ====>  preparing: select deptno, dname, loc from dept where deptno = ?\ndebug [main] - ====> parameters: 141(integer)\ndebug [main] - <====      total: 1\ndebug [main] - ====>  preparing: select deptno, dname, loc from dept where deptno = ?\ndebug [main] - ====> parameters: 140(integer)\ndebug [main] - <====      total: 1\ndebug [main] - ====>  preparing: select deptno, dname, loc from dept where deptno = ?\ndebug [main] - ====> parameters: 164(integer)\ndebug [main] - <====      total: 1\ndebug [main] - ====>  preparing: select deptno, dname, loc from dept where deptno = ?\ndebug [main] - ====> parameters: 167(integer)\ndebug [main] - <====      total: 1\ndebug [main] - ====>  preparing: select deptno, dname, loc from dept where deptno = ?\ndebug [main] - ====> parameters: 1(integer)\ndebug [main] - <====      total: 1\ndebug [main] - <==      total: 43\n张小三 ==> dept{deptno=20, dname=\'research\', loc=\'dallas\'} => research\n张小 ==> dept{deptno=20, dname=\'research\', loc=\'dallas\'} => research\n李四 ==> dept{deptno=30, dname=\'sales\', loc=\'chicago\'} => sales\n旺财2 ==> dept{deptno=47, dname=\'学术部\', loc=\'b区\'} => 学术部\nzhansan ==> dept{deptno=20, dname=\'research\', loc=\'dallas\'} => research\nzhansan2 ==> dept{deptno=20, dname=\'research\', loc=\'dallas\'} => research\nwangwu ==> dept{deptno=20, dname=\'research\', loc=\'dallas\'} => research\njason ==> dept{deptno=10, dname=\'市场部\', loc=\'new york\'} => 市场部\n王五 ==> dept{deptno=30, dname=\'sales\', loc=\'chicago\'} => sales\n旺财 ==> dept{deptno=47, dname=\'学术部\', loc=\'b区\'} => 学术部\n王小二 ==> dept{deptno=30, dname=\'sales\', loc=\'chicago\'} => sales\nkkkkk ==> dept{deptno=20, dname=\'research\', loc=\'dallas\'} => research\nj1 ==> dept{deptno=13, dname=\'bb\', loc=\'b\'} => bb\nj3 ==> dept{deptno=14, dname=\'cc\', loc=\'b\'} => cc\nj4 ==> dept{deptno=141, dname=\'cqc\', loc=\'b\'} => cqc\nj5 ==> dept{deptno=140, dname=\'cqc\', loc=\'b\'} => cqc\nj6 ==> dept{deptno=141, dname=\'cqc\', loc=\'b\'} => cqc\nhhh ==> dept{deptno=20, dname=\'research\', loc=\'dallas\'} => research\nking2 ==> dept{deptno=30, dname=\'sales\', loc=\'chicago\'} => sales\nmm ==> dept{deptno=20, dname=\'research\', loc=\'dallas\'} => research\n旺 ==> dept{deptno=20, dname=\'research\', loc=\'dallas\'} => research\n李 ==> dept{deptno=30, dname=\'sales\', loc=\'chicago\'} => sales\nnull ==> dept{deptno=10, dname=\'市场部\', loc=\'new york\'} => 市场部\njjj ==> dept{deptno=164, dname=\'m1\', loc=\'m1\'} => m1\nmmm ==> dept{deptno=164, dname=\'m1\', loc=\'m1\'} => m1\njjj2 ==> dept{deptno=167, dname=\'m2\', loc=\'m1\'} => m2\nmmm2 ==> dept{deptno=167, dname=\'m2\', loc=\'m1\'} => m2\naaa ==> dept{deptno=47, dname=\'学术部\', loc=\'b区\'} => 学术部\nsmith ==> dept{deptno=20, dname=\'research\', loc=\'dallas\'} => research\nallen ==> dept{deptno=30, dname=\'sales\', loc=\'chicago\'} => sales\nward ==> dept{deptno=30, dname=\'sales\', loc=\'chicago\'} => sales\njones ==> dept{deptno=20, dname=\'research\', loc=\'dallas\'} => research\nmartin ==> dept{deptno=30, dname=\'sales\', loc=\'chicago\'} => sales\nblake ==> dept{deptno=30, dname=\'sales\', loc=\'chicago\'} => sales\nclark ==> dept{deptno=10, dname=\'市场部\', loc=\'new york\'} => 市场部\nscott ==> dept{deptno=20, dname=\'research\', loc=\'dallas\'} => research\nking ==> dept{deptno=10, dname=\'市场部\', loc=\'new york\'} => 市场部\nturner ==> dept{deptno=30, dname=\'sales\', loc=\'chicago\'} => sales\nadams ==> dept{deptno=20, dname=\'research\', loc=\'dallas\'} => research\njames ==> dept{deptno=30, dname=\'sales\', loc=\'chicago\'} => sales\nford ==> dept{deptno=20, dname=\'research\', loc=\'dallas\'} => research\nmiller ==> dept{deptno=10, dname=\'市场部\', loc=\'new york\'} => 市场部\n赵六 ==> dept{deptno=1, dname=\'会计部\', loc=\'海珠区\'} => 会计部\n\n\n懒加载\n\ndebug [main] - ==>  preparing: select * from emp\ndebug [main] - ==> parameters: \ndebug [main] - <==      total: 43\ndebug [main] - ==>  preparing: select deptno, dname, loc from dept where deptno = ?\ndebug [main] - ==> parameters: 20(integer)\ndebug [main] - <==      total: 1\n张小三 ==> dept{deptno=20, dname=\'research\', loc=\'dallas\'} => research\n张小 ==> dept{deptno=20, dname=\'research\', loc=\'dallas\'} => research\ndebug [main] - ==>  preparing: select deptno, dname, loc from dept where deptno = ?\ndebug [main] - ==> parameters: 30(integer)\ndebug [main] - <==      total: 1\n李四 ==> dept{deptno=30, dname=\'sales\', loc=\'chicago\'} => sales\ndebug [main] - ==>  preparing: select deptno, dname, loc from dept where deptno = ?\ndebug [main] - ==> parameters: 47(integer)\ndebug [main] - <==      total: 1\n旺财2 ==> dept{deptno=47, dname=\'学术部\', loc=\'b区\'} => 学术部\nzhansan ==> dept{deptno=20, dname=\'research\', loc=\'dallas\'} => research\nzhansan2 ==> dept{deptno=20, dname=\'research\', loc=\'dallas\'} => research\nwangwu ==> dept{deptno=20, dname=\'research\', loc=\'dallas\'} => research\ndebug [main] - ==>  preparing: select deptno, dname, loc from dept where deptno = ?\ndebug [main] - ==> parameters: 10(integer)\ndebug [main] - <==      total: 1\njason ==> dept{deptno=10, dname=\'市场部\', loc=\'new york\'} => 市场部\n王五 ==> dept{deptno=30, dname=\'sales\', loc=\'chicago\'} => sales\n旺财 ==> dept{deptno=47, dname=\'学术部\', loc=\'b区\'} => 学术部\n王小二 ==> dept{deptno=30, dname=\'sales\', loc=\'chicago\'} => sales\nkkkkk ==> dept{deptno=20, dname=\'research\', loc=\'dallas\'} => research\ndebug [main] - ==>  preparing: select deptno, dname, loc from dept where deptno = ?\ndebug [main] - ==> parameters: 13(integer)\ndebug [main] - <==      total: 1\nj1 ==> dept{deptno=13, dname=\'bb\', loc=\'b\'} => bb\ndebug [main] - ==>  preparing: select deptno, dname, loc from dept where deptno = ?\ndebug [main] - ==> parameters: 14(integer)\ndebug [main] - <==      total: 1\nj3 ==> dept{deptno=14, dname=\'cc\', loc=\'b\'} => cc\ndebug [main] - ==>  preparing: select deptno, dname, loc from dept where deptno = ?\ndebug [main] - ==> parameters: 141(integer)\ndebug [main] - <==      total: 1\nj4 ==> dept{deptno=141, dname=\'cqc\', loc=\'b\'} => cqc\ndebug [main] - ==>  preparing: select deptno, dname, loc from dept where deptno = ?\ndebug [main] - ==> parameters: 140(integer)\ndebug [main] - <==      total: 1\nj5 ==> dept{deptno=140, dname=\'cqc\', loc=\'b\'} => cqc\nj6 ==> dept{deptno=141, dname=\'cqc\', loc=\'b\'} => cqc\nhhh ==> dept{deptno=20, dname=\'research\', loc=\'dallas\'} => research\nking2 ==> dept{deptno=30, dname=\'sales\', loc=\'chicago\'} => sales\nmm ==> dept{deptno=20, dname=\'research\', loc=\'dallas\'} => research\n旺 ==> dept{deptno=20, dname=\'research\', loc=\'dallas\'} => research\n李 ==> dept{deptno=30, dname=\'sales\', loc=\'chicago\'} => sales\nnull ==> dept{deptno=10, dname=\'市场部\', loc=\'new york\'} => 市场部\ndebug [main] - ==>  preparing: select deptno, dname, loc from dept where deptno = ?\ndebug [main] - ==> parameters: 164(integer)\ndebug [main] - <==      total: 1\njjj ==> dept{deptno=164, dname=\'m1\', loc=\'m1\'} => m1\nmmm ==> dept{deptno=164, dname=\'m1\', loc=\'m1\'} => m1\ndebug [main] - ==>  preparing: select deptno, dname, loc from dept where deptno = ?\ndebug [main] - ==> parameters: 167(integer)\ndebug [main] - <==      total: 1\njjj2 ==> dept{deptno=167, dname=\'m2\', loc=\'m1\'} => m2\nmmm2 ==> dept{deptno=167, dname=\'m2\', loc=\'m1\'} => m2\naaa ==> dept{deptno=47, dname=\'学术部\', loc=\'b区\'} => 学术部\nsmith ==> dept{deptno=20, dname=\'research\', loc=\'dallas\'} => research\nallen ==> dept{deptno=30, dname=\'sales\', loc=\'chicago\'} => sales\nward ==> dept{deptno=30, dname=\'sales\', loc=\'chicago\'} => sales\njones ==> dept{deptno=20, dname=\'research\', loc=\'dallas\'} => research\nmartin ==> dept{deptno=30, dname=\'sales\', loc=\'chicago\'} => sales\nblake ==> dept{deptno=30, dname=\'sales\', loc=\'chicago\'} => sales\nclark ==> dept{deptno=10, dname=\'市场部\', loc=\'new york\'} => 市场部\nscott ==> dept{deptno=20, dname=\'research\', loc=\'dallas\'} => research\nking ==> dept{deptno=10, dname=\'市场部\', loc=\'new york\'} => 市场部\nturner ==> dept{deptno=30, dname=\'sales\', loc=\'chicago\'} => sales\nadams ==> dept{deptno=20, dname=\'research\', loc=\'dallas\'} => research\njames ==> dept{deptno=30, dname=\'sales\', loc=\'chicago\'} => sales\nford ==> dept{deptno=20, dname=\'research\', loc=\'dallas\'} => research\nmiller ==> dept{deptno=10, dname=\'市场部\', loc=\'new york\'} => 市场部\ndebug [main] - ==>  preparing: select deptno, dname, loc from dept where deptno = ?\ndebug [main] - ==> parameters: 1(integer)\ndebug [main] - <==      total: 1\n赵六 ==> dept{deptno=1, dname=\'会计部\', loc=\'海珠区\'} => 会计部\n\n\n\n# mybatis缓存\n\nmybatis缓存是一般的orm 框架都会提供的功能，目的就是提升查询的效率和减少数据库的压力。\n\n将经常查询的数据存在缓存（内存）中，用户查询该数据的时候不需要从库上 查询，而是直接从缓存中查询，提高查询效率，解决高并发问题。 mybatis 也有一级缓存 和 二级缓存，并且预留了集成 第三方缓存的接口\n\n\n# 一级缓存\n\nmybatis自带的 缓存 ，在构造sqlsession对象时内部有个 hashmap 结构存储缓存数据，它的作用域范围是 sqlsession 。如果两次查询用同一个sqlsession进行查询语句，则第一次会通过数据库获取到数据库 ，二次会缓存中获取数据！\n\n> 缓存清除条件：\n> \n>  * session.clearcache()\n>  * session.close()\n>  * 执行 增删改\n>  * 事务回滚\n>  * 事务提交\n\n\n\n应用实例\n\nimport com.pojo.team;\nimport com.utils.mybatisutil;\nimport org.apache.ibatis.session.sqlsession;\nimport org.junit.test;\n\npublic class cachetest {\n    \n    private sqlsession sqlsession = mybatisutil.getsqlsession();\n    \n    @test\n    public void test01() {\n        team t1 = sqlsession.selectone("com.mapper.teammapper.querybyid",1003);\n        system.out.println("t1 : " + t1);\n        team t2 = sqlsession.selectone("com.mapper.teammapper.querybyid",1003);\n        system.out.println("t2 : " + t2);\n        \n        mybatisutil.close();\n        \n        //换 sqlsession ，刷新缓存\n        sqlsession = mybatisutil.getsqlsession();\n        team t3 = sqlsession.selectone("com.mapper.teammapper.querybyid",1003);\n        system.out.println("t3 : " + t3);\n        \n        int num = sqlsession.delete("com.mapper.teammapper.delbyid",1000);\n        sqlsession.commit();\n        system.out.println("num : " + num);\n        \n        team t4 = sqlsession.selectone("com.mapper.teammapper.querybyid",1003);\n        sqlsession.close();\n    }\n    \n}\n\n/* 运行结果\n\ndebug [main] - setting autocommit to false on jdbc connection [com.mysql.cj.jdbc.connectionimpl@1f760b47]\ndebug [main] - ==>  preparing: select * from team where teamid=?\ndebug [main] - ==> parameters: 1003(integer)\ndebug [main] - <==      total: 1\nt1 : team{teamid=1003, teamname=\'老八\', location=\'温州\', createtime=wed feb 17 00:00:00 cst 2021}\nt2 : team{teamid=1003, teamname=\'老八\', location=\'温州\', createtime=wed feb 17 00:00:00 cst 2021}\ndebug [main] - resetting autocommit to true on jdbc connection [com.mysql.cj.jdbc.connectionimpl@1f760b47]\ndebug [main] - closing jdbc connection [com.mysql.cj.jdbc.connectionimpl@1f760b47]\ndebug [main] - returned connection 527829831 to pool.\ndebug [main] - opening jdbc connection\ndebug [main] - checked out connection 527829831 from pool.\ndebug [main] - setting autocommit to false on jdbc connection [com.mysql.cj.jdbc.connectionimpl@1f760b47]\ndebug [main] - ==>  preparing: select * from team where teamid=?\ndebug [main] - ==> parameters: 1003(integer)\ndebug [main] - <==      total: 1\nt3 : team{teamid=1003, teamname=\'老八\', location=\'温州\', createtime=wed feb 17 00:00:00 cst 2021}\ndebug [main] - ==>  preparing: delete from `mybatis`.`team` where `teamid` = ?\ndebug [main] - ==> parameters: 1000(integer)\ndebug [main] - <==    updates: 0\ndebug [main] - committing jdbc connection [com.mysql.cj.jdbc.connectionimpl@1f760b47]\nnum : 0\ndebug [main] - ==>  preparing: select * from team where teamid=?\ndebug [main] - ==> parameters: 1003(integer)\ndebug [main] - <==      total: 1\ndebug [main] - resetting autocommit to true on jdbc connection [com.mysql.cj.jdbc.connectionimpl@1f760b47]\ndebug [main] - closing jdbc connection [com.mysql.cj.jdbc.connectionimpl@1f760b47]\ndebug [main] - returned connection 527829831 to pool.\n\n*/\n\n\n\n# 二级缓存\n\nmybatis 二级缓存是全局缓存，作用域超出 sqlsession 范围之外，其作用域是 mapper 的同一命名空间！\n\n两个不同的sqlsession在同一 命名空间 下，执行的sql语句参数相同 ，最终执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据，从而提高性能！\n\n\n\n应用实例\n\n修改配置文件 ==mybatis.xml==\n\n···\n\t<settings>\n\t    \x3c!--    日志配置--\x3e\n\t    <setting name="logimpl" value="log4j"/>\n\t    \x3c!--    是否启动二级缓存--\x3e\n\t    <setting name="cacheenabled" value="true"/>\n\t</settings>\n···\n\n\n修改映射文件 ==teammapper.xml==\n\n<mapper namespace="com.mapper.teammapper">\n\x3c!--   二级缓存标签--\x3e\n    <cache></cache>\n\t····    \n<mapper/>\n\n\n实体类实现 ==serializable接口==\n\npackage com.pojo;\n\nimport java.io.serializable;\nimport java.util.date;\nimport java.util.list;\n\npublic class team implements serializable {\n    \n    private integer teamid;\n    private string teamname;\n    private string location;\n    private date createtime;\n    \n    //一对多的体现：一方持有多方的对象\n    private list<player> playerlist1;\n    private list<player> playerlist2;\n  \t\n    //省略 set、get、tostring、构造 方法\n    \n}\n\n\n测试\n\nimport com.mapper.teammapper;\nimport com.pojo.team;\nimport com.utils.mybatisutil;\nimport org.apache.ibatis.session.sqlsession;\nimport org.junit.test;\n\npublic class cachetest {\n    \n    @test\n    public void test02() {\n        //查 数据 保留缓存\n        sqlsession sqlsession1 = mybatisutil.getsqlsession();\n        team t1 = sqlsession1.selectone("com.mapper.teammapper.querybyid" , 1019);\n        system.out.println("t1 : " + t1);\n        //清空一级缓存，保留二级缓存\n        mybatisutil.close();\n    \n        //测试 是否保留二级缓存\n        sqlsession sqlsession2 = mybatisutil.getsqlsession();\n        team t2 = sqlsession2.selectone("com.mapper.teammapper.querybyid" , 1019);\n        system.out.println("t2 : " + t2);\n        mybatisutil.close();\n    \n        //测试 删除数据 清空二级缓存\n        sqlsession sqlsession3 = mybatisutil.getsqlsession();\n        //删除不存在的数据（假删除）\n        int i = sqlsession3.delete("com.mapper.teammapper.delbyid" , 10000);\n        system.out.println("i : " + i);\n        sqlsession3.commit();\n        mybatisutil.close();\n    \n        //测试 是否保留二级缓存\n        sqlsession sqlsession4 = mybatisutil.getsqlsession();\n        team t4 = sqlsession4.selectone("com.mapper.teammapper.querybyid" , 1019);\n        system.out.println("t4 : " + t4);\n        mybatisutil.close();\n        \n    }\n    \n}\n\n/*运行结果\n    \ndebug [main] - created connection 292138977.\ndebug [main] - setting autocommit to false on jdbc connection [com.mysql.cj.jdbc.connectionimpl@1169afe1]\ndebug [main] - ==>  preparing: select * from team where teamid=?\ndebug [main] - ==> parameters: 1019(integer)\ndebug [main] - <==      total: 1\nt1 : team{teamid=1019, teamname=\'哥斯拉\', location=\'华盛顿\', createtime=sun jul 25 00:00:00 cst 2021}\ndebug [main] - resetting autocommit to true on jdbc connection [com.mysql.cj.jdbc.connectionimpl@1169afe1]\ndebug [main] - closing jdbc connection [com.mysql.cj.jdbc.connectionimpl@1169afe1]\ndebug [main] - returned connection 292138977 to pool.\n warn [main] - as you are using functionality that deserializes object streams, it is recommended to define the jep-290 serial filter. please refer to https://docs.oracle.com/pls/topic/lookup?ctx=javase15&id=guid-8296d8e8-2b93-4b9a-856e-0a65af9b8c66\ndebug [main] - cache hit ratio [com.mapper.teammapper]: 0.5\nt2 : team{teamid=1019, teamname=\'哥斯拉\', location=\'华盛顿\', createtime=sun jul 25 00:00:00 cst 2021}\ndebug [main] - opening jdbc connection\ndebug [main] - checked out connection 292138977 from pool.\ndebug [main] - setting autocommit to false on jdbc connection [com.mysql.cj.jdbc.connectionimpl@1169afe1]\ndebug [main] - ==>  preparing: delete from `mybatis`.`team` where `teamid` = ?\ndebug [main] - ==> parameters: 10000(integer)\ndebug [main] - <==    updates: 0\ni : 0\ndebug [main] - committing jdbc connection [com.mysql.cj.jdbc.connectionimpl@1169afe1]\ndebug [main] - resetting autocommit to true on jdbc connection [com.mysql.cj.jdbc.connectionimpl@1169afe1]\ndebug [main] - closing jdbc connection [com.mysql.cj.jdbc.connectionimpl@1169afe1]\ndebug [main] - returned connection 292138977 to pool.\ndebug [main] - cache hit ratio [com.mapper.teammapper]: 0.3333333333333333\ndebug [main] - opening jdbc connection\ndebug [main] - checked out connection 292138977 from pool.\ndebug [main] - setting autocommit to false on jdbc connection [com.mysql.cj.jdbc.connectionimpl@1169afe1]\ndebug [main] - ==>  preparing: select * from team where teamid=?\ndebug [main] - ==> parameters: 1019(integer)\ndebug [main] - <==      total: 1\nt4 : team{teamid=1019, teamname=\'哥斯拉\', location=\'华盛顿\', createtime=sun jul 25 00:00:00 cst 2021}\ndebug [main] - resetting autocommit to true on jdbc connection [com.mysql.cj.jdbc.connectionimpl@1169afe1]\ndebug [main] - closing jdbc connection [com.mysql.cj.jdbc.connectionimpl@1169afe1]\ndebug [main] - returned connection 292138977 to pool.\n    \n*/\n\n\n# 二级缓存其他设置\n\n映射文件中的cache标签\n\n···\t\n\t\x3c!--二级缓存默认配置--\x3e\n\t<cache>\n\t\t<property name="eviction" value="lru"/>\x3c!--回收策略为lru--\x3e\n\t\t<property name="flushinterval" value="60000"/>\x3c!--自动刷新时间间隔为60s--\x3e\n\t\t<property name="size" value="1024"/>\x3c!--最多缓存1024个引用对象--\x3e\n\t\t<property name="readonly" value="true"/>\x3c!--只读--\x3e\n\t</cache>\n···\n\n\n属性              说明\neviction        代表的是缓存回收策略，目前 mybatis 提供以下策略。\n                lru：使用较少，移除最长时间不用的对象；\n                fifo：先进先出，按对象进入缓存的顺序来移除它们；\n                soft：软引用，移除基于垃圾回收器状态和软引用规则的对象；\n                weak：弱引用，更积极地移除基于垃圾收集器状态和弱引用规则的对象\nflushinterval   刷新间隔时间，单位为毫秒，这里配置的是 100 秒刷新，如果省略该配置，那么只有当 sql 被执行的时候才会刷新缓存\nsize            引用数目，正整数，代表缓存最多可以存储多少个对象，不宜设置过大。设置过大会导致内存溢出。这里配置的是 1024 个对象\nreadonly        只读，默认值为 false，意味着缓存数据只能读取而不能修改，这样设置的好处是可以快速读取缓存，缺点是没有办法修改缓存\n\n重用cache标签配置\n\n在命名空间中共享相同的缓存配置和实例，可以使用cache-ref 元素来引用另外一个缓存。引用实例：\n\n···\n\t\x3c!--需要指定 映射文件的位置--\x3e\n\t<cache-ref namespace="com.mapper.teammapper" />\n···\n\n\n\n# 反向工程\n\nmybatis 提供逆向生成工具，该工具可以根据 数据库中的表 自动生成单表的 pojo 类、mapper 映射文件和 mapper 接口。大大缩减了开发时间！！（应用前提，不同库表名不建议写相同！）\n\nmybatis反向生成方式有多种，本次引用了：项目生成 和 maven项目工具生成\n\n\n# 项目生成\n\n项目到手直接配置 generatorconfig.xml 该文件即可，我们只需要关注以下的配置信息\n\n * <jdbcconnection>：jdbc 库连接\n   * **driverclass：**驱动加载\n   * **connectionurl：**连接url\n   * **userid：**账号\n   * **password：**密码\n * <javamodelgenerator>.targetpackage：指定生成 实体类路径\n * <sqlmapgenerator>.targetpackage：指定生成 映射文件路径\n * <javaclientgenerator>.targetpackage：指定生成 mapper接口路径\n * <table>.tablename：指定 反向生成 的数据库 表\n\n> 对以上标签详细了解以及配置的信息，可在一下jar包路径了解详细： ==mybatis-generator-core-1.3.2.jar\\org\\mybatis\\generator\\config\\xml\\mybatis-generator-config_1_0.dtd==\n\n依赖包\n\n * log4j-1.2.16.jar（日志\n * mybatis-3.5.6.jar（mybatis\n * mybatis-generator-core-1.3.2.jar （反向工程\n * mysql-connector-java-8.0.16.jar（jdbc\n\n项目生成问题:\n\n * 反向生成项目 不能通过子项目进行应用该项目，否则 反向生成找不到 src 根路径\n * 反向生成项目，配置 指定的包名路径 必须与应用的项目一致 （实例和映射的路径\n\n\n\n示例：\n\ngeneratorconfig.xml配置文件\n\n<?xml version="1.0" encoding="utf-8"?>\n<!doctype generatorconfiguration\n  public "-//mybatis.org//dtd mybatis generator configuration 1.0//en"\n  "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">\n\n<generatorconfiguration>\n   <context id="testtables" targetruntime="mybatis3">\n      <commentgenerator>\n         \x3c!-- 是否去除自动生成的注释 true：是 ： false:否 --\x3e\n         <property name="suppressallcomments" value="true" />\n      </commentgenerator>\n      \x3c!--数据库连接的信息：驱动类、连接地址、用户名、密码 --\x3e\n       \n      <jdbcconnection\n            driverclass="com.mysql.cj.jdbc.driver"\n         connectionurl="jdbc:mysql://127.0.0.1:3306/test?\nuseunicode=true&amp;characterencoding=utf-8&amp;servertimezone=gmt"\n         userid="root"\n         password="root">\n      </jdbcconnection>\n     \n      \x3c!-- 默认false，把jdbc decimal 和 numeric 类型解析为 integer，为 true时把jdbc decimal 和 \n         numeric 类型解析为java.math.bigdecimal --\x3e\n      <javatyperesolver>\n         <property name="forcebigdecimals" value="false" />\n      </javatyperesolver>\n\n      \x3c!-- targetproject:生成pojo类的位置 --\x3e\n      <javamodelgenerator targetpackage="com.sans.pojo"\n         targetproject=".\\src">\n         \x3c!-- enablesubpackages:是否让schema作为包的后缀 --\x3e\n         <property name="enablesubpackages" value="false" />\n         \x3c!-- 从数据库返回的值被清理前后的空格 --\x3e\n         <property name="trimstrings" value="true" />\n      </javamodelgenerator>\n        \x3c!-- targetproject:mapper映射文件生成的位置 --\x3e\n      <sqlmapgenerator targetpackage="com.sans.mapper"\n         targetproject=".\\src">\n         \x3c!-- enablesubpackages:是否让schema作为包的后缀 --\x3e\n         <property name="enablesubpackages" value="false" />\n      </sqlmapgenerator>\n      \x3c!-- targetpackage：mapper接口生成的位置 --\x3e\n      <javaclientgenerator type="xmlmapper"\n         targetpackage="com.sans.mapper"\n         targetproject=".\\src">\n         \x3c!-- enablesubpackages:是否让schema作为包的后缀 --\x3e\n         <property name="enablesubpackages" value="false" />\n      </javaclientgenerator>\n\n      \x3c!-- 指定数据库表    --\x3e\n      <table tablename="emp">\n         \x3c!-- 大小写也一起搬 --\x3e\n         <property name="useactualcolumnnames" value="true"/>\n      </table>\n      <table tablename="dept">\n         <property name="useactualcolumnnames" value="true"/>\n      </table>\n       \n      \x3c!-- 有些表的字段需要指定java类型\n       <table schema="" tablename="">\n         <columnoverride column="" javatype="" />\n      </table> --\x3e\n   </context>\n</generatorconfiguration>\n\n\ngeneratorsqlmap类 执行入口\n\nimport java.io.file;\nimport java.net.urldecoder;\nimport java.util.arraylist;\nimport java.util.list;\n\nimport org.mybatis.generator.api.mybatisgenerator;\nimport org.mybatis.generator.config.configuration;\nimport org.mybatis.generator.config.xml.configurationparser;\nimport org.mybatis.generator.internal.defaultshellcallback;\n\npublic class generatorsqlmap {\n   \n   // 指定 逆向工程配置文件\n   private static string configname = "generatorconfig.xml";\n   \n   public void generator() throws exception{\n\n      list<string> warnings = new arraylist<>();\n      boolean overwrite = true;\n      \n      // 通过类加载的路径进入查找文件\n      // 中文路径转义\n      string decode = urldecoder.decode(this.getclass().getclassloader().getresource(configname).getfile() , "utf-8");\n      system.out.println("decode : " + decode);\n      file configfile = new file(decode);\n      \n      configurationparser cp = new configurationparser(warnings);\n      configuration config = cp.parseconfiguration(configfile);\n      defaultshellcallback callback = new defaultshellcallback(overwrite);\n      mybatisgenerator mybatisgenerator = new mybatisgenerator(config,\n            callback, warnings);\n      mybatisgenerator.generate(null);\n\n   } \n   public static void main(string[] args) {\n      try {\n         // 直接指定路径可能会有问题\n         new generatorsqlmap().generator();\n      } catch (exception e) {\n         e.printstacktrace();\n      }\n      \n   }\n\n}\n\n\n执行成功会在指定的路径生成出文件\n\n反向工程应用\n\n直接上测试代码，就不多bb\n\npackage com.sans;\n\nimport com.sans.mapper.deptmapper;\nimport com.sans.pojo.dept;\nimport com.sans.pojo.deptexample;\nimport com.sans.utils.mybatisutil;\nimport org.junit.test;\n\nimport java.util.list;\n\npublic class demo {\n    \n    /** 反向工程 单表应用测试\n     *  已 dept对象 示例\n     *  反向生成的接口方法\n     *     // 查询所有条数 （带约束\n     *     int countbyexample(deptexample example);\n     *     // 删除指定数据 （带约束\n     *     int deletebyexample(deptexample example);\n     *     // 删除指定id\n     *     int deletebyprimarykey(integer deptno);\n     *     // 添加数据 （完全字段添加\n     *     int insert(dept record);\n     *     // 添加数据 （选择添加字段\n     *     int insertselective(dept record);\n     *     // 查询 约束\n     *     list<dept> selectbyexample(deptexample example);\n     *     // 查询 指定id\n     *     dept selectbyprimarykey(integer deptno);\n     *     // 修改 约束 选择性\n     *     int updatebyexampleselective(@param("record") dept record, @param("example") deptexample example);\n     *     // 修改 约束\n     *     int updatebyexample(@param("record") dept record, @param("example") deptexample example);\n     *     // 修改 指定id 选择性\n     *     int updatebyprimarykeyselective(dept record);\n     *     // 修改 指定id\n     *     int updatebyprimarykey(dept record);\n     *\n     *     以上方法 共同信息： id、约束、选择性\n     *\n     *     本次测试围绕：实体约束对象的使用 和 对象属性选择的操作 和 基本的crud\n     */\n\n    deptmapper mapper = mybatisutil.getsession().getmapper(deptmapper.class);\n    \n    // 查询 条数\n    // sql示例：select count(*) from dept\n    @test\n    public void counttest() {\n        int i = mapper.countbyexample(null);\n        system.out.println("i : " + i);\n    }\n    \n    // 查询 普通\n    // sql示例：select deptno, dname, loc from dept\n    @test\n    public void findtest() {\n        list<dept> depts = mapper.selectbyexample(null);\n        depts.foreach(system.out::println);\n    }\n    \n    // 查询 约束\n    // sql示例：select deptno, dname, loc from dept where ( deptno = 44 ) or( loc like \'天河\' )\n    @test\n    public void findbyexampletest() {\n        deptexample example = new deptexample();\n        // 约束容器\n        deptexample.criteria criteria = example.createcriteria();\n        deptexample.criteria criteria2 = example.or();\n        criteria.anddeptnoequalto(44);\n        criteria2.andloclike("天河");\n        \n        list<dept> depts = mapper.selectbyexample(example);\n        depts.foreach(system.out::println);\n    }\n    \n    // 添加\n    // sql示例：insert into dept (deptno, dname, loc ) values (null, \'会计部1\', \'汇总\' )\n    @test\n    public void addtest() {\n        dept dept = new dept();\n        dept.setdname("会计部1");\n        dept.setloc("汇总");\n        int i = mapper.insert(dept);\n        system.out.println(" ["+i+"] ");\n    }\n    \n    // 添加 选择\n    // sql示例：insert into dept ( loc ) values ( \'汇总\' )\n    @test\n    public void addsselectivetest() {\n        dept dept = new dept();\n        dept.setloc("汇总");\n        int i = mapper.insertselective(dept);\n        system.out.println(" ["+i+"] ");\n    }\n    \n    // 修改 约束 选择\n    // sql示例：update dept set dname = \'张三\', loc = \'张三2\' where ( deptno = 50 )\n    @test\n    public void updatetest() {\n        dept dept = new dept();\n        dept.setdname("张三");\n        dept.setloc("张三2");\n        deptexample example = new deptexample();\n        deptexample.criteria criteria = example.createcriteria();\n        criteria.anddeptnoequalto(50);\n        int i = mapper.updatebyexampleselective(dept , example);\n        system.out.println(" ["+i+"] ");\n    }\n    \n}\n\n\n\n# maven项目\n\nmaven反向生成 需要在 ==pom.xml== 中配置 ==org.mybatis.generator== 插件工具进行生成\n\n应用实现\n\n库数据引入&展示 （库名mybatis）\n\ncreate table `team` (\n  `teamid` int not null auto_increment comment \'球队id\',\n  `teamname` varchar(50) default null comment \'球队名称\',\n  `location` varchar(50) default null comment \'球队位置\',\n  `createtime` date default null comment \'球队建立时间\',\n  primary key (`teamid`)\n) engine=innodb auto_increment=1026 default charset=utf8mb4 collate=utf8mb4_0900_ai_ci;\n\n\ncreate table `player` (\n  `playerid` int not null,\n  `playername` varchar(100) default null,\n  `playernum` int default null,\n  `teamid` int default null,\n  primary key (`playerid`)\n) engine=innodb default charset=utf8;\n\n\ncreate table `gamerecord` (\n  `recordid` varchar(36) character set utf8 collate utf8_general_ci not null,\n  `hometeamid` int default null comment \' 主队id\',\n  `gamedate` datetime default null comment \'比赛时间\',\n  `score` int default null comment \'得分\',\n  `visitingteamid` int default null comment \'客队id\',\n  primary key (`recordid`)\n) engine=innodb default charset=utf8;\n\n\n配置文件 ==pom.xml==\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n\t\n    ·····\n    <dependencies>\n        \x3c!--mybatis--\x3e\n        <dependency>\n            <groupid>org.mybatis</groupid>\n            <artifactid>mybatis</artifactid>\n            <version>3.5.6</version>\n        </dependency>\n        \x3c!--jdbc--\x3e\n        <dependency>\n            <groupid>mysql</groupid>\n            <artifactid>mysql-connector-java</artifactid>\n            <version>8.0.23</version>\n        </dependency>\n        \x3c!--测试--\x3e\n        <dependency>\n            <groupid>junit</groupid>\n            <artifactid>junit</artifactid>\n            <version>4.12</version>\n            <scope>test</scope>\n        </dependency>\n        \x3c!--mybatis日志 依赖--\x3e\n        <dependency>\n            <groupid>log4j</groupid>\n            <artifactid>log4j</artifactid>\n            <version>1.2.17</version>\n        </dependency>\n    \t\x3c!--xml解析 依赖--\x3e\n        <dependency>\n            <groupid>org.codehaus.plexus</groupid>\n            <artifactid>plexus-classworlds</artifactid>\n            <version>2.5.2</version>\n        </dependency>\n        \x3c!--xml解析 依赖--\x3e\n        <dependency>\n            <groupid>org.mybatis.generator</groupid>\n            <artifactid>mybatis-generator-core</artifactid>\n            <version>1.3.5</version>\n        </dependency>\n    </dependencies>\n    \n    <build>\n        <plugins>\n            \x3c!--反向生成插件--\x3e\n            <plugin>\n                <groupid>org.mybatis.generator</groupid>\n                <artifactid>mybatis-generator-maven-plugin</artifactid>\n                <version>1.3.5</version>\n                <configuration>\n                    \x3c!--配置文件的路径--\x3e\n                    <configurationfile>src/main/resources/generatorconfig.xml</configurationfile>\n                    <overwrite>true</overwrite>\n                </configuration>\n                <dependencies>\n                    <dependency>\n                        <groupid>org.mybatis.generator</groupid>\n                        <artifactid>mybatis-generator-core</artifactid>\n                        <version>1.3.5</version>\n                    </dependency>\n                </dependencies>\n            </plugin>\n        </plugins>\n    </build>\n\n</project>\n\n\n创建逆向生成配置文件 ==resources/generatorconfig.xml==\n\n<?xml version="1.0" encoding="utf-8"?>\n<!doctype generatorconfiguration\n        public "-//mybatis.org//dtd mybatis generator configuration 1.0//en"\n        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">\n\n\x3c!-- 配置生成器 --\x3e\n<generatorconfiguration>\n    \x3c!--1、数据库驱动jar:添加自己的jar路径 --\x3e\n    <classpathentry\n            location="d:\\maven\\repository\\mysql\\mysql-connector-java\\8.0.23\\mysql-connector-java-8.0.23.jar" />\n    <context id="mybatis" targetruntime="mybatis3">\n        \x3c!--去除注释 --\x3e\n        <commentgenerator>\n            <property name="suppressallcomments" value="true" />\n        </commentgenerator>\n        \x3c!--2、数据库连接 --\x3e\n        <jdbcconnection driverclass="com.mysql.cj.jdbc.driver"\n                        connectionurl="jdbc:mysql://127.0.0.1:3306/mybatis?useunicode=true&amp;characterencoding=utf-8&amp;usessl=false&amp;servertimezone=gmt"\n                        userid="root"\n                        password="root">\n        </jdbcconnection>\n        \x3c!--\n        默认false，把jdbc decimal 和 numeric 类型解析为 integer;\n        为 true时把jdbc decimal和numeric类型解析为java.math.bigdecimal\n            false: integer\n            true: bigdecimal (双精度浮点型变量double可以处理16位有效数)\n         --\x3e\n        <javatyperesolver>\n            <property name="forcebigdecimals" value="false" />\n        </javatyperesolver>\n        \x3c!--3、生成实体类 指定包名 以及生成的地址 （可以自定义地址，但是路径不存在不会自动创建\n        使用maven生成在target目录下，会自动创建） --\x3e\n        <javamodelgenerator targetpackage="com.pojo"\n                            targetproject="src\\main\\java">\n            <property name="trimstrings" value="true" />\n        </javamodelgenerator>\n        \x3c!--4、生成sqlmapper.xml映射文件 --\x3e\n        <sqlmapgenerator targetpackage="com.mapper"\n                         targetproject="src\\main\\resources">\n        </sqlmapgenerator>\n        \x3c!--5、生成dao（mapper）接口文件,--\x3e\n        <javaclientgenerator type="xmlmapper"\n                             targetpackage="com.mapper"\n                             targetproject="src\\main\\java">\n        </javaclientgenerator>\n        \x3c!--6、要生成哪些表(更改tablename和domainobjectname就可以) --\x3e\n        \x3c!-- tablename:要生成的表名\n        enablecountbyexample:count语句中加入where条件查询，默认为true开启\n        enableupdatebyexample:update语句中加入where条件查询，默认为true开启\n        enabledeletebyexample:delete语句中加入where条件查询，默认为true开启\n        enableselectbyexample:select多条语句中加入where条件查询，默认为true开启\n        selectbyexamplequeryid:select单个对象语句中加入where条件查询，默认为true开启\n        --\x3e\n\x3c!--        <table tablename="team"--\x3e\n\x3c!--               enablecountbyexample="false"--\x3e\n\x3c!--               enableupdatebyexample="false"--\x3e\n\x3c!--               enableupdatebyprimarykey="false"--\x3e\n\x3c!--               enabledeletebyexample="false"--\x3e\n\x3c!--               enabledeletebyprimarykey="false"--\x3e\n\x3c!--               enableselectbyexample="false"--\x3e\n\x3c!--               selectbyexamplequeryid="false">--\x3e\n\x3c!--            <property name="useactualcolumnnames" value="true"/>--\x3e\n\x3c!--        </table>--\x3e\n        <table tablename="team">\n            \x3c!--应用 库中对应的名称 (大小写也搬过去)--\x3e\n            <property name="useactualcolumnnames" value="true"/>\n        </table>\n        <table tablename="player">\n            <property name="useactualcolumnnames" value="true"/>\n        </table>\n        <table tablename="gamerecord">\n            <property name="useactualcolumnnames" value="true"/>\n        </table>\n    </context>\n</generatorconfiguration>\n\n\nmaven插件 反向生成 插件命令行：==mybatis-generator:generate==\n\n\n\n测试（应用测试主要部分，多余就不赘述了）\n\nimport com.mapper.teammapper;\nimport com.pojo.team;\nimport com.pojo.teamexample;\nimport com.utils.mybatisutil;\nimport org.junit.test;\n\nimport java.util.date;\nimport java.util.list;\n\npublic class teamtest {\n\n    private teammapper teammapper = mybatisutil.getsqlsession().getmapper(teammapper.class);\n    \n    //查 主键\n    @test\n    public void test01() {\n        team team = teammapper.selectbyprimarykey(1019);\n        system.out.println("team : " + team);\n    }\n    \n    //查总数 无约束\n    @test\n    public void test02() {\n        \n        teamexample example = new teamexample();\n        //查总数\n        long l = teammapper.countbyexample(example);\n        system.out.println("l : " + l);\n    \n    }\n    \n    //添加\n    @test\n    public void test03() {\n    \n        team team = new team();\n        team.setteamname("bozhu-test");\n        int insert = teammapper.insert(team);\n        mybatisutil.getsqlsession().commit();\n        system.out.println("insert : " + insert);\n    }\n    \n    //动态添加\n    @test\n    public void test04() {\n        team team = new team();\n        team.setteamname("bozhu-test2");\n        int insert = teammapper.insertselective(team);\n        mybatisutil.getsqlsession().commit();\n        system.out.println("insert : " + insert);\n    }\n    \n    //修改 指定key\n    @test\n    public void test05() {\n        team team = teammapper.selectbyprimarykey(1026);\n        team.setteamname("老哥");\n        team.setlocation("bj");\n        team.setcreatetime(new date());\n        int i = teammapper.updatebyprimarykey(team);\n        mybatisutil.getsqlsession().commit();\n        system.out.println("i : " + i);\n    }\n    \n    //example约束 应用\n    \n    /**\n     * example 约束服务\n     *      criteria1容器 约束方法名\n     *          add+约束列+约束方式\n     *          ····\n     *      or：criteria2容器 约束方法名\n     *          add+约束列+约束方式\n     *          ····\n     */\n    @test\n    public void test06() {\n        //设置多条件 服务\n        teamexample example = new teamexample();\n        // criteria 多条件 容器\n        teamexample.criteria criteria = example.createcriteria();\n        // or 添加’或‘运算符 约束\n        teamexample.criteria criteria2 = example.or();\n        //为容器添加条件\n        criteria.andteamidbetween(1001,1100);\n        criteria2.andteamidbetween(1,3);\n        list<team> teamlist = teammapper.selectbyexample(example);\n        teamlist.foreach(team -> system.out.println(team));\n    }\n}\n\n\n\n# 分页插件\n\nmybatis分页查询，可直接 通过插件进行 快速实现分页功能！\n\n在配置中添加插件一定一定要遵循标签的顺序 查看顺序\n\n依赖包：\n\n * jsqlparser-0.9.5.jar\n * pagehelper-4.2.1.jar\n\nmybatis全局配置插件\n\n<configuration>\n\t...\n    <plugins>\n        \x3c!-- com.github.pagehelper为pagehelper类所在包名 --\x3e\n        <plugin interceptor="com.github.pagehelper.pagehelper">\n            <property name="dialect" value="mysql" />\n            \x3c!-- 3.3.0版本可用 - 分页参数合理化，默认false禁用 --\x3e\n            \x3c!-- 启用合理化时，如果pagenum<1会查询第一页，如果pagenum>pages会查询最后一页 --\x3e\n            \x3c!-- 禁用合理化时，如果pagenum<1或pagenum>pages会返回空数据 --\x3e\n            <property name="reasonable" value="true" />\n        </plugin>\n    </plugins>\n    ...\n</configuration>\n\n\n测试\n\n@test\npublic void test() {\n    empmapper mapper = mybatisutil.getsession().getmapper(empmapper.class);\n    \n    int pagenum = 2;\n    int pagesize = 5;\n    \n    // 以下分页代码必须定义在 sql查询前的语句，否则分页查询会失效\n    pagehelper.startpage(pagenum , pagesize);\n    list<emp> emps = mapper.selectbyexample(null);\n    \n    emps.foreach(system.out::println);\n    \n    pageinfo<emp> page = new pageinfo<>(emps);\n    system.out.println("总记录数：" + page.gettotal());\n    system.out.println("总页数：" + page.getpages());\n    system.out.println("上页：" + page.getprepage());\n    system.out.println("下页：" + page.getnextpage());\n}\n\n\n\n# mybatis问题\n\n\n# 线程优化\n\nthreadlocal\n\nthreadlocal是一个线程内部的存储类，可以在指定线程内存储数据，数据存储以后，只有指定线程可以得到存储数据\n\nsqlsession线程是不安全的线程，利用threadlocal实现多线程也能独立完成业务，防止sqlsession同时访问并发问题\n\nthreadlocal可看作集合容器 ，里面存放的都是唯一且都是相同的副本，里面存储的对象都是独立的\n\nthreadlocal不是一个线程的本地实现版本，也不是一个thread。threadlocal是为每一个使用该变量的线程都提供一个变量值的副本， 是java中一种较为特殊的线程绑定机制，是每一个线程都可以独立地改变自己的副本，而不会和其它线程的副本冲突\n\n实现应用\n\n项目结构（在原有的基础上优化）\n\n  .\n  |\n  ├── src\n  |    ├── main\n  |\t   |\t├── java\n  |\t   |\t|\t  └── com\n  |\t   |    |   \t   ├── dao\n  |    |    |          |\t├── teamdao\n  |    |    |          |    └── teamdaoimpl\n  |\t   |\t|\t  \t   ├── pojo\n  |\t   |\t|\t  \t   |\t├── team\n  |\t   |\t|\t\t   |\t└── team.xml\n  |\t   |    | \t\t   └── utils\t\t\n  |\t   |    |    \t   \t\t└── mybatisutil\n  |\t   |\t└──\tresources\n  |\t   |\t\t    ├── log4j.properties\n  |\t   |\t\t\t└── mybatis.xml\n  |\t  test\n  |    └── ...\n  └── pom.xml\n\n\n添加映射sql ==team.xml==\n\n<?xml version="1.0" encoding="utf-8" ?>\n<!doctype mapper\n        public "-//mybatis.org//dtd mapper 3.0//en"\n        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n\x3c!--namespace="名称必须与映射的类的名字一致，是完全限定名"--\x3e\n<mapper namespace="com.pojo.team">\n\n    \x3c!--\n    id="自定义名称，id不能重复；相当于dao中的方法名称"\n    resulttype="使用的要求：实体类中的属性名与表中的列名一致"\n    --\x3e\n\x3c!--    查询所有--\x3e\n    <select id="findall" resulttype="com.pojo.team">\n        select * from team;\n    </select>\n\n\x3c!--    查询指定--\x3e\n    <select id="findid" resulttype="com.pojo.team">\n        select * from team where teamid=#{teamid}\n    </select>\n    <select id="findname" resulttype="com.pojo.team">\n        select * from team where teamname=#{teamname}\n    </select>\n\n    \x3c!--\n    parametertype="指定对象作为参数"\n    #{对象属性名}\n    --\x3e\n\x3c!--    添加数据--\x3e\n    <insert id="add" parametertype="com.pojo.team">\n        insert into `mybatis`.`team`(`teamname`, `location`, `createtime`) values (#{teamname}, #{location}, #{createtime})\n    </insert>\n\n\x3c!--    修改数据--\x3e\n    <update id="updatebyid"  parametertype="com.pojo.team">\n        update `team` set teamname=#{teamname},location=#{location} where teamid=#{teamid}\n    </update>\n\n\x3c!--    删除数据--\x3e\n    <delete id="deletebyid" parametertype="com.pojo.team">\n        delete from `mybatis`.`team` where `teamid` = #{id}\n    </delete>\n    <delete id="deletebyname" parametertype="com.pojo.team">\n        delete  from `mybatis`.`team` where `teamname` = #{name}\n    </delete>\n\n</mapper>\n\n\n工具类实现 ==mybatisutil== （应用主要）\n\npackage com.utils;\n\nimport org.apache.ibatis.io.resources;\nimport org.apache.ibatis.session.sqlsession;\nimport org.apache.ibatis.session.sqlsessionfactory;\nimport org.apache.ibatis.session.sqlsessionfactorybuilder;\n\nimport java.io.ioexception;\nimport java.io.reader;\n\npublic class mybatisutil {\n    \n    private static sqlsessionfactory sqlsessionfactory;\n    private static threadlocal<sqlsession> sqlsessionthreadlocal = new threadlocal<>();\n    \n    static {\n        try {\n            reader reader = resources.getresourceasreader("mybatis.xml");\n            sqlsessionfactory = new sqlsessionfactorybuilder().build(reader);\n        } catch (ioexception e) {\n            e.printstacktrace();\n        }\n    }\n    \n    public static sqlsession getsqlsession(){\n        sqlsession sqlsession = sqlsessionthreadlocal.get();\n        if (sqlsession == null){\n            sqlsession = sqlsessionfactory.opensession();\n            sqlsessionthreadlocal.set(sqlsession);\n        }\n        return sqlsession;\n    }\n    \n    public static void close() {\n        sqlsession sqlsession = sqlsessionthreadlocal.get();\n        if (sqlsession != null) {\n            sqlsession.close();\n            sqlsessionthreadlocal.remove();\n        }\n    }\n    \n}\n\n\n实现dao，创建 ==teamdaoimpl接口==\n\npackage com.dao;\nimport com.pojo.team;\nimport java.util.list;\n\npublic interface teamdaoimpl {\n    public list<team> findall();\n    public team querybyid(int id);\n    public team querybyname(string name);\n    public int add(team team);\n    public int updatebyid(int id , team newteam);\n    public int updatebyname(string name , team newteam);\n    public int delbyid(int id);\n    public int delbyname(string name);\n}\n\n\n创建 ==teamdao实现类== （业务实现）\n\npackage com.dao;\n\nimport com.pojo.team;\nimport com.utils.mybatisutil;\nimport org.apache.ibatis.session.sqlsession;\n\nimport java.util.list;\n\npublic class teamdao implements teamdaoimpl{\n    \n    @override\n    public list<team> findall() {\n        sqlsession sqlsession = mybatisutil.getsqlsession();\n        list<team> teams = sqlsession.selectlist("com.pojo.team.findall");\n        sqlsession.commit();\n        return teams;\n    }\n    \n    @override\n    public team querybyid(int id) {\n        sqlsession sqlsession = mybatisutil.getsqlsession();\n        return sqlsession.selectone("com.pojo.team.querybyid" , id);\n    }\n    \n    @override\n    public team querybyname(string name) {\n        sqlsession sqlsession = mybatisutil.getsqlsession();\n        return sqlsession.selectone("com.pojo.team.querybyname" , name);\n    }\n    \n    @override\n    public int add(team team) {\n        sqlsession sqlsession = mybatisutil.getsqlsession();\n        int num = sqlsession.insert("com.pojo.team.add",team);\n        sqlsession.commit();\n        return num;\n    }\n    \n    @override\n    public int updatebyid(int id ,team newteam) {\n        sqlsession sqlsession = mybatisutil.getsqlsession();\n        team team = sqlsession.selectone("com.pojo.team.querybyid" , id);\n        team.setteamname(newteam.getteamname());\n        team.setlocation(newteam.getlocation());\n        int num = sqlsession.update("com.pojo.team.updatebyid" , team);\n        sqlsession.commit();\n        return num;\n    }\n    \n    @override\n    public int updatebyname(string name , team newteam) {\n        sqlsession sqlsession = mybatisutil.getsqlsession();\n        team team = sqlsession.selectone("com.pojo.team.querybyname" , name);\n        team.setteamname(newteam.getteamname());\n        team.setlocation(newteam.getlocation());\n        int num = sqlsession.update("com.pojo.team.updatebyid" , team);\n        sqlsession.commit();\n        return num;\n    }\n    \n    @override\n    public int delbyid(int id) {\n        sqlsession sqlsession = mybatisutil.getsqlsession();\n        int num = sqlsession.delete("com.pojo.team.deletebyid" , id);\n        sqlsession.commit();\n        return num;\n    }\n    \n    @override\n    public int delbyname(string name) {\n        sqlsession sqlsession = mybatisutil.getsqlsession();\n        int num = sqlsession.delete("com.pojo.team.deletebyname" , name);\n        sqlsession.commit();\n        return num;\n    }\n    \n}\n\n\n测试类 (前提数据库中要有相应数据)\n\nimport com.dao.teamdao;\nimport com.dao.teamdaoimpl;\nimport com.pojo.team;\nimport org.junit.test;\n\nimport java.util.date;\nimport java.util.list;\n\npublic class daoapp {\n    \n    teamdaoimpl teamdao = new teamdao();\n    \n    @test\n    public void testfindall() {\n        list<team> all = teamdao.findall();\n        all.foreach(team -> system.out.println(team));\n    }\n    \n    @test\n    public void testquerybyid() {\n        team team = teamdao.querybyid(1009);\n        system.out.println("team : " + team);\n    }\n    \n    @test\n    public void testquerybyname() {\n        team team = teamdao.querybyname("老八");\n        system.out.println("team : " + team);\n    }\n    \n    @test\n    public void testadd() {\n        team team = new team("火箭","洛杉矶",new date());\n        int add = teamdao.add(team);\n        system.out.println("add : " + add);\n    }\n    \n    @test\n    public void testupdatebyid() {\n        team newteam = new team("老鸽","上海");\n        int i = teamdao.updatebyid(1004 , newteam);\n        system.out.println("i : " + i);\n    }\n    \n    @test\n    public void testupdatebyname() {\n        team newteam = new team("法外狂徒","南京");\n        int i = teamdao.updatebyname("老鸽" , newteam);\n        system.out.println("i : " + i);\n    }\n    \n    @test\n    public void testdelbyid() {\n        int i = teamdao.delbyid(1004);\n        system.out.println("i : " + i);\n    }\n    \n    @test\n    public void testdelbyname() {\n        int num = teamdao.delbyname("火箭");\n        system.out.println("num : " + num);\n    }\n}\n\n\n\n# sql语句字段调配问题\n\n# 库添加获取id问题\n\n数据库 在添加对象 的时候 序列 都是也默认形式在 数据库 中进行自增的 ，并且自增后 后端是获取不到该对象的自增数据，因此可通过以下方式进行 自定义添加并获取\n\n> 主要涉及点：\n> \n>  * 配置映射 文件 ，insert标签 中 添加 selectkey标签 进行 对指定列 的值 自定义添加并获取\n>  * selectkey标签属性说明：\n>    * keyproperty：表示自增的id值 赋值 到哪个实体类的属性\n>    * order：after(之后)、before(之前)两值，表示在sql语句执行 之前 或 之后\n>      * 一般情况 before 用于 指定id并获取；after 用于 获取自增后的id值\n>    * resulttype：表示返回值类型\n\n实现应用\n\n项目结构（在原有的基础上优化）\n\n  .\n  |\n  ├── src\n  |    ├── main\n  |\t   |\t├── java\n  |\t   |\t|\t  └── com\n  |\t   |    |   \t   ├── ···\n  |\t   |\t|\t  \t   ├── pojo\n  |\t   |\t|\t  \t   |\t└── gamerecord\n  |\t   |    | \t\t   └── utils\t\t\n  |\t   |    |    \t   \t\t└── mybatisutil\n  |\t   |\t└──\tresources\n  |\t   |            ├── com\n  |\t   |            |\t └── mapper\n  |\t   |            |\t\t   ├──gamerecordmapper.xml\n  |\t   |            |\t\t   └──teammapper.xml\n  |\t   |\t\t    ├── log4j.properties\n  |\t   |\t\t\t└── mybatis.xml\n  |\t  test\n  |    └── ...\n  └── pom.xml\n\n\n数据库添加表（球队比赛信息）\n\ncreate table `gamerecord` (\n  `recordid` varchar(36) character set utf8 collate utf8_general_ci not null,\n  `hometeamid` int default null comment \' 主队id\',\n  `gamedate` datetime default null comment \'比赛时间\',\n  `score` int default null comment \'得分\',\n  `visitingteamid` int default null comment \'客队id\',\n  primary key (`recordid`)\n) engine=innodb default charset=utf8;\n\n\n实体类对象 ==gamerecord==\n\npackage com.pojo;\n\nimport java.util.date;\n\n/**\n* classname: gamerecord\n* 球队记录实体类\n* @author wanglina\n* @version 1.0\n*/\npublic class gamerecord {\n    private string recordid;\n    private integer hometeamid;\n    private date gamedate;\n    private integer score;\n    private integer visitingteamid;\n    \n\t//省略 set 和 get 方法\n    \n    @override\n    public string tostring() {\n        return "gamerecord{" +\n                "recordid=\'" + recordid + \'\\\'\' +\n                ", hometeamid=" + hometeamid +\n                ", gamedate=" + gamedate +\n                ", score=" + score +\n                ", visitingteamid=" + visitingteamid +\n                \'}\';\n    }\n}\n\n\n创建接口 ==gamerecordmapper==\n\npackage com.mapper;\n\nimport com.pojo.gamerecord;\n\npublic interface gamerecordmapper {\n    int add(gamerecord gamerecord);\n}\n\n\n添加 ==resources/com/mapper/gamerecordmapper.xml== 配置文件 （order="before"应用）\n\n<?xml version="1.0" encoding="utf-8" ?>\n<!doctype mapper\n        public "-//mybatis.org//dtd mapper 3.0//en"\n        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">\n\x3c!--namespace="名称必须与映射的类的名字一致，是完全限定名"--\x3e\n<mapper namespace="com.mapper.gamerecordmapper">\n\n    \x3c!--\n    新增成功后将自增的id赋值给参数属性 的 teamid\n    selectkey标签属性说明：\n        keyproperty：表示自增的id值 赋值 到哪个实体类的属性\n        order：after(之后)、before(之前)两值，表示在sql语句执行 之前 或 之后\n\t\t\t一般情况 before 用于 指定id并获取；after 用于 获取自增后的id值\n        resulttype：表示返回值类型\n--\x3e\n    <insert id="add" parametertype="com.pojo.gamerecord">\n        <selectkey keyproperty="recordid" order="before" resulttype="java.lang.string">\n            select uuid();\n        </selectkey>\n        insert into `mybatis`.`gamerecord`(`recordid`, `hometeamid`, `gamedate`, `score`, `visitingteamid`)\n            values (#{recordid}, #{hometeamid}, #{gamedate}, #{score}, #{visitingteamid})\n    </insert>\n\n</mapper>\n\n\n修改==teammapper.xml==文件中的insert标签\n\n<insert id="add" parametertype="com.pojo.team">\n    <selectkey keyproperty="teamid" order="after" resulttype="java.lang.integer">\n        select last_insert_id()\n    </selectkey>\n    insert into `mybatis`.`team`(`teamname`, `location`, `createtime`) values (#{teamname}, #{location}, #{createtime})\n</insert>\n\n\n在 ==mybatis.xml配置文件== 中注册映射文件\n\n\x3c!-- 注册映射文件 --\x3e\n<mappers>\n\t···\n    <mapper resource="com/mapper/teammapper.xml"/>\n    <mapper resource="com/mapper/gamerecordmapper.xml"/>\n</mappers>\n\n\n测试：\n\nimport com.mapper.gamerecordmapper;\nimport com.mapper.teammapper;\nimport com.pojo.gamerecord;\nimport com.pojo.team;\nimport com.utils.mybatisutil;\nimport org.junit.test;\n\nimport java.util.date;\n\n//id自增测试\npublic class id_incrementtest {\n    \n    private teammapper teammapper = mybatisutil.getsqlsession().getmapper(teammapper.class);\n    private gamerecordmapper gamerecordmapper = mybatisutil.getsqlsession().getmapper(gamerecordmapper.class);\n    \n    @test\n    public void teammapper_order_after() {\n        team team = new team("哥斯拉","东京",new date());\n        int add = teammapper.add(team);\n        mybatisutil.getsqlsession().commit();\n        system.out.println("add : " + add);\n        system.out.println("team : " + team);\n    }\n    \n    @test\n    public void gamerecordmapper_order_before() {\n        gamerecord gamerecord = new gamerecord();\n        gamerecord.sethometeamid(1002);\n        gamerecord.setgamedate(new date());\n        gamerecord.setvisitingteamid(1001);\n        gamerecord.setscore(90);\n        int add = gamerecordmapper.add(gamerecord);\n        mybatisutil.getsqlsession().commit();\n        system.out.println("add : " + add);\n        system.out.println("gamerecord : " + gamerecord);\n    }\n    \n}\n\n\n\n# 映射问题\n\n# 数据库列名与实体类属性不匹配问题\n\n一般情况 数据库列名 和 实体类属性名 一样，在以上条件为前提下 mybatis 会自动匹配数据映射问题\n\n> 解决方案：\n> \n>  1. sql 查询的别名 与 实体类属性名 一致\n>  2. 通过resultmap自行映射\n\n数据库 表 列名\n\n> teamid、teamname、location、createtime\n\n创建 ==team2实体类==\n\npackage com.pojo;\n\nimport java.util.date;\n\n/**\n * @author sans\n */\n//用于映射测试\npublic class team2 {\n    private integer team_id;\n    private string team_name;\n    private string location;\n    private date createtime;\n    \n\t//set和get 省略\n    \n    @override\n    public string tostring() {\n        return "team2{" +\n                "team_id=" + team_id +\n                ", team_name=\'" + team_name + \'\\\'\' +\n                ", location=\'" + location + \'\\\'\' +\n                ", createtime=" + createtime +\n                \'}\';\n    }\n}\n\n\n==teammapper接口方法==\n\npublic interface teammapper {\n    list<team2> queryall3();\n\tlist<team2> queryall4();\n}\n\n\n修改 ==teammapper.xml映射文件== 添加sql语句\n\n\x3c!--    库列名 与 类属性名 不一致问题--\x3e\n\x3c!--    解决方案1 (别名形式匹配)--\x3e\n<select id="queryall3" resulttype="com.pojo.team2">\n    select teamid \'team_id\',teamname \'team_name\',location,createtime from team\n</select>\n\x3c!--    解决方案2（自行配置映射）--\x3e\n<select id="queryall4" resultmap="basemap">\n    select * from team\n</select>\n<resultmap id="basemap" type="com.pojo.team2">\n    <id column="teamid" property="team_id" javatype="java.lang.integer"/>\n    <result column="teamname" property="team_name" javatype="java.lang.string"/>\n    <result column="location" property="location" javatype="java.lang.string"/>\n    <result column="createtime" property="createtime" javatype="java.util.date"/>\n</resultmap>\n\n\n测试：\n\n//处理自定义类型数据\n@test\npublic void queryall3() {\n    list<team2> teamlist = teammapper.queryall3();\n    teamlist.foreach(team -> system.out.println(team));\n}\n\n@test\npublic void queryall4() {\n    list<team2> teamlist = teammapper.queryall4();\n    teamlist.foreach(team -> system.out.println(team));\n}\n\n\n\n# 分页问题\n\n查询 处理出来的大量数据需要分页功能浏览大量数据，缓解查询结果带来的压力\n\n注意：\n\n * sql语句末尾不能添加 分号 ;\n\n应用\n\n添加依赖\n\n\x3c!--        分页应用--\x3e\n<dependency>\n    <groupid>com.github.pagehelper</groupid>\n    <artifactid>pagehelper</artifactid>\n    <version>5.2.1</version>\n</dependency>\n\n\n设置配置文件 ==mybatis.xml== （plugins标签节点 在 environments标签节点 之前）\n\n\x3c!--    配置分页插件--\x3e\n<plugins>\n    <plugin interceptor="com.github.pagehelper.pageinterceptor"/>\n</plugins>\n\n\n测试（在以往的基础上执行）\n\nprivate teammapper teammapper = mybatisutil.getsqlsession().getmapper(teammapper.class);\n\n\n//分页插件应用\n@test\npublic void pagetest() {\n    pagehelper.startpage(1,3);\n    list<team> all = teammapper.findall();\n    all.foreach(team -> system.out.println(team));\n    system.out.println("其他分页信息：");\n    pageinfo<team> info = new pageinfo<>(all);\n    system.out.println("当前页："+info.getpagenum());\n    system.out.println("总页数："+info.getpages());\n    system.out.println("前一页："+info.getprepage());\n    system.out.println("后一页："+info.getnextpage());\n    system.out.println("所有导航页号：");\n    for (int navigatepagenum : info.getnavigatepagenums()) {\n        system.out.println("\\t" + navigatepagenum);\n    }\n}\n\n/* 运行结果\n\nteam{teamid=1, teamname=\'张三\', location=\'上海\', createtime=thu jul 15 00:00:00 cst 2021}\nteam{teamid=2, teamname=\'李四\', location=\'深圳\', createtime=wed jun 02 00:00:00 cst 2021}\nteam{teamid=3, teamname=\'王五\', location=\'南京\', createtime=sun aug 01 00:00:00 cst 2021}\n其他分页信息：\n当前页：1\n总页数：3\n前一页：0\n后一页：2\n所有导航页号：\n\t1\n\t2\n\t3\n\n*/\n',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"SpringIOC",frontmatter:{title:"SpringIOC",author:"柏竹",permalink:"/backend/x1cutb",date:"2020-02-18T00:00:00.000Z",categories:["后端","框架"],tags:["spring"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/07.Spring/02.Spring%E6%A0%B8%E5%BF%83Loc.html",relativePath:"01.后端/07.Spring/02.Spring核心Loc.md",key:"v-2e058210",path:"/backend/x1cutb/",headers:[{level:2,title:"对象说明和获取",slug:"对象说明和获取",normalizedTitle:"对象说明和获取",charIndex:234},{level:3,title:"BeanFactory",slug:"beanfactory",normalizedTitle:"beanfactory",charIndex:197},{level:3,title:"ApplicationContext",slug:"applicationcontext",normalizedTitle:"applicationcontext",charIndex:211},{level:2,title:"Bean",slug:"bean",normalizedTitle:"bean",charIndex:197},{level:3,title:"应用示例",slug:"应用示例",normalizedTitle:"应用示例",charIndex:2534},{level:3,title:"Bean 作用域",slug:"bean-作用域",normalizedTitle:"bean 作用域",charIndex:2293},{level:2,title:"依赖注入 DI",slug:"依赖注入-di",normalizedTitle:"依赖注入 di",charIndex:5039},{level:3,title:"属性注入",slug:"属性注入",normalizedTitle:"属性注入",charIndex:5218},{level:3,title:"自动注入",slug:"自动注入",normalizedTitle:"自动注入",charIndex:11934},{level:4,title:"byName装配",slug:"byname装配",normalizedTitle:"byname装配",charIndex:12427},{level:4,title:"byType",slug:"bytype",normalizedTitle:"bytype",charIndex:2335},{level:2,title:"注解装配Bean",slug:"注解装配bean",normalizedTitle:"注解装配bean",charIndex:14232},{level:3,title:"包扫描",slug:"包扫描",normalizedTitle:"包扫描",charIndex:15491},{level:3,title:"自动注入",slug:"自动注入-2",normalizedTitle:"自动注入",charIndex:11934}],headersStr:"对象说明和获取 BeanFactory ApplicationContext Bean 应用示例 Bean 作用域 依赖注入 DI 属性注入 自动注入 byName装配 byType 注解装配Bean 包扫描 自动注入",content:'# Spring IOC\n\nIoc—Inversion of Control，即“控制反转”，不是什么技术，而是一种设计思想\n\nIoc 在开发中，无需自行实例对象，而是有 Spring Ioc容器 创建。Spring容器会负责控制程序之间的关系，而不是由代码直接控制，因此，控制权由 Spring容器 接管，控制权发生了反转，是Ioc设计思想\n\nSpring 提供了两种 IoC 容器，分别为 BeanFactory 和 ApplicationContext\n\n\n# 对象说明和获取\n\n\n# BeanFactory\n\nBeanFactory接口 是一个管理Bean的工厂, 也是最顶层的接口 , 定义了Ioc容器的基本功能规范 . 它主要根据xml配置文件中的定义Bean进行管理，主要负责初始化各种Bean对象\n\n可进行 延迟加载 , 他们会在调用的时候进行加载对象\n\n// 加载 xml文件\nBeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource("application.xml"));\nbeanFactory.getBean("...");\n\n\nBeanFactory有以下三个重要子接口 :\n\n * ListableBeanFactory接口 : Bean可序列化\n * HierarchicalBeanFactory接口 : Bean有继承关系 , 每个Bean有父Bean\n * AutowireCapableBeanFactory接口 : Bean的自动装配规则\n\n\n# ApplicationContext\n\nApplicationContext 是 BeanFactory 的子接口，也是 应用上下文。支持了 BeanFactory 的所有功能\n\nApplicationContext接口有两个常用的 实现类，主要用于加载配置文件的\n\n * ClassPathXmlApplicationContext 通过 类路径上下文加载\n   \n   ==new ClassPathXmlApplicationContext(<Spring配置文件的名>)==\n   \n   > 将普通路径解释为包含包路径的类路径资源名称（例如“mypackage/myresource.txt”）\n\n * FileSystemXmlApplicationContext 通过 文件系统路径/URL 加载指定配置文件\n   \n   ==new FileSystemXmlApplicationContext(<文件系统路径/URL>);==\n   \n   > **注意：**普通路径将始终被解释为相对于当前 VM 工作目录，即使它们以斜杠开头 使用显式的“file:”前缀来强制使用绝对文件路径\n\n对象获取实例\n\n//指定决定绝对路径的文件\nnew FileSystemXmlApplicationContext(new FileSystemResource("D:\\applicationContext.xml"));\n\n//指定相对根路径的文件\nnew ClassPathXmlApplicationContext("applicationContext.xml");\n\n\n\n# Bean\n\nSpring Bean标签 可以想象成 我们使用的 实例对象 ，Spring是通过在配置文件中进行调取出来的实例对象(反射原理) . 在以往的操作 是通过 硬编码 new 出来的新对象 ，因此 我们需要提前 编写好配置文件\n\nBean标签，因此我们需要自己手动配置Bean对象，以下有两种Spring配置文件支持的格式\n\n * Properties配置文件 （只能存在键值形式存在\n * XML配置文件\n\nXML配置文件\n\n该配置文件的根元素是 <beans>，该元素包含了多个 <bean> 子元素，每一个 <bean> 子元素定义了一个对象\n\n\x3c!-- 使用id属性定义person1，其对应的实现类为com.mengma.person1 （类路径及包路径）--\x3e\n<bean id="person1" class="com.mengma.person1 " />\n\x3c!--使用name属性定义person2，其对应的实现类为com.mengma.domain.Person2 （类路径及包路径） --\x3e\n<bean name="Person2" class="com.mengma.domain.Person2"/>\n\n\nbean标签属性说明\n\n属性               值                 说明\nid               String            Bean 的唯一标识符，Spring IoC 容器对 Bean的 配置和管理都通过该属性完成\nname             String            Bean 的名称，可通过 name属性 为同一个 Bean同时指定多个名称，每个名之间用 逗号/分号\n                                   隔开。Spring容器 可通过 name属性 配置和管理容器中的 Bean\nclass            String            Bean 的具体实现类 (全限定名\nscope            String            定义 的 [Bean作用域](#Bean 作用域) （点击跳转\nautowire         byName | byType   Bean自动装配，根据定义的 name/type 进行自动装配\nlazy-init        boolean           延迟加载 (默认false)，在getBean()方法调用时才实例\ninit-method      String            初始化对象方法\ndestroy-method   String            销毁对象方法\n\n\n# 应用示例\n\n实体类 People.calss\n\n类型       成员变量\nString   name\nString   age\n\n配置文件 applicationContext.xml\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    \x3c!-- Bean实例方式\n        - 构造器实例\n        - 静态工厂实例\n        - 实例工厂实例\n     --\x3e\n    \x3c!-- 无参构造器 --\x3e\n    <bean id="person1" class="com.sans.Person"/>\n    \x3c!-- 有参构造器 --\x3e\n    \x3c!-- Bean属性 初始化/销毁 --\x3e\n    <bean id="person2" class="com.sans.Person" init-method="init" destroy-method="destroy">\n        <constructor-arg index="0" value="张三"/>\n        <constructor-arg index="1" value="Spring挺简单的嘛"/>\n    </bean>\n\n    \x3c!-- 静态工厂实例 --\x3e\n    <bean id="personFactory1" class="com.sans.MyFactory" factory-method="instanceLisi" />\n\n    \x3c!-- 实例工厂实例 --\x3e\n    <bean id="factory" class="com.sans.MyFactory"/>\n    <bean id="personFactory2" factory-bean="factory" factory-method="instanceZhangsan"/>\n</beans>\n\n\n测试\n\n@Test\npublic void beanExampleTest() {\n    ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");\n    Person person1 = (Person) applicationContext.getBean("person1");\n    Person person2 = (Person) applicationContext.getBean("person2");\n    Person factory1 = (Person) applicationContext.getBean("personFactory1");\n    Person factory2 = (Person) applicationContext.getBean("personFactory2");\n\n    System.out.println("person1 = " + person1);\n    System.out.println("person2 = " + person2);\n    System.out.println("factory1 = " + factory1);\n    System.out.println("factory2 = " + factory2);\n\n    /* 结果：\n        Person对象初始化: Person{name=\'张三\', msg=\'Spring挺简单的嘛\'}\n        Person对象初始化: Person{name=\'null\', msg=\'null\'}\n        person1 = Person{name=\'null\', msg=\'null\'}\n        person2 = Person{name=\'张三\', msg=\'Spring挺简单的嘛\'}\n        factory1 = Person{name=\'李四\', msg=\'我也这么觉得！\'}\n        factory2 = Person{name=\'张三\', msg=\'Spring挺简单的嘛\'}\n     */\n}\n\n\n\n# Bean 作用域\n\nSpring Bean作用域，可方便的管理 Bean应用的时期 以及场景\n\n只需在 <bean>.scope属性 配置范围值即可。scope范围值有以下6种：\n\n属性值           说明\nsingleton     单例模式，每次在容器获取都是同一 Bean实例 (默认值)\nprototype     原型模式，每次在容器获取都是新的 Bean实例\nrequest       每次request请求，容器都会创建一个 Bean实例。该域只在当前 request 内有效\nsession       每次session会话，不同的会话使用的 Bean实例不同。该域仅在当前 Session 内有效\napplication   Web应用 共享一个 Bean实例。该域在当前 ServletContext 内有效（和单例模式差不多\nwebsocket     websocket 的作用域是 WebSocket ，即在整个 WebSocket 中有效\n\n\n# 依赖注入 DI\n\nDI—Dependency Injection，即 依赖注入。需要通过 简单的配置，而无需任何代码就可指定目标需要的资源。而注入的方式有：\n\n * setter\n * 构造器\n * 接口\n * 注解\n\n> Ioc 和 DI 是同一个概念的不同角度描述。IoC是一种思想；DI是实现它的手段 Spring框架使用依 赖注入实现IoC\n\n\n# 属性注入\n\nBean 属性注入，是将属性数据注入到 Bean 中的过程\n\n实现属性注入方式 ：\n\n * 构造函数注入\n * setter 注入\n\nbean标签 代表的是一个实例对象，实例对象中 包含多个 属性/子标签 等。以下说明当中的标签以及作用\n\nconstructor-arg标签 构造实例。应用的构造器指定的参数进行实例对象。该标签有以下属性\n\n属性      值        说明\nindex   String   传参的序号（从0开始\nvalue   String   指定传递的 常量值\nname    String   构造方法对应的 形参名称\nref     String   引用配置 Bean实例\ntype    String   传参的属性类型\n\n> **ref：**引用可通过 id/name 属性的值 进行引入\n\nproperty标签 set注入。该标签是通过 属性的set方法进行填充数据，因此属性一定要有set方法。该标签有以下属性\n\n属性      值        说明\nname    String   属性名称\nref     String   引用配置 Bean实例\nvalue   String   配置指定 常量值\n\n> 注意：\n> \n>  * name属性 在配置的时候，如果失去高亮，那么很有可能实体类没有配置该属性的 set方法 （前提：需要配置Spring上下文\n> \n>  * set注入P命名空间，使用前提父标签需要引入以下配置\n>    \n>    ==xmlns:p="http://www.springframework.org/schema/p"==\n\n集合属性配置 在配置当中难免会存在一些特殊情况，例如集合属性的配置。以下是 集合标签的说明\n\n标签        说明\n<array>   封装数组（可重复\n<list>    封装 List (可重复\n<set>     封装 Set（不可重复\n<map>     封装 Map （k和v均可任意类型\n<props>   封装 Map （k和v都是字符串类型\n\n * <array> 封装数组（可重复\n   \n   * <ref>.bean：引用对象元素\n   * <value>：常量值\n\n * <list> 封装List（可重复\n   \n   * <ref>.bean：引用对象元素\n   * <value>：常量值\n\n * <set> 封装 Set（不可重复\n   \n   * <ref>.bean：引用对象元素\n   * <value>：常量值\n\n * <map> 封装 Map （k和v均可任意类型\n   \n   * <entry>.key：Map键 K\n   \n   * <entry>.value：Map值 V\n     \n     > 键和值可以 都可以 引用实例对象。引用方式 属性名后缀添加 -ref\n\n * <props> 封装 Map （k和v都是字符串类型\n   \n   * <prop>.key：Map键 K\n   * <prop>：Map值 V（标签包裹\n\n应用示例\n\n步骤：\n\n 1. 编写好实体类的属性以及get/set方法\n 2. 在 xml/Properties 配置上编辑 bean实例\n 3. 通过 ==new ClassPathXmlApplicationContext(<配置文件路径>).getBean()==方法获取实例对象\n\n实体类 Person.class\n\npublic class Person {\n    private String name;\n    private String msg;\n\n    // 数组类型\n    private Person[] array;\n\n    // 集合 特殊应用\n    private List<Person> list;\n    private Set<String> set;\n    private Map<String, Object> map;\n    private Properties properties;\n\n    // 构造方法注入\n    public Person() {\n    }\n    \n    public Person(String name, String msg) {\n        this.name = name;\n        this.msg = msg;\n    }\n\n    // 省略 自动生成的 get/set 方法\n\n    @Override\n    public String toString() {\n        return "Person{" +\n                "name=\'" + name + \'\\\'\' +\n                ", msg=\'" + msg + \'\\\'\' +\n                \'}\';\n    }\n}\n\n\napplicationContext.xml\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:p="http://www.springframework.org/schema/p"\n       xsi:schemaLocation="http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    \x3c!-- 无参构造 --\x3e\n    <bean id="person1" class="com.sans.bean.Person"/>\n    \x3c!-- 全参构造 --\x3e\n    <bean id="person2" class="com.sans.bean.Person">\n        <constructor-arg index="0" value="张三"/>\n        <constructor-arg index="1" value="Spring挺简单的嘛"/>\n    </bean>\n\n    \x3c!-- set注入 --\x3e\n    <bean id="person3" class="com.sans.bean.Person">\n        <property name="name" value="李四"/>\n        <property name="msg" value="我也觉得"/>\n    </bean>\n    \x3c!-- P命名空间 set注入--\x3e\n    <bean id="person4" class="com.sans.bean.Person" p:name="王五" p:msg="还行吧！挺好的"/>\n    \x3c!-- set方法 集合注入 --\x3e\n    <bean id="person5" class="com.sans.bean.Person">\n\n        \x3c!-- 数组类型 --\x3e\n        <property name="array">\n            <array>\n                <ref bean="person1"/>\n                <ref bean="person2"/>\n                <ref bean="person3"/>\n                <ref bean="person4"/>\n            </array>\n        </property>\n        \n        \x3c!-- List类型 --\x3e\n        <property name="list">\n            <list>\n                <ref bean="person1"/>\n                <ref bean="person2"/>\n                <ref bean="person3"/>\n                <ref bean="person4"/>\n            </list>\n        </property>\n        \n        \x3c!-- Set类型 --\x3e\n        <property name="set">\n            <set>\n                <value>张三</value>\n                <value>李四</value>\n                <value>王五</value>\n            </set>\n        </property>\n\n        \x3c!-- Map类型 --\x3e\n        <property name="map">\n            <map>\n                <entry key="No1" value="张三" />\n                <entry key="No2" value="李四"/>\n                <entry key="No3" value="王五"/>\n            </map>\n        </property>\n\n        <property name="properties">\n            <props>\n                <prop key="No1">张三</prop>\n                <prop key="No2">李四</prop>\n                <prop key="No3">王五</prop>\n                <prop key="No4">12</prop>\n            </props>\n        </property>\n    </bean>\n</beans>\n\n\n测试结果\n\npublic class Demo {\n\n    ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");\n\n    /* 通过构造器 实例 */\n    @Test\n    public void constructor() {\n        Person person1 = (Person) applicationContext.getBean("person1");\n        Person person2 = (Person) applicationContext.getBean("person2");\n        System.out.println("person1 = " + person1);\n        System.out.println("person2 = " + person2);\n        /* 结果 toString方法直接打印\n            person1 = Person{name=\'null\', msg=\'null\'}\n            person2 = Person{name=\'张三\', msg=\'Spring挺简单的嘛\'}\n         */\n    }\n\n    /* set注入 实例 */\n    @Test\n    public void setInjection() {\n        Person person3 = (Person) applicationContext.getBean("person3");\n        Person person4 = (Person) applicationContext.getBean("person4");\n        Person person5 = (Person) applicationContext.getBean("person5");\n        System.out.println("person3 = " + person3);\n        System.out.println("person4 = " + person4);\n\n        // 由于 person4对象 针对了 数组/集合 类型的属性测试\n        System.out.println("person5.getArray() = " + Arrays.toString(person5.getArray()));\n        System.out.println("person5.getList() = ");\n        person5.getList().forEach(person -> System.out.println("\\t"+person));\n        System.out.println("person5.getSet() = " + person5.getSet());\n        System.out.println("person5.getMsg() = ");\n        person5.getMap().forEach((key, value) -> System.out.println("\\t"+key+" : "+value));\n        System.out.println("person5.getProperties() = " + person5.getProperties());\n        /* 结果 （PS: 由于有一个是无参的引用因此为null\n            person3 = Person{name=\'李四\', msg=\'我也觉得\'}\n            person4 = Person{name=\'王五\', msg=\'还行吧！挺好的\'}\n            person5.getArray() = [Person{name=\'null\', msg=\'null\'}, Person{name=\'张三\', msg=\'Spring挺简单的嘛\'}, Person{name=\'李四\', msg=\'我也觉得\'}, Person{name=\'王五\', msg=\'还行吧！挺好的\'}]\n            person5.getList() = \n            \tPerson{name=\'null\', msg=\'null\'}\n            \tPerson{name=\'张三\', msg=\'Spring挺简单的嘛\'}\n            \tPerson{name=\'李四\', msg=\'我也觉得\'}\n            \tPerson{name=\'王五\', msg=\'还行吧！挺好的\'}\n            person5.getSet() = [张三, 李四, 王五]\n            person5.getMsg() = \n            \tNo1 : 张三\n            \tNo2 : 李四\n            \tNo3 : 王五\n            person5.getProperties() = {No2=李四, No1=张三, No4=12, No3=王五}\n         */\n\n    }\n}\n\n\n\n# 自动注入\n\nSpring 的自动注入功能可以让 Spring容器 依据指定规则，为指定的 Bean 从应用的上下文中查找它所依赖的 Bean 并自动建立 Bean 之间的依赖关系。而这一过程是在完全不使用任何 <constructor-arg>.ref/ <property>.ref 形式配置Bean\n\n> 自动注入 主要作用是 简化 Spring 在 XML配置应用，因此在大工程中降低很多工作量\n\nSpring容器 默认不支持自动装配的，需要在配置文件中的 <bean>.autowire属性应用\n\n<bean>.autowire属性说明\n\n属性值           说明\nbyName        根据 名称 自动注入 (id/name均可引用\nbyType        根据 类型 自动注入\nconstructor   根据 构造器参数 的数据类型，进行 byType模式 的自动装配\ndefault       默认采用上一级元素 <beans>设置的自动装配规则（default-autowire）进行装配\nno            默认值，不使用自动注入\n\n# byName装配\n\nByName表示 按属性名称自动装配，配置文件中 <bean>.id/name属性值 必须与 类中属性名称 相同\n\n示例\n\nPerson实体对象 （省略\n\n实体工厂对象\n\npublic class MyFactory {\n    private Person person1;\n    private Person person2;\n    // 省略 自动生成的 set/get 方法\n}\n\n\n配置文件\n\n\x3c!-- 使用 id/name 属性 标明  --\x3e\n<bean id="person1" class="com.sans.bean.Person" p:name="张三" p:msg="Spring挺简单的嘛！"/>\n<bean name="person2" class="com.sans.bean.Person" p:name="李四" p:msg="我也觉得"/>\n\n\x3c!--  byName --\x3e\n<bean id="Myfactory" class="com.sans.MyFactory" autowire="byName"/>\n\n\n测试\n\n@Test\npublic void auotInjection() {\n    ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");\n    MyFactory factory = (MyFactory) applicationContext.getBean("Myfactory");\n\n    System.out.println(factory.getPerson1());\n    System.out.println(factory.getPerson2());\n    /* 结果：\n        Person{name=\'张三\', msg=\'Spring挺简单的嘛！\'}\n        Person{name=\'李四\', msg=\'我也觉得\'}\n    */\n}\n\n\n# byType\n\nbyType表示 按属性类型自动装配，配置文件中 被注入类中的属性类型 与 容器内的Bean类型 相同，则自动注入\n\n> 注意：\n> \n>  * 如果类中有一个以上的相同属性类型，那么该类型全部自动注入\n>  * 在Spring Ioc容器上下文应用中不能存在相同类型的 Bean实例，否则无法引用\n\n示例\n\nPerson实体对象 （省略\n\n实体工厂对象 （省略\n\n配置文件\n\n<bean id="person1" class="com.sans.bean.Person" p:name="张三" p:msg="Spring挺简单的嘛！"/>\n\x3c!--    不能存在相同类型\n<bean name="person2" class="com.sans.bean.Person" p:name="李四" p:msg="我也觉得"/>--\x3e\n\n\x3c!-- byClass --\x3e\n<bean id="Myfactory" class="com.sans.MyFactory" autowire="byType"/>\n\n\n测试\n\n@Test\npublic void auotInjection() {\n    ApplicationContext applicationContext = new ClassPathXmlApplicationContext("applicationContext.xml");\n    MyFactory factory = (MyFactory) applicationContext.getBean("Myfactory");\n\n    System.out.println(factory.getPerson1());\n    System.out.println(factory.getPerson2());\n    /* 结果：\n        Person{name=\'张三\', msg=\'Spring挺简单的嘛！\'}\n\t\tPerson{name=\'张三\', msg=\'Spring挺简单的嘛！\'}\n    */\n}\n\n\n\n# 注解装配Bean\n\n在 Spring 中，尽管使用 XML配置文件可实现 Bean 的装配工作，如果应用中 Bean 的数量较多，会导致 XML配置文件过于臃肿，从而给维护和升级带来一定的困难，因此 Spring 提供了注解应用，需要在原有的运行环境基础上做些变化，由此减少过多的Bean\n\n@Component\n\n在类上添加上 @Component注解 表示该类实例的对象的权限交给 Spring容器 。注解的value属性用于指定bean的 id值 或 name值 ，但一般情况可省略 value 属性！（该注解指定id是类名的首字母小写）\n\n以下注解与 @Component注解 用法和功能 相同，表达的含义不同！\n\n * @Repository dao层实现类的注解（持久层）\n * @Service service层实现类的注解（业务层）\n * @Controller controller层实现类的注解（控制层）\n\n> PS : 应用前提需要扫描 , 点击跳转\n\n@Value\n\n该 注解 是为指定属性 注入值。该注解用在 类的属性 或 指定set方法上 。 其注解注入 原理 和 set方法 写入是一样，因此 set方法 也可\n\npackage com;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class MyUser {\n    //方式1\n    @Value("001")\n    private int id;\n    @Value("张三")\n    private String name;\n    @Value("23")\n    private int age;\n    @Value("洛杉矶")\n    private String locateion;\n    \n    ···\n    \n    //方式2\n    @Value("001")\n    public void setId(int id) {\n        this.id = id;\n    }\n    @Value("张三")\n    public void setName(String name) {\n        this.name = name;\n    }\n    @Value("23")\n    public void setAge(int age) {\n        this.age = age;\n    }\n    @Value("洛杉矶")\n    public void setLocateion(String locateion) {\n        this.locateion = locateion;\n    }\n    \n   \t···\n}\n\n\n\n\n# 包扫描\n\n需要在 xml配置文件中配置组件扫描器，用于在指定包中扫描的注解。如果未添加扫描，则对象添加的注解 将无法实例化\n\nxml配置文件 添加扫描\n\n>  1. beans标签 配置属性 xmlns:context属性： ==xmlns:context="http://www.springframework.org/schema/context"== xsi:schemaLocation属性(添加值)： ==http://www.springframework.org/schema/context==\n>     \n>     ==http://www.springframework.org/schema/context/spring-context.xsd==\n>     \n>     ···\n>     <beans xmlns="http://www.springframework.org/schema/beans"\n>            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n>            xmlns:context="http://www.springframework.org/schema/context"\n>            xsi:schemaLocation="http://www.springframework.org/schema/beans\n>            http://www.springframework.org/schema/beans/spring-beans.xsd\n>            http://www.springframework.org/schema/context\n>            http://www.springframework.org/schema/context/spring-context.xsd">\n>     \t···\n>     </beans>\n>     \n> \n>  2. context:component-scan标签 指定包扫描 分隔符可以使用逗号（，）分号（；）还可以使用空格，不建议使用空格。\n>     \n>     <?xml version="1.0" encoding="UTF-8"?>\n>     <beans xmlns="http://www.springframework.org/schema/beans"\n>         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n>         xmlns:context="http://www.springframework.org/schema/context"\n>         xsi:schemaLocation="http://www.springframework.org/schema/beans\n>         http://www.springframework.org/schema/beans/spring-beans.xsd\n>         http://www.springframework.org/schema/context\n>         http://www.springframework.org/schema/context/spring-context.xsd">\n>     \x3c!--    包扫描 方法1: （包路径 Annotation.dao、Annotation.service、Annotation.controller）--\x3e\n>     \t    <context:component-scan base-package="Annotation.dao"/>\n>     \t    <context:component-scan base-package="Annotation.service"/>\n>     \t    <context:component-scan base-package="Annotation.controller"/>\n>     \x3c!--    包扫描 方法2: （包路径 Annotation.dao、Annotation.service、Annotation.controller）--\x3e\n>     \t    <context:component-scan base-package="Annotation.dao;Annotation.service;Annotation.dao"/>\n>     </beans>\n>     \n> \n>  3. 添加对应注解即可\n\n\n# 自动注入\n\n自动注入指定对象的前提，需要为该对象添加注解，且 上级包 或 指定类 有扫描到！\n\n@Autowired\n\n用于对 Bean 的 属性变量、属性Set方法 及构造方法进行标注（构造方法应用的前提，参数必须指定的是对应的实例对象），配合对应的注解处理器完成 Bean 的自动配置工作。默认按照 Bean 的类型 进行装配\n\n@Autowired 还有一个属性 required，默认值为 true，表示匹配失败后终止程序运行；若值为 false，则匹配失败后 其属性值为 null\n\n@Qualifier\n\n与 @Autowired 注解配合使用，会将默认的按 Bean类型 装配修改为按 Bean实例队形名称 装配，Bean 的实例名称由 @Qualifier 注解的 value参数 指定\n\n@Resource\n\n该注解 在jdk1.6版本以上 支持使用，Bean属性可指定按照 类型(type) 或 名称(name) 进行自动注入，可在 属性变量、属性Set方法 进行使用',normalizedContent:'# spring ioc\n\nioc—inversion of control，即“控制反转”，不是什么技术，而是一种设计思想\n\nioc 在开发中，无需自行实例对象，而是有 spring ioc容器 创建。spring容器会负责控制程序之间的关系，而不是由代码直接控制，因此，控制权由 spring容器 接管，控制权发生了反转，是ioc设计思想\n\nspring 提供了两种 ioc 容器，分别为 beanfactory 和 applicationcontext\n\n\n# 对象说明和获取\n\n\n# beanfactory\n\nbeanfactory接口 是一个管理bean的工厂, 也是最顶层的接口 , 定义了ioc容器的基本功能规范 . 它主要根据xml配置文件中的定义bean进行管理，主要负责初始化各种bean对象\n\n可进行 延迟加载 , 他们会在调用的时候进行加载对象\n\n// 加载 xml文件\nbeanfactory beanfactory = new xmlbeanfactory(new classpathresource("application.xml"));\nbeanfactory.getbean("...");\n\n\nbeanfactory有以下三个重要子接口 :\n\n * listablebeanfactory接口 : bean可序列化\n * hierarchicalbeanfactory接口 : bean有继承关系 , 每个bean有父bean\n * autowirecapablebeanfactory接口 : bean的自动装配规则\n\n\n# applicationcontext\n\napplicationcontext 是 beanfactory 的子接口，也是 应用上下文。支持了 beanfactory 的所有功能\n\napplicationcontext接口有两个常用的 实现类，主要用于加载配置文件的\n\n * classpathxmlapplicationcontext 通过 类路径上下文加载\n   \n   ==new classpathxmlapplicationcontext(<spring配置文件的名>)==\n   \n   > 将普通路径解释为包含包路径的类路径资源名称（例如“mypackage/myresource.txt”）\n\n * filesystemxmlapplicationcontext 通过 文件系统路径/url 加载指定配置文件\n   \n   ==new filesystemxmlapplicationcontext(<文件系统路径/url>);==\n   \n   > **注意：**普通路径将始终被解释为相对于当前 vm 工作目录，即使它们以斜杠开头 使用显式的“file:”前缀来强制使用绝对文件路径\n\n对象获取实例\n\n//指定决定绝对路径的文件\nnew filesystemxmlapplicationcontext(new filesystemresource("d:\\applicationcontext.xml"));\n\n//指定相对根路径的文件\nnew classpathxmlapplicationcontext("applicationcontext.xml");\n\n\n\n# bean\n\nspring bean标签 可以想象成 我们使用的 实例对象 ，spring是通过在配置文件中进行调取出来的实例对象(反射原理) . 在以往的操作 是通过 硬编码 new 出来的新对象 ，因此 我们需要提前 编写好配置文件\n\nbean标签，因此我们需要自己手动配置bean对象，以下有两种spring配置文件支持的格式\n\n * properties配置文件 （只能存在键值形式存在\n * xml配置文件\n\nxml配置文件\n\n该配置文件的根元素是 <beans>，该元素包含了多个 <bean> 子元素，每一个 <bean> 子元素定义了一个对象\n\n\x3c!-- 使用id属性定义person1，其对应的实现类为com.mengma.person1 （类路径及包路径）--\x3e\n<bean id="person1" class="com.mengma.person1 " />\n\x3c!--使用name属性定义person2，其对应的实现类为com.mengma.domain.person2 （类路径及包路径） --\x3e\n<bean name="person2" class="com.mengma.domain.person2"/>\n\n\nbean标签属性说明\n\n属性               值                 说明\nid               string            bean 的唯一标识符，spring ioc 容器对 bean的 配置和管理都通过该属性完成\nname             string            bean 的名称，可通过 name属性 为同一个 bean同时指定多个名称，每个名之间用 逗号/分号\n                                   隔开。spring容器 可通过 name属性 配置和管理容器中的 bean\nclass            string            bean 的具体实现类 (全限定名\nscope            string            定义 的 [bean作用域](#bean 作用域) （点击跳转\nautowire         byname | bytype   bean自动装配，根据定义的 name/type 进行自动装配\nlazy-init        boolean           延迟加载 (默认false)，在getbean()方法调用时才实例\ninit-method      string            初始化对象方法\ndestroy-method   string            销毁对象方法\n\n\n# 应用示例\n\n实体类 people.calss\n\n类型       成员变量\nstring   name\nstring   age\n\n配置文件 applicationcontext.xml\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    \x3c!-- bean实例方式\n        - 构造器实例\n        - 静态工厂实例\n        - 实例工厂实例\n     --\x3e\n    \x3c!-- 无参构造器 --\x3e\n    <bean id="person1" class="com.sans.person"/>\n    \x3c!-- 有参构造器 --\x3e\n    \x3c!-- bean属性 初始化/销毁 --\x3e\n    <bean id="person2" class="com.sans.person" init-method="init" destroy-method="destroy">\n        <constructor-arg index="0" value="张三"/>\n        <constructor-arg index="1" value="spring挺简单的嘛"/>\n    </bean>\n\n    \x3c!-- 静态工厂实例 --\x3e\n    <bean id="personfactory1" class="com.sans.myfactory" factory-method="instancelisi" />\n\n    \x3c!-- 实例工厂实例 --\x3e\n    <bean id="factory" class="com.sans.myfactory"/>\n    <bean id="personfactory2" factory-bean="factory" factory-method="instancezhangsan"/>\n</beans>\n\n\n测试\n\n@test\npublic void beanexampletest() {\n    applicationcontext applicationcontext = new classpathxmlapplicationcontext("applicationcontext.xml");\n    person person1 = (person) applicationcontext.getbean("person1");\n    person person2 = (person) applicationcontext.getbean("person2");\n    person factory1 = (person) applicationcontext.getbean("personfactory1");\n    person factory2 = (person) applicationcontext.getbean("personfactory2");\n\n    system.out.println("person1 = " + person1);\n    system.out.println("person2 = " + person2);\n    system.out.println("factory1 = " + factory1);\n    system.out.println("factory2 = " + factory2);\n\n    /* 结果：\n        person对象初始化: person{name=\'张三\', msg=\'spring挺简单的嘛\'}\n        person对象初始化: person{name=\'null\', msg=\'null\'}\n        person1 = person{name=\'null\', msg=\'null\'}\n        person2 = person{name=\'张三\', msg=\'spring挺简单的嘛\'}\n        factory1 = person{name=\'李四\', msg=\'我也这么觉得！\'}\n        factory2 = person{name=\'张三\', msg=\'spring挺简单的嘛\'}\n     */\n}\n\n\n\n# bean 作用域\n\nspring bean作用域，可方便的管理 bean应用的时期 以及场景\n\n只需在 <bean>.scope属性 配置范围值即可。scope范围值有以下6种：\n\n属性值           说明\nsingleton     单例模式，每次在容器获取都是同一 bean实例 (默认值)\nprototype     原型模式，每次在容器获取都是新的 bean实例\nrequest       每次request请求，容器都会创建一个 bean实例。该域只在当前 request 内有效\nsession       每次session会话，不同的会话使用的 bean实例不同。该域仅在当前 session 内有效\napplication   web应用 共享一个 bean实例。该域在当前 servletcontext 内有效（和单例模式差不多\nwebsocket     websocket 的作用域是 websocket ，即在整个 websocket 中有效\n\n\n# 依赖注入 di\n\ndi—dependency injection，即 依赖注入。需要通过 简单的配置，而无需任何代码就可指定目标需要的资源。而注入的方式有：\n\n * setter\n * 构造器\n * 接口\n * 注解\n\n> ioc 和 di 是同一个概念的不同角度描述。ioc是一种思想；di是实现它的手段 spring框架使用依 赖注入实现ioc\n\n\n# 属性注入\n\nbean 属性注入，是将属性数据注入到 bean 中的过程\n\n实现属性注入方式 ：\n\n * 构造函数注入\n * setter 注入\n\nbean标签 代表的是一个实例对象，实例对象中 包含多个 属性/子标签 等。以下说明当中的标签以及作用\n\nconstructor-arg标签 构造实例。应用的构造器指定的参数进行实例对象。该标签有以下属性\n\n属性      值        说明\nindex   string   传参的序号（从0开始\nvalue   string   指定传递的 常量值\nname    string   构造方法对应的 形参名称\nref     string   引用配置 bean实例\ntype    string   传参的属性类型\n\n> **ref：**引用可通过 id/name 属性的值 进行引入\n\nproperty标签 set注入。该标签是通过 属性的set方法进行填充数据，因此属性一定要有set方法。该标签有以下属性\n\n属性      值        说明\nname    string   属性名称\nref     string   引用配置 bean实例\nvalue   string   配置指定 常量值\n\n> 注意：\n> \n>  * name属性 在配置的时候，如果失去高亮，那么很有可能实体类没有配置该属性的 set方法 （前提：需要配置spring上下文\n> \n>  * set注入p命名空间，使用前提父标签需要引入以下配置\n>    \n>    ==xmlns:p="http://www.springframework.org/schema/p"==\n\n集合属性配置 在配置当中难免会存在一些特殊情况，例如集合属性的配置。以下是 集合标签的说明\n\n标签        说明\n<array>   封装数组（可重复\n<list>    封装 list (可重复\n<set>     封装 set（不可重复\n<map>     封装 map （k和v均可任意类型\n<props>   封装 map （k和v都是字符串类型\n\n * <array> 封装数组（可重复\n   \n   * <ref>.bean：引用对象元素\n   * <value>：常量值\n\n * <list> 封装list（可重复\n   \n   * <ref>.bean：引用对象元素\n   * <value>：常量值\n\n * <set> 封装 set（不可重复\n   \n   * <ref>.bean：引用对象元素\n   * <value>：常量值\n\n * <map> 封装 map （k和v均可任意类型\n   \n   * <entry>.key：map键 k\n   \n   * <entry>.value：map值 v\n     \n     > 键和值可以 都可以 引用实例对象。引用方式 属性名后缀添加 -ref\n\n * <props> 封装 map （k和v都是字符串类型\n   \n   * <prop>.key：map键 k\n   * <prop>：map值 v（标签包裹\n\n应用示例\n\n步骤：\n\n 1. 编写好实体类的属性以及get/set方法\n 2. 在 xml/properties 配置上编辑 bean实例\n 3. 通过 ==new classpathxmlapplicationcontext(<配置文件路径>).getbean()==方法获取实例对象\n\n实体类 person.class\n\npublic class person {\n    private string name;\n    private string msg;\n\n    // 数组类型\n    private person[] array;\n\n    // 集合 特殊应用\n    private list<person> list;\n    private set<string> set;\n    private map<string, object> map;\n    private properties properties;\n\n    // 构造方法注入\n    public person() {\n    }\n    \n    public person(string name, string msg) {\n        this.name = name;\n        this.msg = msg;\n    }\n\n    // 省略 自动生成的 get/set 方法\n\n    @override\n    public string tostring() {\n        return "person{" +\n                "name=\'" + name + \'\\\'\' +\n                ", msg=\'" + msg + \'\\\'\' +\n                \'}\';\n    }\n}\n\n\napplicationcontext.xml\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:p="http://www.springframework.org/schema/p"\n       xsi:schemalocation="http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd">\n\n    \x3c!-- 无参构造 --\x3e\n    <bean id="person1" class="com.sans.bean.person"/>\n    \x3c!-- 全参构造 --\x3e\n    <bean id="person2" class="com.sans.bean.person">\n        <constructor-arg index="0" value="张三"/>\n        <constructor-arg index="1" value="spring挺简单的嘛"/>\n    </bean>\n\n    \x3c!-- set注入 --\x3e\n    <bean id="person3" class="com.sans.bean.person">\n        <property name="name" value="李四"/>\n        <property name="msg" value="我也觉得"/>\n    </bean>\n    \x3c!-- p命名空间 set注入--\x3e\n    <bean id="person4" class="com.sans.bean.person" p:name="王五" p:msg="还行吧！挺好的"/>\n    \x3c!-- set方法 集合注入 --\x3e\n    <bean id="person5" class="com.sans.bean.person">\n\n        \x3c!-- 数组类型 --\x3e\n        <property name="array">\n            <array>\n                <ref bean="person1"/>\n                <ref bean="person2"/>\n                <ref bean="person3"/>\n                <ref bean="person4"/>\n            </array>\n        </property>\n        \n        \x3c!-- list类型 --\x3e\n        <property name="list">\n            <list>\n                <ref bean="person1"/>\n                <ref bean="person2"/>\n                <ref bean="person3"/>\n                <ref bean="person4"/>\n            </list>\n        </property>\n        \n        \x3c!-- set类型 --\x3e\n        <property name="set">\n            <set>\n                <value>张三</value>\n                <value>李四</value>\n                <value>王五</value>\n            </set>\n        </property>\n\n        \x3c!-- map类型 --\x3e\n        <property name="map">\n            <map>\n                <entry key="no1" value="张三" />\n                <entry key="no2" value="李四"/>\n                <entry key="no3" value="王五"/>\n            </map>\n        </property>\n\n        <property name="properties">\n            <props>\n                <prop key="no1">张三</prop>\n                <prop key="no2">李四</prop>\n                <prop key="no3">王五</prop>\n                <prop key="no4">12</prop>\n            </props>\n        </property>\n    </bean>\n</beans>\n\n\n测试结果\n\npublic class demo {\n\n    applicationcontext applicationcontext = new classpathxmlapplicationcontext("applicationcontext.xml");\n\n    /* 通过构造器 实例 */\n    @test\n    public void constructor() {\n        person person1 = (person) applicationcontext.getbean("person1");\n        person person2 = (person) applicationcontext.getbean("person2");\n        system.out.println("person1 = " + person1);\n        system.out.println("person2 = " + person2);\n        /* 结果 tostring方法直接打印\n            person1 = person{name=\'null\', msg=\'null\'}\n            person2 = person{name=\'张三\', msg=\'spring挺简单的嘛\'}\n         */\n    }\n\n    /* set注入 实例 */\n    @test\n    public void setinjection() {\n        person person3 = (person) applicationcontext.getbean("person3");\n        person person4 = (person) applicationcontext.getbean("person4");\n        person person5 = (person) applicationcontext.getbean("person5");\n        system.out.println("person3 = " + person3);\n        system.out.println("person4 = " + person4);\n\n        // 由于 person4对象 针对了 数组/集合 类型的属性测试\n        system.out.println("person5.getarray() = " + arrays.tostring(person5.getarray()));\n        system.out.println("person5.getlist() = ");\n        person5.getlist().foreach(person -> system.out.println("\\t"+person));\n        system.out.println("person5.getset() = " + person5.getset());\n        system.out.println("person5.getmsg() = ");\n        person5.getmap().foreach((key, value) -> system.out.println("\\t"+key+" : "+value));\n        system.out.println("person5.getproperties() = " + person5.getproperties());\n        /* 结果 （ps: 由于有一个是无参的引用因此为null\n            person3 = person{name=\'李四\', msg=\'我也觉得\'}\n            person4 = person{name=\'王五\', msg=\'还行吧！挺好的\'}\n            person5.getarray() = [person{name=\'null\', msg=\'null\'}, person{name=\'张三\', msg=\'spring挺简单的嘛\'}, person{name=\'李四\', msg=\'我也觉得\'}, person{name=\'王五\', msg=\'还行吧！挺好的\'}]\n            person5.getlist() = \n            \tperson{name=\'null\', msg=\'null\'}\n            \tperson{name=\'张三\', msg=\'spring挺简单的嘛\'}\n            \tperson{name=\'李四\', msg=\'我也觉得\'}\n            \tperson{name=\'王五\', msg=\'还行吧！挺好的\'}\n            person5.getset() = [张三, 李四, 王五]\n            person5.getmsg() = \n            \tno1 : 张三\n            \tno2 : 李四\n            \tno3 : 王五\n            person5.getproperties() = {no2=李四, no1=张三, no4=12, no3=王五}\n         */\n\n    }\n}\n\n\n\n# 自动注入\n\nspring 的自动注入功能可以让 spring容器 依据指定规则，为指定的 bean 从应用的上下文中查找它所依赖的 bean 并自动建立 bean 之间的依赖关系。而这一过程是在完全不使用任何 <constructor-arg>.ref/ <property>.ref 形式配置bean\n\n> 自动注入 主要作用是 简化 spring 在 xml配置应用，因此在大工程中降低很多工作量\n\nspring容器 默认不支持自动装配的，需要在配置文件中的 <bean>.autowire属性应用\n\n<bean>.autowire属性说明\n\n属性值           说明\nbyname        根据 名称 自动注入 (id/name均可引用\nbytype        根据 类型 自动注入\nconstructor   根据 构造器参数 的数据类型，进行 bytype模式 的自动装配\ndefault       默认采用上一级元素 <beans>设置的自动装配规则（default-autowire）进行装配\nno            默认值，不使用自动注入\n\n# byname装配\n\nbyname表示 按属性名称自动装配，配置文件中 <bean>.id/name属性值 必须与 类中属性名称 相同\n\n示例\n\nperson实体对象 （省略\n\n实体工厂对象\n\npublic class myfactory {\n    private person person1;\n    private person person2;\n    // 省略 自动生成的 set/get 方法\n}\n\n\n配置文件\n\n\x3c!-- 使用 id/name 属性 标明  --\x3e\n<bean id="person1" class="com.sans.bean.person" p:name="张三" p:msg="spring挺简单的嘛！"/>\n<bean name="person2" class="com.sans.bean.person" p:name="李四" p:msg="我也觉得"/>\n\n\x3c!--  byname --\x3e\n<bean id="myfactory" class="com.sans.myfactory" autowire="byname"/>\n\n\n测试\n\n@test\npublic void auotinjection() {\n    applicationcontext applicationcontext = new classpathxmlapplicationcontext("applicationcontext.xml");\n    myfactory factory = (myfactory) applicationcontext.getbean("myfactory");\n\n    system.out.println(factory.getperson1());\n    system.out.println(factory.getperson2());\n    /* 结果：\n        person{name=\'张三\', msg=\'spring挺简单的嘛！\'}\n        person{name=\'李四\', msg=\'我也觉得\'}\n    */\n}\n\n\n# bytype\n\nbytype表示 按属性类型自动装配，配置文件中 被注入类中的属性类型 与 容器内的bean类型 相同，则自动注入\n\n> 注意：\n> \n>  * 如果类中有一个以上的相同属性类型，那么该类型全部自动注入\n>  * 在spring ioc容器上下文应用中不能存在相同类型的 bean实例，否则无法引用\n\n示例\n\nperson实体对象 （省略\n\n实体工厂对象 （省略\n\n配置文件\n\n<bean id="person1" class="com.sans.bean.person" p:name="张三" p:msg="spring挺简单的嘛！"/>\n\x3c!--    不能存在相同类型\n<bean name="person2" class="com.sans.bean.person" p:name="李四" p:msg="我也觉得"/>--\x3e\n\n\x3c!-- byclass --\x3e\n<bean id="myfactory" class="com.sans.myfactory" autowire="bytype"/>\n\n\n测试\n\n@test\npublic void auotinjection() {\n    applicationcontext applicationcontext = new classpathxmlapplicationcontext("applicationcontext.xml");\n    myfactory factory = (myfactory) applicationcontext.getbean("myfactory");\n\n    system.out.println(factory.getperson1());\n    system.out.println(factory.getperson2());\n    /* 结果：\n        person{name=\'张三\', msg=\'spring挺简单的嘛！\'}\n\t\tperson{name=\'张三\', msg=\'spring挺简单的嘛！\'}\n    */\n}\n\n\n\n# 注解装配bean\n\n在 spring 中，尽管使用 xml配置文件可实现 bean 的装配工作，如果应用中 bean 的数量较多，会导致 xml配置文件过于臃肿，从而给维护和升级带来一定的困难，因此 spring 提供了注解应用，需要在原有的运行环境基础上做些变化，由此减少过多的bean\n\n@component\n\n在类上添加上 @component注解 表示该类实例的对象的权限交给 spring容器 。注解的value属性用于指定bean的 id值 或 name值 ，但一般情况可省略 value 属性！（该注解指定id是类名的首字母小写）\n\n以下注解与 @component注解 用法和功能 相同，表达的含义不同！\n\n * @repository dao层实现类的注解（持久层）\n * @service service层实现类的注解（业务层）\n * @controller controller层实现类的注解（控制层）\n\n> ps : 应用前提需要扫描 , 点击跳转\n\n@value\n\n该 注解 是为指定属性 注入值。该注解用在 类的属性 或 指定set方法上 。 其注解注入 原理 和 set方法 写入是一样，因此 set方法 也可\n\npackage com;\n\nimport org.springframework.beans.factory.annotation.value;\nimport org.springframework.stereotype.component;\n\n@component\npublic class myuser {\n    //方式1\n    @value("001")\n    private int id;\n    @value("张三")\n    private string name;\n    @value("23")\n    private int age;\n    @value("洛杉矶")\n    private string locateion;\n    \n    ···\n    \n    //方式2\n    @value("001")\n    public void setid(int id) {\n        this.id = id;\n    }\n    @value("张三")\n    public void setname(string name) {\n        this.name = name;\n    }\n    @value("23")\n    public void setage(int age) {\n        this.age = age;\n    }\n    @value("洛杉矶")\n    public void setlocateion(string locateion) {\n        this.locateion = locateion;\n    }\n    \n   \t···\n}\n\n\n\n\n# 包扫描\n\n需要在 xml配置文件中配置组件扫描器，用于在指定包中扫描的注解。如果未添加扫描，则对象添加的注解 将无法实例化\n\nxml配置文件 添加扫描\n\n>  1. beans标签 配置属性 xmlns:context属性： ==xmlns:context="http://www.springframework.org/schema/context"== xsi:schemalocation属性(添加值)： ==http://www.springframework.org/schema/context==\n>     \n>     ==http://www.springframework.org/schema/context/spring-context.xsd==\n>     \n>     ···\n>     <beans xmlns="http://www.springframework.org/schema/beans"\n>            xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n>            xmlns:context="http://www.springframework.org/schema/context"\n>            xsi:schemalocation="http://www.springframework.org/schema/beans\n>            http://www.springframework.org/schema/beans/spring-beans.xsd\n>            http://www.springframework.org/schema/context\n>            http://www.springframework.org/schema/context/spring-context.xsd">\n>     \t···\n>     </beans>\n>     \n> \n>  2. context:component-scan标签 指定包扫描 分隔符可以使用逗号（，）分号（；）还可以使用空格，不建议使用空格。\n>     \n>     <?xml version="1.0" encoding="utf-8"?>\n>     <beans xmlns="http://www.springframework.org/schema/beans"\n>         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n>         xmlns:context="http://www.springframework.org/schema/context"\n>         xsi:schemalocation="http://www.springframework.org/schema/beans\n>         http://www.springframework.org/schema/beans/spring-beans.xsd\n>         http://www.springframework.org/schema/context\n>         http://www.springframework.org/schema/context/spring-context.xsd">\n>     \x3c!--    包扫描 方法1: （包路径 annotation.dao、annotation.service、annotation.controller）--\x3e\n>     \t    <context:component-scan base-package="annotation.dao"/>\n>     \t    <context:component-scan base-package="annotation.service"/>\n>     \t    <context:component-scan base-package="annotation.controller"/>\n>     \x3c!--    包扫描 方法2: （包路径 annotation.dao、annotation.service、annotation.controller）--\x3e\n>     \t    <context:component-scan base-package="annotation.dao;annotation.service;annotation.dao"/>\n>     </beans>\n>     \n> \n>  3. 添加对应注解即可\n\n\n# 自动注入\n\n自动注入指定对象的前提，需要为该对象添加注解，且 上级包 或 指定类 有扫描到！\n\n@autowired\n\n用于对 bean 的 属性变量、属性set方法 及构造方法进行标注（构造方法应用的前提，参数必须指定的是对应的实例对象），配合对应的注解处理器完成 bean 的自动配置工作。默认按照 bean 的类型 进行装配\n\n@autowired 还有一个属性 required，默认值为 true，表示匹配失败后终止程序运行；若值为 false，则匹配失败后 其属性值为 null\n\n@qualifier\n\n与 @autowired 注解配合使用，会将默认的按 bean类型 装配修改为按 bean实例队形名称 装配，bean 的实例名称由 @qualifier 注解的 value参数 指定\n\n@resource\n\n该注解 在jdk1.6版本以上 支持使用，bean属性可指定按照 类型(type) 或 名称(name) 进行自动注入，可在 属性变量、属性set方法 进行使用',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Spring拓展",frontmatter:{title:"Spring拓展",author:"柏竹",permalink:"/backend/x1cutd",date:"2020-02-18T00:00:00.000Z",categories:["后端","框架"],tags:["spring"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/07.Spring/04.Spring%E6%8B%93%E5%B1%95.html",relativePath:"01.后端/07.Spring/04.Spring拓展.md",key:"v-34330dd8",path:"/backend/x1cutd/",headers:[{level:2,title:"SpringJDBC实现",slug:"springjdbc实现",normalizedTitle:"springjdbc实现",charIndex:15},{level:2,title:"Spring事务管理",slug:"spring事务管理",normalizedTitle:"spring事务管理",charIndex:10496},{level:3,title:"事务管理接口",slug:"事务管理接口",normalizedTitle:"事务管理接口",charIndex:10671},{level:3,title:"xml应用",slug:"xml应用",normalizedTitle:"xml应用",charIndex:9123},{level:3,title:"Annotation应用",slug:"annotation应用",normalizedTitle:"annotation应用",charIndex:18409}],headersStr:"SpringJDBC实现 Spring事务管理 事务管理接口 xml应用 Annotation应用",content:'# Spring拓展\n\n\n# SpringJDBC实现\n\nSpring 针对数据库开发提供了 JdbcTemplate 类，它封装了 JDBC，支持对数据库的所有操作\n\nJDBC以往的说明：Java学习记录 JDBC篇\n\n> Class JdbcTemplate\n> \n> org.springframework.jdbc.core.JdbcTemplate\n\n方法\n\n修饰符      返回                    方法                                          说明\npublic   int                   update(String sql)                          用于执行新增、修改、删除等语句\npublic   int                   update(String sql,Object... args)           用于执行新增、修改、删除等语句 args 表示需要传入的参数\npublic   void                  execute(String sql)                         可以执行任意 SQL，一般用于执行 DDL 语句 action 表示执行完 SQL 语句后，要调用的函数\npublic   T                     query(String sql, ResultSetExtractor rse)   用于执行查询语句 以 ResultSetExtractor 作为参数的 query 方法返回值为 Object\npublic   List                  query(String sql, RowMapper rse)            使用查询结果需要对其进行强制转型 以 RowMapper 作为参数的 query 方法返回值为 List\npublic   Map<String, Object>   queryForMap(String sql)                     SQL查询多个聚合函数结果值，查询出的结果值形式：key-value\n\nJDBC应用\n\n 1. 导入包 spring-jdbc-x.x.x.jar 、spring-tx-x.x.x.jar 以下为个人用Maven配置\n    \n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-jdbc</artifactId>\n        <version>5.2.13.RELEASE</version>\n    </dependency>\n    \n\n 2. Spring-xml配置数据源\n    \n    <?xml version="1.0" encoding="UTF-8"?>\n    <beans xmlns="http://www.springframework.org/schema/beans"\n           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n           xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">\n    \n    \x3c!--    XML 配置数据源--\x3e\n        <bean id="dateSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">\n            \x3c!--驱动加载--\x3e\n            <property name="driverClassName" value="com.mysql.jdbc.Driver"/>\n            \x3c!--连接数据库的url  . 本次连接 test库--\x3e\n         \t\x3c!--指定IP地址 、 库（个人应用的 test库）--\x3e   \n            <property name="url" value="jdbc:mysql://192.168.74.131/test"/>\n            <property name="username" value="root"/>\n            <property name="password" value="root"/>\n        </bean>\n    \n    \x3c!--    配置jdbc模板--\x3e\n        <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">\n            \x3c!--必须使用数据源--\x3e\n            <property name="dataSource" ref="dateSource"/>\n        </bean>\n    \n    \x3c!--    配置注入类使用--\x3e\n        <bean id="xxx" class="xxx">\n            <property name="jdbcTemplate" ref="jdbcTemplate"/>\n        </bean>\n    \x3c!--\t例如：--\x3e\n    \x3c!--    <bean id="studentDao" class="com.StudentDao">--\x3e\n    \x3c!--        <property name="jdbcTemplate" ref="jdbcTemplate"/>--\x3e\n    \x3c!--    </bean>--\x3e\n    \t...\n    </beans>\n    \n    \n    配置注入类需要自己指定类进行配置\n\n 3. 创建实体类 Student\n    \n    package com;\n    \n    public class Student {\n        int id ;\n        String name;\n        int age;\n        \n        public Student() {\n        }\n        \n        public Student(int id , String name , int age) {\n            this.id = id;\n            this.name = name;\n            this.age = age;\n        }\n        \n        public Student(String name , int age) {\n            this.name = name;\n            this.age = age;\n        }\n        \n        public int getAge() {\n            return age;\n        }\n        \n        public void setAge(int age) {\n            this.age = age;\n        }\n        \n        public int getId() {\n            return id;\n        }\n        \n        public void setId(int id) {\n            this.id = id;\n        }\n        \n        public String getName() {\n            return name;\n        }\n        \n        public void setName(String name) {\n            this.name = name;\n        }\n        \n        @Override\n        public String toString() {\n            return "Student{" +\n                    "id=" + id +\n                    ", name=\'" + name + \'\\\'\' +\n                    ", age=" + age +\n                    \'}\';\n        }\n    }\n    \n\n 4. 数据库 test库引入库\n    \n    ID   NAME   AGE\n    \n    DROP TABLE IF EXISTS `student`;\n    CREATE TABLE `student`  (\n      `id` int(11) NOT NULL AUTO_INCREMENT,\n      `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n      `age` int(11) NULL DEFAULT 16,\n      PRIMARY KEY (`id`) USING BTREE\n    ) ENGINE = InnoDB AUTO_INCREMENT = 16 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;\n    \n\n 5. 指定类注入使用 JdbcTemplate类 （应用指定实例 StudentDao；实现一个操作业务即可）\n    \n    package com;\n    \n    import org.springframework.dao.DataAccessException;\n    import org.springframework.jdbc.core.ResultSetExtractor;\n    import org.springframework.jdbc.core.RowMapper;\n    import org.springframework.jdbc.core.support.JdbcDaoSupport;\n    \n    import java.sql.ResultSet;\n    import java.sql.SQLException;\n    import java.util.List;\n    import java.util.Map;\n    \n    public class StudentDao extends JdbcDaoSupport {\n        \n        //方法封装\n        public Student turnEncapsulation(ResultSet resultSet) throws SQLException {\n            Student student = new Student();\n            student.setId(resultSet.getInt("id"));\n            student.setName(resultSet.getString("name"));\n            student.setAge(resultSet.getInt("age"));\n            return student;\n        }\n        \n        /**\n         * 添加数据\n         * @param student 学生类封装\n         * @return 更变条数\n         */\n        public int insert(Student student) {\n            if (student == null) {\n                return 0;\n            } \n            String sql = "INSERT INTO student(name,age) VALUE(?,?)";\n            return this.getJdbcTemplate().update(sql,student.getName(),student.getAge());\n        }\n        \n        /**\n         * 删除数据\n         * @param id 删除指定id\n         * @return 更变条数\n         */\n        public int delete(int id) {\n            String sql = "DELETE FROM student WHERE id = ?";\n            return this.getJdbcTemplate().update(sql,id);\n        }\n        \n        /**\n         * 更变数据\n         * @param id 指定学生id\n         * @param student 更变指定 学生类\n         * @return 更变条数\n         */\n        public int update(int id , Student student) {\n            String sql = "UPDATE student set name=?,age=? WHERE id=?";\n            return this.getJdbcTemplate().update(sql,student.getName(),student.getAge(),id);\n        }\n        \n        /**\n         * 查询所有条数\n         * @return 学生队列\n         */\n        public List<Student> queryAll(){\n            String sql = "SELECT * FROM student";\n            /* 原型\n            return this.getJdbcTemplate().query(sql , new RowMapper<Student>() {\n               @Override\n               public Student mapRow(ResultSet resultSet , int i) throws SQLException{\n                   System.out.println("\\ti : " + i);\n                   return turnEncapsulation(resultSet);\n               }\n            });\n    \t\t*/\n            // 简写 \n            return this.getJdbcTemplate().query(sql, (rs,i) -> turnEncapsulation(rs));\n        }\n        \n        /**\n         * 查询指定学生\n         * @param id 指定学生id\n         * @return 学生队列\n         */\n        public List<Student> queryFindById(int id) {\n            String sql = "SELECT * FROM student WHERE id = ?";\n            return this.getJdbcTemplate().query(sql,new Object[]{id}, new RowMapper<Student>() {\n                @Override\n                public Student mapRow(ResultSet resultSet , int i) throws SQLException {\n                    System.out.println("\\ti : " + i);\n                    return turnEncapsulation(resultSet);\n                }\n            });\n        }\n        \n        /**\n         * 查询指定学生名称\n         * @param name 名称\n         * @return 学生队列\n         */\n        public List<Student> queryFindByName(String name) {\n            String sql = "SELECT * FROM student WHERE name = ?";\n            //匿名 new RowMapper<Student>() 替换为 lambda\n            return this.getJdbcTemplate().query(sql,new Object[]{name}, (resultSet , i) -> {\n                System.out.println("\\ti : " + i);\n                return turnEncapsulation(resultSet);\n            });\n        }\n        \n        /**\n         * 聚合函数应用\n         */\n        /**\n         * 获取学生总数\n         * @return 学生总数\n         */\n        public int tableSize(){\n            String sql = "SELECT count(id) FROM student";\n            return this.getJdbcTemplate().queryForObject(sql,Integer.class);\n        }\n        \n        /**\n         * 学生首尾id\n         * @return MAP形式返回id首尾\n         */\n        public Map<String , Object> tableMaxMin(){\n            String sql = "SELECT max(id),min(id) FROM student";\n            return this.getJdbcTemplate().queryForMap(sql);\n        }\n        \n    }\n    \n\n 6. 测试类 （测试业务）\n    \n    package com;\n    \n    import com.mchange.v2.c3p0.ComboPooledDataSource;\n    import org.junit.Test;\n    import org.springframework.context.ApplicationContext;\n    import org.springframework.context.support.ClassPathXmlApplicationContext;\n    import org.springframework.jdbc.core.JdbcTemplate;\n    \n    import java.beans.PropertyVetoException;\n    import java.util.List;\n    import java.util.Map;\n    \n    //连接测试\n    public class connectionMySQL {\n    \n        ApplicationContext ac = new ClassPathXmlApplicationContext("springJDBC.xml");\n        StudentDao dao = (StudentDao) ac.getBean("studentDao");\n        \n        /**\n         * xml应用\n         */\n        @Test\n        public void test01_Insert(){\n            int insert = dao.insert(new Student("老哥" , 23));\n            System.out.println("insert : " + insert);\n        }\n        @Test\n        public void test02_Delete() {\n            int delete = dao.delete(19);\n            System.out.println("delete : " + delete);\n            \n        }\n        @Test\n        public void test03_Update() {\n            int update = dao.update(16,new Student("黑马",32));\n            System.out.println("update : " + update);\n        }\n        @Test\n        public void test04_Query() {\n            List<Student> student = dao.queryFindById(17);\n            System.out.println("student : " + student);\n        }\n        @Test\n        public void test04_Querys() {\n            List<Student> students = dao.queryAll();\n            // List<Student> students = dao.queryFindByName("李四");\n            for (Student student : students) {\n                System.out.println(student.toString());\n            }\n        }\n        @Test\n        public void test05_group(){\n            int i = dao.tableSize();\n            System.out.println("i : " + i);\n            System.out.println("==============");\n            Map<String, Object> stringObjectMap = dao.tableMaxMin();\n            System.out.println("stringObjectMap : " + stringObjectMap);\n        }\n        \n    }\n    \n\n\n# Spring事务管理\n\n事务（Transaction）是面向关系型数据库（RDBMS）企业应用程序的重要组成部分，用来确保数据的完整性和一致性。\n\n事务了解 ：MySQL学习记录 事务篇\n\nSpring 实现声明式事务管理主要有 2 种方式：\n\n * 基于 XML 方式的声明式事务管理\n * 通过 Annotation 注解方式的事务管理\n\n\n# 事务管理接口\n\nSpring 的事务管理 ：PlatformTransactionManager、TransactionDefinition 是事务主要核心接口\n\nPlatformTransactionManager接口\n\n该接口用于管理事务。其主要用于完成事务的提交、回滚，及获取 事务的状态信息\n\npublic interface PlatformTransactionManager extends TransactionManager {\n    TransactionStatus getTransaction(@Nullable TransactionDefinition var1) throws TransactionException;\n\n    void commit(TransactionStatus var1) throws TransactionException;\n\n    void rollback(TransactionStatus var1) throws TransactionException;\n}\n\n\n返回                  抽象方法                                                   说明\nTransactionStatus   getTransaction(@Nullable TransactionDefinition var1)   获取事务的状态信息\nvoid                commit(TransactionStatus var1)                         提交事务\nvoid                rollback(TransactionStatus var1)                       回滚事务\n\nTransactionDefinition接口\n\n该接口主要获取事务相关信息的作用\n\npublic interface TransactionDefinition {\n    ....\n\n    default int getPropagationBehavior() {\n        return 0;\n    }\n\n    default int getIsolationLevel() {\n        return -1;\n    }\n\n    default int getTimeout() {\n        return -1;\n    }\n\n    default boolean isReadOnly() {\n        return false;\n    }\n\n    @Nullable\n    default String getName() {\n        return null;\n    }\n\t....\n}\n\n\n返回        抽象方法                       说明\nint       getPropagationBehavior()   获取事务的 传播行为\nint       getIsolationLevel()        获取事务的 隔离级别\nint       getTimeout()               获取事务的 超时时间\nboolean   isReadOnly()               获取事务是否 只读\nString    getName()                  获取事务的 名称\n\n属性说明\n\n事务传播行为（propagation behavior）指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行。\n\n传播行为名称值                     说明\nPROPAGATION_MANDATORY       支持当前事务，如果不存在当前事务，则引发异常\nPROPAGATION_NESTED          如果当前事务存在，则在嵌套事务中执行\nPROPAGATION_NEVER           不支持当前事务，如果当前事务存在，则引发异常\nPROPAGATION_NOT_SUPPORTED   不支持当前事务，始终以非事务方式执行\nPROPAGATION_REQUIRED        默认传播行为，支持当前事务，如果不存在，则创建一个新的\nPROPAGATION_REQUIRES_NEW    创建新事务，如果已存在事务则暂停当前事务，应用新的\nPROPAGATION_SUPPORTS        支持当前事务，如果不存在事务，则以非事务方式执行\n\n\n# xml应用\n\n主要配置组件（.xml）\n\n<tx:advice id="txAdvice" transaction-manager="transactionManager">\n    <tx:attributes>\n        \x3c!--            <tx:method name="insert*" propagation="REQUIRED"/>--\x3e\n        \x3c!--            <tx:method name="add*" propagation="REQUIRED"/>--\x3e\n        \x3c!--            <tx:method name="find*" propagation="SUPPORTS" read-only="true"/>--\x3e\n        <tx:method name="*" />\n    </tx:attributes>\n</tx:advice>\n\x3c!--   aop编写，让Spring自动对目标生成代理，需要使用AspectJ的表达式 --\x3e\n<aop:config>\n    <aop:pointcut id="pt" expression="execution(* com.service..*.*(..))"/>\n    <aop:advisor advice-ref="txAdvice"  pointcut-ref="pt" />\n</aop:config>\n\n\n应用前提：\n\n添加依赖\n\n<dependency>\n    <groupId>org.aspectj</groupId>\n    <artifactId>aspectjweaver</artifactId>\n    <version>1.9.6</version>\n</dependency>\n\n\n实体类：（Student）\n\npackage com;\n\npublic class Student {\n    int id ;\n    String name;\n    int age;\n    \n    public Student() {\n    }\n    \n    public Student(int id , String name , int age) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n    }\n    \n    public Student(String name , int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    public int getAge() {\n        return age;\n    }\n    \n    public void setAge(int age) {\n        this.age = age;\n    }\n    \n    public int getId() {\n        return id;\n    }\n    \n    public void setId(int id) {\n        this.id = id;\n    }\n    \n    public String getName() {\n        return name;\n    }\n    \n    public void setName(String name) {\n        this.name = name;\n    }\n    \n    @Override\n    public String toString() {\n        return "Student{" +\n                "id=" + id +\n                ", name=\'" + name + \'\\\'\' +\n                ", age=" + age +\n                \'}\';\n    }\n}\n\n\nStudentDao类：（信息交互类）\n\npackage com.dao;\n\nimport com.Student;\nimport org.springframework.jdbc.core.support.JdbcDaoSupport;\n\npublic class StudentDao extends JdbcDaoSupport {\n    \n    /**\n     * 添加数据\n     * @param student 学生类封装\n     * @return 更变条数\n     */\n    public int insert(Student student) {\n        if (student == null) {\n            return 0;\n        }\n        String sql = "insert into student(name,age) value(?,?)";\n        return this.getJdbcTemplate().update(sql,student.getName(),student.getAge());\n    }\n    \n    //其他业务操作省略\n    ····\n}\n\n\nStudentService类：（业务处理类）\n\npackage com.service;\n\nimport com.Student;\nimport com.dao.StudentDao;\n\npublic class StudentService {\n    \n    private StudentDao studentDao;\n    \n    public void setStudentDao(StudentDao studentDao) {\n        this.studentDao = studentDao;\n    }\n    \n    public int insert(Student student){\n        int a = studentDao.insert(student);\n        System.out.println("(1)添加成功 数据: " + student + "\\t影响条目："+a);\n        int aa = 1/0;   //制造异常\n        student.setAge(student.getAge()+1);\n        int b = studentDao.insert(student);\n        System.out.println("(2)添加成功 数据: " + student + "\\t影响条目："+a);\n        return a+b;\n    }\n}\n\n\nSpring 容器配置：（.xml文件）\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:tx="http://www.springframework.org/schema/tx"\n       xmlns:aop="http://www.springframework.org/schema/aop"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       \n       xsi:schemaLocation="\n\t\t\thttp://www.springframework.org/schema/beans\n\t\t\thttp://www.springframework.org/schema/beans/spring-beans.xsd\n\t\t\thttp://www.springframework.org/schema/tx \n\t\t\thttp://www.springframework.org/schema/tx/spring-tx.xsd\n\t\t\thttp://www.springframework.org/schema/aop \n\t\t\thttp://www.springframework.org/schema/aop/spring-aop.xsd\n">\n\n    \x3c!--    XML 配置数据源--\x3e\n    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">\n        <property name="driverClass" value="com.mysql.cj.jdbc.Driver"/>\n        <property name="jdbcUrl"\n                  value="jdbc:mysql://192.168.6.129:3306/test?serverTimezone=UTC&amp;characterEncoding=utf8&amp;useUnicode=true&amp;useSSL=false"/>\n        <property name="user" value="root"/>\n        <property name="password" value="root"/>\n    </bean>\n    \x3c!--    配置jdbc模板--\x3e\n    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">\n        <property name="dataSource" ref="dataSource"/>\n    </bean>\n\n    \x3c!--    类注入应用--\x3e\n    <bean id="studentDao" class="com.dao.StudentDao">\n        <property name="jdbcTemplate" ref="jdbcTemplate"/>\n    </bean>\n    <bean id="studentService" class="com.service.StudentService">\n        <property name="studentDao" ref="studentDao"/>\n    </bean>\n\n    \x3c!--    事务管理器--\x3e\n    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n        <property name="dataSource" ref="dataSource"/>\n    </bean>\n\n    \x3c!--    事务触发方法 以及 事务处理方式--\x3e\n    <tx:advice id="txAdvice" transaction-manager="transactionManager">\n        <tx:attributes>\n            \x3c!--            <tx:method name="insert*" propagation="REQUIRED"/>--\x3e\n            \x3c!--            <tx:method name="add*" propagation="REQUIRED"/>--\x3e\n            \x3c!--            <tx:method name="find*" propagation="SUPPORTS" read-only="true"/>--\x3e\n            <tx:method name="*" />\n        </tx:attributes>\n    </tx:advice>\n    \x3c!--   aop编写，让Spring自动对目标生成代理，需要使用AspectJ的表达式 --\x3e\n    <aop:config>\n        <aop:pointcut id="pt" expression="execution(* com.service..*.*(..))"/>\n        <aop:advisor advice-ref="txAdvice"  pointcut-ref="pt" />\n    </aop:config>\n\n</beans>\n\n\n测试：\n\n@Test\npublic void test_XML(){\n    \n    ApplicationContext ac = new ClassPathXmlApplicationContext("SpringConfig.xml");\n   \n    StudentService service = (StudentService) ac.getBean("studentService");\n    \n    //在studentService类 会异常回滚 \n    int number = service.insert(new Student("李四" , 33));\n    System.out.println("number : " + number);\n\n}\n\n\n\n# Annotation应用\n\n主要组件\n\n@Transactional\n\n@Transactional常用属性\n\n属性名           说明\npropagation   配置 事务传播行为\nisolation     配置 事务隔离级别\nreadOnly      配置 事务是否只读\ntimeout       配置 事务超时事件（单位: s）\n\n应用前提：\n\n * 添加事务管理\n   \n   <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n       <property name="dataSource" ref="dataSource"/>\n   </bean>\n   \n\n * 注册加载驱动\n   \n   <tx:annotation-driven transaction-manager="txManager"/>\n   \n\n * 应用方法需要添加 @Transactional 注解\n\n实体类：（Student）\n\npackage com;\n\npublic class Student {\n    int id ;\n    String name;\n    int age;\n    \n    public Student() {\n    }\n    \n    public Student(int id , String name , int age) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n    }\n    \n    public Student(String name , int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    public int getAge() {\n        return age;\n    }\n    \n    public void setAge(int age) {\n        this.age = age;\n    }\n    \n    public int getId() {\n        return id;\n    }\n    \n    public void setId(int id) {\n        this.id = id;\n    }\n    \n    public String getName() {\n        return name;\n    }\n    \n    public void setName(String name) {\n        this.name = name;\n    }\n    \n    @Override\n    public String toString() {\n        return "Student{" +\n                "id=" + id +\n                ", name=\'" + name + \'\\\'\' +\n                ", age=" + age +\n                \'}\';\n    }\n}\n\n\nStudentDao类：（信息交互类）\n\npackage com.dao;\n\nimport com.Student;\nimport org.springframework.jdbc.core.support.JdbcDaoSupport;\n\npublic class StudentDao extends JdbcDaoSupport {\n    \n    /**\n     * 添加数据\n     * @param student 学生类封装\n     * @return 更变条数\n     */\n    public int insert(Student student) {\n        if (student == null) {\n            return 0;\n        }\n        String sql = "insert into student(name,age) value(?,?)";\n        return this.getJdbcTemplate().update(sql,student.getName(),student.getAge());\n    }\n    \n    //其他业务操作省略\n    ····\n}\n\n\nStudentService类：（业务处理类）\n\npackage com.service;\n\nimport com.Student;\nimport com.dao.StudentDao;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Propagation;\nimport org.springframework.transaction.annotation.Transactional;\n\n@Service\npublic class StudentService {\n    \n    //注入类\n    @Autowired\n    private StudentDao studentDao;\n    \n    //事务配置\n    @Transactional(propagation = Propagation.REQUIRED , rollbackFor = {Exception.class})\n    public int insert(Student student){\n        int a = studentDao.insert(student);\n        System.out.println("(1)添加成功 数据: " + student + "\\t影响条目："+a);\n        \n        int aa = 1/0;   //制造异常\n        \n        student.setAge(student.getAge()+1);\n        int b = studentDao.insert(student);\n        System.out.println("(2)添加成功 数据: " + student + "\\t影响条目："+a);\n        return a+b;\n    }\n    \n}\n\n\nSpring 容器配置：（.xml文件）\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:tx="http://www.springframework.org/schema/tx"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       \n       xsi:schemaLocation="\n       http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/tx\n       http://www.springframework.org/schema/tx/spring-tx.xsd\n       http://www.springframework.org/schema/context\n       http://www.springframework.org/schema/context/spring-context.xsd\n">\n\n    \x3c!--    XML 配置数据源--\x3e\n    <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">\n        \x3c!--驱动加载--\x3e\n        <property name="driverClassName" value="com.mysql.jdbc.Driver"/>\n        \x3c!--连接数据库的url  . 本次连接 test库--\x3e\n        <property name="url" value="jdbc:mysql://192.168.6.129/test"/>\n        <property name="username" value="root"/>\n        <property name="password" value="root"/>\n    </bean>\n    \x3c!--    配置jdbc模板--\x3e\n    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">\n        \x3c!--必须使用数据源--\x3e\n        <property name="dataSource" ref="dataSource"/>\n    </bean>\n\t\n    \x3c!--扫描包--\x3e\n    <context:component-scan base-package="com"/>\n\x3c!--    事务管理器--\x3e\n    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n        <property name="dataSource" ref="dataSource"/>\n    </bean>\n    \n\x3c!--    事务应用--\x3e\n    <bean id="studentDao" class="com.dao.StudentDao">\n        <property name="jdbcTemplate" ref="jdbcTemplate"/>\n    </bean>\n\t\x3c!--以注解形式应用--\x3e\n    <tx:annotation-driven transaction-manager="transactionManager"/>\n\n</beans>\n\n\n测试：\n\n @Test\npublic void test_Annotation() {\n    ApplicationContext ac = new ClassPathXmlApplicationContext("SpringConfig_Annotation.xml");\n    StudentServic service = (StudentService) ac.getBean("");\n\n    int number = service_annotation.insert(new Student("赵六" , 34));\n    System.out.println("number : " + number);\n    \n}\n',normalizedContent:'# spring拓展\n\n\n# springjdbc实现\n\nspring 针对数据库开发提供了 jdbctemplate 类，它封装了 jdbc，支持对数据库的所有操作\n\njdbc以往的说明：java学习记录 jdbc篇\n\n> class jdbctemplate\n> \n> org.springframework.jdbc.core.jdbctemplate\n\n方法\n\n修饰符      返回                    方法                                          说明\npublic   int                   update(string sql)                          用于执行新增、修改、删除等语句\npublic   int                   update(string sql,object... args)           用于执行新增、修改、删除等语句 args 表示需要传入的参数\npublic   void                  execute(string sql)                         可以执行任意 sql，一般用于执行 ddl 语句 action 表示执行完 sql 语句后，要调用的函数\npublic   t                     query(string sql, resultsetextractor rse)   用于执行查询语句 以 resultsetextractor 作为参数的 query 方法返回值为 object\npublic   list                  query(string sql, rowmapper rse)            使用查询结果需要对其进行强制转型 以 rowmapper 作为参数的 query 方法返回值为 list\npublic   map<string, object>   queryformap(string sql)                     sql查询多个聚合函数结果值，查询出的结果值形式：key-value\n\njdbc应用\n\n 1. 导入包 spring-jdbc-x.x.x.jar 、spring-tx-x.x.x.jar 以下为个人用maven配置\n    \n    <dependency>\n        <groupid>org.springframework</groupid>\n        <artifactid>spring-jdbc</artifactid>\n        <version>5.2.13.release</version>\n    </dependency>\n    \n\n 2. spring-xml配置数据源\n    \n    <?xml version="1.0" encoding="utf-8"?>\n    <beans xmlns="http://www.springframework.org/schema/beans"\n           xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n           xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">\n    \n    \x3c!--    xml 配置数据源--\x3e\n        <bean id="datesource" class="org.springframework.jdbc.datasource.drivermanagerdatasource">\n            \x3c!--驱动加载--\x3e\n            <property name="driverclassname" value="com.mysql.jdbc.driver"/>\n            \x3c!--连接数据库的url  . 本次连接 test库--\x3e\n         \t\x3c!--指定ip地址 、 库（个人应用的 test库）--\x3e   \n            <property name="url" value="jdbc:mysql://192.168.74.131/test"/>\n            <property name="username" value="root"/>\n            <property name="password" value="root"/>\n        </bean>\n    \n    \x3c!--    配置jdbc模板--\x3e\n        <bean id="jdbctemplate" class="org.springframework.jdbc.core.jdbctemplate">\n            \x3c!--必须使用数据源--\x3e\n            <property name="datasource" ref="datesource"/>\n        </bean>\n    \n    \x3c!--    配置注入类使用--\x3e\n        <bean id="xxx" class="xxx">\n            <property name="jdbctemplate" ref="jdbctemplate"/>\n        </bean>\n    \x3c!--\t例如：--\x3e\n    \x3c!--    <bean id="studentdao" class="com.studentdao">--\x3e\n    \x3c!--        <property name="jdbctemplate" ref="jdbctemplate"/>--\x3e\n    \x3c!--    </bean>--\x3e\n    \t...\n    </beans>\n    \n    \n    配置注入类需要自己指定类进行配置\n\n 3. 创建实体类 student\n    \n    package com;\n    \n    public class student {\n        int id ;\n        string name;\n        int age;\n        \n        public student() {\n        }\n        \n        public student(int id , string name , int age) {\n            this.id = id;\n            this.name = name;\n            this.age = age;\n        }\n        \n        public student(string name , int age) {\n            this.name = name;\n            this.age = age;\n        }\n        \n        public int getage() {\n            return age;\n        }\n        \n        public void setage(int age) {\n            this.age = age;\n        }\n        \n        public int getid() {\n            return id;\n        }\n        \n        public void setid(int id) {\n            this.id = id;\n        }\n        \n        public string getname() {\n            return name;\n        }\n        \n        public void setname(string name) {\n            this.name = name;\n        }\n        \n        @override\n        public string tostring() {\n            return "student{" +\n                    "id=" + id +\n                    ", name=\'" + name + \'\\\'\' +\n                    ", age=" + age +\n                    \'}\';\n        }\n    }\n    \n\n 4. 数据库 test库引入库\n    \n    id   name   age\n    \n    drop table if exists `student`;\n    create table `student`  (\n      `id` int(11) not null auto_increment,\n      `name` varchar(255) character set utf8 collate utf8_general_ci null default null,\n      `age` int(11) null default 16,\n      primary key (`id`) using btree\n    ) engine = innodb auto_increment = 16 character set = utf8 collate = utf8_general_ci row_format = compact;\n    \n\n 5. 指定类注入使用 jdbctemplate类 （应用指定实例 studentdao；实现一个操作业务即可）\n    \n    package com;\n    \n    import org.springframework.dao.dataaccessexception;\n    import org.springframework.jdbc.core.resultsetextractor;\n    import org.springframework.jdbc.core.rowmapper;\n    import org.springframework.jdbc.core.support.jdbcdaosupport;\n    \n    import java.sql.resultset;\n    import java.sql.sqlexception;\n    import java.util.list;\n    import java.util.map;\n    \n    public class studentdao extends jdbcdaosupport {\n        \n        //方法封装\n        public student turnencapsulation(resultset resultset) throws sqlexception {\n            student student = new student();\n            student.setid(resultset.getint("id"));\n            student.setname(resultset.getstring("name"));\n            student.setage(resultset.getint("age"));\n            return student;\n        }\n        \n        /**\n         * 添加数据\n         * @param student 学生类封装\n         * @return 更变条数\n         */\n        public int insert(student student) {\n            if (student == null) {\n                return 0;\n            } \n            string sql = "insert into student(name,age) value(?,?)";\n            return this.getjdbctemplate().update(sql,student.getname(),student.getage());\n        }\n        \n        /**\n         * 删除数据\n         * @param id 删除指定id\n         * @return 更变条数\n         */\n        public int delete(int id) {\n            string sql = "delete from student where id = ?";\n            return this.getjdbctemplate().update(sql,id);\n        }\n        \n        /**\n         * 更变数据\n         * @param id 指定学生id\n         * @param student 更变指定 学生类\n         * @return 更变条数\n         */\n        public int update(int id , student student) {\n            string sql = "update student set name=?,age=? where id=?";\n            return this.getjdbctemplate().update(sql,student.getname(),student.getage(),id);\n        }\n        \n        /**\n         * 查询所有条数\n         * @return 学生队列\n         */\n        public list<student> queryall(){\n            string sql = "select * from student";\n            /* 原型\n            return this.getjdbctemplate().query(sql , new rowmapper<student>() {\n               @override\n               public student maprow(resultset resultset , int i) throws sqlexception{\n                   system.out.println("\\ti : " + i);\n                   return turnencapsulation(resultset);\n               }\n            });\n    \t\t*/\n            // 简写 \n            return this.getjdbctemplate().query(sql, (rs,i) -> turnencapsulation(rs));\n        }\n        \n        /**\n         * 查询指定学生\n         * @param id 指定学生id\n         * @return 学生队列\n         */\n        public list<student> queryfindbyid(int id) {\n            string sql = "select * from student where id = ?";\n            return this.getjdbctemplate().query(sql,new object[]{id}, new rowmapper<student>() {\n                @override\n                public student maprow(resultset resultset , int i) throws sqlexception {\n                    system.out.println("\\ti : " + i);\n                    return turnencapsulation(resultset);\n                }\n            });\n        }\n        \n        /**\n         * 查询指定学生名称\n         * @param name 名称\n         * @return 学生队列\n         */\n        public list<student> queryfindbyname(string name) {\n            string sql = "select * from student where name = ?";\n            //匿名 new rowmapper<student>() 替换为 lambda\n            return this.getjdbctemplate().query(sql,new object[]{name}, (resultset , i) -> {\n                system.out.println("\\ti : " + i);\n                return turnencapsulation(resultset);\n            });\n        }\n        \n        /**\n         * 聚合函数应用\n         */\n        /**\n         * 获取学生总数\n         * @return 学生总数\n         */\n        public int tablesize(){\n            string sql = "select count(id) from student";\n            return this.getjdbctemplate().queryforobject(sql,integer.class);\n        }\n        \n        /**\n         * 学生首尾id\n         * @return map形式返回id首尾\n         */\n        public map<string , object> tablemaxmin(){\n            string sql = "select max(id),min(id) from student";\n            return this.getjdbctemplate().queryformap(sql);\n        }\n        \n    }\n    \n\n 6. 测试类 （测试业务）\n    \n    package com;\n    \n    import com.mchange.v2.c3p0.combopooleddatasource;\n    import org.junit.test;\n    import org.springframework.context.applicationcontext;\n    import org.springframework.context.support.classpathxmlapplicationcontext;\n    import org.springframework.jdbc.core.jdbctemplate;\n    \n    import java.beans.propertyvetoexception;\n    import java.util.list;\n    import java.util.map;\n    \n    //连接测试\n    public class connectionmysql {\n    \n        applicationcontext ac = new classpathxmlapplicationcontext("springjdbc.xml");\n        studentdao dao = (studentdao) ac.getbean("studentdao");\n        \n        /**\n         * xml应用\n         */\n        @test\n        public void test01_insert(){\n            int insert = dao.insert(new student("老哥" , 23));\n            system.out.println("insert : " + insert);\n        }\n        @test\n        public void test02_delete() {\n            int delete = dao.delete(19);\n            system.out.println("delete : " + delete);\n            \n        }\n        @test\n        public void test03_update() {\n            int update = dao.update(16,new student("黑马",32));\n            system.out.println("update : " + update);\n        }\n        @test\n        public void test04_query() {\n            list<student> student = dao.queryfindbyid(17);\n            system.out.println("student : " + student);\n        }\n        @test\n        public void test04_querys() {\n            list<student> students = dao.queryall();\n            // list<student> students = dao.queryfindbyname("李四");\n            for (student student : students) {\n                system.out.println(student.tostring());\n            }\n        }\n        @test\n        public void test05_group(){\n            int i = dao.tablesize();\n            system.out.println("i : " + i);\n            system.out.println("==============");\n            map<string, object> stringobjectmap = dao.tablemaxmin();\n            system.out.println("stringobjectmap : " + stringobjectmap);\n        }\n        \n    }\n    \n\n\n# spring事务管理\n\n事务（transaction）是面向关系型数据库（rdbms）企业应用程序的重要组成部分，用来确保数据的完整性和一致性。\n\n事务了解 ：mysql学习记录 事务篇\n\nspring 实现声明式事务管理主要有 2 种方式：\n\n * 基于 xml 方式的声明式事务管理\n * 通过 annotation 注解方式的事务管理\n\n\n# 事务管理接口\n\nspring 的事务管理 ：platformtransactionmanager、transactiondefinition 是事务主要核心接口\n\nplatformtransactionmanager接口\n\n该接口用于管理事务。其主要用于完成事务的提交、回滚，及获取 事务的状态信息\n\npublic interface platformtransactionmanager extends transactionmanager {\n    transactionstatus gettransaction(@nullable transactiondefinition var1) throws transactionexception;\n\n    void commit(transactionstatus var1) throws transactionexception;\n\n    void rollback(transactionstatus var1) throws transactionexception;\n}\n\n\n返回                  抽象方法                                                   说明\ntransactionstatus   gettransaction(@nullable transactiondefinition var1)   获取事务的状态信息\nvoid                commit(transactionstatus var1)                         提交事务\nvoid                rollback(transactionstatus var1)                       回滚事务\n\ntransactiondefinition接口\n\n该接口主要获取事务相关信息的作用\n\npublic interface transactiondefinition {\n    ....\n\n    default int getpropagationbehavior() {\n        return 0;\n    }\n\n    default int getisolationlevel() {\n        return -1;\n    }\n\n    default int gettimeout() {\n        return -1;\n    }\n\n    default boolean isreadonly() {\n        return false;\n    }\n\n    @nullable\n    default string getname() {\n        return null;\n    }\n\t....\n}\n\n\n返回        抽象方法                       说明\nint       getpropagationbehavior()   获取事务的 传播行为\nint       getisolationlevel()        获取事务的 隔离级别\nint       gettimeout()               获取事务的 超时时间\nboolean   isreadonly()               获取事务是否 只读\nstring    getname()                  获取事务的 名称\n\n属性说明\n\n事务传播行为（propagation behavior）指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行。\n\n传播行为名称值                     说明\npropagation_mandatory       支持当前事务，如果不存在当前事务，则引发异常\npropagation_nested          如果当前事务存在，则在嵌套事务中执行\npropagation_never           不支持当前事务，如果当前事务存在，则引发异常\npropagation_not_supported   不支持当前事务，始终以非事务方式执行\npropagation_required        默认传播行为，支持当前事务，如果不存在，则创建一个新的\npropagation_requires_new    创建新事务，如果已存在事务则暂停当前事务，应用新的\npropagation_supports        支持当前事务，如果不存在事务，则以非事务方式执行\n\n\n# xml应用\n\n主要配置组件（.xml）\n\n<tx:advice id="txadvice" transaction-manager="transactionmanager">\n    <tx:attributes>\n        \x3c!--            <tx:method name="insert*" propagation="required"/>--\x3e\n        \x3c!--            <tx:method name="add*" propagation="required"/>--\x3e\n        \x3c!--            <tx:method name="find*" propagation="supports" read-only="true"/>--\x3e\n        <tx:method name="*" />\n    </tx:attributes>\n</tx:advice>\n\x3c!--   aop编写，让spring自动对目标生成代理，需要使用aspectj的表达式 --\x3e\n<aop:config>\n    <aop:pointcut id="pt" expression="execution(* com.service..*.*(..))"/>\n    <aop:advisor advice-ref="txadvice"  pointcut-ref="pt" />\n</aop:config>\n\n\n应用前提：\n\n添加依赖\n\n<dependency>\n    <groupid>org.aspectj</groupid>\n    <artifactid>aspectjweaver</artifactid>\n    <version>1.9.6</version>\n</dependency>\n\n\n实体类：（student）\n\npackage com;\n\npublic class student {\n    int id ;\n    string name;\n    int age;\n    \n    public student() {\n    }\n    \n    public student(int id , string name , int age) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n    }\n    \n    public student(string name , int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    public int getage() {\n        return age;\n    }\n    \n    public void setage(int age) {\n        this.age = age;\n    }\n    \n    public int getid() {\n        return id;\n    }\n    \n    public void setid(int id) {\n        this.id = id;\n    }\n    \n    public string getname() {\n        return name;\n    }\n    \n    public void setname(string name) {\n        this.name = name;\n    }\n    \n    @override\n    public string tostring() {\n        return "student{" +\n                "id=" + id +\n                ", name=\'" + name + \'\\\'\' +\n                ", age=" + age +\n                \'}\';\n    }\n}\n\n\nstudentdao类：（信息交互类）\n\npackage com.dao;\n\nimport com.student;\nimport org.springframework.jdbc.core.support.jdbcdaosupport;\n\npublic class studentdao extends jdbcdaosupport {\n    \n    /**\n     * 添加数据\n     * @param student 学生类封装\n     * @return 更变条数\n     */\n    public int insert(student student) {\n        if (student == null) {\n            return 0;\n        }\n        string sql = "insert into student(name,age) value(?,?)";\n        return this.getjdbctemplate().update(sql,student.getname(),student.getage());\n    }\n    \n    //其他业务操作省略\n    ····\n}\n\n\nstudentservice类：（业务处理类）\n\npackage com.service;\n\nimport com.student;\nimport com.dao.studentdao;\n\npublic class studentservice {\n    \n    private studentdao studentdao;\n    \n    public void setstudentdao(studentdao studentdao) {\n        this.studentdao = studentdao;\n    }\n    \n    public int insert(student student){\n        int a = studentdao.insert(student);\n        system.out.println("(1)添加成功 数据: " + student + "\\t影响条目："+a);\n        int aa = 1/0;   //制造异常\n        student.setage(student.getage()+1);\n        int b = studentdao.insert(student);\n        system.out.println("(2)添加成功 数据: " + student + "\\t影响条目："+a);\n        return a+b;\n    }\n}\n\n\nspring 容器配置：（.xml文件）\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:tx="http://www.springframework.org/schema/tx"\n       xmlns:aop="http://www.springframework.org/schema/aop"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       \n       xsi:schemalocation="\n\t\t\thttp://www.springframework.org/schema/beans\n\t\t\thttp://www.springframework.org/schema/beans/spring-beans.xsd\n\t\t\thttp://www.springframework.org/schema/tx \n\t\t\thttp://www.springframework.org/schema/tx/spring-tx.xsd\n\t\t\thttp://www.springframework.org/schema/aop \n\t\t\thttp://www.springframework.org/schema/aop/spring-aop.xsd\n">\n\n    \x3c!--    xml 配置数据源--\x3e\n    <bean id="datasource" class="com.mchange.v2.c3p0.combopooleddatasource">\n        <property name="driverclass" value="com.mysql.cj.jdbc.driver"/>\n        <property name="jdbcurl"\n                  value="jdbc:mysql://192.168.6.129:3306/test?servertimezone=utc&amp;characterencoding=utf8&amp;useunicode=true&amp;usessl=false"/>\n        <property name="user" value="root"/>\n        <property name="password" value="root"/>\n    </bean>\n    \x3c!--    配置jdbc模板--\x3e\n    <bean id="jdbctemplate" class="org.springframework.jdbc.core.jdbctemplate">\n        <property name="datasource" ref="datasource"/>\n    </bean>\n\n    \x3c!--    类注入应用--\x3e\n    <bean id="studentdao" class="com.dao.studentdao">\n        <property name="jdbctemplate" ref="jdbctemplate"/>\n    </bean>\n    <bean id="studentservice" class="com.service.studentservice">\n        <property name="studentdao" ref="studentdao"/>\n    </bean>\n\n    \x3c!--    事务管理器--\x3e\n    <bean id="transactionmanager" class="org.springframework.jdbc.datasource.datasourcetransactionmanager">\n        <property name="datasource" ref="datasource"/>\n    </bean>\n\n    \x3c!--    事务触发方法 以及 事务处理方式--\x3e\n    <tx:advice id="txadvice" transaction-manager="transactionmanager">\n        <tx:attributes>\n            \x3c!--            <tx:method name="insert*" propagation="required"/>--\x3e\n            \x3c!--            <tx:method name="add*" propagation="required"/>--\x3e\n            \x3c!--            <tx:method name="find*" propagation="supports" read-only="true"/>--\x3e\n            <tx:method name="*" />\n        </tx:attributes>\n    </tx:advice>\n    \x3c!--   aop编写，让spring自动对目标生成代理，需要使用aspectj的表达式 --\x3e\n    <aop:config>\n        <aop:pointcut id="pt" expression="execution(* com.service..*.*(..))"/>\n        <aop:advisor advice-ref="txadvice"  pointcut-ref="pt" />\n    </aop:config>\n\n</beans>\n\n\n测试：\n\n@test\npublic void test_xml(){\n    \n    applicationcontext ac = new classpathxmlapplicationcontext("springconfig.xml");\n   \n    studentservice service = (studentservice) ac.getbean("studentservice");\n    \n    //在studentservice类 会异常回滚 \n    int number = service.insert(new student("李四" , 33));\n    system.out.println("number : " + number);\n\n}\n\n\n\n# annotation应用\n\n主要组件\n\n@transactional\n\n@transactional常用属性\n\n属性名           说明\npropagation   配置 事务传播行为\nisolation     配置 事务隔离级别\nreadonly      配置 事务是否只读\ntimeout       配置 事务超时事件（单位: s）\n\n应用前提：\n\n * 添加事务管理\n   \n   <bean id="transactionmanager" class="org.springframework.jdbc.datasource.datasourcetransactionmanager">\n       <property name="datasource" ref="datasource"/>\n   </bean>\n   \n\n * 注册加载驱动\n   \n   <tx:annotation-driven transaction-manager="txmanager"/>\n   \n\n * 应用方法需要添加 @transactional 注解\n\n实体类：（student）\n\npackage com;\n\npublic class student {\n    int id ;\n    string name;\n    int age;\n    \n    public student() {\n    }\n    \n    public student(int id , string name , int age) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n    }\n    \n    public student(string name , int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    public int getage() {\n        return age;\n    }\n    \n    public void setage(int age) {\n        this.age = age;\n    }\n    \n    public int getid() {\n        return id;\n    }\n    \n    public void setid(int id) {\n        this.id = id;\n    }\n    \n    public string getname() {\n        return name;\n    }\n    \n    public void setname(string name) {\n        this.name = name;\n    }\n    \n    @override\n    public string tostring() {\n        return "student{" +\n                "id=" + id +\n                ", name=\'" + name + \'\\\'\' +\n                ", age=" + age +\n                \'}\';\n    }\n}\n\n\nstudentdao类：（信息交互类）\n\npackage com.dao;\n\nimport com.student;\nimport org.springframework.jdbc.core.support.jdbcdaosupport;\n\npublic class studentdao extends jdbcdaosupport {\n    \n    /**\n     * 添加数据\n     * @param student 学生类封装\n     * @return 更变条数\n     */\n    public int insert(student student) {\n        if (student == null) {\n            return 0;\n        }\n        string sql = "insert into student(name,age) value(?,?)";\n        return this.getjdbctemplate().update(sql,student.getname(),student.getage());\n    }\n    \n    //其他业务操作省略\n    ····\n}\n\n\nstudentservice类：（业务处理类）\n\npackage com.service;\n\nimport com.student;\nimport com.dao.studentdao;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.stereotype.service;\nimport org.springframework.transaction.annotation.propagation;\nimport org.springframework.transaction.annotation.transactional;\n\n@service\npublic class studentservice {\n    \n    //注入类\n    @autowired\n    private studentdao studentdao;\n    \n    //事务配置\n    @transactional(propagation = propagation.required , rollbackfor = {exception.class})\n    public int insert(student student){\n        int a = studentdao.insert(student);\n        system.out.println("(1)添加成功 数据: " + student + "\\t影响条目："+a);\n        \n        int aa = 1/0;   //制造异常\n        \n        student.setage(student.getage()+1);\n        int b = studentdao.insert(student);\n        system.out.println("(2)添加成功 数据: " + student + "\\t影响条目："+a);\n        return a+b;\n    }\n    \n}\n\n\nspring 容器配置：（.xml文件）\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:tx="http://www.springframework.org/schema/tx"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       \n       xsi:schemalocation="\n       http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/tx\n       http://www.springframework.org/schema/tx/spring-tx.xsd\n       http://www.springframework.org/schema/context\n       http://www.springframework.org/schema/context/spring-context.xsd\n">\n\n    \x3c!--    xml 配置数据源--\x3e\n    <bean id="datasource" class="org.springframework.jdbc.datasource.drivermanagerdatasource">\n        \x3c!--驱动加载--\x3e\n        <property name="driverclassname" value="com.mysql.jdbc.driver"/>\n        \x3c!--连接数据库的url  . 本次连接 test库--\x3e\n        <property name="url" value="jdbc:mysql://192.168.6.129/test"/>\n        <property name="username" value="root"/>\n        <property name="password" value="root"/>\n    </bean>\n    \x3c!--    配置jdbc模板--\x3e\n    <bean id="jdbctemplate" class="org.springframework.jdbc.core.jdbctemplate">\n        \x3c!--必须使用数据源--\x3e\n        <property name="datasource" ref="datasource"/>\n    </bean>\n\t\n    \x3c!--扫描包--\x3e\n    <context:component-scan base-package="com"/>\n\x3c!--    事务管理器--\x3e\n    <bean id="transactionmanager" class="org.springframework.jdbc.datasource.datasourcetransactionmanager">\n        <property name="datasource" ref="datasource"/>\n    </bean>\n    \n\x3c!--    事务应用--\x3e\n    <bean id="studentdao" class="com.dao.studentdao">\n        <property name="jdbctemplate" ref="jdbctemplate"/>\n    </bean>\n\t\x3c!--以注解形式应用--\x3e\n    <tx:annotation-driven transaction-manager="transactionmanager"/>\n\n</beans>\n\n\n测试：\n\n @test\npublic void test_annotation() {\n    applicationcontext ac = new classpathxmlapplicationcontext("springconfig_annotation.xml");\n    studentservic service = (studentservice) ac.getbean("");\n\n    int number = service_annotation.insert(new student("赵六" , 34));\n    system.out.println("number : " + number);\n    \n}\n',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"静态资源的访问",frontmatter:{title:"静态资源的访问",author:"柏竹",permalink:"/backend/6nom7s",date:"2020-02-18T00:00:00.000Z",categories:["后端"],tags:["SpringMVC","Java"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/08.SpringMVC/02.%E8%AE%BF%E9%97%AE%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90.html",relativePath:"01.后端/08.SpringMVC/02.访问静态资源.md",key:"v-261bed0c",path:"/backend/6nom7s/",headersStr:null,content:'# 静态资源的访问\n\n静态资源一般在web.xml 配置时需要添加允许路径url（url-pattern节点）。url-pattern节点 中的值一般有两种写法：\n\n>  1. *.do SpringMVC 的前端控制器 DispatcherServlet 的常使用后辍匹配方式，可以写为*.do 或者 *.action, *.mvc 等。\n>  2. / DispatcherServlet 会将向静态内容。例如 .css 、.js 、图片 等资源的获取请求 时，也会当作是一个普通的 Controller 请求，因此所有的静态资源获取请求也均会报 404 错误\n\n示例：\n\nweb.xml\n\n···\n<servlet-mapping>\n        <servlet-name>dispatcherServlet</servlet-name>\n\x3c!--        <url-pattern>*.do</url-pattern>--\x3e\n        <url-pattern>/</url-pattern>\n</servlet-mapping>\n···\n\n\nindex\n\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n    <h1>index ----- ${userName}</h1>\n    \n    //前提 webapp目录 下有 images目录 存放图片文件（加载图片静态资源）\n    //访问时地址：http://localhost:8080/images/ov.jpg\n    <img src="images/ov.jpg" alt="test"/>\n\n</body>\n</html>\n\n\n如果 url-pattern节点 值为 /，可通过以下两个解决方法\n\n解决方法通过以上第一次用的代码进而修改实例：（常用示例）\n\n 1. 在 springmvc.xml 添加 <mvc:default-servlet-handler/> 节点 ，通过转发到 Servlet 容器的默认 Servlet 来配置处理程序以提供静态资源\n\n<mvc:default-servlet-handler/>\n\n\n> Springmvc框架会在容器中创建 DefaultServletHttpRequestHandler处理器对象。该对象会对所有进入 DispatcherServlet的URL 进行检查。如果发现是静态资源的请求，就将该请求转由Web应用服务器默认的Servlet处理，如果不是静态资源的请求，才由DispatcherServlet继续处理。\n> \n> 以往使用的Tomcat服务器中，有一个专门用于处理静态资源 访问的 Servlet 名叫 DefaultServlet。其为default。可以处理各种静态资源访问 请求。该Servlet注册在 Tomcat 服务器的 web.xml 中。在 Tomcat安装目录/conf/web.xml。\n\n 2. 在 springmvc.xml 添加 <mvc:resources /> 节点 ，配置一个处理程序来提供静态资源\n\n<mvc:resources location="/images/" mapping="/images/**" />\n\n\n> location: 静态资源所在目录（建议 不应用 /WEB-INF/目录 及其 子目录 ）\n> \n> mapping: 对该资源的请求（后面是两个星号**）',normalizedContent:'# 静态资源的访问\n\n静态资源一般在web.xml 配置时需要添加允许路径url（url-pattern节点）。url-pattern节点 中的值一般有两种写法：\n\n>  1. *.do springmvc 的前端控制器 dispatcherservlet 的常使用后辍匹配方式，可以写为*.do 或者 *.action, *.mvc 等。\n>  2. / dispatcherservlet 会将向静态内容。例如 .css 、.js 、图片 等资源的获取请求 时，也会当作是一个普通的 controller 请求，因此所有的静态资源获取请求也均会报 404 错误\n\n示例：\n\nweb.xml\n\n···\n<servlet-mapping>\n        <servlet-name>dispatcherservlet</servlet-name>\n\x3c!--        <url-pattern>*.do</url-pattern>--\x3e\n        <url-pattern>/</url-pattern>\n</servlet-mapping>\n···\n\n\nindex\n\n<%@ page contenttype="text/html;charset=utf-8" language="java" %>\n<html>\n<head>\n    <title>title</title>\n</head>\n<body>\n    <h1>index ----- ${username}</h1>\n    \n    //前提 webapp目录 下有 images目录 存放图片文件（加载图片静态资源）\n    //访问时地址：http://localhost:8080/images/ov.jpg\n    <img src="images/ov.jpg" alt="test"/>\n\n</body>\n</html>\n\n\n如果 url-pattern节点 值为 /，可通过以下两个解决方法\n\n解决方法通过以上第一次用的代码进而修改实例：（常用示例）\n\n 1. 在 springmvc.xml 添加 <mvc:default-servlet-handler/> 节点 ，通过转发到 servlet 容器的默认 servlet 来配置处理程序以提供静态资源\n\n<mvc:default-servlet-handler/>\n\n\n> springmvc框架会在容器中创建 defaultservlethttprequesthandler处理器对象。该对象会对所有进入 dispatcherservlet的url 进行检查。如果发现是静态资源的请求，就将该请求转由web应用服务器默认的servlet处理，如果不是静态资源的请求，才由dispatcherservlet继续处理。\n> \n> 以往使用的tomcat服务器中，有一个专门用于处理静态资源 访问的 servlet 名叫 defaultservlet。其为default。可以处理各种静态资源访问 请求。该servlet注册在 tomcat 服务器的 web.xml 中。在 tomcat安装目录/conf/web.xml。\n\n 2. 在 springmvc.xml 添加 <mvc:resources /> 节点 ，配置一个处理程序来提供静态资源\n\n<mvc:resources location="/images/" mapping="/images/**" />\n\n\n> location: 静态资源所在目录（建议 不应用 /web-inf/目录 及其 子目录 ）\n> \n> mapping: 对该资源的请求（后面是两个星号**）',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Spring",frontmatter:{title:"Spring",author:"柏竹",permalink:"/backend/x1cuta",date:"2020-02-18T00:00:00.000Z",categories:["后端","框架"],tags:["spring"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/07.Spring/01.Spring%E6%A6%82%E8%BF%B0.html",relativePath:"01.后端/07.Spring/01.Spring概述.md",key:"v-070e9099",path:"/backend/x1cuta/",headers:[{level:2,title:"Spring体系结构",slug:"spring体系结构",normalizedTitle:"spring体系结构",charIndex:239},{level:2,title:"Spring JDBC",slug:"spring-jdbc",normalizedTitle:"spring jdbc",charIndex:958},{level:2,title:"Spring事务管理",slug:"spring事务管理",normalizedTitle:"spring事务管理",charIndex:9778},{level:3,title:"事务管理接口",slug:"事务管理接口",normalizedTitle:"事务管理接口",charIndex:9953},{level:3,title:"xml应用",slug:"xml应用",normalizedTitle:"xml应用",charIndex:8405},{level:3,title:"Annotation应用",slug:"annotation应用",normalizedTitle:"annotation应用",charIndex:17691}],headersStr:"Spring体系结构 Spring JDBC Spring事务管理 事务管理接口 xml应用 Annotation应用",content:'# Spring\n\nSpring是主流的 Java Web开发框架 ，该框架是轻量级、性能好、易于测试。\n\nSpring具有控制反转（IoC）和 面向切面（AOP）两大核心。Java Spring 框架通过声明式方式灵活地进 行事务的管理，提高开发效率和质量\n\nSpring优势\n\n>  * 方便解耦，简化开发\n>  * 方便继承各种优秀框架\n>  * 降低 Java EE API 使用难度\n>  * 方便程序测试\n>  * AOP编程支持\n>  * 声明式事务支持\n\n\n# Spring体系结构\n\nSpring提供了一站式服务，是以模块化形式呈现需要自行选择\n\n 1. 数据访问/集成\n    * JDBC模块：提供了JDBC抽象层\n    * ORM模块：对 对象关系映射API\n    * OXM模块：支持 对象/XML 映射的抽象层实现\n    * JMS模块：Java消息服务，生产消费信息等\n    * Transactions事务模块：支持编程和声明式事务管理实现特殊接口类\n 2. Web\n    * Web模块：Web开发继承的特性\n    * Servlet模块：Spring 模型-视图-控制器 (MVC) 实现Web应用程序\n    * Struts模块：支持类内的Spring应用程序\n    * Portlet模块：提供在Portlet环境中使用MVC实现\n 3. 核心容器\n    * Beans模块：将对象以Bean进行管理\n    * Core核心模块：提供框架基本部分， IoC 和 DI 功能 等\n    * Context上下文模块：是Beans模块基础之上，是访问和配置文件任何对象的媒介\n    * Expression Language模块：运行时查询和对象图的强大的表达式语音\n 4. 其他\n    * AOP模块：面向切面的编程实现，允许定义方法拦截器和切入点，按方法功能进行分离，降低耦合性\n    * Aspects模块：提供与AspectJ的集成，是功能强大的AOP框架\n    * Instrumentation模块：提供类工具的支持和类加载器的实现，在特定的应用服务器中使用\n    * Test模块：支持JUnit 或 TestNG 框架测试\n\n\n# Spring JDBC\n\nSpring 针对数据库开发提供了 JdbcTemplate 类，它封装了 JDBC，支持对数据库的所有操作\n\nJDBC以往的说明：Java学习记录 JDBC篇\n\n> jar包：\n> \n>  * spring-jdbc\n>  * spring-tx\n>  * spring-core\n\n应用步骤：\n\n 1. 引入依赖\n 2. xml数据源配置\n 3. dao层方法继承JdbcTemplate注入\n 4. 测试\n\n方法\n\n返回                    方法                                          说明\nint                   update(String sql)                          用于执行新增、修改、删除等语句\nint                   update(String sql,Object... args)           用于执行新增、修改、删除等语句 args 表示需要传入的参数\nvoid                  execute(String sql)                         可以执行任意 SQL，一般用于执行 DDL 语句 action 表示执行完 SQL 语句后，要调用的函数\nT                     query(String sql, ResultSetExtractor rse)   用于执行查询语句 以 ResultSetExtractor 作为参数的 query 方法返回值为 Object\nList                  query(String sql, RowMapper rse)            使用查询结果需要对其进行强制转型 以 RowMapper 作为参数的 query 方法返回值为 List\nMap<String, Object>   queryForMap(String sql)                     SQL查询多个聚合函数结果值，查询出的结果值形式：key-value\n...                   ...                                         ...\n\nJDBC应用\n\n 1. 导入包 spring-jdbc-x.x.x.jar 、spring-tx-x.x.x.jar 以下为个人用Maven配置\n    \n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-jdbc</artifactId>\n        <version>5.2.13.RELEASE</version>\n    </dependency>\n    \n\n 2. Spring-xml配置数据源\n    \n    <?xml version="1.0" encoding="UTF-8"?>\n    <beans xmlns="http://www.springframework.org/schema/beans"\n           xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n           xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">\n    \n    \x3c!--    XML 配置数据源--\x3e\n        <bean id="dateSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">\n            \x3c!--驱动加载--\x3e\n            <property name="driverClassName" value="com.mysql.jdbc.Driver"/>\n            \x3c!--连接数据库的url  . 本次连接 test库--\x3e\n         \t\x3c!--指定IP地址 、 库（个人应用的 test库）--\x3e   \n            <property name="url" value="jdbc:mysql://192.168.74.131/test"/>\n            <property name="username" value="root"/>\n            <property name="password" value="root"/>\n        </bean>\n    \n    \x3c!--    配置jdbc模板--\x3e\n        <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">\n            \x3c!--必须使用数据源--\x3e\n            <property name="dataSource" ref="dateSource"/>\n        </bean>\n    \n    \x3c!--    配置注入类使用--\x3e\n        <bean id="xxx" class="xxx">\n            <property name="jdbcTemplate" ref="jdbcTemplate"/>\n        </bean>\n    \x3c!--\t例如：--\x3e\n    \x3c!--    <bean id="studentDao" class="com.StudentDao">--\x3e\n    \x3c!--        <property name="jdbcTemplate" ref="jdbcTemplate"/>--\x3e\n    \x3c!--    </bean>--\x3e\n    \t...\n    </beans>\n    \n    \n    配置注入类需要自己指定类进行配置\n\n 3. 创建实体类 Student\n    \n    public class Student {\n        int id ;\n        String name;\n        int age;\n        \n        // 省略多余的 get和set方法\n        \n        @Override\n        public String toString() {\n            return "Student{" +\n                    "id=" + id +\n                    ", name=\'" + name + \'\\\'\' +\n                    ", age=" + age +\n                    \'}\';\n        }\n    }\n    \n\n 4. 数据库 test库引入库\n    \n    ID   NAME   AGE\n    \n    DROP TABLE IF EXISTS `student`;\n    CREATE TABLE `student`  (\n      `id` int(11) NOT NULL AUTO_INCREMENT,\n      `name` varchar(255) CHARACTER SET utf8 COLLATE utf8_general_ci NULL DEFAULT NULL,\n      `age` int(11) NULL DEFAULT 16,\n      PRIMARY KEY (`id`) USING BTREE\n    ) ENGINE = InnoDB AUTO_INCREMENT = 16 CHARACTER SET = utf8 COLLATE = utf8_general_ci ROW_FORMAT = Compact;\n    \n\n 5. 指定类注入使用 JdbcTemplate类 （应用指定实例 StudentDao；实现一个操作业务即可）\n    \n    public class StudentDao extends JdbcDaoSupport {\n        \n        // 方法封装\n        public Student turnEncapsulation(ResultSet resultSet) throws SQLException {\n            Student student = new Student();\n            student.setId(resultSet.getInt("id"));\n            student.setName(resultSet.getString("name"));\n            student.setAge(resultSet.getInt("age"));\n            return student;\n        }\n        \n        /**\n         * 添加数据\n         * @param student 学生类封装\n         * @return 更变条数\n         */\n        public int insert(Student student) {\n            if (student == null) {\n                return 0;\n            } \n            String sql = "INSERT INTO student(name,age) VALUE(?,?)";\n            return this.getJdbcTemplate().update(sql,student.getName(),student.getAge());\n        }\n        \n        /**\n         * 删除数据\n         * @param id 删除指定id\n         * @return 更变条数\n         */\n        public int delete(int id) {\n            String sql = "DELETE FROM student WHERE id = ?";\n            return this.getJdbcTemplate().update(sql,id);\n        }\n        \n        /**\n         * 更变数据\n         * @param id 指定学生id\n         * @param student 更变指定 学生类\n         * @return 更变条数\n         */\n        public int update(int id , Student student) {\n            String sql = "UPDATE student set name=?,age=? WHERE id=?";\n            return this.getJdbcTemplate().update(sql,student.getName(),student.getAge(),id);\n        }\n        \n        /**\n         * 查询所有条数\n         * @return 学生队列\n         */\n        public List<Student> queryAll(){\n            String sql = "SELECT * FROM student";\n            return this.getJdbcTemplate().query(sql , new RowMapper<Student>() {\n                @Override\n                public Student mapRow(ResultSet resultSet , int i) throws SQLException {\n                    System.out.println("\\ti : " + i);\n                    return turnEncapsulation(resultSet);\n                }\n            });\n        }\n        \n        /**\n         * 查询指定学生\n         * @param id 指定学生id\n         * @return 学生队列\n         */\n        public List<Student> queryFindById(int id) {\n            String sql = "SELECT * FROM student WHERE id = ?";\n            return this.getJdbcTemplate().query(sql,new Object[]{id}, new RowMapper<Student>() {\n                @Override\n                public Student mapRow(ResultSet resultSet , int i) throws SQLException {\n                    System.out.println("\\ti : " + i);\n                    return turnEncapsulation(resultSet);\n                }\n            });\n        }\n        \n        /**\n         * 查询指定学生名称\n         * @param name 名称\n         * @return 学生队列\n         */\n        public List<Student> queryFindByName(String name) {\n            String sql = "SELECT * FROM student WHERE name = ?";\n            //匿名 new RowMapper<Student>() 替换为 lambda\n            return this.getJdbcTemplate().query(sql,new Object[]{name}, (resultSet , i) -> {\n                System.out.println("\\ti : " + i);\n                return turnEncapsulation(resultSet);\n            });\n        }\n        \n        /**\n         * 聚合函数应用\n         */\n        /**\n         * 获取学生总数\n         * @return 学生总数\n         */\n        public int tableSize(){\n            String sql = "SELECT count(id) FROM student";\n            return this.getJdbcTemplate().queryForObject(sql,Integer.class);\n        }\n        \n        /**\n         * 学生首尾id\n         * @return MAP形式返回id首尾\n         */\n        public Map<String , Object> tableMaxMin(){\n            String sql = "SELECT max(id),min(id) FROM student";\n            return this.getJdbcTemplate().queryForMap(sql);\n        }\n        \n    }\n    \n\n 6. 测试类 （测试业务）\n    \n    public class connectionMySQL {\n    \n        ApplicationContext ac = new ClassPathXmlApplicationContext("springJDBC.xml");\n        StudentDao dao = (StudentDao) ac.getBean("studentDao");\n        \n        /**\n         * xml应用\n         */\n        @Test\n        public void test01_Insert(){\n            int insert = dao.insert(new Student("老哥" , 23));\n            System.out.println("insert : " + insert);\n        }\n        @Test\n        public void test02_Delete() {\n            int delete = dao.delete(19);\n            System.out.println("delete : " + delete);\n            \n        }\n        @Test\n        public void test03_Update() {\n            int update = dao.update(16,new Student("黑马",32));\n            System.out.println("update : " + update);\n        }\n        @Test\n        public void test04_Query() {\n            List<Student> student = dao.queryFindById(17);\n            System.out.println("student : " + student);\n        }\n        @Test\n        public void test04_Querys() {\n            List<Student> students = dao.queryAll();\n            // List<Student> students = dao.queryFindByName("李四");\n            for (Student student : students) {\n                System.out.println(student.toString());\n            }\n        }\n        @Test\n        public void test05_group(){\n            int i = dao.tableSize();\n            System.out.println("i : " + i);\n            System.out.println("==============");\n            Map<String, Object> stringObjectMap = dao.tableMaxMin();\n            System.out.println("stringObjectMap : " + stringObjectMap);\n        }\n        \n    }\n    \n\n\n# Spring事务管理\n\n事务（Transaction）是面向关系型数据库（RDBMS）企业应用程序的重要组成部分，用来确保数据的完整性和一致性。\n\n事务了解 ：MySQL学习记录 事务篇\n\nSpring 实现声明式事务管理主要有 2 种方式：\n\n * 基于 XML 方式的声明式事务管理\n * 通过 Annotation 注解方式的事务管理\n\n\n# 事务管理接口\n\nSpring 的事务管理 ：PlatformTransactionManager、TransactionDefinition 是事务主要核心接口\n\nPlatformTransactionManager接口\n\n该接口用于管理事务。其主要用于完成事务的提交、回滚，及获取 事务的状态信息\n\npublic interface PlatformTransactionManager extends TransactionManager {\n    TransactionStatus getTransaction(@Nullable TransactionDefinition var1) throws TransactionException;\n\n    void commit(TransactionStatus var1) throws TransactionException;\n\n    void rollback(TransactionStatus var1) throws TransactionException;\n}\n\n\n返回                  抽象方法                                                   说明\nTransactionStatus   getTransaction(@Nullable TransactionDefinition var1)   获取事务的状态信息\nvoid                commit(TransactionStatus var1)                         提交事务\nvoid                rollback(TransactionStatus var1)                       回滚事务\n\nTransactionDefinition接口\n\n该接口主要获取事务相关信息的作用\n\npublic interface TransactionDefinition {\n    ....\n\n    default int getPropagationBehavior() {\n        return 0;\n    }\n\n    default int getIsolationLevel() {\n        return -1;\n    }\n\n    default int getTimeout() {\n        return -1;\n    }\n\n    default boolean isReadOnly() {\n        return false;\n    }\n\n    @Nullable\n    default String getName() {\n        return null;\n    }\n\t....\n}\n\n\n返回        抽象方法                       说明\nint       getPropagationBehavior()   获取事务的 传播行为\nint       getIsolationLevel()        获取事务的 隔离级别\nint       getTimeout()               获取事务的 超时时间\nboolean   isReadOnly()               获取事务是否 只读\nString    getName()                  获取事务的 名称\n\n属性说明\n\n事务传播行为（propagation behavior）指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行。\n\n传播行为名称值                     说明\nPROPAGATION_MANDATORY       支持当前事务，如果不存在当前事务，则引发异常\nPROPAGATION_NESTED          如果当前事务存在，则在嵌套事务中执行\nPROPAGATION_NEVER           不支持当前事务，如果当前事务存在，则引发异常\nPROPAGATION_NOT_SUPPORTED   不支持当前事务，始终以非事务方式执行\nPROPAGATION_REQUIRED        默认传播行为，支持当前事务，如果不存在，则创建一个新的\nPROPAGATION_REQUIRES_NEW    创建新事务，如果已存在事务则暂停当前事务，应用新的\nPROPAGATION_SUPPORTS        支持当前事务，如果不存在事务，则以非事务方式执行\n\n\n# xml应用\n\n主要配置组件（.xml）\n\n<tx:advice id="txAdvice" transaction-manager="transactionManager">\n    <tx:attributes>\n        \x3c!--            <tx:method name="insert*" propagation="REQUIRED"/>--\x3e\n        \x3c!--            <tx:method name="add*" propagation="REQUIRED"/>--\x3e\n        \x3c!--            <tx:method name="find*" propagation="SUPPORTS" read-only="true"/>--\x3e\n        <tx:method name="*" />\n    </tx:attributes>\n</tx:advice>\n\x3c!--   aop编写，让Spring自动对目标生成代理，需要使用AspectJ的表达式 --\x3e\n<aop:config>\n    <aop:pointcut id="pt" expression="execution(* com.service..*.*(..))"/>\n    <aop:advisor advice-ref="txAdvice"  pointcut-ref="pt" />\n</aop:config>\n\n\n应用前提：\n\n添加依赖\n\n<dependency>\n    <groupId>org.aspectj</groupId>\n    <artifactId>aspectjweaver</artifactId>\n    <version>1.9.6</version>\n</dependency>\n\n\n实体类：（Student）\n\npackage com;\n\npublic class Student {\n    int id ;\n    String name;\n    int age;\n    \n    public Student() {\n    }\n    \n    public Student(int id , String name , int age) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n    }\n    \n    public Student(String name , int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    public int getAge() {\n        return age;\n    }\n    \n    public void setAge(int age) {\n        this.age = age;\n    }\n    \n    public int getId() {\n        return id;\n    }\n    \n    public void setId(int id) {\n        this.id = id;\n    }\n    \n    public String getName() {\n        return name;\n    }\n    \n    public void setName(String name) {\n        this.name = name;\n    }\n    \n    @Override\n    public String toString() {\n        return "Student{" +\n                "id=" + id +\n                ", name=\'" + name + \'\\\'\' +\n                ", age=" + age +\n                \'}\';\n    }\n}\n\n\nStudentDao类：（信息交互类）\n\npackage com.dao;\n\nimport com.Student;\nimport org.springframework.jdbc.core.support.JdbcDaoSupport;\n\npublic class StudentDao extends JdbcDaoSupport {\n    \n    /**\n     * 添加数据\n     * @param student 学生类封装\n     * @return 更变条数\n     */\n    public int insert(Student student) {\n        if (student == null) {\n            return 0;\n        }\n        String sql = "insert into student(name,age) value(?,?)";\n        return this.getJdbcTemplate().update(sql,student.getName(),student.getAge());\n    }\n    \n    //其他业务操作省略\n    ····\n}\n\n\nStudentService类：（业务处理类）\n\npackage com.service;\n\nimport com.Student;\nimport com.dao.StudentDao;\n\npublic class StudentService {\n    \n    private StudentDao studentDao;\n    \n    public void setStudentDao(StudentDao studentDao) {\n        this.studentDao = studentDao;\n    }\n    \n    public int insert(Student student){\n        int a = studentDao.insert(student);\n        System.out.println("(1)添加成功 数据: " + student + "\\t影响条目："+a);\n        int aa = 1/0;   //制造异常\n        student.setAge(student.getAge()+1);\n        int b = studentDao.insert(student);\n        System.out.println("(2)添加成功 数据: " + student + "\\t影响条目："+a);\n        return a+b;\n    }\n}\n\n\nSpring 容器配置：（.xml文件）\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:tx="http://www.springframework.org/schema/tx"\n       xmlns:aop="http://www.springframework.org/schema/aop"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       \n       xsi:schemaLocation="\n\t\t\thttp://www.springframework.org/schema/beans\n\t\t\thttp://www.springframework.org/schema/beans/spring-beans.xsd\n\t\t\thttp://www.springframework.org/schema/tx \n\t\t\thttp://www.springframework.org/schema/tx/spring-tx.xsd\n\t\t\thttp://www.springframework.org/schema/aop \n\t\t\thttp://www.springframework.org/schema/aop/spring-aop.xsd\n">\n\n    \x3c!--    XML 配置数据源--\x3e\n    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource">\n        <property name="driverClass" value="com.mysql.cj.jdbc.Driver"/>\n        <property name="jdbcUrl"\n                  value="jdbc:mysql://192.168.6.129:3306/test?serverTimezone=UTC&amp;characterEncoding=utf8&amp;useUnicode=true&amp;useSSL=false"/>\n        <property name="user" value="root"/>\n        <property name="password" value="root"/>\n    </bean>\n    \x3c!--    配置jdbc模板--\x3e\n    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">\n        <property name="dataSource" ref="dataSource"/>\n    </bean>\n\n    \x3c!--    类注入应用--\x3e\n    <bean id="studentDao" class="com.dao.StudentDao">\n        <property name="jdbcTemplate" ref="jdbcTemplate"/>\n    </bean>\n    <bean id="studentService" class="com.service.StudentService">\n        <property name="studentDao" ref="studentDao"/>\n    </bean>\n\n    \x3c!--    事务管理器--\x3e\n    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n        <property name="dataSource" ref="dataSource"/>\n    </bean>\n\n    \x3c!--    事务触发方法 以及 事务处理方式--\x3e\n    <tx:advice id="txAdvice" transaction-manager="transactionManager">\n        <tx:attributes>\n            \x3c!--            <tx:method name="insert*" propagation="REQUIRED"/>--\x3e\n            \x3c!--            <tx:method name="add*" propagation="REQUIRED"/>--\x3e\n            \x3c!--            <tx:method name="find*" propagation="SUPPORTS" read-only="true"/>--\x3e\n            <tx:method name="*" />\n        </tx:attributes>\n    </tx:advice>\n    \x3c!--   aop编写，让Spring自动对目标生成代理，需要使用AspectJ的表达式 --\x3e\n    <aop:config>\n        <aop:pointcut id="pt" expression="execution(* com.service..*.*(..))"/>\n        <aop:advisor advice-ref="txAdvice"  pointcut-ref="pt" />\n    </aop:config>\n\n</beans>\n\n\n测试：\n\n@Test\npublic void test_XML(){\n    \n    ApplicationContext ac = new ClassPathXmlApplicationContext("SpringConfig.xml");\n   \n    StudentService service = (StudentService) ac.getBean("studentService");\n    \n    //在studentService类 会异常回滚 \n    int number = service.insert(new Student("李四" , 33));\n    System.out.println("number : " + number);\n\n}\n\n\n\n# Annotation应用\n\n主要组件\n\n@Transactional\n\n@Transactional常用属性\n\n属性名           说明\npropagation   配置 事务传播行为\nisolation     配置 事务隔离级别\nreadOnly      配置 事务是否只读\ntimeout       配置 事务超时事件（单位: s）\n\n应用前提：\n\n * 添加事务管理\n   \n   <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n       <property name="dataSource" ref="dataSource"/>\n   </bean>\n   \n\n * 注册加载驱动\n   \n   <tx:annotation-driven transaction-manager="txManager"/>\n   \n\n * 应用方法需要添加 @Transactional 注解\n\n实体类：（Student）\n\npackage com;\n\npublic class Student {\n    int id ;\n    String name;\n    int age;\n    \n    public Student() {\n    }\n    \n    public Student(int id , String name , int age) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n    }\n    \n    public Student(String name , int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    public int getAge() {\n        return age;\n    }\n    \n    public void setAge(int age) {\n        this.age = age;\n    }\n    \n    public int getId() {\n        return id;\n    }\n    \n    public void setId(int id) {\n        this.id = id;\n    }\n    \n    public String getName() {\n        return name;\n    }\n    \n    public void setName(String name) {\n        this.name = name;\n    }\n    \n    @Override\n    public String toString() {\n        return "Student{" +\n                "id=" + id +\n                ", name=\'" + name + \'\\\'\' +\n                ", age=" + age +\n                \'}\';\n    }\n}\n\n\nStudentDao类：（信息交互类）\n\npackage com.dao;\n\nimport com.Student;\nimport org.springframework.jdbc.core.support.JdbcDaoSupport;\n\npublic class StudentDao extends JdbcDaoSupport {\n    \n    /**\n     * 添加数据\n     * @param student 学生类封装\n     * @return 更变条数\n     */\n    public int insert(Student student) {\n        if (student == null) {\n            return 0;\n        }\n        String sql = "insert into student(name,age) value(?,?)";\n        return this.getJdbcTemplate().update(sql,student.getName(),student.getAge());\n    }\n    \n    //其他业务操作省略\n    ····\n}\n\n\nStudentService类：（业务处理类）\n\npackage com.service;\n\nimport com.Student;\nimport com.dao.StudentDao;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Propagation;\nimport org.springframework.transaction.annotation.Transactional;\n\n@Service\npublic class StudentService {\n    \n    //注入类\n    @Autowired\n    private StudentDao studentDao;\n    \n    //事务配置\n    @Transactional(propagation = Propagation.REQUIRED , rollbackFor = {Exception.class})\n    public int insert(Student student){\n        int a = studentDao.insert(student);\n        System.out.println("(1)添加成功 数据: " + student + "\\t影响条目："+a);\n        \n        int aa = 1/0;   //制造异常\n        \n        student.setAge(student.getAge()+1);\n        int b = studentDao.insert(student);\n        System.out.println("(2)添加成功 数据: " + student + "\\t影响条目："+a);\n        return a+b;\n    }\n    \n}\n\n\nSpring 容器配置：（.xml文件）\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:tx="http://www.springframework.org/schema/tx"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       \n       xsi:schemaLocation="\n       http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/tx\n       http://www.springframework.org/schema/tx/spring-tx.xsd\n       http://www.springframework.org/schema/context\n       http://www.springframework.org/schema/context/spring-context.xsd\n">\n\n    \x3c!--    XML 配置数据源--\x3e\n    <bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource">\n        \x3c!--驱动加载--\x3e\n        <property name="driverClassName" value="com.mysql.jdbc.Driver"/>\n        \x3c!--连接数据库的url  . 本次连接 test库--\x3e\n        <property name="url" value="jdbc:mysql://192.168.6.129/test"/>\n        <property name="username" value="root"/>\n        <property name="password" value="root"/>\n    </bean>\n    \x3c!--    配置jdbc模板--\x3e\n    <bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate">\n        \x3c!--必须使用数据源--\x3e\n        <property name="dataSource" ref="dataSource"/>\n    </bean>\n\t\n    \x3c!--扫描包--\x3e\n    <context:component-scan base-package="com"/>\n\x3c!--    事务管理器--\x3e\n    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager">\n        <property name="dataSource" ref="dataSource"/>\n    </bean>\n    \n\x3c!--    事务应用--\x3e\n    <bean id="studentDao" class="com.dao.StudentDao">\n        <property name="jdbcTemplate" ref="jdbcTemplate"/>\n    </bean>\n\t\x3c!--以注解形式应用--\x3e\n    <tx:annotation-driven transaction-manager="transactionManager"/>\n\n</beans>\n\n\n测试：\n\n @Test\npublic void test_Annotation() {\n    ApplicationContext ac = new ClassPathXmlApplicationContext("SpringConfig_Annotation.xml");\n    StudentServic service = (StudentService) ac.getBean("");\n\n    int number = service_annotation.insert(new Student("赵六" , 34));\n    System.out.println("number : " + number);\n    \n}\n',normalizedContent:'# spring\n\nspring是主流的 java web开发框架 ，该框架是轻量级、性能好、易于测试。\n\nspring具有控制反转（ioc）和 面向切面（aop）两大核心。java spring 框架通过声明式方式灵活地进 行事务的管理，提高开发效率和质量\n\nspring优势\n\n>  * 方便解耦，简化开发\n>  * 方便继承各种优秀框架\n>  * 降低 java ee api 使用难度\n>  * 方便程序测试\n>  * aop编程支持\n>  * 声明式事务支持\n\n\n# spring体系结构\n\nspring提供了一站式服务，是以模块化形式呈现需要自行选择\n\n 1. 数据访问/集成\n    * jdbc模块：提供了jdbc抽象层\n    * orm模块：对 对象关系映射api\n    * oxm模块：支持 对象/xml 映射的抽象层实现\n    * jms模块：java消息服务，生产消费信息等\n    * transactions事务模块：支持编程和声明式事务管理实现特殊接口类\n 2. web\n    * web模块：web开发继承的特性\n    * servlet模块：spring 模型-视图-控制器 (mvc) 实现web应用程序\n    * struts模块：支持类内的spring应用程序\n    * portlet模块：提供在portlet环境中使用mvc实现\n 3. 核心容器\n    * beans模块：将对象以bean进行管理\n    * core核心模块：提供框架基本部分， ioc 和 di 功能 等\n    * context上下文模块：是beans模块基础之上，是访问和配置文件任何对象的媒介\n    * expression language模块：运行时查询和对象图的强大的表达式语音\n 4. 其他\n    * aop模块：面向切面的编程实现，允许定义方法拦截器和切入点，按方法功能进行分离，降低耦合性\n    * aspects模块：提供与aspectj的集成，是功能强大的aop框架\n    * instrumentation模块：提供类工具的支持和类加载器的实现，在特定的应用服务器中使用\n    * test模块：支持junit 或 testng 框架测试\n\n\n# spring jdbc\n\nspring 针对数据库开发提供了 jdbctemplate 类，它封装了 jdbc，支持对数据库的所有操作\n\njdbc以往的说明：java学习记录 jdbc篇\n\n> jar包：\n> \n>  * spring-jdbc\n>  * spring-tx\n>  * spring-core\n\n应用步骤：\n\n 1. 引入依赖\n 2. xml数据源配置\n 3. dao层方法继承jdbctemplate注入\n 4. 测试\n\n方法\n\n返回                    方法                                          说明\nint                   update(string sql)                          用于执行新增、修改、删除等语句\nint                   update(string sql,object... args)           用于执行新增、修改、删除等语句 args 表示需要传入的参数\nvoid                  execute(string sql)                         可以执行任意 sql，一般用于执行 ddl 语句 action 表示执行完 sql 语句后，要调用的函数\nt                     query(string sql, resultsetextractor rse)   用于执行查询语句 以 resultsetextractor 作为参数的 query 方法返回值为 object\nlist                  query(string sql, rowmapper rse)            使用查询结果需要对其进行强制转型 以 rowmapper 作为参数的 query 方法返回值为 list\nmap<string, object>   queryformap(string sql)                     sql查询多个聚合函数结果值，查询出的结果值形式：key-value\n...                   ...                                         ...\n\njdbc应用\n\n 1. 导入包 spring-jdbc-x.x.x.jar 、spring-tx-x.x.x.jar 以下为个人用maven配置\n    \n    <dependency>\n        <groupid>org.springframework</groupid>\n        <artifactid>spring-jdbc</artifactid>\n        <version>5.2.13.release</version>\n    </dependency>\n    \n\n 2. spring-xml配置数据源\n    \n    <?xml version="1.0" encoding="utf-8"?>\n    <beans xmlns="http://www.springframework.org/schema/beans"\n           xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n           xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd">\n    \n    \x3c!--    xml 配置数据源--\x3e\n        <bean id="datesource" class="org.springframework.jdbc.datasource.drivermanagerdatasource">\n            \x3c!--驱动加载--\x3e\n            <property name="driverclassname" value="com.mysql.jdbc.driver"/>\n            \x3c!--连接数据库的url  . 本次连接 test库--\x3e\n         \t\x3c!--指定ip地址 、 库（个人应用的 test库）--\x3e   \n            <property name="url" value="jdbc:mysql://192.168.74.131/test"/>\n            <property name="username" value="root"/>\n            <property name="password" value="root"/>\n        </bean>\n    \n    \x3c!--    配置jdbc模板--\x3e\n        <bean id="jdbctemplate" class="org.springframework.jdbc.core.jdbctemplate">\n            \x3c!--必须使用数据源--\x3e\n            <property name="datasource" ref="datesource"/>\n        </bean>\n    \n    \x3c!--    配置注入类使用--\x3e\n        <bean id="xxx" class="xxx">\n            <property name="jdbctemplate" ref="jdbctemplate"/>\n        </bean>\n    \x3c!--\t例如：--\x3e\n    \x3c!--    <bean id="studentdao" class="com.studentdao">--\x3e\n    \x3c!--        <property name="jdbctemplate" ref="jdbctemplate"/>--\x3e\n    \x3c!--    </bean>--\x3e\n    \t...\n    </beans>\n    \n    \n    配置注入类需要自己指定类进行配置\n\n 3. 创建实体类 student\n    \n    public class student {\n        int id ;\n        string name;\n        int age;\n        \n        // 省略多余的 get和set方法\n        \n        @override\n        public string tostring() {\n            return "student{" +\n                    "id=" + id +\n                    ", name=\'" + name + \'\\\'\' +\n                    ", age=" + age +\n                    \'}\';\n        }\n    }\n    \n\n 4. 数据库 test库引入库\n    \n    id   name   age\n    \n    drop table if exists `student`;\n    create table `student`  (\n      `id` int(11) not null auto_increment,\n      `name` varchar(255) character set utf8 collate utf8_general_ci null default null,\n      `age` int(11) null default 16,\n      primary key (`id`) using btree\n    ) engine = innodb auto_increment = 16 character set = utf8 collate = utf8_general_ci row_format = compact;\n    \n\n 5. 指定类注入使用 jdbctemplate类 （应用指定实例 studentdao；实现一个操作业务即可）\n    \n    public class studentdao extends jdbcdaosupport {\n        \n        // 方法封装\n        public student turnencapsulation(resultset resultset) throws sqlexception {\n            student student = new student();\n            student.setid(resultset.getint("id"));\n            student.setname(resultset.getstring("name"));\n            student.setage(resultset.getint("age"));\n            return student;\n        }\n        \n        /**\n         * 添加数据\n         * @param student 学生类封装\n         * @return 更变条数\n         */\n        public int insert(student student) {\n            if (student == null) {\n                return 0;\n            } \n            string sql = "insert into student(name,age) value(?,?)";\n            return this.getjdbctemplate().update(sql,student.getname(),student.getage());\n        }\n        \n        /**\n         * 删除数据\n         * @param id 删除指定id\n         * @return 更变条数\n         */\n        public int delete(int id) {\n            string sql = "delete from student where id = ?";\n            return this.getjdbctemplate().update(sql,id);\n        }\n        \n        /**\n         * 更变数据\n         * @param id 指定学生id\n         * @param student 更变指定 学生类\n         * @return 更变条数\n         */\n        public int update(int id , student student) {\n            string sql = "update student set name=?,age=? where id=?";\n            return this.getjdbctemplate().update(sql,student.getname(),student.getage(),id);\n        }\n        \n        /**\n         * 查询所有条数\n         * @return 学生队列\n         */\n        public list<student> queryall(){\n            string sql = "select * from student";\n            return this.getjdbctemplate().query(sql , new rowmapper<student>() {\n                @override\n                public student maprow(resultset resultset , int i) throws sqlexception {\n                    system.out.println("\\ti : " + i);\n                    return turnencapsulation(resultset);\n                }\n            });\n        }\n        \n        /**\n         * 查询指定学生\n         * @param id 指定学生id\n         * @return 学生队列\n         */\n        public list<student> queryfindbyid(int id) {\n            string sql = "select * from student where id = ?";\n            return this.getjdbctemplate().query(sql,new object[]{id}, new rowmapper<student>() {\n                @override\n                public student maprow(resultset resultset , int i) throws sqlexception {\n                    system.out.println("\\ti : " + i);\n                    return turnencapsulation(resultset);\n                }\n            });\n        }\n        \n        /**\n         * 查询指定学生名称\n         * @param name 名称\n         * @return 学生队列\n         */\n        public list<student> queryfindbyname(string name) {\n            string sql = "select * from student where name = ?";\n            //匿名 new rowmapper<student>() 替换为 lambda\n            return this.getjdbctemplate().query(sql,new object[]{name}, (resultset , i) -> {\n                system.out.println("\\ti : " + i);\n                return turnencapsulation(resultset);\n            });\n        }\n        \n        /**\n         * 聚合函数应用\n         */\n        /**\n         * 获取学生总数\n         * @return 学生总数\n         */\n        public int tablesize(){\n            string sql = "select count(id) from student";\n            return this.getjdbctemplate().queryforobject(sql,integer.class);\n        }\n        \n        /**\n         * 学生首尾id\n         * @return map形式返回id首尾\n         */\n        public map<string , object> tablemaxmin(){\n            string sql = "select max(id),min(id) from student";\n            return this.getjdbctemplate().queryformap(sql);\n        }\n        \n    }\n    \n\n 6. 测试类 （测试业务）\n    \n    public class connectionmysql {\n    \n        applicationcontext ac = new classpathxmlapplicationcontext("springjdbc.xml");\n        studentdao dao = (studentdao) ac.getbean("studentdao");\n        \n        /**\n         * xml应用\n         */\n        @test\n        public void test01_insert(){\n            int insert = dao.insert(new student("老哥" , 23));\n            system.out.println("insert : " + insert);\n        }\n        @test\n        public void test02_delete() {\n            int delete = dao.delete(19);\n            system.out.println("delete : " + delete);\n            \n        }\n        @test\n        public void test03_update() {\n            int update = dao.update(16,new student("黑马",32));\n            system.out.println("update : " + update);\n        }\n        @test\n        public void test04_query() {\n            list<student> student = dao.queryfindbyid(17);\n            system.out.println("student : " + student);\n        }\n        @test\n        public void test04_querys() {\n            list<student> students = dao.queryall();\n            // list<student> students = dao.queryfindbyname("李四");\n            for (student student : students) {\n                system.out.println(student.tostring());\n            }\n        }\n        @test\n        public void test05_group(){\n            int i = dao.tablesize();\n            system.out.println("i : " + i);\n            system.out.println("==============");\n            map<string, object> stringobjectmap = dao.tablemaxmin();\n            system.out.println("stringobjectmap : " + stringobjectmap);\n        }\n        \n    }\n    \n\n\n# spring事务管理\n\n事务（transaction）是面向关系型数据库（rdbms）企业应用程序的重要组成部分，用来确保数据的完整性和一致性。\n\n事务了解 ：mysql学习记录 事务篇\n\nspring 实现声明式事务管理主要有 2 种方式：\n\n * 基于 xml 方式的声明式事务管理\n * 通过 annotation 注解方式的事务管理\n\n\n# 事务管理接口\n\nspring 的事务管理 ：platformtransactionmanager、transactiondefinition 是事务主要核心接口\n\nplatformtransactionmanager接口\n\n该接口用于管理事务。其主要用于完成事务的提交、回滚，及获取 事务的状态信息\n\npublic interface platformtransactionmanager extends transactionmanager {\n    transactionstatus gettransaction(@nullable transactiondefinition var1) throws transactionexception;\n\n    void commit(transactionstatus var1) throws transactionexception;\n\n    void rollback(transactionstatus var1) throws transactionexception;\n}\n\n\n返回                  抽象方法                                                   说明\ntransactionstatus   gettransaction(@nullable transactiondefinition var1)   获取事务的状态信息\nvoid                commit(transactionstatus var1)                         提交事务\nvoid                rollback(transactionstatus var1)                       回滚事务\n\ntransactiondefinition接口\n\n该接口主要获取事务相关信息的作用\n\npublic interface transactiondefinition {\n    ....\n\n    default int getpropagationbehavior() {\n        return 0;\n    }\n\n    default int getisolationlevel() {\n        return -1;\n    }\n\n    default int gettimeout() {\n        return -1;\n    }\n\n    default boolean isreadonly() {\n        return false;\n    }\n\n    @nullable\n    default string getname() {\n        return null;\n    }\n\t....\n}\n\n\n返回        抽象方法                       说明\nint       getpropagationbehavior()   获取事务的 传播行为\nint       getisolationlevel()        获取事务的 隔离级别\nint       gettimeout()               获取事务的 超时时间\nboolean   isreadonly()               获取事务是否 只读\nstring    getname()                  获取事务的 名称\n\n属性说明\n\n事务传播行为（propagation behavior）指的就是当一个事务方法被另一个事务方法调用时，这个事务方法应该如何进行。\n\n传播行为名称值                     说明\npropagation_mandatory       支持当前事务，如果不存在当前事务，则引发异常\npropagation_nested          如果当前事务存在，则在嵌套事务中执行\npropagation_never           不支持当前事务，如果当前事务存在，则引发异常\npropagation_not_supported   不支持当前事务，始终以非事务方式执行\npropagation_required        默认传播行为，支持当前事务，如果不存在，则创建一个新的\npropagation_requires_new    创建新事务，如果已存在事务则暂停当前事务，应用新的\npropagation_supports        支持当前事务，如果不存在事务，则以非事务方式执行\n\n\n# xml应用\n\n主要配置组件（.xml）\n\n<tx:advice id="txadvice" transaction-manager="transactionmanager">\n    <tx:attributes>\n        \x3c!--            <tx:method name="insert*" propagation="required"/>--\x3e\n        \x3c!--            <tx:method name="add*" propagation="required"/>--\x3e\n        \x3c!--            <tx:method name="find*" propagation="supports" read-only="true"/>--\x3e\n        <tx:method name="*" />\n    </tx:attributes>\n</tx:advice>\n\x3c!--   aop编写，让spring自动对目标生成代理，需要使用aspectj的表达式 --\x3e\n<aop:config>\n    <aop:pointcut id="pt" expression="execution(* com.service..*.*(..))"/>\n    <aop:advisor advice-ref="txadvice"  pointcut-ref="pt" />\n</aop:config>\n\n\n应用前提：\n\n添加依赖\n\n<dependency>\n    <groupid>org.aspectj</groupid>\n    <artifactid>aspectjweaver</artifactid>\n    <version>1.9.6</version>\n</dependency>\n\n\n实体类：（student）\n\npackage com;\n\npublic class student {\n    int id ;\n    string name;\n    int age;\n    \n    public student() {\n    }\n    \n    public student(int id , string name , int age) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n    }\n    \n    public student(string name , int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    public int getage() {\n        return age;\n    }\n    \n    public void setage(int age) {\n        this.age = age;\n    }\n    \n    public int getid() {\n        return id;\n    }\n    \n    public void setid(int id) {\n        this.id = id;\n    }\n    \n    public string getname() {\n        return name;\n    }\n    \n    public void setname(string name) {\n        this.name = name;\n    }\n    \n    @override\n    public string tostring() {\n        return "student{" +\n                "id=" + id +\n                ", name=\'" + name + \'\\\'\' +\n                ", age=" + age +\n                \'}\';\n    }\n}\n\n\nstudentdao类：（信息交互类）\n\npackage com.dao;\n\nimport com.student;\nimport org.springframework.jdbc.core.support.jdbcdaosupport;\n\npublic class studentdao extends jdbcdaosupport {\n    \n    /**\n     * 添加数据\n     * @param student 学生类封装\n     * @return 更变条数\n     */\n    public int insert(student student) {\n        if (student == null) {\n            return 0;\n        }\n        string sql = "insert into student(name,age) value(?,?)";\n        return this.getjdbctemplate().update(sql,student.getname(),student.getage());\n    }\n    \n    //其他业务操作省略\n    ····\n}\n\n\nstudentservice类：（业务处理类）\n\npackage com.service;\n\nimport com.student;\nimport com.dao.studentdao;\n\npublic class studentservice {\n    \n    private studentdao studentdao;\n    \n    public void setstudentdao(studentdao studentdao) {\n        this.studentdao = studentdao;\n    }\n    \n    public int insert(student student){\n        int a = studentdao.insert(student);\n        system.out.println("(1)添加成功 数据: " + student + "\\t影响条目："+a);\n        int aa = 1/0;   //制造异常\n        student.setage(student.getage()+1);\n        int b = studentdao.insert(student);\n        system.out.println("(2)添加成功 数据: " + student + "\\t影响条目："+a);\n        return a+b;\n    }\n}\n\n\nspring 容器配置：（.xml文件）\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:tx="http://www.springframework.org/schema/tx"\n       xmlns:aop="http://www.springframework.org/schema/aop"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       \n       xsi:schemalocation="\n\t\t\thttp://www.springframework.org/schema/beans\n\t\t\thttp://www.springframework.org/schema/beans/spring-beans.xsd\n\t\t\thttp://www.springframework.org/schema/tx \n\t\t\thttp://www.springframework.org/schema/tx/spring-tx.xsd\n\t\t\thttp://www.springframework.org/schema/aop \n\t\t\thttp://www.springframework.org/schema/aop/spring-aop.xsd\n">\n\n    \x3c!--    xml 配置数据源--\x3e\n    <bean id="datasource" class="com.mchange.v2.c3p0.combopooleddatasource">\n        <property name="driverclass" value="com.mysql.cj.jdbc.driver"/>\n        <property name="jdbcurl"\n                  value="jdbc:mysql://192.168.6.129:3306/test?servertimezone=utc&amp;characterencoding=utf8&amp;useunicode=true&amp;usessl=false"/>\n        <property name="user" value="root"/>\n        <property name="password" value="root"/>\n    </bean>\n    \x3c!--    配置jdbc模板--\x3e\n    <bean id="jdbctemplate" class="org.springframework.jdbc.core.jdbctemplate">\n        <property name="datasource" ref="datasource"/>\n    </bean>\n\n    \x3c!--    类注入应用--\x3e\n    <bean id="studentdao" class="com.dao.studentdao">\n        <property name="jdbctemplate" ref="jdbctemplate"/>\n    </bean>\n    <bean id="studentservice" class="com.service.studentservice">\n        <property name="studentdao" ref="studentdao"/>\n    </bean>\n\n    \x3c!--    事务管理器--\x3e\n    <bean id="transactionmanager" class="org.springframework.jdbc.datasource.datasourcetransactionmanager">\n        <property name="datasource" ref="datasource"/>\n    </bean>\n\n    \x3c!--    事务触发方法 以及 事务处理方式--\x3e\n    <tx:advice id="txadvice" transaction-manager="transactionmanager">\n        <tx:attributes>\n            \x3c!--            <tx:method name="insert*" propagation="required"/>--\x3e\n            \x3c!--            <tx:method name="add*" propagation="required"/>--\x3e\n            \x3c!--            <tx:method name="find*" propagation="supports" read-only="true"/>--\x3e\n            <tx:method name="*" />\n        </tx:attributes>\n    </tx:advice>\n    \x3c!--   aop编写，让spring自动对目标生成代理，需要使用aspectj的表达式 --\x3e\n    <aop:config>\n        <aop:pointcut id="pt" expression="execution(* com.service..*.*(..))"/>\n        <aop:advisor advice-ref="txadvice"  pointcut-ref="pt" />\n    </aop:config>\n\n</beans>\n\n\n测试：\n\n@test\npublic void test_xml(){\n    \n    applicationcontext ac = new classpathxmlapplicationcontext("springconfig.xml");\n   \n    studentservice service = (studentservice) ac.getbean("studentservice");\n    \n    //在studentservice类 会异常回滚 \n    int number = service.insert(new student("李四" , 33));\n    system.out.println("number : " + number);\n\n}\n\n\n\n# annotation应用\n\n主要组件\n\n@transactional\n\n@transactional常用属性\n\n属性名           说明\npropagation   配置 事务传播行为\nisolation     配置 事务隔离级别\nreadonly      配置 事务是否只读\ntimeout       配置 事务超时事件（单位: s）\n\n应用前提：\n\n * 添加事务管理\n   \n   <bean id="transactionmanager" class="org.springframework.jdbc.datasource.datasourcetransactionmanager">\n       <property name="datasource" ref="datasource"/>\n   </bean>\n   \n\n * 注册加载驱动\n   \n   <tx:annotation-driven transaction-manager="txmanager"/>\n   \n\n * 应用方法需要添加 @transactional 注解\n\n实体类：（student）\n\npackage com;\n\npublic class student {\n    int id ;\n    string name;\n    int age;\n    \n    public student() {\n    }\n    \n    public student(int id , string name , int age) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n    }\n    \n    public student(string name , int age) {\n        this.name = name;\n        this.age = age;\n    }\n    \n    public int getage() {\n        return age;\n    }\n    \n    public void setage(int age) {\n        this.age = age;\n    }\n    \n    public int getid() {\n        return id;\n    }\n    \n    public void setid(int id) {\n        this.id = id;\n    }\n    \n    public string getname() {\n        return name;\n    }\n    \n    public void setname(string name) {\n        this.name = name;\n    }\n    \n    @override\n    public string tostring() {\n        return "student{" +\n                "id=" + id +\n                ", name=\'" + name + \'\\\'\' +\n                ", age=" + age +\n                \'}\';\n    }\n}\n\n\nstudentdao类：（信息交互类）\n\npackage com.dao;\n\nimport com.student;\nimport org.springframework.jdbc.core.support.jdbcdaosupport;\n\npublic class studentdao extends jdbcdaosupport {\n    \n    /**\n     * 添加数据\n     * @param student 学生类封装\n     * @return 更变条数\n     */\n    public int insert(student student) {\n        if (student == null) {\n            return 0;\n        }\n        string sql = "insert into student(name,age) value(?,?)";\n        return this.getjdbctemplate().update(sql,student.getname(),student.getage());\n    }\n    \n    //其他业务操作省略\n    ····\n}\n\n\nstudentservice类：（业务处理类）\n\npackage com.service;\n\nimport com.student;\nimport com.dao.studentdao;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.stereotype.service;\nimport org.springframework.transaction.annotation.propagation;\nimport org.springframework.transaction.annotation.transactional;\n\n@service\npublic class studentservice {\n    \n    //注入类\n    @autowired\n    private studentdao studentdao;\n    \n    //事务配置\n    @transactional(propagation = propagation.required , rollbackfor = {exception.class})\n    public int insert(student student){\n        int a = studentdao.insert(student);\n        system.out.println("(1)添加成功 数据: " + student + "\\t影响条目："+a);\n        \n        int aa = 1/0;   //制造异常\n        \n        student.setage(student.getage()+1);\n        int b = studentdao.insert(student);\n        system.out.println("(2)添加成功 数据: " + student + "\\t影响条目："+a);\n        return a+b;\n    }\n    \n}\n\n\nspring 容器配置：（.xml文件）\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:tx="http://www.springframework.org/schema/tx"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       \n       xsi:schemalocation="\n       http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/tx\n       http://www.springframework.org/schema/tx/spring-tx.xsd\n       http://www.springframework.org/schema/context\n       http://www.springframework.org/schema/context/spring-context.xsd\n">\n\n    \x3c!--    xml 配置数据源--\x3e\n    <bean id="datasource" class="org.springframework.jdbc.datasource.drivermanagerdatasource">\n        \x3c!--驱动加载--\x3e\n        <property name="driverclassname" value="com.mysql.jdbc.driver"/>\n        \x3c!--连接数据库的url  . 本次连接 test库--\x3e\n        <property name="url" value="jdbc:mysql://192.168.6.129/test"/>\n        <property name="username" value="root"/>\n        <property name="password" value="root"/>\n    </bean>\n    \x3c!--    配置jdbc模板--\x3e\n    <bean id="jdbctemplate" class="org.springframework.jdbc.core.jdbctemplate">\n        \x3c!--必须使用数据源--\x3e\n        <property name="datasource" ref="datasource"/>\n    </bean>\n\t\n    \x3c!--扫描包--\x3e\n    <context:component-scan base-package="com"/>\n\x3c!--    事务管理器--\x3e\n    <bean id="transactionmanager" class="org.springframework.jdbc.datasource.datasourcetransactionmanager">\n        <property name="datasource" ref="datasource"/>\n    </bean>\n    \n\x3c!--    事务应用--\x3e\n    <bean id="studentdao" class="com.dao.studentdao">\n        <property name="jdbctemplate" ref="jdbctemplate"/>\n    </bean>\n\t\x3c!--以注解形式应用--\x3e\n    <tx:annotation-driven transaction-manager="transactionmanager"/>\n\n</beans>\n\n\n测试：\n\n @test\npublic void test_annotation() {\n    applicationcontext ac = new classpathxmlapplicationcontext("springconfig_annotation.xml");\n    studentservic service = (studentservice) ac.getbean("");\n\n    int number = service_annotation.insert(new student("赵六" , 34));\n    system.out.println("number : " + number);\n    \n}\n',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"SpringMVC 重定向和转发",frontmatter:{title:"SpringMVC 重定向和转发",author:"柏竹",permalink:"/backend/8pqmjz",date:"2020-02-18T00:00:00.000Z",categories:["后端"],tags:["SpringMVC","Java"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/08.SpringMVC/04.%E9%87%8D%E5%AE%9A%E5%90%91%E5%92%8C%E8%BD%AC%E5%8F%91.html",relativePath:"01.后端/08.SpringMVC/04.重定向和转发.md",key:"v-790e32d0",path:"/backend/8pqmjz/",headers:[{level:2,title:"应用测试",slug:"应用测试",normalizedTitle:"应用测试",charIndex:433},{level:3,title:"转发",slug:"转发",normalizedTitle:"转发",charIndex:16},{level:3,title:"重定向",slug:"重定向",normalizedTitle:"重定向",charIndex:12}],headersStr:"应用测试 转发 重定向",content:'# SpringMVC 重定向和转发\n\nSpring MVC 请求方式 分为：转发、重定向 2种。在Servlet中 请求方式处理都是在 controller层 ！！！\n\n转发\n\n> 客户浏览器发送 http 请求，在内部方法中完成请求处理和转发动作。在这里转发的路径必须是同一个 Web 容器下的 URL，其不能转向到其他的 Web 路径上，中间传递的是自己的容器内的 request\n\n重定向\n\n> 客户浏览器发送 http 请求，Web 服务器接受后发送 302 状态码响应及对应新的 URL地址 给客户浏览器，客户浏览器发现是 302 响应，则自动再发送一个新的 http 请求，请求 URL 是新的地址，服务器根据此请求寻找资源并发送给客户\n\n\n\n重定向与转发的区别\n\n>  * 重定向 会改变地址，requset存储的数据会丢失 转发 时地址会显示请求页面的地址，保存了页面的数据\n>  * 重定向 两次请求 两次响应 转发 一次请求 一次响应\n\n\n# 应用测试\n\n应用前提&说明\n\nNavigationController类 控制器\n\n@Controller\n@RequestMapping ("/navigation")\npublic class NavigationController {\n    ····\n}\n\n\nnavigationTest.jsp文件响应形式\n\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>navigationTest</title>\n</head>\n<body>\n    <h1> 跳转 & 重定向 测试</h1>\n    <h2>参数测试</h2>\n    \n    <h3>requestScope 作用域</h3>\n    <div>\n        <span>id: ${requestScope.id}</span> <br>\n        <span>name: ${requestScope.name}</span>\n    </div>\n    \n    <h3>pageScope 作用域</h3>\n    <div>\n        <span>id: ${pageScope.id}</span> <br>\n        <span>name: ${pageScope.name}</span>\n    </div>\n    \n    <h3>sessionScope 作用域</h3>\n    <div>\n        <span>id: ${sessionScope.id}</span> <br>\n        <span>name: ${sessionScope.name}</span>\n    </div>\n    \n</body>\n</html>\n\n\n\n# 转发\n\n/**\n *  String 形式转发\n *  应用前提：前缀 需要 forward关键字\n */\n@RequestMapping("forwardString")\npublic String forwardString(HttpServletRequest request) {\n    request.setAttribute("id" , 1);\n    request.setAttribute("name" , "柏竹");\n    //return "jsp/navigationTest.jsp"\n    return "forward:/jsp/navigationTest.jsp";\n}\n\n\n/**\n *  ModelAndView 形式转发\n *  应用前提：前缀 需要 forward关键字\n */\n@RequestMapping("forwardMAV")\npublic ModelAndView forwardMAV(){\n    ModelAndView mv = new ModelAndView();\n    mv.addObject("id",2);\n    mv.addObject("name","智乃");\n    mv.setViewName("forward:/jsp/navigationTest.jsp");\n    return mv;\n}\n\n\n/**\n *  String 形式转发 控制器\n */\n@RequestMapping("forwardString2")\npublic String forwardString2(HttpServletRequest request) {\n    request.setAttribute("id" , 6);\n    request.setAttribute("name" , "纱雾");\n    return "forward:/navigation/forwardString";\n}\n\n\n/**\n *  ModelAndView 形式转发 控制器\n */\n@RequestMapping("forwardMAV2")\npublic ModelAndView forwardMAV2(){\n    ModelAndView mv = new ModelAndView();\n    mv.addObject("id",7);\n    mv.addObject("name","琪露诺");\n    mv.setViewName("forward:/navigation/forwardMAV");\n    return mv;\n}\n\n\n\n# 重定向\n\n/**\n *  String 重定向\n */\n@RequestMapping("redirectString")\npublic String redirectString(HttpServletRequest request) {\n    request.setAttribute("id",4);\n    request.setAttribute("name","黑猫");\n    return "redirect:/jsp/navigationTest.jsp";\n}\n\n\n/**\n *  ModelAndView 重定向\n */\n@RequestMapping("redirectMAV")\npublic ModelAndView redirectMAV() {\n    ModelAndView mv = new ModelAndView();\n    mv.addObject("id",5);\n    mv.addObject("name","蕾姆");\n    mv.setViewName("redirect:/jsp/navigationTest.jsp");\n    return mv;\n}\n\n\n//重定向 控制器\n\n/**\n *  String 控制器重定向\n */\n@RequestMapping("redirectString2")\npublic String redirectString2(HttpServletRequest request) {\n    request.setAttribute("id",8);\n    request.setAttribute("name","香子兰");\n    return "redirect:/navigation/redirectString";\n}\n\n\n/**\n *  ModelAndView 控制器重定向\n */\n@RequestMapping("redirectMAV2")\npublic ModelAndView redirectMAV2() {\n    ModelAndView mv = new ModelAndView();\n    mv.addObject("id",9);\n    mv.addObject("name","黑子");\n    mv.setViewName("redirect:/navigation/redirectMAV");\n    return mv;\n}\n',normalizedContent:'# springmvc 重定向和转发\n\nspring mvc 请求方式 分为：转发、重定向 2种。在servlet中 请求方式处理都是在 controller层 ！！！\n\n转发\n\n> 客户浏览器发送 http 请求，在内部方法中完成请求处理和转发动作。在这里转发的路径必须是同一个 web 容器下的 url，其不能转向到其他的 web 路径上，中间传递的是自己的容器内的 request\n\n重定向\n\n> 客户浏览器发送 http 请求，web 服务器接受后发送 302 状态码响应及对应新的 url地址 给客户浏览器，客户浏览器发现是 302 响应，则自动再发送一个新的 http 请求，请求 url 是新的地址，服务器根据此请求寻找资源并发送给客户\n\n\n\n重定向与转发的区别\n\n>  * 重定向 会改变地址，requset存储的数据会丢失 转发 时地址会显示请求页面的地址，保存了页面的数据\n>  * 重定向 两次请求 两次响应 转发 一次请求 一次响应\n\n\n# 应用测试\n\n应用前提&说明\n\nnavigationcontroller类 控制器\n\n@controller\n@requestmapping ("/navigation")\npublic class navigationcontroller {\n    ····\n}\n\n\nnavigationtest.jsp文件响应形式\n\n<%@ page contenttype="text/html;charset=utf-8" language="java" %>\n<html>\n<head>\n    <title>navigationtest</title>\n</head>\n<body>\n    <h1> 跳转 & 重定向 测试</h1>\n    <h2>参数测试</h2>\n    \n    <h3>requestscope 作用域</h3>\n    <div>\n        <span>id: ${requestscope.id}</span> <br>\n        <span>name: ${requestscope.name}</span>\n    </div>\n    \n    <h3>pagescope 作用域</h3>\n    <div>\n        <span>id: ${pagescope.id}</span> <br>\n        <span>name: ${pagescope.name}</span>\n    </div>\n    \n    <h3>sessionscope 作用域</h3>\n    <div>\n        <span>id: ${sessionscope.id}</span> <br>\n        <span>name: ${sessionscope.name}</span>\n    </div>\n    \n</body>\n</html>\n\n\n\n# 转发\n\n/**\n *  string 形式转发\n *  应用前提：前缀 需要 forward关键字\n */\n@requestmapping("forwardstring")\npublic string forwardstring(httpservletrequest request) {\n    request.setattribute("id" , 1);\n    request.setattribute("name" , "柏竹");\n    //return "jsp/navigationtest.jsp"\n    return "forward:/jsp/navigationtest.jsp";\n}\n\n\n/**\n *  modelandview 形式转发\n *  应用前提：前缀 需要 forward关键字\n */\n@requestmapping("forwardmav")\npublic modelandview forwardmav(){\n    modelandview mv = new modelandview();\n    mv.addobject("id",2);\n    mv.addobject("name","智乃");\n    mv.setviewname("forward:/jsp/navigationtest.jsp");\n    return mv;\n}\n\n\n/**\n *  string 形式转发 控制器\n */\n@requestmapping("forwardstring2")\npublic string forwardstring2(httpservletrequest request) {\n    request.setattribute("id" , 6);\n    request.setattribute("name" , "纱雾");\n    return "forward:/navigation/forwardstring";\n}\n\n\n/**\n *  modelandview 形式转发 控制器\n */\n@requestmapping("forwardmav2")\npublic modelandview forwardmav2(){\n    modelandview mv = new modelandview();\n    mv.addobject("id",7);\n    mv.addobject("name","琪露诺");\n    mv.setviewname("forward:/navigation/forwardmav");\n    return mv;\n}\n\n\n\n# 重定向\n\n/**\n *  string 重定向\n */\n@requestmapping("redirectstring")\npublic string redirectstring(httpservletrequest request) {\n    request.setattribute("id",4);\n    request.setattribute("name","黑猫");\n    return "redirect:/jsp/navigationtest.jsp";\n}\n\n\n/**\n *  modelandview 重定向\n */\n@requestmapping("redirectmav")\npublic modelandview redirectmav() {\n    modelandview mv = new modelandview();\n    mv.addobject("id",5);\n    mv.addobject("name","蕾姆");\n    mv.setviewname("redirect:/jsp/navigationtest.jsp");\n    return mv;\n}\n\n\n//重定向 控制器\n\n/**\n *  string 控制器重定向\n */\n@requestmapping("redirectstring2")\npublic string redirectstring2(httpservletrequest request) {\n    request.setattribute("id",8);\n    request.setattribute("name","香子兰");\n    return "redirect:/navigation/redirectstring";\n}\n\n\n/**\n *  modelandview 控制器重定向\n */\n@requestmapping("redirectmav2")\npublic modelandview redirectmav2() {\n    modelandview mv = new modelandview();\n    mv.addobject("id",9);\n    mv.addobject("name","黑子");\n    mv.setviewname("redirect:/navigation/redirectmav");\n    return mv;\n}\n',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"SpringMVC",frontmatter:{title:"SpringMVC",author:"柏竹",permalink:"/backend/t373xy",date:"2020-02-18T00:00:00.000Z",categories:["后端"],tags:["SpringMVC","Java"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/08.SpringMVC/01.%E8%AE%A4%E7%9F%A5%E5%BA%94%E7%94%A8.html",relativePath:"01.后端/08.SpringMVC/01.认知应用.md",key:"v-c84beac8",path:"/backend/t373xy/",headers:[{level:2,title:"首次应用",slug:"首次应用",normalizedTitle:"首次应用",charIndex:289},{level:2,title:"工作流程",slug:"工作流程",normalizedTitle:"工作流程",charIndex:6990},{level:2,title:"组件",slug:"组件",normalizedTitle:"组件",charIndex:120},{level:2,title:"注解应用",slug:"注解应用",normalizedTitle:"注解应用",charIndex:8771},{level:3,title:"@Controller",slug:"controller",normalizedTitle:"@controller",charIndex:1734},{level:3,title:"@RequestMapping",slug:"requestmapping",normalizedTitle:"@requestmapping",charIndex:1950},{level:2,title:"SpringMVC问题",slug:"springmvc问题",normalizedTitle:"springmvc问题",charIndex:13141},{level:3,title:"Tomcat 首次访问 index 404",slug:"tomcat-首次访问-index-404",normalizedTitle:"tomcat 首次访问 index 404",charIndex:13157}],headersStr:"首次应用 工作流程 组件 注解应用 @Controller @RequestMapping SpringMVC问题 Tomcat 首次访问 index 404",content:'# SpringMVC\n\nSpring MVC 是 Spring 提供的一个基于 MVC 设计模式的轻量级 Web 开发框架，本质上相当于 Servlet（底层运行）\n\nSpring MVC 分工明细 ，和框架无缝结合，采用了松散耦合可插拔组件结构，比其他 MVC 框架更具扩展性 和灵活性\n\nMVC设计模式了解：JavaWeb学习记录 MVC与三层的设计模式_\n\n**SpringMVC优势 **\n\n * 轻量级，不依赖特性接口 和 类\n * 分工明确，实现前后端分离\n * Spring的一部分 可以 应用 Ioc 和 Aop\n * 国际化支持\n * 面向接口编程\n\n\n# 首次应用\n\n添加依赖\n\n\x3c!--    web项目--\x3e\n<packaging>war</packaging>\n\n<dependencies>\n\x3c!--        spring-webmvc依赖--\x3e\n    <dependency>\n        <groupId>org.springframework</groupId>\n        <artifactId>spring-webmvc</artifactId>\n        <version>5.2.13.RELEASE</version>\n    </dependency>\n\x3c!--        springmvc底层 servlet依赖--\x3e\n    <dependency>\n        <groupId>javax.servlet</groupId>\n        <artifactId>javax.servlet-api</artifactId>\n        <version>4.0.1</version>\n        \x3c!--插件运行的时候没有范围插件启动会失败--\x3e\n        <scope>provided</scope>\n    </dependency>\n</dependencies>\n\n<build>\n    <plugins>\n        <plugin>\n            <groupId>org.apache.maven.plugins</groupId>\n            <artifactId>maven-compiler-plugin</artifactId>\n            <version>3.8.0</version>\n    \t\t\x3c!--jdk版本--\x3e\n            <configuration>\n                <source>1.8</source>\n                <target>1.8</target>\n            </configuration>\n        </plugin>\n\x3c!--            tomcat插件--\x3e\n        <plugin>\n            <groupId>org.apache.tomcat.maven</groupId>\n            <artifactId>tomcat7-maven-plugin</artifactId>\n            <version>2.2</version>\n            <configuration>\n                <path>/</path>\n                <port>8080</port>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n\n\n业务类及控制器 UserService类 add业务\n\n@Service\npublic class UserService {\n    public void add() {\n        System.out.println("UserService---add---");\n    }\n}\n\n\nUserController类 控制器\n\n//@Controller注解 会自动注册DefaultAnnotationHandlerMapping与AnnotationMethodHandlerAdapter 两个bean\n@Controller\npublic class UserController {\n    \n    @Autowired\n    private UserService userService;\n    \n    //注解值 url请求 后缀\n    @RequestMapping("/hello.do")\n    public ModelAndView add(){\n        System.out.println("UserController---add---");\n        userService.add();\n     \t//用于响应    \n        ModelAndView mv = new ModelAndView();\n        //响应至 前端指定变量\n        //相当于 request.setAttrubuite("userName","Sanscan12") \n        mv.addObject("userName","Sanscan12");\n        //经过springmvc的视图解析器处理，转换成物理资源路径（配置跳转页面设置）\n        //相当于 request.getRequestDispatcher("index.jsp").forward(); （跳转页面）\n        mv.setViewName("index");\n        //经过InternalResourceViewResolver对象的处理之后加上前后缀就变为了/index.jsp\n        return mv;\n    }\n    \n}\n\n\n建立 配置文件（resources目录下） Spring容器 applicationContext.xml 配置文件\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xsi:schemaLocation="\n       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n">\n\n    <context:component-scan base-package="com.service,com.dao"/>\n\n</beans>\n\n\nSpringMVC容器 springmvc.xml 配置文件\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:mvc="http://www.springframework.org/schema/mvc"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xsi:schemaLocation="\n       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\n">\n\n    <context:component-scan base-package="com.controller"/>\n\n\x3c!--    分发用户请求--\x3e\n    <mvc:annotation-driven/>\n\x3c!--    视图解析器--\x3e\n    <bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver">\n        <property name="prefix" value="/"/>\n        <property name="suffix" value=".jsp"/>\n    </bean>\n\n</beans>\n\n\n配置 web.xml 文件 （web目录下）\n\n<?xml version="1.0" encoding="UTF-8"?>\n<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"\n         version="4.0">\n\n\t\x3c!--   spring配置--\x3e\n    <context-param>\n        \x3c!--contextConfigLocation:用于加载bean的配置文件--\x3e\n        <param-name>contextConfigLocation</param-name>\n        \x3c!--指定spring配置文件的位置 --\x3e\n        <param-value>classpath:applicationContext.xml</param-value>\n    </context-param>\n    <listener>\n        <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class>\n    </listener>\n\n    \x3c!-- Springmvc配置--\x3e\n    <servlet>\n        <servlet-name>dispatcherServlet</servlet-name>\n        \x3c!--前端控制器的完全限定名，在spring-webmvc-5.2.5.RELEASE.jar包中的 org.springframework.web.servlet下--\x3e\n        <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>\n        \x3c!-- 创建前端控制器时会读取springmvc配置文件启动ioc容器--\x3e\n        <init-param>\n            <param-name>contextConfigLocation</param-name>\n         \t\x3c!--指定的配置文件。如果没有将会在 WEB-INF目录下 找 servlet.xml --\x3e\n            <param-value>classpath:springmvc.xml</param-value>\n        </init-param>\n        \x3c!--Tomcat启动\tload-on-startup \t\n\t\t\t标记是否在Web服务器（Tomcat）启动时会创建 Servlet 实例\n           \t\t通过数值进行配置优先级\n                number > 0 初始化加载就创建\n                number < 0 Servlet应用时创建\n        --\x3e\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n\n    \x3c!-- 配置拦截路径url，所有以.do结尾的请求都会被前端控制器拦截处理 --\x3e\n    <servlet-mapping>\n        <servlet-name>dispatcherServlet</servlet-name>\n        <url-pattern>*.do</url-pattern>\n    </servlet-mapping>\n\n</web-app>\n\n\n> 注意：\n> \n> 如果没有配置，启用默认的规则：即如果配置文件放在 webapp/WEB-INF/ 目录下，并且配置文 件的名字等于 DispatcherServlet 的名字 + -servlet（即这里的配置文件路径是 web/WEB-INF/dispatcherServlet-servlet.xml），如果是这样的话，可以不用添加 init-param 参数，即不用手动配置 springmvc 的配置文件，框架会自动加载。\n> \n> 而一般情况下，配置文件是放在类路径下，即 resources 目录下。所以，在注册前端控制器时， 还需要设置查找 SpringMVC 配置文件路径。\n> \n> 其中contextConfigLocation属性：来自DispatcherServlet的父类FrameworkServlet， 该类中的contextConfigLocation属性用来配置springmvc的路径和名称。\n\nweb文件夹下创建 页面 index.jsp页面\n\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n\t<title>index</title>\n</head>\n<body>\n\t<h1>index---------------${userName}</h1>\n</body>\n</html>\n    \n    \n<%-- 执行结果 访问页：http://localhost:8088/hello.do\n    \n    index---------------Sanscan12\n    \n--%>\n\n\n说明\n\n项目中有 Spring 和 SpringMVC 两个容器\n\n * Spring 容器通过 ContextLoaderListener 加载\n\n * SpringMVC 容器通过 DispatcherServlet 加载\n\n\n\n> ContextLoaderListener 初始化的上下文加载的 Bean 是对于整个应用程序共享的，一般 dao层、service层 的bean\n> \n> DispatcherServlet 初始化的上下文加载的 Bean 是只对 Spring Web MVC 有效的 bean，如 Controller、HandlerMapping、HandlerAdapter 等等，该初始化上下文应该只加载 Web相关组件\n\n\n# 工作流程\n\n\n\n步骤详细说明：\n\n 1.  用户点击某个请求路径，发起一个 HTTP request请求，该请求会被提交到 DispatcherServlet（前端控制器）\n 2.  由 DispatcherServlet 请求查找Handler 一个或多个 HandlerMapping（处理器映射器）\n 3.  每个HandlerMapping响应 返回一个执行链（HandlerExecutionChain）\n 4.  DispatcherServlet 将执行链返回的 Handler 信息发送给 HandlerAdapter（处理器适配器）\n 5.  HandlerAdapter 根据 Handler 信息找到并执行相应的 Handler（常称为 Controller）\n 6.  Handler 执行完毕后会返回给 HandlerAdapter 一个 ModelAndView 对象（Spring MVC的底层对象，包括 Model 数据模型和 View 视图信息）\n 7.  HandlerAdapter 接收到 ModelAndView 对象后，将其返回给 DispatcherServlet\n 8.  DispatcherServlet 接收到 ModelAndView 对象后，会请求 ViewResolver（视图解析器）对视图进行解析\n 9.  ViewResolver 根据 View 信息匹配到相应的视图结果，并返回给 DispatcherServlet\n 10. DispatcherServlet 接收到具体的 View 视图后，进行视图渲染，将 Model 中的模型数据填充到 View 视图中的 request 域，生成最终的 View（视图）\n 11. 视图负责将结果显示到浏览器（客户端）\n\n\n# 组件\n\n 1. DispatcherServlet （前端控制器/中央控制器/核心控制器）\n    \n    > DispatcherServlet 相当于是 SpringMVC 的大脑，由它调用其它组件处理用户的请求，它降低组件之间的耦合性，有利组件之间的拓展。SpringMVC框架提供的该核心控制器需要在 web.xml 文件中配置\n\n 2. HandlerMapping （处理器映射器）\n    \n    > HandlerMapping也是控制器，派发请求的控制器。该控制器无需自行控制。其作用是根据请求的 URL 路径，通过 注解 或者 XML 配置，寻找匹配的处理器（Handler）信息。在实际开发中，通常使用注解方式\n\n 3. Handler （处理器）\n    \n    > Handler 和 Java Servlet 扮演的角色一致。其作用是执行相关的请求处理逻辑，并返回相应的数据和视图信息，将其封装至 ModelAndView 对象中。由于 Handler 涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发 Handler\n\n 4. HandlAdapter （处理器适配器）\n    \n    > 通过 HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过映射器找到的处理器（Handler）信息，按照特定规则执行相关的处理器（Handler），可支持多种 类型的处理器，调用处理器传递参数等工作\n\n 5. View Resolver （视图解析器）\n    \n    > ViewResolver 负责将处理结果生成 View 视图，通过 ModelAndView 对象中的 View 信息将逻辑视图名解析成真正的视图 View（如通过一个 JSP 路径返回一个真正的 JSP 页面），最后对 View 进行渲染将处理结果通过页面展示给用户。 SpringMVC 框架提供了很多的 View 视图类型，包括：jstlView、freemarkerView、pdfView 等。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务 需求开发具体的页面\n\n 6. View （视图）\n    \n    > 其本身是一个接口，实现类支持不同的 View 类型（JSP、FreeMarker、Excel 等）\n\n\n# 注解应用\n\nSpring 2.5 版本新增了 SpringMVC 注解功能，用于替换传统的基于 XML 的 SpringMVC 配置\n\nSpringMVC最重要的两个注解类型 @Controller 和 @RequestMapping 注解\n\n使用基于注解的控制器具有以下优点：\n\n 1. 在基于注解的控制器类中可以编写多个处理方法，从而处理多个请求，这就允许将相关的操作编写在同一个控制器类中，减少控制器类的数量，方便以后维护\n 2. 基于注解的控制器不需要在配置文件中部署映射，仅需要使用 @RequestMapping 注解一个方法进行请求处理即可\n\n\n# @Controller\n\n@Controller 注解用于声明某类的实例是一个控制器\n\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Component\npublic @interface Controller {\n    @AliasFor(\n        annotation = Component.class\n    )\n    String value() default "";\n}\n\n\n注解应用前提 需要被 Spring 扫描机制 扫描到才能用！！！\n\n\n# @RequestMapping\n\n@RequestMapping 注解定义了处理器对于请求的映射规则\n\npackage org.springframework.web.bind.annotation;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\nimport org.springframework.core.annotation.AliasFor;\n\n//用于 类 或 方法上\n@Target({ElementType.TYPE, ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Mapping\npublic @interface RequestMapping {\n\t\n    //注释使用\n\tString name() default "";\n\t\n    //默认值(可省略)，指定访问的URL路径后缀\n    //如：@RequestMapping(value="/User/UserAdd.do") 表示 http://localhost:8080/User/UserAdd.do\n\t@AliasFor("path")\n\tString[] value() default {};\n\n    //和 value 属性都用来作为映射使用\n\t@AliasFor("value")\n\tString[] path() default {};\n\t\n    //该方法支持哪些 HTTP 请求，如果省略则支持所有HTTP类型的请求 （GET、POST、...）\n    //如 ：@RequestMapping(value = "User",method = {RequestMethod.GET,RequestMethod.POST})\n\tRequestMethod[] method() default {};\n\t\n    //指定请求中规定的参数，请求中必须包含 指定参数 时才能执行该请求\n    //如：@RequestMapping(value = "User",params = "type") => http://localhost:8080/toUser?type=xxx \n\tString[] params() default {};\n\t\n    //请求中必须包含某些指定的 header 值，请求中必须包含 指定的请求头 才能执行该请求 \n    //如：@RequestMapping(value = "User",headers = "Referer=http://www.xxx.com") => http://www.xxx.com\n\tString[] headers() default {};\n\t\n   \t//指定处理请求的提交内容类型 (application/json、text/html)\n   \t//如：@RequestMapping(value = "User",consumes = "application/json")\n\tString[] consumes() default {};\n\t\n    //指定返回的内容类型，请求的返回类型 必须包含 指定的请求头 才能执行该请求（也可设置编码返回类型）\n    //如：@RequestMapping(value = "User",produces = "application/json,charset=utf-8")\n\tString[] produces() default {};\n\n}\n\n\n该注解声明于 方法 或 类 上\n\n> 声明注解说明\n> \n> 方法：请求的 URI 路径后缀\n> \n> 类：当前类中的所有响应请求的方法都以该地址作为父路径\n\n通过以上第一次用的代码进而修改实例：（常用示例）\n\nUserController类\n\npackage com.controller;\n\nimport com.service.UserService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.servlet.ModelAndView;\n\n@Controller\n@RequestMapping("/user")\npublic class UserController {\n    \n    @Autowired\n    private UserService userService;\n    \n    //访问：http://localhost:8080/user/hello.do\n    @RequestMapping("hello.do")\n    public ModelAndView add(){\n        System.out.println("UserController---add---");\n        userService.add();\n        ModelAndView mv = new ModelAndView();\n        mv.addObject("userName","Sanscan12");\n        mv.setViewName("index");\n        return mv;\n    }\n    \n    /*\n        访问不同资源路径\n        地址访问：http://localhost:8080/ => 控件测试\n        物理资源路径：/test/update.jsp\n     */\n    @RequestMapping("update.do")\n    public ModelAndView update() {\n        System.out.println("UserController---update---");\n        ModelAndView mv = new ModelAndView();\n        mv.setViewName("test/update");\n        return mv;\n    }\n    \n    /*\n        不同类型请求测试\n        地址访问：http://localhost:8080/user/delete.jsp\n        物理资源路径：/test/delete.jsp\n     */\n    @RequestMapping(value = "delete.do",method = {RequestMethod.POST})\n    public ModelAndView delete() {\n        System.out.println("UserController---delete---");\n        ModelAndView mv = new ModelAndView();\n        mv.setViewName("test/update");\n        return mv;\n    }\n\n    \n}\n\n\nindex.jsp 页面\n\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n\t<title>index</title>\n</head>\n<body>\n\t<p>测试访问</p>\n    \n    <a href="/user/delete.do">/user/delete.do（GET）</a>\n    \n    <form action="/user/delete.do" accept-charset="UTF-8" method="post">\n        <button type="submit">/user/delete.do （POST）</button>\n    </form>\n    \n</body>\n</html>\n  \n\n<%--\n    \n    a标签访问会异常，因请求类型被限制！\n    \n--%>\n\n\n\n# SpringMVC问题\n\n\n# Tomcat 首次访问 index 404\n\n原因\n\n 1. wab目录 未被idea识别为web项目\n\n 2. 编译器输出路径 未同步 target缓存，导致 web.xml 找不到\n\n 3. 在web.xml配置。拦截路径url，所有请求都会被前端控制器拦截处理设置（静态文件的加载也会拦截）\n    \n    ····\n     \t<servlet-mapping>\n          <servlet-name>dispatcherServlet</servlet-name>\n          <url-pattern>/</url-pattern>\n        </servlet-mapping>\n    ····\n    \n\n 4. 配置文件 springmvc.xml 未进行 静态资源处理，导致找不到资源\n\n 5. DispatcherServlet找不到url。未加载到 配置文件 所配置的静态资源（如:spring.xml、springmvc.xml等...）\n\n解决方案\n\n 1. 恢复项目结构。点击链接恢复说明：Web项目未被idea识别\n\n 2. 刷新项目工件\n\n 3. 编译器编辑输出，设置说明如下图：\n\n 4. 避免拦截。修改 url-patternj节点。(如：==.do==、==do/==)\n\n 5. 静态资源处理。添加扫描处理，点击链接配置说明：SpringMVC 访问静态资源\n\n 6. 在 pom.xml 中的插件配置模块（主要指定加载目录） 在directory节点 写上自己配置的资源路径\n    \n    <build>\n        \n        <resources>\n        \t<resource>\n        \t    \x3c!--配置文件加载目录--\x3e\n        \t    <directory>src/main/resources</directory>\n        \t    <includes>\n        \t        \x3c!-- 扫描文件对应的后缀 .properties 、 .xml\n        \t            未扫描，则无法 加载配置文件\n        \t        --\x3e\n        \t        <include>**/*.properties</include>\n        \t        <include>**/*.xml</include>\n        \t    </includes>\n        \t    <filtering>false</filtering>\n        \t</resource>\n    \t</resources>\n        ·····\n    </build>\n    ',normalizedContent:'# springmvc\n\nspring mvc 是 spring 提供的一个基于 mvc 设计模式的轻量级 web 开发框架，本质上相当于 servlet（底层运行）\n\nspring mvc 分工明细 ，和框架无缝结合，采用了松散耦合可插拔组件结构，比其他 mvc 框架更具扩展性 和灵活性\n\nmvc设计模式了解：javaweb学习记录 mvc与三层的设计模式_\n\n**springmvc优势 **\n\n * 轻量级，不依赖特性接口 和 类\n * 分工明确，实现前后端分离\n * spring的一部分 可以 应用 ioc 和 aop\n * 国际化支持\n * 面向接口编程\n\n\n# 首次应用\n\n添加依赖\n\n\x3c!--    web项目--\x3e\n<packaging>war</packaging>\n\n<dependencies>\n\x3c!--        spring-webmvc依赖--\x3e\n    <dependency>\n        <groupid>org.springframework</groupid>\n        <artifactid>spring-webmvc</artifactid>\n        <version>5.2.13.release</version>\n    </dependency>\n\x3c!--        springmvc底层 servlet依赖--\x3e\n    <dependency>\n        <groupid>javax.servlet</groupid>\n        <artifactid>javax.servlet-api</artifactid>\n        <version>4.0.1</version>\n        \x3c!--插件运行的时候没有范围插件启动会失败--\x3e\n        <scope>provided</scope>\n    </dependency>\n</dependencies>\n\n<build>\n    <plugins>\n        <plugin>\n            <groupid>org.apache.maven.plugins</groupid>\n            <artifactid>maven-compiler-plugin</artifactid>\n            <version>3.8.0</version>\n    \t\t\x3c!--jdk版本--\x3e\n            <configuration>\n                <source>1.8</source>\n                <target>1.8</target>\n            </configuration>\n        </plugin>\n\x3c!--            tomcat插件--\x3e\n        <plugin>\n            <groupid>org.apache.tomcat.maven</groupid>\n            <artifactid>tomcat7-maven-plugin</artifactid>\n            <version>2.2</version>\n            <configuration>\n                <path>/</path>\n                <port>8080</port>\n            </configuration>\n        </plugin>\n    </plugins>\n</build>\n\n\n业务类及控制器 userservice类 add业务\n\n@service\npublic class userservice {\n    public void add() {\n        system.out.println("userservice---add---");\n    }\n}\n\n\nusercontroller类 控制器\n\n//@controller注解 会自动注册defaultannotationhandlermapping与annotationmethodhandleradapter 两个bean\n@controller\npublic class usercontroller {\n    \n    @autowired\n    private userservice userservice;\n    \n    //注解值 url请求 后缀\n    @requestmapping("/hello.do")\n    public modelandview add(){\n        system.out.println("usercontroller---add---");\n        userservice.add();\n     \t//用于响应    \n        modelandview mv = new modelandview();\n        //响应至 前端指定变量\n        //相当于 request.setattrubuite("username","sanscan12") \n        mv.addobject("username","sanscan12");\n        //经过springmvc的视图解析器处理，转换成物理资源路径（配置跳转页面设置）\n        //相当于 request.getrequestdispatcher("index.jsp").forward(); （跳转页面）\n        mv.setviewname("index");\n        //经过internalresourceviewresolver对象的处理之后加上前后缀就变为了/index.jsp\n        return mv;\n    }\n    \n}\n\n\n建立 配置文件（resources目录下） spring容器 applicationcontext.xml 配置文件\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xsi:schemalocation="\n       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n">\n\n    <context:component-scan base-package="com.service,com.dao"/>\n\n</beans>\n\n\nspringmvc容器 springmvc.xml 配置文件\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xmlns:mvc="http://www.springframework.org/schema/mvc"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xsi:schemalocation="\n       http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\n       http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\n">\n\n    <context:component-scan base-package="com.controller"/>\n\n\x3c!--    分发用户请求--\x3e\n    <mvc:annotation-driven/>\n\x3c!--    视图解析器--\x3e\n    <bean id="internalresourceviewresolver" class="org.springframework.web.servlet.view.internalresourceviewresolver">\n        <property name="prefix" value="/"/>\n        <property name="suffix" value=".jsp"/>\n    </bean>\n\n</beans>\n\n\n配置 web.xml 文件 （web目录下）\n\n<?xml version="1.0" encoding="utf-8"?>\n<web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee"\n         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"\n         version="4.0">\n\n\t\x3c!--   spring配置--\x3e\n    <context-param>\n        \x3c!--contextconfiglocation:用于加载bean的配置文件--\x3e\n        <param-name>contextconfiglocation</param-name>\n        \x3c!--指定spring配置文件的位置 --\x3e\n        <param-value>classpath:applicationcontext.xml</param-value>\n    </context-param>\n    <listener>\n        <listener-class>org.springframework.web.context.contextloaderlistener</listener-class>\n    </listener>\n\n    \x3c!-- springmvc配置--\x3e\n    <servlet>\n        <servlet-name>dispatcherservlet</servlet-name>\n        \x3c!--前端控制器的完全限定名，在spring-webmvc-5.2.5.release.jar包中的 org.springframework.web.servlet下--\x3e\n        <servlet-class>org.springframework.web.servlet.dispatcherservlet</servlet-class>\n        \x3c!-- 创建前端控制器时会读取springmvc配置文件启动ioc容器--\x3e\n        <init-param>\n            <param-name>contextconfiglocation</param-name>\n         \t\x3c!--指定的配置文件。如果没有将会在 web-inf目录下 找 servlet.xml --\x3e\n            <param-value>classpath:springmvc.xml</param-value>\n        </init-param>\n        \x3c!--tomcat启动\tload-on-startup \t\n\t\t\t标记是否在web服务器（tomcat）启动时会创建 servlet 实例\n           \t\t通过数值进行配置优先级\n                number > 0 初始化加载就创建\n                number < 0 servlet应用时创建\n        --\x3e\n        <load-on-startup>1</load-on-startup>\n    </servlet>\n\n    \x3c!-- 配置拦截路径url，所有以.do结尾的请求都会被前端控制器拦截处理 --\x3e\n    <servlet-mapping>\n        <servlet-name>dispatcherservlet</servlet-name>\n        <url-pattern>*.do</url-pattern>\n    </servlet-mapping>\n\n</web-app>\n\n\n> 注意：\n> \n> 如果没有配置，启用默认的规则：即如果配置文件放在 webapp/web-inf/ 目录下，并且配置文 件的名字等于 dispatcherservlet 的名字 + -servlet（即这里的配置文件路径是 web/web-inf/dispatcherservlet-servlet.xml），如果是这样的话，可以不用添加 init-param 参数，即不用手动配置 springmvc 的配置文件，框架会自动加载。\n> \n> 而一般情况下，配置文件是放在类路径下，即 resources 目录下。所以，在注册前端控制器时， 还需要设置查找 springmvc 配置文件路径。\n> \n> 其中contextconfiglocation属性：来自dispatcherservlet的父类frameworkservlet， 该类中的contextconfiglocation属性用来配置springmvc的路径和名称。\n\nweb文件夹下创建 页面 index.jsp页面\n\n<%@ page contenttype="text/html;charset=utf-8" language="java" %>\n<html>\n<head>\n\t<title>index</title>\n</head>\n<body>\n\t<h1>index---------------${username}</h1>\n</body>\n</html>\n    \n    \n<%-- 执行结果 访问页：http://localhost:8088/hello.do\n    \n    index---------------sanscan12\n    \n--%>\n\n\n说明\n\n项目中有 spring 和 springmvc 两个容器\n\n * spring 容器通过 contextloaderlistener 加载\n\n * springmvc 容器通过 dispatcherservlet 加载\n\n\n\n> contextloaderlistener 初始化的上下文加载的 bean 是对于整个应用程序共享的，一般 dao层、service层 的bean\n> \n> dispatcherservlet 初始化的上下文加载的 bean 是只对 spring web mvc 有效的 bean，如 controller、handlermapping、handleradapter 等等，该初始化上下文应该只加载 web相关组件\n\n\n# 工作流程\n\n\n\n步骤详细说明：\n\n 1.  用户点击某个请求路径，发起一个 http request请求，该请求会被提交到 dispatcherservlet（前端控制器）\n 2.  由 dispatcherservlet 请求查找handler 一个或多个 handlermapping（处理器映射器）\n 3.  每个handlermapping响应 返回一个执行链（handlerexecutionchain）\n 4.  dispatcherservlet 将执行链返回的 handler 信息发送给 handleradapter（处理器适配器）\n 5.  handleradapter 根据 handler 信息找到并执行相应的 handler（常称为 controller）\n 6.  handler 执行完毕后会返回给 handleradapter 一个 modelandview 对象（spring mvc的底层对象，包括 model 数据模型和 view 视图信息）\n 7.  handleradapter 接收到 modelandview 对象后，将其返回给 dispatcherservlet\n 8.  dispatcherservlet 接收到 modelandview 对象后，会请求 viewresolver（视图解析器）对视图进行解析\n 9.  viewresolver 根据 view 信息匹配到相应的视图结果，并返回给 dispatcherservlet\n 10. dispatcherservlet 接收到具体的 view 视图后，进行视图渲染，将 model 中的模型数据填充到 view 视图中的 request 域，生成最终的 view（视图）\n 11. 视图负责将结果显示到浏览器（客户端）\n\n\n# 组件\n\n 1. dispatcherservlet （前端控制器/中央控制器/核心控制器）\n    \n    > dispatcherservlet 相当于是 springmvc 的大脑，由它调用其它组件处理用户的请求，它降低组件之间的耦合性，有利组件之间的拓展。springmvc框架提供的该核心控制器需要在 web.xml 文件中配置\n\n 2. handlermapping （处理器映射器）\n    \n    > handlermapping也是控制器，派发请求的控制器。该控制器无需自行控制。其作用是根据请求的 url 路径，通过 注解 或者 xml 配置，寻找匹配的处理器（handler）信息。在实际开发中，通常使用注解方式\n\n 3. handler （处理器）\n    \n    > handler 和 java servlet 扮演的角色一致。其作用是执行相关的请求处理逻辑，并返回相应的数据和视图信息，将其封装至 modelandview 对象中。由于 handler 涉及到具体的用户业务请求，所以一般情况需要程序员根据业务需求开发 handler\n\n 4. handladapter （处理器适配器）\n    \n    > 通过 handleradapter 对处理器进行执行，这是适配器模式的应用，通过映射器找到的处理器（handler）信息，按照特定规则执行相关的处理器（handler），可支持多种 类型的处理器，调用处理器传递参数等工作\n\n 5. view resolver （视图解析器）\n    \n    > viewresolver 负责将处理结果生成 view 视图，通过 modelandview 对象中的 view 信息将逻辑视图名解析成真正的视图 view（如通过一个 jsp 路径返回一个真正的 jsp 页面），最后对 view 进行渲染将处理结果通过页面展示给用户。 springmvc 框架提供了很多的 view 视图类型，包括：jstlview、freemarkerview、pdfview 等。 一般情况下需要通过页面标签或页面模版技术将模型数据通过页面展示给用户，需要由程序员根据业务 需求开发具体的页面\n\n 6. view （视图）\n    \n    > 其本身是一个接口，实现类支持不同的 view 类型（jsp、freemarker、excel 等）\n\n\n# 注解应用\n\nspring 2.5 版本新增了 springmvc 注解功能，用于替换传统的基于 xml 的 springmvc 配置\n\nspringmvc最重要的两个注解类型 @controller 和 @requestmapping 注解\n\n使用基于注解的控制器具有以下优点：\n\n 1. 在基于注解的控制器类中可以编写多个处理方法，从而处理多个请求，这就允许将相关的操作编写在同一个控制器类中，减少控制器类的数量，方便以后维护\n 2. 基于注解的控制器不需要在配置文件中部署映射，仅需要使用 @requestmapping 注解一个方法进行请求处理即可\n\n\n# @controller\n\n@controller 注解用于声明某类的实例是一个控制器\n\n@target({elementtype.type})\n@retention(retentionpolicy.runtime)\n@documented\n@component\npublic @interface controller {\n    @aliasfor(\n        annotation = component.class\n    )\n    string value() default "";\n}\n\n\n注解应用前提 需要被 spring 扫描机制 扫描到才能用！！！\n\n\n# @requestmapping\n\n@requestmapping 注解定义了处理器对于请求的映射规则\n\npackage org.springframework.web.bind.annotation;\n\nimport java.lang.annotation.documented;\nimport java.lang.annotation.elementtype;\nimport java.lang.annotation.retention;\nimport java.lang.annotation.retentionpolicy;\nimport java.lang.annotation.target;\n\nimport org.springframework.core.annotation.aliasfor;\n\n//用于 类 或 方法上\n@target({elementtype.type, elementtype.method})\n@retention(retentionpolicy.runtime)\n@documented\n@mapping\npublic @interface requestmapping {\n\t\n    //注释使用\n\tstring name() default "";\n\t\n    //默认值(可省略)，指定访问的url路径后缀\n    //如：@requestmapping(value="/user/useradd.do") 表示 http://localhost:8080/user/useradd.do\n\t@aliasfor("path")\n\tstring[] value() default {};\n\n    //和 value 属性都用来作为映射使用\n\t@aliasfor("value")\n\tstring[] path() default {};\n\t\n    //该方法支持哪些 http 请求，如果省略则支持所有http类型的请求 （get、post、...）\n    //如 ：@requestmapping(value = "user",method = {requestmethod.get,requestmethod.post})\n\trequestmethod[] method() default {};\n\t\n    //指定请求中规定的参数，请求中必须包含 指定参数 时才能执行该请求\n    //如：@requestmapping(value = "user",params = "type") => http://localhost:8080/touser?type=xxx \n\tstring[] params() default {};\n\t\n    //请求中必须包含某些指定的 header 值，请求中必须包含 指定的请求头 才能执行该请求 \n    //如：@requestmapping(value = "user",headers = "referer=http://www.xxx.com") => http://www.xxx.com\n\tstring[] headers() default {};\n\t\n   \t//指定处理请求的提交内容类型 (application/json、text/html)\n   \t//如：@requestmapping(value = "user",consumes = "application/json")\n\tstring[] consumes() default {};\n\t\n    //指定返回的内容类型，请求的返回类型 必须包含 指定的请求头 才能执行该请求（也可设置编码返回类型）\n    //如：@requestmapping(value = "user",produces = "application/json,charset=utf-8")\n\tstring[] produces() default {};\n\n}\n\n\n该注解声明于 方法 或 类 上\n\n> 声明注解说明\n> \n> 方法：请求的 uri 路径后缀\n> \n> 类：当前类中的所有响应请求的方法都以该地址作为父路径\n\n通过以上第一次用的代码进而修改实例：（常用示例）\n\nusercontroller类\n\npackage com.controller;\n\nimport com.service.userservice;\nimport org.springframework.beans.factory.annotation.autowired;\nimport org.springframework.stereotype.controller;\nimport org.springframework.web.bind.annotation.requestmapping;\nimport org.springframework.web.bind.annotation.requestmethod;\nimport org.springframework.web.servlet.modelandview;\n\n@controller\n@requestmapping("/user")\npublic class usercontroller {\n    \n    @autowired\n    private userservice userservice;\n    \n    //访问：http://localhost:8080/user/hello.do\n    @requestmapping("hello.do")\n    public modelandview add(){\n        system.out.println("usercontroller---add---");\n        userservice.add();\n        modelandview mv = new modelandview();\n        mv.addobject("username","sanscan12");\n        mv.setviewname("index");\n        return mv;\n    }\n    \n    /*\n        访问不同资源路径\n        地址访问：http://localhost:8080/ => 控件测试\n        物理资源路径：/test/update.jsp\n     */\n    @requestmapping("update.do")\n    public modelandview update() {\n        system.out.println("usercontroller---update---");\n        modelandview mv = new modelandview();\n        mv.setviewname("test/update");\n        return mv;\n    }\n    \n    /*\n        不同类型请求测试\n        地址访问：http://localhost:8080/user/delete.jsp\n        物理资源路径：/test/delete.jsp\n     */\n    @requestmapping(value = "delete.do",method = {requestmethod.post})\n    public modelandview delete() {\n        system.out.println("usercontroller---delete---");\n        modelandview mv = new modelandview();\n        mv.setviewname("test/update");\n        return mv;\n    }\n\n    \n}\n\n\nindex.jsp 页面\n\n<%@ page contenttype="text/html;charset=utf-8" language="java" %>\n<html>\n<head>\n\t<title>index</title>\n</head>\n<body>\n\t<p>测试访问</p>\n    \n    <a href="/user/delete.do">/user/delete.do（get）</a>\n    \n    <form action="/user/delete.do" accept-charset="utf-8" method="post">\n        <button type="submit">/user/delete.do （post）</button>\n    </form>\n    \n</body>\n</html>\n  \n\n<%--\n    \n    a标签访问会异常，因请求类型被限制！\n    \n--%>\n\n\n\n# springmvc问题\n\n\n# tomcat 首次访问 index 404\n\n原因\n\n 1. wab目录 未被idea识别为web项目\n\n 2. 编译器输出路径 未同步 target缓存，导致 web.xml 找不到\n\n 3. 在web.xml配置。拦截路径url，所有请求都会被前端控制器拦截处理设置（静态文件的加载也会拦截）\n    \n    ····\n     \t<servlet-mapping>\n          <servlet-name>dispatcherservlet</servlet-name>\n          <url-pattern>/</url-pattern>\n        </servlet-mapping>\n    ····\n    \n\n 4. 配置文件 springmvc.xml 未进行 静态资源处理，导致找不到资源\n\n 5. dispatcherservlet找不到url。未加载到 配置文件 所配置的静态资源（如:spring.xml、springmvc.xml等...）\n\n解决方案\n\n 1. 恢复项目结构。点击链接恢复说明：web项目未被idea识别\n\n 2. 刷新项目工件\n\n 3. 编译器编辑输出，设置说明如下图：\n\n 4. 避免拦截。修改 url-patternj节点。(如：==.do==、==do/==)\n\n 5. 静态资源处理。添加扫描处理，点击链接配置说明：springmvc 访问静态资源\n\n 6. 在 pom.xml 中的插件配置模块（主要指定加载目录） 在directory节点 写上自己配置的资源路径\n    \n    <build>\n        \n        <resources>\n        \t<resource>\n        \t    \x3c!--配置文件加载目录--\x3e\n        \t    <directory>src/main/resources</directory>\n        \t    <includes>\n        \t        \x3c!-- 扫描文件对应的后缀 .properties 、 .xml\n        \t            未扫描，则无法 加载配置文件\n        \t        --\x3e\n        \t        <include>**/*.properties</include>\n        \t        <include>**/*.xml</include>\n        \t    </includes>\n        \t    <filtering>false</filtering>\n        \t</resource>\n    \t</resources>\n        ·····\n    </build>\n    ',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"SpringAOP",frontmatter:{title:"SpringAOP",author:"柏竹",permalink:"/backend/x1cutc",date:"2020-02-18T00:00:00.000Z",categories:["后端","框架"],tags:["spring"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/07.Spring/03.Spring%E6%A0%B8%E5%BF%83AOP.html",relativePath:"01.后端/07.Spring/03.Spring核心AOP.md",key:"v-613d8bec",path:"/backend/x1cutc/",headers:[{level:2,title:"AOP代理",slug:"aop代理",normalizedTitle:"aop代理",charIndex:114},{level:3,title:"静态代理",slug:"静态代理",normalizedTitle:"静态代理",charIndex:163},{level:3,title:"动态代理",slug:"动态代理",normalizedTitle:"动态代理",charIndex:168},{level:4,title:"基于JDK的动态代理",slug:"基于jdk的动态代理",normalizedTitle:"基于jdk的动态代理",charIndex:1373},{level:4,title:"基于CGLIB的动态代理",slug:"基于cglib的动态代理",normalizedTitle:"基于cglib的动态代理",charIndex:1386},{level:2,title:"AOP通知",slug:"aop通知",normalizedTitle:"aop通知",charIndex:11438},{level:3,title:"AspectJ 实现AOP",slug:"aspectj-实现aop",normalizedTitle:"aspectj 实现aop",charIndex:12198},{level:4,title:"XML实现AOP",slug:"xml实现aop",normalizedTitle:"xml实现aop",charIndex:13152},{level:4,title:"Annotation实现AOP",slug:"annotation实现aop",normalizedTitle:"annotation实现aop",charIndex:18422},{level:4,title:"XML与Annotation 声明区别",slug:"xml与annotation-声明区别",normalizedTitle:"xml与annotation 声明区别",charIndex:23690}],headersStr:"AOP代理 静态代理 动态代理 基于JDK的动态代理 基于CGLIB的动态代理 AOP通知 AspectJ 实现AOP XML实现AOP Annotation实现AOP XML与Annotation 声明区别",content:'# Spring核心AOP\n\nAOP 的全称是“Aspect Oriented Programming” 面向切面编程，是一种编程模式，将业务逻辑的各个部分进行隔离，使开发业务逻辑时可 减少代码重复率、提高业务开发效率\n\n\n# AOP代理\n\n代理：自己不做，找人帮你做\n\n代理模式：在一个原有功能的基础上添加新的功能\n\n分类：静态代理和动态代理\n\n\n# 静态代理\n\n将 服务性代码 分离出来。通过接口进行静态代理\n\n接口\n\npublic interface IService {\n\tvoid add();\n}\n\n\n业务类\n\npublic class UserService implements IService {\n    @Override\n    public void add() {\n        System.out.println("UserService---user---");\n    }\n}\n\n\n代理类\n\npublic class Proxy_affair implements IService {\n    private IService iService;\n    \n    public Proxy_affair(IService iService) {\n        this.iService = iService;\n    }\n    \n    @Override\n    public void add() {\n        try {\n            System.out.println("事务开启");\n            \n            //核心业务\n            iService.add();\n            \n            System.out.println("事务结束");\n        } catch (Exception e) {\n            System.out.println("事务回滚");\n        }\n    }\n}\n\n\n测试类\n\n@Test\npublic void test() {\n    UserService userService = new UserService();\n    //一级代理（事务）\n    Proxy_affair proxy_affair = new Proxy_affair(userService);\n    \n    //二级代理（日志）\n    //添加多个业务进行测试\n    //Proxy_log proxy_log = new Proxy_log(proxy_affair);\n    //proxy_log.add();\n    \n    proxy_affair.add();\n}\n\n/*运行结果\n\n日志开始\n事务开启\nUserService---add---\n事务结束\n日志结束\n\n*/\n\n\n总结\n\n>  * 代理在不修改 业务功能 的前提下，对 业务功能 进一步进行拓展\n>  * 如果有 多个代理类 会影响 接口方法增加 和 维护难度\n\n\n# 动态代理\n\n程序运行的时候，根据要被代理的对象动态生成代理类\n\n动态代理有类型两种类型分为 基于JDK的动态代理 和 基于CGLIB的动态代理\n\n# 基于JDK的动态代理\n\nJDK代理的前提 目标对象 必须实现接口，否则无法实现JDK动态代理\n\nProxy类\n\n> Class Proxy\n> \n> java.lang.Object java.lang.reflect.Proxy\n\nProxy 提供创建动态代理类和实例的静态方法，它也是由这些方法创建的所有动态代理类的超类\n\n主要方法\n\nProxy.newProxyInstance\n\npublic static Object newProxyInstance(ClassLoader loader,\n                                      类<?>[] interfaces,\n                                      InvocationHandler h)\n                               throws IllegalArgumentException\n\n\n> ClassLoader loader： 类加载器，因为动态代理类，借助别人的类加载器。一般使用被代理对象的类加载器\n> \n> Class[] interfaces： 接口类对象的集合，针对接口的代理，针对哪个接口做代理\n> \n> InvocationHandler h： 句柄，回调函数，编写代理的规则代码\n\nInvocationHandler.invoke （接口方法）\n\nObject invoke(Object proxy,\n              方法 method,\n              Object[] args)\n       throws Throwable\n\n\n> Object proxy： 代理对象\n> \n> Method method： 被代理的方法\n> \n> Object[] args： 被代理方法的 参数数组\n\n原始实例 （main方法实现）\n\n业务类\n\npublic class UserService implements IService {\n    @Override\n    public void add() {\n        System.out.println("UserService---user---");\n    }\n}\n\n\nmain方法执行\n\npublic static void main(String[] args) {\n    //目标对象\n        UserService userService = new UserService();\n        \n        //返回代理对象\n        IService proxyService = (IService) Proxy.newProxyInstance(\n                //目标对象类 加载器\n                userService.getClass().getClassLoader() ,\n                //实现的接口集合\n                userService.getClass().getInterfaces() ,\n                //动态代理 规则编辑\n                new InvocationHandler() {\n                    /**\n                     * @param proxy 代理对象\n                     * @param method 被代理的方法\n                     * @param args 被代理方法的 参数数组\n                     * @return 被代理方法的返回\n                     */\n                    @Override\n                    public Object invoke(Object proxy , Method method , Object[] args) throws Throwable {\n                        Object invoke = null;\n                        try {\n                            System.out.println("开始事务");\n                            \n                            //核心业务\n                            invoke = method.invoke(userService,args);\n                            \n                            System.out.println("提交事务");\n                        } catch (Exception e) {\n                            System.out.println("事务回滚");\n                            e.printStackTrace();\n                            throw e;\n                        }finally {\n                            System.out.println("finally---");\n                        }\n                        System.out.println("invoke : " + invoke);\n                        return invoke;\n                    }\n                }\n        );\n        //执行代理业务\n        proxyService.add();\n}\n\n/*运行结果\n\n开始事务\nUserService---add---\n提交事务\nfinally---\ninvoke : null\n\n*/\n\n\n工具化设计\n\n业务类\n\npublic class UserService implements IService {\n    @Override\n    public void add() {\n        System.out.println("UserService---user---");\n    }\n}\n\n\nAop接口\n\n/**\n * 切面：服务代码，切入核心代码\n */\npublic interface Aop {\n    \n    //4个阶段\n    void before();\n    void after();\n    void exception();\n    void myFinally();\n    \n}\n\n\n切面类 （事务）\n\npublic class TranLAop implements Aop{\n    @Override\n    public void before() {\n        System.out.println("事务---before");\n    }\n    \n    @Override\n    public void after() {\n        System.out.println("事务---after");\n    }\n    \n    @Override\n    public void exception() {\n        System.out.println("事务---exception");\n    }\n    \n    @Override\n    public void myFinally() {\n        System.out.println("事务---myFinally");\n    }\n}\n\n\n工具类\n\npublic class ProxyFactory {\n    \n    private IService iService;\n    private Aop aop;\n    \n    public ProxyFactory(IService iService , Aop aop) {\n        this.iService = iService;\n        this.aop = aop;\n    }\n    \n    public IService getProxyInstance(){\n        return (IService) Proxy.newProxyInstance(\n                //目标对象类 加载器\n                iService.getClass().getClassLoader() ,\n                //实现的接口集合\n                iService.getClass().getInterfaces() ,\n                //动态代理 规则编辑\n                new InvocationHandler() {\n                    /**\n                     * @param proxy 代理对象\n                     * @param method 被代理的方法\n                     * @param args 被代理方法的参数\n                     * @return 被代理方法的返回\n                     */\n                    @Override\n                    public Object invoke(Object proxy , Method method , Object[] args) throws Throwable {\n                        Object invoke = null;\n                        try {\n                            aop.before();\n                            //核心业务\n                            invoke = method.invoke(iService,args);\n                            aop.after();\n                        } catch (Exception e) {\n                            aop.exception();\n                            e.printStackTrace();\n                            throw e;\n                        }finally {\n                            aop.myFinally();\n                        }\n                        return invoke;\n                    }\n                }\n        );\n    }\n    \n}\n\n\n测试类\n\n//工具化 实现动态代理\n@Test\npublic void test() {\n    UserService userService = new UserService();\n    TranLAop tranLAop = new TranLAop();\n    IService proxyFactory = new ProxyFactory(userService,tranLAop).getProxyInstance();\n    proxyFactory.add();\n}\n\n/*运行结果\n\n事务---before\nUserService---add---\n事务---after\n事务---myFinally\n\n*/\n\n\n# 基于CGLIB的动态代理\n\nCglib代理，也称子类代理。在内存中构建一个子类对象从而实现对目标对象功能的扩展（目标对象无需应用接口也可实现目标对象的代理）\n\nGLIB 被许多 AOP 框架所使用，其底层是通过使用一个小而快的字节码处理框架 ASM（Java 字节码操控框架）转换字节码并生成新的类\n\n应用前提需要引入Cglib动态代理jar\n\n\x3c!--CGLIB的动态代理--\x3e\n<dependency>\n    <groupId>cglib</groupId>\n    <artifactId>cglib</artifactId>\n    <version>3.2.2</version>\n</dependency>\n\n\n业务类 （学生类）\n\npublic class StudentService {\n    public void add(int id , String name) {\n        System.out.println("StudentService---add---");\n        System.out.println("引入数据: " + id +"--"+name);\n    }\n}\n\n\nmain方法执行\n\npublic static void main(String[] args) {\n//目标对象（无接口）\n    StudentService service = new StudentService();\n    //cglib动态代理 （因 无接口，使用类型是与目标对象一直）\n    StudentService proxyService = (StudentService) Enhancer.create(\n            //目标对象类\n            service.getClass() ,\n            //回调对象代理规则\n            new MethodInterceptor() {\n                /**\n                 *\n                 * @param o\n                 * @param method 针对方法\n                 * @param objects\n                 * @param methodProxy\n                 * @return 调取方法的返回\n                 */\n                @Override\n                public Object intercept(Object o , Method method , Object[] objects , MethodProxy methodProxy)\n                        throws Throwable {\n                    try {\n                        System.out.println("开始事务");\n                        //核心业务\n                        Object invoke = methodProxy.invokeSuper(o , objects);\n                        \n                        System.out.println("提交事务");\n                        return null;\n                    } catch (Throwable throwable) {\n                        System.out.println("事务回滚");\n                        throw throwable;\n                    } finally {\n                        System.out.println("finally-----");\n                    }\n                }\n            }\n    );\n    proxyService.add(001 , "张三");\n}\n\n\n/*运行结果\n\n开始事务\nStudentService---add---\n引入数据: 1--张三\n提交事务\nfinally-----\n\n*/\n\n\n工具化设计\n\n业务类\n\npublic class StudentService {\n    public void add(int id , String name) {\n        System.out.println("StudentService---add---");\n        System.out.println("引入数据: " + id +"--"+name);\n    }\n}\n\n\nAop接口\n\n/**\n * 切面：服务代码，切入核心代码\n */\npublic interface Aop {\n    \n    //4个阶段\n    void before();\n    void after();\n    void exception();\n    void myFinally();\n    \n}\n\n\n切面类 （日志）\n\npublic class LogAop implements Aop{\n    \n    @Override\n    public void before() {\n        System.out.println("日志---before");\n    }\n    \n    @Override\n    public void after() {\n        System.out.println("日志---after");\n    }\n    \n    @Override\n    public void exception() {\n        System.out.println("日志---exception");\n    }\n    \n    @Override\n    public void myFinally() {\n        System.out.println("日志---myFinally");\n    }\n}\n\n\n\n工具类\n\npublic class CglibProxyFactory {\n    \n    private StudentService service;\n    private Aop aop;\n    \n    public CglibProxyFactory(StudentService service , Aop aop) {\n        this.service = service;\n        this.aop = aop;\n    }\n    \n    public Object getProxyInstance() {\n        return Enhancer.create(\n                //目标对象类\n                service.getClass() ,\n                //回调对象代理规则\n                new MethodInterceptor() {\n                    /**\n                     *\n                     * @param o\n                     * @param method 针对方法\n                     * @param objects\n                     * @param methodProxy\n                     * @return 调取方法的返回\n                     */\n                    @Override\n                    public Object intercept(Object o , Method method , Object[] objects , MethodProxy methodProxy)\n                            throws Throwable {\n                        try {\n                            aop.before();\n                            //核心业务\n                            Object invoke = methodProxy.invokeSuper(o , objects);\n                    \n                            aop.after();\n                            return null;\n                        } catch (Throwable throwable) {\n                            aop.exception();\n                            throw throwable;\n                        } finally {\n                            aop.myFinally();\n                        }\n                    }\n                }\n        );\n    }\n    \n}\n\n\n测试类\n\n@Test\npublic void test() {\n    //目标对象（无接口）\n    StudentService service = new StudentService();\n    //cglib动态代理 （因 无接口，使用类型是与目标对象一直）\n    Aop aop = new LogAop();\n    StudentService proxyInstance = (StudentService) new CglibProxyFactory(service , aop).getProxyInstance();\n    proxyInstance.add(001,"张三");\n}\n\n/*运行结果\n\n日志---before\nStudentService---add---\n引入数据: 1--张三\n日志---after\n日志---myFinally\n\n*/\n\n\n\n# AOP通知\n\nSpring的AOP实现底层就是对上面动态代理的代码进行封装，封装后我们子需要对关注部分进行代码编写，并通过配置的方式完成指定目标的方法增强\n\nSpring 通知 指定目标类方法 的连接点位置，分为以下5种通知类型\n\n> 通知类型\n> \n>  1. 前置通知 在方法执行前的通知，可以应用于权限管理等功能\n>  2. 后置通知 在方法执行后的通知，可以应用于关闭流、上传文件、删除临时文件等功能\n>  3. 环绕通知 在方法执行 前、后 都通知，可以应用于日志、事务管理等功能\n>  4. 异常通知 在方法抛出异常时的通知，可以应用于处理异常记录日志等功能\n>  5. 最终通知 方法执行完毕后最后的通知\n\nAOP相关术语：\n\n * Target（目标对象） 要被增强的对象，一般业务逻辑类对象\n * Proxy（代理） 一个类被AOP 织入增强后，产生一个结果代理类\n * Aspect（切面） 切面点 增强功能，就是一些代码完成某些功能，非业务功能。是切入点和通知的结合\n * Joinpoint（连接点） 连接点 指 那些被拦截的点。在Spring中，这些点指定与 核心业务的方法（Spring只支持方法类型的连接点）\n * Pointcut（切入点） 切入点 指 声明一个或多个连接点的集合。通过切入点指定一组方法（非final方法）\n * Advice（通知/增强） 通知 指 拦截到 连接点 后要做的 通知。通知定义了增强代码切入到目标代码的时间点，是目标方法执行之前执行，还是之后执行等。通知类型不同，切入时间不同\n * Weaving（织入） 织入 指 增强应用到目标对象来创建新的代理对象的过程。 spring 采用动态代理织入，而 AspectJ 采用编译期织入和类装载期织入\n\n\n# AspectJ 实现AOP\n\nAspectJ 基于 Java语言的AOP框架，它扩展了 Java语言，使得AOP功能使用更便捷\n\n切入点表达式\n\nAspectJ 定义 专门的表达式 指定 切入点\n\n表达式原型：\n\nexecution([modifiers-pattern] ret-type-pattern declaring-type-pattern name-pattern(param-pattern) [throws-pattern])\n\n//必要参数：方法返回值 方法声明(参数)\nexecution(访问权限 方法返回值 方法声明(参数) 异常类型)\n\n\n> 参数说明 （中括号表示可选类型）\n> \n> modifiers-pattern ：访问权限类型 ret-type-pattern ：返回类型 declaring-type-pattern ：包名类名 name-pattern(param-pattern) ：方法名（参数的 类型 和 个数） throws-pattern ：抛出异常类型\n\nPS：表达式各个部分可以用空格隔开，可用以下符号：\n\n符号   范围         说明\n*    所有         0 ~ n 个任意字符\n..   方法参数、包路径   指定任意个参数；当前包的子路径\n+    类名、接口      当前类路径的子类；当前接口及实现的类\n\n> 切入点表达式实例\n> \n> execution(* com.service.*.*(..)) 定义 com.service 包路径里的 任意类、任意方法、方法任意返回类型\n> \n> execution(* com.service..*.*(..)) 定义 com.service 包路径里的 任意子包、任意类、任意方法、方法任意返回类型\n> \n> execution(* com.service.IUserService+.*(..)) 当路径 com.service.IUserService 的文件类型为以下条件： 若为接口，则为接口中 任意方法及其所有实现类中的任意方法 若为类，则为该类及其子类中的任意方法\n\nAOP声明方式\n\n * 基于 XML 声明\n * 基于 Annotation 声明\n\n# XML实现AOP\n\n基于 xml 的配置文件方式进行定义 切面、切入点 等\n\n依赖、插件\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <modelVersion>4.0.0</modelVersion>\n\n    <groupId>com.sans</groupId>\n    <artifactId>Spring-AOP</artifactId>\n    <version>1.0-SNAPSHOT</version>\n\n    <properties>\n        <maven.compiler.source>15</maven.compiler.source>\n        <maven.compiler.target>15</maven.compiler.target>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupId>junit</groupId>\n            <artifactId>junit</artifactId>\n            <version>4.12</version>\n            <scope>test</scope>\n        </dependency>\n\n        \x3c!-- spring依赖 --\x3e\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-context</artifactId>\n            <version>5.2.13.RELEASE</version>\n        </dependency>\n\n        \x3c!-- CGLIB的动态代理 --\x3e\n        <dependency>\n            <groupId>cglib</groupId>\n            <artifactId>cglib</artifactId>\n            <version>3.2.2</version>\n        </dependency>\n\n        \x3c!--aop切面依赖--\x3e\n        <dependency>\n            <groupId>org.springframework</groupId>\n            <artifactId>spring-aspects</artifactId>\n            <version>5.2.13.RELEASE</version>\n        </dependency>\n\n    </dependencies>\n\n    <build>\n        <plugins>\n            \x3c!--编译插件--\x3e\n            <plugin>\n                <groupId>org.apache.maven.plugins</groupId>\n                <artifactId>maven-compiler-plugin</artifactId>\n                <version>3.8.0</version>\n                <configuration>\n                    <source>1.8</source>\n                    <target>1.8</target>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n\n</project>\n\n\n业务接口\n\npackage com.newAOP.service;\n\npublic interface IService {\n    void add(int id , String name);\n    boolean update(int a , int b);\n}\n\n\n业务类\n\npackage com.newAOP.service;\n\nimport org.springframework.stereotype.Service;\n\n@Service\npublic class TeamService implements IService{\n    \n    @Override\n    public void add(int id , String name) {\n        //制造异常\n        //int num = id/0;\n        System.out.println("MyAspect---add---");\n    }\n    \n    @Override\n    public boolean update(int a , int b) {\n        System.out.println("MyAspect---update---");\n        if (a + b > 10) {\n            return true;\n        }\n        return false;\n    }\n}\n\n\n切面类\n\npackage com.newAOP.aop;\n\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.springframework.stereotype.Component;\n\n/**\n * 切面类 XML实现\n * 简洁代理通知\n */\n@Component  //创建权限交给 spring容器 进行创建\n@Aspect     //aspectj 框架注解 标识该类为切面类\npublic class MyAspect_XML {\n    \n    public void before(JoinPoint jp){\n        System.out.println("前置通知");\n    }\n    \n    public void afterReturn(Object result){\n        System.out.println("后置通知");\n    }\n    \n    public Object around(ProceedingJoinPoint pjp) throws Throwable{\n        System.out.println("======================AroundOpen");\n        Object obj = pjp.proceed();\n        System.out.println("======================AroundEnd");\n        return obj;\n    }\n    \n    public void exception(JoinPoint jp, Throwable ex){\n        System.out.println("异常通知");\n    }\n    \n    public void myFinally(JoinPoint jp){\n        System.out.println("最终通知");\n    }\n    \n}\n\n\n配置文件 （扫描包，引入代理）\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:aop="http://www.springframework.org/schema/aop"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemaLocation="\n       http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/aop\n       http://www.springframework.org/schema/aop/spring-aop.xsd\n       http://www.springframework.org/schema/context\n       http://www.springframework.org/schema/context/spring-context.xsd">\n\n    <context:component-scan base-package="com.newAOP" />\n\n\x3c!--    xml实现 代理--\x3e\n    <aop:config>\n        <aop:pointcut id="pt_ALL" expression="execution(* com.newAOP.service..*.*(..))"/>\n        <aop:aspect ref="myAspect_XML">\n            <aop:before method="before" pointcut-ref="pt_ALL"/>\n            <aop:after-returning method="afterReturn" pointcut-ref="pt_ALL" returning="result"/>\n            <aop:after-throwing method="exception" pointcut-ref="pt_ALL" throwing="ex"/>\n            <aop:after method="myFinally" pointcut-ref="pt_ALL"/>\n\x3c!--            容易出现问题--\x3e\n\x3c!--            <aop:around method="around" pointcut-ref="pt_ALL"/>--\x3e\n        </aop:aspect>\n    </aop:config>\n\n</beans>\n\n\n测试\n\n@Test\npublic void test(){\n    ApplicationContext ac = new ClassPathXmlApplicationContext("MySpring.xml");\n    IService teamService = (IService) ac.getBean("teamService");\n    teamService.add(001,"张三");\n    System.out.println("\\n");\n    teamService.update(6, 5);\n}\n\n/*运行结果\n\n前置通知\nMyAspect---add---\n后置通知\n最终通知\n\n\n前置通知\nMyAspect---update---\n后置通知\n最终通知\n\n*/\n\n\n# Annotation实现AOP\n\n对切面类使用指定 注解 定义 切面、切入点 等\n\n注解类型\n\n注解名称              说明\n@Aspect           定义 切面（指定 类）\n@Pointcut         定义 切入点表达式（指定 类）\n@Before           定义 前置通知（指定 方法）\n@AfterReturning   定义 后置通知（指定 方法）\n@Around           定义 环绕通知（指定 方法）\n@AfterThrowing    定义 异常通知（指定 方法）\n@After            定义 最终通知（指定 方法，无论异常都会通知）\n\n依赖配置 、 业务类 和 业务接口 与上述一致\n\n切面类\n\npackage com.newAOP.aop;\n\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.ProceedingJoinPoint;\nimport org.aspectj.lang.annotation.*;\nimport org.springframework.stereotype.Component;\n\n/**\n * 切面类\n * @author Sans\n */\n@Component  //创建权限交给 spring容器 进行创建\n@Aspect     //aspectj 框架注解 标识该类为切面类\npublic class MyAspect {\n    /**\n     * 切点表达式为：\n     *      方法 任意返回类型\n     *      指定路径 com.newAOP包\n     *      指定包下的所有 子包、子类、类、接口、方法、方法参数\n     */\n    @Pointcut("execution(* com.newAOP..*.*(..))")\n    private void pointCut_all(){ }\n    \n    /**\n     * 前置通知\n     * @param jp\n     */\n    @Before("pointCut_all()")\n    public void before(JoinPoint jp){\n        System.out.println("======================BeforeOpen");\n        System.out.println("前置通知");\n        System.out.println("拦截信息：");\n        System.out.println("\\t方法名称："+jp.getSignature().getName());\n        Object[] args = jp.getArgs();\n        if (args.length != 0){\n            System.out.println("\\t参数格式："+args.length);\n            System.out.println("\\t参数列表:");\n            for (Object arg : args) {\n                System.out.println("\\t\\t"+arg);\n            }\n        }\n        System.out.println("======================BeforeEnd");\n    }\n    \n    /**\n     * 后置通知\n     * @param result\n     */\n    @AfterReturning (value="pointCut_all()",returning = "result")\n    public void afterReturn(Object result){\n        System.out.println("======================AfterReturnOpen");\n        System.out.println("后置通知");\n        System.out.println("拦截信息:");\n        System.out.println("\\t方法返回值："+result);\n        System.out.println("======================AfterReturnEnd");\n    }\n    \n    /**\n     * 环绕通知\n     * @param pjp\n     * @return 方法返回类型\n     * @throws Throwable 当前方法运行抛出的异常\n     */\n    @Around("pointCut_all()")\n    public Object around(ProceedingJoinPoint pjp) throws Throwable{\n        System.out.println("======================AroundOpen");\n        System.out.println("环绕通知");\n        Object obj = pjp.proceed();\n        System.out.println("方法 返回值为:"+obj);\n        System.out.println("======================AroundEnd");\n        return obj;\n    }\n    \n    /**\n     * 异常通知\n     * @param jp 连接点状态\n     * @param ex 异常返回\n     */\n    @AfterThrowing(value = "pointCut_all()",throwing = "ex")\n    public void exception(JoinPoint jp,Throwable ex){\n        System.out.println("======================ExceptionOpen");\n        System.out.println("异常通知");\n        //返回连接点的签名（异常）\n        System.out.println("异常原因："+jp.getSignature());\n        //返回 throwable 的详细消息字符串\n        System.out.println("异常类型："+ex.getMessage());\n        System.out.println("======================ExceptionEnd");\n    }\n    \n    /**\n     * 最终通知（无论出现异常都会执行的通知）\n     */\n    @After("pointCut_all()")\n    public void myFinally(JoinPoint jp){\n        System.out.println("======================FinallyOpen");\n        System.out.println("最终通知");\n        System.out.println(jp.getSignature().getName()+" 方法结束!");\n        System.out.println("======================FinallyEnd");\n    }\n    \n}\n\n\n配置文件 （扫描包，切面类注解应用）\n\n<?xml version="1.0" encoding="UTF-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n       xmlns:aop="http://www.springframework.org/schema/aop"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemaLocation="\n       http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/aop\n       http://www.springframework.org/schema/aop/spring-aop.xsd\n       http://www.springframework.org/schema/context\n       http://www.springframework.org/schema/context/spring-context.xsd">\n\t//扫描包。个人配置包路径 为 com.newAOP\n    <context:component-scan base-package="com.newAOP" />\n\t//允许 Spring容器 权限应用\n    <aop:aspectj-autoproxy expose-proxy="true"/>\n</beans>\n\n\n测试\n\n@Test\npublic void test(){\n    ApplicationContext ac = new ClassPathXmlApplicationContext("MySpring.xml");\n    IService teamService = (IService) ac.getBean("teamService");\n    teamService.add(001,"张三");\n    System.out.println("\\n");\n    teamService.update(6, 5);\n}\n\n/*运行结果\n\n======================AroundOpen\n环绕通知\n======================BeforeOpen\n前置通知\n拦截信息：\n\t方法名称：add\n\t参数格式：2\n\t参数列表:\n\t\t1\n\t\t张三\n======================BeforeEnd\nMyAspect---add---\n======================AfterReturnOpen\n后置通知\n拦截信息:\n\t方法返回值：null\n======================AfterReturnEnd\n======================FinallyOpen\n最终通知\nadd 方法结束!\n======================FinallyEnd\n方法 返回值为:null\n======================AroundEnd\n\n\n======================AroundOpen\n环绕通知\n======================BeforeOpen\n前置通知\n拦截信息：\n\t方法名称：update\n\t参数格式：2\n\t参数列表:\n\t\t6\n\t\t5\n======================BeforeEnd\nMyAspect---update---\n======================AfterReturnOpen\n后置通知\n拦截信息:\n\t方法返回值：true\n======================AfterReturnEnd\n======================FinallyOpen\n最终通知\nupdate 方法结束!\n======================FinallyEnd\n方法 返回值为:true\n======================AroundEnd\n\n*/\n\n\n# XML与Annotation 声明区别\n\n> xml在外部文件 .xml进行配置；Annotation在类文件中进行配置 无需外部辅助\n> \n> xml效率一般(需要解析)；Annotation效率高\n> \n> xml需要解析工具进行完成；Annotation无需解析，利用Java反射进行完成\n> \n> xml易于观察对象关系（业务量较多时）；Annotation 不易观察',normalizedContent:'# spring核心aop\n\naop 的全称是“aspect oriented programming” 面向切面编程，是一种编程模式，将业务逻辑的各个部分进行隔离，使开发业务逻辑时可 减少代码重复率、提高业务开发效率\n\n\n# aop代理\n\n代理：自己不做，找人帮你做\n\n代理模式：在一个原有功能的基础上添加新的功能\n\n分类：静态代理和动态代理\n\n\n# 静态代理\n\n将 服务性代码 分离出来。通过接口进行静态代理\n\n接口\n\npublic interface iservice {\n\tvoid add();\n}\n\n\n业务类\n\npublic class userservice implements iservice {\n    @override\n    public void add() {\n        system.out.println("userservice---user---");\n    }\n}\n\n\n代理类\n\npublic class proxy_affair implements iservice {\n    private iservice iservice;\n    \n    public proxy_affair(iservice iservice) {\n        this.iservice = iservice;\n    }\n    \n    @override\n    public void add() {\n        try {\n            system.out.println("事务开启");\n            \n            //核心业务\n            iservice.add();\n            \n            system.out.println("事务结束");\n        } catch (exception e) {\n            system.out.println("事务回滚");\n        }\n    }\n}\n\n\n测试类\n\n@test\npublic void test() {\n    userservice userservice = new userservice();\n    //一级代理（事务）\n    proxy_affair proxy_affair = new proxy_affair(userservice);\n    \n    //二级代理（日志）\n    //添加多个业务进行测试\n    //proxy_log proxy_log = new proxy_log(proxy_affair);\n    //proxy_log.add();\n    \n    proxy_affair.add();\n}\n\n/*运行结果\n\n日志开始\n事务开启\nuserservice---add---\n事务结束\n日志结束\n\n*/\n\n\n总结\n\n>  * 代理在不修改 业务功能 的前提下，对 业务功能 进一步进行拓展\n>  * 如果有 多个代理类 会影响 接口方法增加 和 维护难度\n\n\n# 动态代理\n\n程序运行的时候，根据要被代理的对象动态生成代理类\n\n动态代理有类型两种类型分为 基于jdk的动态代理 和 基于cglib的动态代理\n\n# 基于jdk的动态代理\n\njdk代理的前提 目标对象 必须实现接口，否则无法实现jdk动态代理\n\nproxy类\n\n> class proxy\n> \n> java.lang.object java.lang.reflect.proxy\n\nproxy 提供创建动态代理类和实例的静态方法，它也是由这些方法创建的所有动态代理类的超类\n\n主要方法\n\nproxy.newproxyinstance\n\npublic static object newproxyinstance(classloader loader,\n                                      类<?>[] interfaces,\n                                      invocationhandler h)\n                               throws illegalargumentexception\n\n\n> classloader loader： 类加载器，因为动态代理类，借助别人的类加载器。一般使用被代理对象的类加载器\n> \n> class[] interfaces： 接口类对象的集合，针对接口的代理，针对哪个接口做代理\n> \n> invocationhandler h： 句柄，回调函数，编写代理的规则代码\n\ninvocationhandler.invoke （接口方法）\n\nobject invoke(object proxy,\n              方法 method,\n              object[] args)\n       throws throwable\n\n\n> object proxy： 代理对象\n> \n> method method： 被代理的方法\n> \n> object[] args： 被代理方法的 参数数组\n\n原始实例 （main方法实现）\n\n业务类\n\npublic class userservice implements iservice {\n    @override\n    public void add() {\n        system.out.println("userservice---user---");\n    }\n}\n\n\nmain方法执行\n\npublic static void main(string[] args) {\n    //目标对象\n        userservice userservice = new userservice();\n        \n        //返回代理对象\n        iservice proxyservice = (iservice) proxy.newproxyinstance(\n                //目标对象类 加载器\n                userservice.getclass().getclassloader() ,\n                //实现的接口集合\n                userservice.getclass().getinterfaces() ,\n                //动态代理 规则编辑\n                new invocationhandler() {\n                    /**\n                     * @param proxy 代理对象\n                     * @param method 被代理的方法\n                     * @param args 被代理方法的 参数数组\n                     * @return 被代理方法的返回\n                     */\n                    @override\n                    public object invoke(object proxy , method method , object[] args) throws throwable {\n                        object invoke = null;\n                        try {\n                            system.out.println("开始事务");\n                            \n                            //核心业务\n                            invoke = method.invoke(userservice,args);\n                            \n                            system.out.println("提交事务");\n                        } catch (exception e) {\n                            system.out.println("事务回滚");\n                            e.printstacktrace();\n                            throw e;\n                        }finally {\n                            system.out.println("finally---");\n                        }\n                        system.out.println("invoke : " + invoke);\n                        return invoke;\n                    }\n                }\n        );\n        //执行代理业务\n        proxyservice.add();\n}\n\n/*运行结果\n\n开始事务\nuserservice---add---\n提交事务\nfinally---\ninvoke : null\n\n*/\n\n\n工具化设计\n\n业务类\n\npublic class userservice implements iservice {\n    @override\n    public void add() {\n        system.out.println("userservice---user---");\n    }\n}\n\n\naop接口\n\n/**\n * 切面：服务代码，切入核心代码\n */\npublic interface aop {\n    \n    //4个阶段\n    void before();\n    void after();\n    void exception();\n    void myfinally();\n    \n}\n\n\n切面类 （事务）\n\npublic class tranlaop implements aop{\n    @override\n    public void before() {\n        system.out.println("事务---before");\n    }\n    \n    @override\n    public void after() {\n        system.out.println("事务---after");\n    }\n    \n    @override\n    public void exception() {\n        system.out.println("事务---exception");\n    }\n    \n    @override\n    public void myfinally() {\n        system.out.println("事务---myfinally");\n    }\n}\n\n\n工具类\n\npublic class proxyfactory {\n    \n    private iservice iservice;\n    private aop aop;\n    \n    public proxyfactory(iservice iservice , aop aop) {\n        this.iservice = iservice;\n        this.aop = aop;\n    }\n    \n    public iservice getproxyinstance(){\n        return (iservice) proxy.newproxyinstance(\n                //目标对象类 加载器\n                iservice.getclass().getclassloader() ,\n                //实现的接口集合\n                iservice.getclass().getinterfaces() ,\n                //动态代理 规则编辑\n                new invocationhandler() {\n                    /**\n                     * @param proxy 代理对象\n                     * @param method 被代理的方法\n                     * @param args 被代理方法的参数\n                     * @return 被代理方法的返回\n                     */\n                    @override\n                    public object invoke(object proxy , method method , object[] args) throws throwable {\n                        object invoke = null;\n                        try {\n                            aop.before();\n                            //核心业务\n                            invoke = method.invoke(iservice,args);\n                            aop.after();\n                        } catch (exception e) {\n                            aop.exception();\n                            e.printstacktrace();\n                            throw e;\n                        }finally {\n                            aop.myfinally();\n                        }\n                        return invoke;\n                    }\n                }\n        );\n    }\n    \n}\n\n\n测试类\n\n//工具化 实现动态代理\n@test\npublic void test() {\n    userservice userservice = new userservice();\n    tranlaop tranlaop = new tranlaop();\n    iservice proxyfactory = new proxyfactory(userservice,tranlaop).getproxyinstance();\n    proxyfactory.add();\n}\n\n/*运行结果\n\n事务---before\nuserservice---add---\n事务---after\n事务---myfinally\n\n*/\n\n\n# 基于cglib的动态代理\n\ncglib代理，也称子类代理。在内存中构建一个子类对象从而实现对目标对象功能的扩展（目标对象无需应用接口也可实现目标对象的代理）\n\nglib 被许多 aop 框架所使用，其底层是通过使用一个小而快的字节码处理框架 asm（java 字节码操控框架）转换字节码并生成新的类\n\n应用前提需要引入cglib动态代理jar\n\n\x3c!--cglib的动态代理--\x3e\n<dependency>\n    <groupid>cglib</groupid>\n    <artifactid>cglib</artifactid>\n    <version>3.2.2</version>\n</dependency>\n\n\n业务类 （学生类）\n\npublic class studentservice {\n    public void add(int id , string name) {\n        system.out.println("studentservice---add---");\n        system.out.println("引入数据: " + id +"--"+name);\n    }\n}\n\n\nmain方法执行\n\npublic static void main(string[] args) {\n//目标对象（无接口）\n    studentservice service = new studentservice();\n    //cglib动态代理 （因 无接口，使用类型是与目标对象一直）\n    studentservice proxyservice = (studentservice) enhancer.create(\n            //目标对象类\n            service.getclass() ,\n            //回调对象代理规则\n            new methodinterceptor() {\n                /**\n                 *\n                 * @param o\n                 * @param method 针对方法\n                 * @param objects\n                 * @param methodproxy\n                 * @return 调取方法的返回\n                 */\n                @override\n                public object intercept(object o , method method , object[] objects , methodproxy methodproxy)\n                        throws throwable {\n                    try {\n                        system.out.println("开始事务");\n                        //核心业务\n                        object invoke = methodproxy.invokesuper(o , objects);\n                        \n                        system.out.println("提交事务");\n                        return null;\n                    } catch (throwable throwable) {\n                        system.out.println("事务回滚");\n                        throw throwable;\n                    } finally {\n                        system.out.println("finally-----");\n                    }\n                }\n            }\n    );\n    proxyservice.add(001 , "张三");\n}\n\n\n/*运行结果\n\n开始事务\nstudentservice---add---\n引入数据: 1--张三\n提交事务\nfinally-----\n\n*/\n\n\n工具化设计\n\n业务类\n\npublic class studentservice {\n    public void add(int id , string name) {\n        system.out.println("studentservice---add---");\n        system.out.println("引入数据: " + id +"--"+name);\n    }\n}\n\n\naop接口\n\n/**\n * 切面：服务代码，切入核心代码\n */\npublic interface aop {\n    \n    //4个阶段\n    void before();\n    void after();\n    void exception();\n    void myfinally();\n    \n}\n\n\n切面类 （日志）\n\npublic class logaop implements aop{\n    \n    @override\n    public void before() {\n        system.out.println("日志---before");\n    }\n    \n    @override\n    public void after() {\n        system.out.println("日志---after");\n    }\n    \n    @override\n    public void exception() {\n        system.out.println("日志---exception");\n    }\n    \n    @override\n    public void myfinally() {\n        system.out.println("日志---myfinally");\n    }\n}\n\n\n\n工具类\n\npublic class cglibproxyfactory {\n    \n    private studentservice service;\n    private aop aop;\n    \n    public cglibproxyfactory(studentservice service , aop aop) {\n        this.service = service;\n        this.aop = aop;\n    }\n    \n    public object getproxyinstance() {\n        return enhancer.create(\n                //目标对象类\n                service.getclass() ,\n                //回调对象代理规则\n                new methodinterceptor() {\n                    /**\n                     *\n                     * @param o\n                     * @param method 针对方法\n                     * @param objects\n                     * @param methodproxy\n                     * @return 调取方法的返回\n                     */\n                    @override\n                    public object intercept(object o , method method , object[] objects , methodproxy methodproxy)\n                            throws throwable {\n                        try {\n                            aop.before();\n                            //核心业务\n                            object invoke = methodproxy.invokesuper(o , objects);\n                    \n                            aop.after();\n                            return null;\n                        } catch (throwable throwable) {\n                            aop.exception();\n                            throw throwable;\n                        } finally {\n                            aop.myfinally();\n                        }\n                    }\n                }\n        );\n    }\n    \n}\n\n\n测试类\n\n@test\npublic void test() {\n    //目标对象（无接口）\n    studentservice service = new studentservice();\n    //cglib动态代理 （因 无接口，使用类型是与目标对象一直）\n    aop aop = new logaop();\n    studentservice proxyinstance = (studentservice) new cglibproxyfactory(service , aop).getproxyinstance();\n    proxyinstance.add(001,"张三");\n}\n\n/*运行结果\n\n日志---before\nstudentservice---add---\n引入数据: 1--张三\n日志---after\n日志---myfinally\n\n*/\n\n\n\n# aop通知\n\nspring的aop实现底层就是对上面动态代理的代码进行封装，封装后我们子需要对关注部分进行代码编写，并通过配置的方式完成指定目标的方法增强\n\nspring 通知 指定目标类方法 的连接点位置，分为以下5种通知类型\n\n> 通知类型\n> \n>  1. 前置通知 在方法执行前的通知，可以应用于权限管理等功能\n>  2. 后置通知 在方法执行后的通知，可以应用于关闭流、上传文件、删除临时文件等功能\n>  3. 环绕通知 在方法执行 前、后 都通知，可以应用于日志、事务管理等功能\n>  4. 异常通知 在方法抛出异常时的通知，可以应用于处理异常记录日志等功能\n>  5. 最终通知 方法执行完毕后最后的通知\n\naop相关术语：\n\n * target（目标对象） 要被增强的对象，一般业务逻辑类对象\n * proxy（代理） 一个类被aop 织入增强后，产生一个结果代理类\n * aspect（切面） 切面点 增强功能，就是一些代码完成某些功能，非业务功能。是切入点和通知的结合\n * joinpoint（连接点） 连接点 指 那些被拦截的点。在spring中，这些点指定与 核心业务的方法（spring只支持方法类型的连接点）\n * pointcut（切入点） 切入点 指 声明一个或多个连接点的集合。通过切入点指定一组方法（非final方法）\n * advice（通知/增强） 通知 指 拦截到 连接点 后要做的 通知。通知定义了增强代码切入到目标代码的时间点，是目标方法执行之前执行，还是之后执行等。通知类型不同，切入时间不同\n * weaving（织入） 织入 指 增强应用到目标对象来创建新的代理对象的过程。 spring 采用动态代理织入，而 aspectj 采用编译期织入和类装载期织入\n\n\n# aspectj 实现aop\n\naspectj 基于 java语言的aop框架，它扩展了 java语言，使得aop功能使用更便捷\n\n切入点表达式\n\naspectj 定义 专门的表达式 指定 切入点\n\n表达式原型：\n\nexecution([modifiers-pattern] ret-type-pattern declaring-type-pattern name-pattern(param-pattern) [throws-pattern])\n\n//必要参数：方法返回值 方法声明(参数)\nexecution(访问权限 方法返回值 方法声明(参数) 异常类型)\n\n\n> 参数说明 （中括号表示可选类型）\n> \n> modifiers-pattern ：访问权限类型 ret-type-pattern ：返回类型 declaring-type-pattern ：包名类名 name-pattern(param-pattern) ：方法名（参数的 类型 和 个数） throws-pattern ：抛出异常类型\n\nps：表达式各个部分可以用空格隔开，可用以下符号：\n\n符号   范围         说明\n*    所有         0 ~ n 个任意字符\n..   方法参数、包路径   指定任意个参数；当前包的子路径\n+    类名、接口      当前类路径的子类；当前接口及实现的类\n\n> 切入点表达式实例\n> \n> execution(* com.service.*.*(..)) 定义 com.service 包路径里的 任意类、任意方法、方法任意返回类型\n> \n> execution(* com.service..*.*(..)) 定义 com.service 包路径里的 任意子包、任意类、任意方法、方法任意返回类型\n> \n> execution(* com.service.iuserservice+.*(..)) 当路径 com.service.iuserservice 的文件类型为以下条件： 若为接口，则为接口中 任意方法及其所有实现类中的任意方法 若为类，则为该类及其子类中的任意方法\n\naop声明方式\n\n * 基于 xml 声明\n * 基于 annotation 声明\n\n# xml实现aop\n\n基于 xml 的配置文件方式进行定义 切面、切入点 等\n\n依赖、插件\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n    <modelversion>4.0.0</modelversion>\n\n    <groupid>com.sans</groupid>\n    <artifactid>spring-aop</artifactid>\n    <version>1.0-snapshot</version>\n\n    <properties>\n        <maven.compiler.source>15</maven.compiler.source>\n        <maven.compiler.target>15</maven.compiler.target>\n    </properties>\n\n    <dependencies>\n        <dependency>\n            <groupid>junit</groupid>\n            <artifactid>junit</artifactid>\n            <version>4.12</version>\n            <scope>test</scope>\n        </dependency>\n\n        \x3c!-- spring依赖 --\x3e\n        <dependency>\n            <groupid>org.springframework</groupid>\n            <artifactid>spring-context</artifactid>\n            <version>5.2.13.release</version>\n        </dependency>\n\n        \x3c!-- cglib的动态代理 --\x3e\n        <dependency>\n            <groupid>cglib</groupid>\n            <artifactid>cglib</artifactid>\n            <version>3.2.2</version>\n        </dependency>\n\n        \x3c!--aop切面依赖--\x3e\n        <dependency>\n            <groupid>org.springframework</groupid>\n            <artifactid>spring-aspects</artifactid>\n            <version>5.2.13.release</version>\n        </dependency>\n\n    </dependencies>\n\n    <build>\n        <plugins>\n            \x3c!--编译插件--\x3e\n            <plugin>\n                <groupid>org.apache.maven.plugins</groupid>\n                <artifactid>maven-compiler-plugin</artifactid>\n                <version>3.8.0</version>\n                <configuration>\n                    <source>1.8</source>\n                    <target>1.8</target>\n                </configuration>\n            </plugin>\n        </plugins>\n    </build>\n\n</project>\n\n\n业务接口\n\npackage com.newaop.service;\n\npublic interface iservice {\n    void add(int id , string name);\n    boolean update(int a , int b);\n}\n\n\n业务类\n\npackage com.newaop.service;\n\nimport org.springframework.stereotype.service;\n\n@service\npublic class teamservice implements iservice{\n    \n    @override\n    public void add(int id , string name) {\n        //制造异常\n        //int num = id/0;\n        system.out.println("myaspect---add---");\n    }\n    \n    @override\n    public boolean update(int a , int b) {\n        system.out.println("myaspect---update---");\n        if (a + b > 10) {\n            return true;\n        }\n        return false;\n    }\n}\n\n\n切面类\n\npackage com.newaop.aop;\n\nimport org.aspectj.lang.joinpoint;\nimport org.aspectj.lang.proceedingjoinpoint;\nimport org.aspectj.lang.annotation.aspect;\nimport org.springframework.stereotype.component;\n\n/**\n * 切面类 xml实现\n * 简洁代理通知\n */\n@component  //创建权限交给 spring容器 进行创建\n@aspect     //aspectj 框架注解 标识该类为切面类\npublic class myaspect_xml {\n    \n    public void before(joinpoint jp){\n        system.out.println("前置通知");\n    }\n    \n    public void afterreturn(object result){\n        system.out.println("后置通知");\n    }\n    \n    public object around(proceedingjoinpoint pjp) throws throwable{\n        system.out.println("======================aroundopen");\n        object obj = pjp.proceed();\n        system.out.println("======================aroundend");\n        return obj;\n    }\n    \n    public void exception(joinpoint jp, throwable ex){\n        system.out.println("异常通知");\n    }\n    \n    public void myfinally(joinpoint jp){\n        system.out.println("最终通知");\n    }\n    \n}\n\n\n配置文件 （扫描包，引入代理）\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:aop="http://www.springframework.org/schema/aop"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemalocation="\n       http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/aop\n       http://www.springframework.org/schema/aop/spring-aop.xsd\n       http://www.springframework.org/schema/context\n       http://www.springframework.org/schema/context/spring-context.xsd">\n\n    <context:component-scan base-package="com.newaop" />\n\n\x3c!--    xml实现 代理--\x3e\n    <aop:config>\n        <aop:pointcut id="pt_all" expression="execution(* com.newaop.service..*.*(..))"/>\n        <aop:aspect ref="myaspect_xml">\n            <aop:before method="before" pointcut-ref="pt_all"/>\n            <aop:after-returning method="afterreturn" pointcut-ref="pt_all" returning="result"/>\n            <aop:after-throwing method="exception" pointcut-ref="pt_all" throwing="ex"/>\n            <aop:after method="myfinally" pointcut-ref="pt_all"/>\n\x3c!--            容易出现问题--\x3e\n\x3c!--            <aop:around method="around" pointcut-ref="pt_all"/>--\x3e\n        </aop:aspect>\n    </aop:config>\n\n</beans>\n\n\n测试\n\n@test\npublic void test(){\n    applicationcontext ac = new classpathxmlapplicationcontext("myspring.xml");\n    iservice teamservice = (iservice) ac.getbean("teamservice");\n    teamservice.add(001,"张三");\n    system.out.println("\\n");\n    teamservice.update(6, 5);\n}\n\n/*运行结果\n\n前置通知\nmyaspect---add---\n后置通知\n最终通知\n\n\n前置通知\nmyaspect---update---\n后置通知\n最终通知\n\n*/\n\n\n# annotation实现aop\n\n对切面类使用指定 注解 定义 切面、切入点 等\n\n注解类型\n\n注解名称              说明\n@aspect           定义 切面（指定 类）\n@pointcut         定义 切入点表达式（指定 类）\n@before           定义 前置通知（指定 方法）\n@afterreturning   定义 后置通知（指定 方法）\n@around           定义 环绕通知（指定 方法）\n@afterthrowing    定义 异常通知（指定 方法）\n@after            定义 最终通知（指定 方法，无论异常都会通知）\n\n依赖配置 、 业务类 和 业务接口 与上述一致\n\n切面类\n\npackage com.newaop.aop;\n\nimport org.aspectj.lang.joinpoint;\nimport org.aspectj.lang.proceedingjoinpoint;\nimport org.aspectj.lang.annotation.*;\nimport org.springframework.stereotype.component;\n\n/**\n * 切面类\n * @author sans\n */\n@component  //创建权限交给 spring容器 进行创建\n@aspect     //aspectj 框架注解 标识该类为切面类\npublic class myaspect {\n    /**\n     * 切点表达式为：\n     *      方法 任意返回类型\n     *      指定路径 com.newaop包\n     *      指定包下的所有 子包、子类、类、接口、方法、方法参数\n     */\n    @pointcut("execution(* com.newaop..*.*(..))")\n    private void pointcut_all(){ }\n    \n    /**\n     * 前置通知\n     * @param jp\n     */\n    @before("pointcut_all()")\n    public void before(joinpoint jp){\n        system.out.println("======================beforeopen");\n        system.out.println("前置通知");\n        system.out.println("拦截信息：");\n        system.out.println("\\t方法名称："+jp.getsignature().getname());\n        object[] args = jp.getargs();\n        if (args.length != 0){\n            system.out.println("\\t参数格式："+args.length);\n            system.out.println("\\t参数列表:");\n            for (object arg : args) {\n                system.out.println("\\t\\t"+arg);\n            }\n        }\n        system.out.println("======================beforeend");\n    }\n    \n    /**\n     * 后置通知\n     * @param result\n     */\n    @afterreturning (value="pointcut_all()",returning = "result")\n    public void afterreturn(object result){\n        system.out.println("======================afterreturnopen");\n        system.out.println("后置通知");\n        system.out.println("拦截信息:");\n        system.out.println("\\t方法返回值："+result);\n        system.out.println("======================afterreturnend");\n    }\n    \n    /**\n     * 环绕通知\n     * @param pjp\n     * @return 方法返回类型\n     * @throws throwable 当前方法运行抛出的异常\n     */\n    @around("pointcut_all()")\n    public object around(proceedingjoinpoint pjp) throws throwable{\n        system.out.println("======================aroundopen");\n        system.out.println("环绕通知");\n        object obj = pjp.proceed();\n        system.out.println("方法 返回值为:"+obj);\n        system.out.println("======================aroundend");\n        return obj;\n    }\n    \n    /**\n     * 异常通知\n     * @param jp 连接点状态\n     * @param ex 异常返回\n     */\n    @afterthrowing(value = "pointcut_all()",throwing = "ex")\n    public void exception(joinpoint jp,throwable ex){\n        system.out.println("======================exceptionopen");\n        system.out.println("异常通知");\n        //返回连接点的签名（异常）\n        system.out.println("异常原因："+jp.getsignature());\n        //返回 throwable 的详细消息字符串\n        system.out.println("异常类型："+ex.getmessage());\n        system.out.println("======================exceptionend");\n    }\n    \n    /**\n     * 最终通知（无论出现异常都会执行的通知）\n     */\n    @after("pointcut_all()")\n    public void myfinally(joinpoint jp){\n        system.out.println("======================finallyopen");\n        system.out.println("最终通知");\n        system.out.println(jp.getsignature().getname()+" 方法结束!");\n        system.out.println("======================finallyend");\n    }\n    \n}\n\n\n配置文件 （扫描包，切面类注解应用）\n\n<?xml version="1.0" encoding="utf-8"?>\n<beans xmlns="http://www.springframework.org/schema/beans"\n       xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n       xmlns:aop="http://www.springframework.org/schema/aop"\n       xmlns:context="http://www.springframework.org/schema/context"\n       xsi:schemalocation="\n       http://www.springframework.org/schema/beans\n       http://www.springframework.org/schema/beans/spring-beans.xsd\n       http://www.springframework.org/schema/aop\n       http://www.springframework.org/schema/aop/spring-aop.xsd\n       http://www.springframework.org/schema/context\n       http://www.springframework.org/schema/context/spring-context.xsd">\n\t//扫描包。个人配置包路径 为 com.newaop\n    <context:component-scan base-package="com.newaop" />\n\t//允许 spring容器 权限应用\n    <aop:aspectj-autoproxy expose-proxy="true"/>\n</beans>\n\n\n测试\n\n@test\npublic void test(){\n    applicationcontext ac = new classpathxmlapplicationcontext("myspring.xml");\n    iservice teamservice = (iservice) ac.getbean("teamservice");\n    teamservice.add(001,"张三");\n    system.out.println("\\n");\n    teamservice.update(6, 5);\n}\n\n/*运行结果\n\n======================aroundopen\n环绕通知\n======================beforeopen\n前置通知\n拦截信息：\n\t方法名称：add\n\t参数格式：2\n\t参数列表:\n\t\t1\n\t\t张三\n======================beforeend\nmyaspect---add---\n======================afterreturnopen\n后置通知\n拦截信息:\n\t方法返回值：null\n======================afterreturnend\n======================finallyopen\n最终通知\nadd 方法结束!\n======================finallyend\n方法 返回值为:null\n======================aroundend\n\n\n======================aroundopen\n环绕通知\n======================beforeopen\n前置通知\n拦截信息：\n\t方法名称：update\n\t参数格式：2\n\t参数列表:\n\t\t6\n\t\t5\n======================beforeend\nmyaspect---update---\n======================afterreturnopen\n后置通知\n拦截信息:\n\t方法返回值：true\n======================afterreturnend\n======================finallyopen\n最终通知\nupdate 方法结束!\n======================finallyend\n方法 返回值为:true\n======================aroundend\n\n*/\n\n\n# xml与annotation 声明区别\n\n> xml在外部文件 .xml进行配置；annotation在类文件中进行配置 无需外部辅助\n> \n> xml效率一般(需要解析)；annotation效率高\n> \n> xml需要解析工具进行完成；annotation无需解析，利用java反射进行完成\n> \n> xml易于观察对象关系（业务量较多时）；annotation 不易观察',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"SpringMVC 拦截器",frontmatter:{title:"SpringMVC 拦截器",author:"柏竹",permalink:"/backend/k8ocwe",date:"2020-02-18T00:00:00.000Z",categories:["后端"],tags:["SpringMVC","Java"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/08.SpringMVC/06.%E6%8B%A6%E6%88%AA%E5%99%A8.html",relativePath:"01.后端/08.SpringMVC/06.拦截器.md",key:"v-e882b48e",path:"/backend/k8ocwe/",headersStr:null,content:'# SpringMVC 拦截器\n\nSpring MVC 提供了 Interceptor 拦截器机制，用于请求的预处理和后处理\n\nSpring MVC 的拦截器（Interceptor）与 Java Servlet 的过滤器（Filter）类似，它主要用于拦截用户的请求并做相应的处理，通常应用在权限验证、记录请求信息的日志、判断用户是否登录等功能上。\n\n了解Java Servlet 的过滤器：JavaWeb学习记录 Servlet过滤监听应用\n\n拦截器定义\n\n在 Spring MVC 框架中定义一个拦截器需要对拦截器进行定义和配置\n\n>  * 拦截器类 实现 HandlerInterceptor接口\n> \n>  * 配置文件 .xml 添加 拦截器\n>    \n>    \x3c!--    拦截器集合--\x3e\n>    <mvc:interceptors>\n>        \x3c!--指定干活的拦截器--\x3e\n>        <mvc:interceptor>\n>            \x3c!--请求规则--\x3e\n>            <mvc:mapping path="/**"/>\n>         \t\x3c!--指定类 拦截器（前提：继承接口）--\x3e\n>            <bean class="com.interceptor.MyInterceptor" id="interceptor"></bean>\n>        </mvc:interceptor>\n>    </mvc:interceptors>\n>    \n\nHandlerInterceptor接口 有三个方法\n\npackage org.springframework.web.servlet;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.springframework.lang.Nullable;\nimport org.springframework.web.method.HandlerMethod;\n\npublic interface HandlerInterceptor {\n\t\n    /**\n     * 执行点：控制器方法执行前\n     * 应用场景：登录验证、...\n     * @return 是否通行，控制器方法；false：进制通行至控制器\n     */\n\tdefault boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)\n\t\t\tthrows Exception {\n\t\treturn true;\n\t}\n\t\n    /**\n     * 执行点：在控制器方法执行后，在视图返回前，有机会修改返回值\n     * 应用场景：日志、登录ip、时间、...\n     */\n\tdefault void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable ModelAndView modelAndView) throws Exception {\n\t}\n\t\n    /**\n     * 执行点：在控制器方法执行后，在视图返回后，没机会修改返回值\n     * 应用场景：全局资源的操作\n     */\n\tdefault void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler,\n\t\t\t@Nullable Exception ex) throws Exception {\n\t}\n\n}\n\n\n拦截器工作流程\n\nSpringMVC 工作流程：\n\n\n\n拦截器 方法拦截点：\n\n>  * preHandle( )：该方法在控制器的处理请求方法前执行（处理器适配器HandlerAdaptor处理前的区间），返回值表示是否中断后续操作\n>  * postHandle( )：该方法在控制器的处理请求方法调用之后、解析视图之前执行，可以通过此方法对请求域中的 模型 和 视图 做进一步的修改\n>  * afterCompletion( )：该方法在控制器的处理请求方法执行完成后执行，即视图渲染结束后执行，可以通过此方法实现一些资源清理、记录日志信息等工作\n\n应用实现：\n\n> 应用前提：\n> \n>  * 需要 xml配置文件添加 拦截器\n> \n>  * 拦截器类 实现 HandlerInterceptor接口\n\n项目结构：（保留重要部分）\n\n  .\n  |\n  ├── com\n  │   ├── controller\n  |\t  |\t\t  └── ...\n  │   ├── interceptor\n  |   |   \t  └── MyInterceptor\n  |   User\n  |   \n  └── webapp\n         └── jsp\n      \t\t  └── ok.jsp\n\n\nMyInterceptor类 拦截器\n\npackage com.interceptor;\n\nimport org.springframework.web.servlet.HandlerInterceptor;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\npublic class MyInterceptor implements HandlerInterceptor {\n    \n    /**\n     * 执行点：控制器方法执行前\n     * 应用场景：登录验证、...\n     * @return 是否通行，控制器方法；false：进制通行至控制器\n     */\n    @Override\n    public boolean preHandle(HttpServletRequest request , HttpServletResponse response , Object handler) throws Exception {\n        System.out.println("preHandle===============");\n        return true;\n    }\n    \n    /**\n     * 执行点：在控制器方法执行后，在视图返回前，有机会修改返回值\n     * 应用场景：日志、登录ip、时间、...\n     */\n    @Override\n    public void postHandle(HttpServletRequest request , HttpServletResponse response , Object handler , ModelAndView modelAndView) throws Exception {\n        System.out.println("postHandle===============");\n    }\n    \n    /**\n     * 执行点：在控制器方法执行后，在视图返回后，没机会修改返回值\n     * 应用场景：全局资源的操作\n     */\n    @Override\n    public void afterCompletion(HttpServletRequest request , HttpServletResponse response , Object handler , Exception ex) throws Exception {\n        System.out.println("afterCompletion===============");\n    }\n}\n\n\n> 当请求时 都会执行拦截器',normalizedContent:'# springmvc 拦截器\n\nspring mvc 提供了 interceptor 拦截器机制，用于请求的预处理和后处理\n\nspring mvc 的拦截器（interceptor）与 java servlet 的过滤器（filter）类似，它主要用于拦截用户的请求并做相应的处理，通常应用在权限验证、记录请求信息的日志、判断用户是否登录等功能上。\n\n了解java servlet 的过滤器：javaweb学习记录 servlet过滤监听应用\n\n拦截器定义\n\n在 spring mvc 框架中定义一个拦截器需要对拦截器进行定义和配置\n\n>  * 拦截器类 实现 handlerinterceptor接口\n> \n>  * 配置文件 .xml 添加 拦截器\n>    \n>    \x3c!--    拦截器集合--\x3e\n>    <mvc:interceptors>\n>        \x3c!--指定干活的拦截器--\x3e\n>        <mvc:interceptor>\n>            \x3c!--请求规则--\x3e\n>            <mvc:mapping path="/**"/>\n>         \t\x3c!--指定类 拦截器（前提：继承接口）--\x3e\n>            <bean class="com.interceptor.myinterceptor" id="interceptor"></bean>\n>        </mvc:interceptor>\n>    </mvc:interceptors>\n>    \n\nhandlerinterceptor接口 有三个方法\n\npackage org.springframework.web.servlet;\n\nimport javax.servlet.http.httpservletrequest;\nimport javax.servlet.http.httpservletresponse;\n\nimport org.springframework.lang.nullable;\nimport org.springframework.web.method.handlermethod;\n\npublic interface handlerinterceptor {\n\t\n    /**\n     * 执行点：控制器方法执行前\n     * 应用场景：登录验证、...\n     * @return 是否通行，控制器方法；false：进制通行至控制器\n     */\n\tdefault boolean prehandle(httpservletrequest request, httpservletresponse response, object handler)\n\t\t\tthrows exception {\n\t\treturn true;\n\t}\n\t\n    /**\n     * 执行点：在控制器方法执行后，在视图返回前，有机会修改返回值\n     * 应用场景：日志、登录ip、时间、...\n     */\n\tdefault void posthandle(httpservletrequest request, httpservletresponse response, object handler,\n\t\t\t@nullable modelandview modelandview) throws exception {\n\t}\n\t\n    /**\n     * 执行点：在控制器方法执行后，在视图返回后，没机会修改返回值\n     * 应用场景：全局资源的操作\n     */\n\tdefault void aftercompletion(httpservletrequest request, httpservletresponse response, object handler,\n\t\t\t@nullable exception ex) throws exception {\n\t}\n\n}\n\n\n拦截器工作流程\n\nspringmvc 工作流程：\n\n\n\n拦截器 方法拦截点：\n\n>  * prehandle( )：该方法在控制器的处理请求方法前执行（处理器适配器handleradaptor处理前的区间），返回值表示是否中断后续操作\n>  * posthandle( )：该方法在控制器的处理请求方法调用之后、解析视图之前执行，可以通过此方法对请求域中的 模型 和 视图 做进一步的修改\n>  * aftercompletion( )：该方法在控制器的处理请求方法执行完成后执行，即视图渲染结束后执行，可以通过此方法实现一些资源清理、记录日志信息等工作\n\n应用实现：\n\n> 应用前提：\n> \n>  * 需要 xml配置文件添加 拦截器\n> \n>  * 拦截器类 实现 handlerinterceptor接口\n\n项目结构：（保留重要部分）\n\n  .\n  |\n  ├── com\n  │   ├── controller\n  |\t  |\t\t  └── ...\n  │   ├── interceptor\n  |   |   \t  └── myinterceptor\n  |   user\n  |   \n  └── webapp\n         └── jsp\n      \t\t  └── ok.jsp\n\n\nmyinterceptor类 拦截器\n\npackage com.interceptor;\n\nimport org.springframework.web.servlet.handlerinterceptor;\nimport org.springframework.web.servlet.modelandview;\n\nimport javax.servlet.http.httpservletrequest;\nimport javax.servlet.http.httpservletresponse;\n\npublic class myinterceptor implements handlerinterceptor {\n    \n    /**\n     * 执行点：控制器方法执行前\n     * 应用场景：登录验证、...\n     * @return 是否通行，控制器方法；false：进制通行至控制器\n     */\n    @override\n    public boolean prehandle(httpservletrequest request , httpservletresponse response , object handler) throws exception {\n        system.out.println("prehandle===============");\n        return true;\n    }\n    \n    /**\n     * 执行点：在控制器方法执行后，在视图返回前，有机会修改返回值\n     * 应用场景：日志、登录ip、时间、...\n     */\n    @override\n    public void posthandle(httpservletrequest request , httpservletresponse response , object handler , modelandview modelandview) throws exception {\n        system.out.println("posthandle===============");\n    }\n    \n    /**\n     * 执行点：在控制器方法执行后，在视图返回后，没机会修改返回值\n     * 应用场景：全局资源的操作\n     */\n    @override\n    public void aftercompletion(httpservletrequest request , httpservletresponse response , object handler , exception ex) throws exception {\n        system.out.println("aftercompletion===============");\n    }\n}\n\n\n> 当请求时 都会执行拦截器',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Spring MVC请求接收",frontmatter:{title:"Spring MVC请求接收",author:"柏竹",permalink:"/backend/pahdv0",date:"2020-02-18T00:00:00.000Z",categories:["后端"],tags:["SpringMVC","Java"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/08.SpringMVC/03.%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0.html",relativePath:"01.后端/08.SpringMVC/03.传递参数.md",key:"v-2693326f",path:"/backend/pahdv0/",headers:[{level:2,title:"逐个参数接收",slug:"逐个参数接收",normalizedTitle:"逐个参数接收",charIndex:751},{level:2,title:"原生Servlet接收",slug:"原生servlet接收",normalizedTitle:"原生servlet接收",charIndex:2366},{level:2,title:"@PathVariable 注解接收",slug:"pathvariable-注解接收",normalizedTitle:"@pathvariable 注解接收",charIndex:3321},{level:2,title:"",slug:"requestparam-接收",normalizedTitle:"",charIndex:0},{level:2,title:"",slug:"requestbody-接收",normalizedTitle:"",charIndex:0},{level:2,title:"",slug:"获取-不同类型的对象",normalizedTitle:"",charIndex:0},{level:3,title:"日期",slug:"日期",normalizedTitle:"日期",charIndex:257},{level:3,title:"数组",slug:"数组",normalizedTitle:"数组",charIndex:260},{level:3,title:"集合",slug:"集合",normalizedTitle:"集合",charIndex:263},{level:3,title:"对象集合",slug:"对象集合",normalizedTitle:"对象集合",charIndex:9255},{level:2,title:"中文乱码解决",slug:"中文乱码解决",normalizedTitle:"中文乱码解决",charIndex:10768},{level:2,title:"SpringMVC 响应返回参数",slug:"springmvc-响应返回参数",normalizedTitle:"springmvc 响应返回参数",charIndex:11633},{level:3,title:"ModelAndView 响应",slug:"modelandview-响应",normalizedTitle:"modelandview 响应",charIndex:12182},{level:2,title:"String 响应",slug:"string-响应",normalizedTitle:"string 响应",charIndex:12889},{level:3,title:"自定义类型对象 响应",slug:"自定义类型对象-响应",normalizedTitle:"自定义类型对象 响应",charIndex:13824},{level:4,title:"Integer 整型",slug:"integer-整型",normalizedTitle:"integer 整型",charIndex:14372},{level:4,title:"String 字符型",slug:"string-字符型",normalizedTitle:"string 字符型",charIndex:14896},{level:4,title:"Double 浮点型",slug:"double-浮点型",normalizedTitle:"double 浮点型",charIndex:15452},{level:4,title:"List 列表",slug:"list-列表",normalizedTitle:"list 列表",charIndex:15969},{level:4,title:"Map 哈希表",slug:"map-哈希表",normalizedTitle:"map 哈希表",charIndex:16708},{level:4,title:"对象",slug:"对象",normalizedTitle:"对象",charIndex:253},{level:3,title:"无返回值 void 响应",slug:"无返回值-void-响应",normalizedTitle:"无返回值 void 响应",charIndex:18586}],headersStr:"逐个参数接收 原生Servlet接收 @PathVariable 注解接收    日期 数组 集合 对象集合 中文乱码解决 SpringMVC 响应返回参数 ModelAndView 响应 String 响应 自定义类型对象 响应 Integer 整型 String 字符型 Double 浮点型 List 列表 Map 哈希表 对象 无返回值 void 响应",content:'# Spring MVC请求接收\n\nSpring MVC Controller 接收请求参数的方式有很多种，有的适合 get 请求方式，有的适合 post 请求方式，有的两者都适合。主要有以下几种方式：\n\n * 通过 处理方法的形参接收请求参数\n * 通过 HttpServletRequest 接收请求参数\n * 通过 @PathVariable 接收 URL 中的请求参数\n * 通过 @RequestParam 接收请求参数\n * 通过 @RequestBody 接收请求参数\n * 获取 不同类型的对象 （日期、数组、集合、...）\n\n项目结构：（主要测试文件其余省略）\n\n  .\n  |\n  ├── com\n  │   ├── controller\n  |\t  |\t\t  └── UserController\n  │   ├── ov\n  |   |\t  └── QueryVO\n  |   User\n  |   \n  └── webapp\n         └── jsp\n      \t\t  ├── parameterTest.jsp\n      \t\t  └── ok.jsp\n\n\n> 说明：\n> \n>  * UserController类 添加了 @RequestMapping 注解路径\n>    \n>    @Controller\n>    @RequestMapping("/user")\n>    public class UserController {···}\n>    \n> \n>  * User类 有 (int)id、(String)name、(int)age、(String)location 属性，分别有各自的 get和set方法 和 toString方法\n\n\n# 逐个参数接收\n\n逐个传递参数\n\nparameterTest.jsp\n\n<form action="/user/parameterMethod" method="post">\n    <span>id：</span> <input type="text" name="id" > <br>\n    <span>name：</span> <input type="text" name="name" > <br>\n    <span>age：</span> <input type="text" name="age" > <br>\n    <span>location：</span> <input type="text" name="location" > <br>\n    <button type="submit">提交</button>\n</form>\n\n\nUserController类\n\n/**\n * 通过 方法逐个参数传递\n * 前提：前端属性名 与 实体类属性名 保持一致，否则获取不到\n */\n@RequestMapping("parameterMethod")\npublic ModelAndView parameterMethod(int id, String name, int age, String location){\n    System.out.println("方法逐个参数传递===============");\n    System.out.println("id : " + id);\n    System.out.println("name : " + name);\n    System.out.println("age : " + age);\n    System.out.println("location : " + location);\n    ModelAndView mv = new ModelAndView();\n    mv.setViewName("jsp/ok");\n    return mv;\n}\n\n\n**对象传递参数 **\n\nparameterTest.jsp\n\n<form action="/user/parameterMethod2" method="post">\n    <span>id：</span> <input type="text" name="id" > <br>\n    <span>name：</span> <input type="text" name="name" > <br>\n    <span>age：</span> <input type="text" name="age" > <br>\n    <span>location：</span> <input type="text" name="location" > <br>\n    <button type="submit">提交</button>\n</form>\n\n\nUserController类\n\n/**\n * 通过 方法对象参数传递\n * 条件：传参要有对应的实体对象\n * 前提：前端属性名 与 实体类属性名 保持一致，否则获取不到\n */\n@RequestMapping("parameterMethod2")\npublic ModelAndView parameterMethod2(User user){\n    System.out.println("方法对象参数传递===============");\n    System.out.println(user);\n    ModelAndView mv = new ModelAndView();\n    mv.setViewName("jsp/ok");\n    return mv;\n}\n\n\n\n# 原生Servlet接收\n\nparameterTest.jsp\n\n<form action="/user/parameterServletRequest" method="post">\n    <span>id：</span> <input type="text" name="id"> <br>\n    <span>name：</span> <input type="text" name="name"> <br>\n    <span>age：</span> <input type="text" name="age"> <br>\n    <span>location：</span> <input type="text" name="location"> <br>\n    <button type="submit">提交</button>\n</form>\n\n\nUserController类\n\n/**\n * 通过 HttpServletRequest 进行参数传递\n */\n@RequestMapping("parameterServletRequest")\npublic ModelAndView parameterServletRequest(HttpServletRequest rs){\n    System.out.println("HttpServletRequest对象传递===============");\n    System.out.println("id : " + rs.getParameter("id"));\n    System.out.println("name : " + rs.getParameter("name"));\n    System.out.println("age : " + rs.getParameter("age"));\n    System.out.println("location : " + rs.getParameter("location"));\n    ModelAndView mv = new ModelAndView();\n    mv.setViewName("jsp/ok");\n    return mv;\n}\n\n\n\n# @PathVariable 注解接收\n\n通过 @PathVariable注解 进行匹配参数逐个接收\n\n它的独特之处在于它能够通过 URL的RESTful风格 传递参数，以下是应用实例\n\nUserController类\n\n/**\n * 通过 @PathVariable 接收 URL中的请求参数\n * 地址应用：http://localhost:8088/user/parameterPathVariable/1003/zhu/23/jsp\n * 属性：\n *      String value：对应前端属性名\n *      boolean required（默认true）：参数是否必须，如果 获取前端数有丝毫问题就会报400异常（获取并非指定的参数值为null）\n */\n@RequestMapping("parameterPathVariable/{id}/{name}/{age}/{location}")\npublic ModelAndView paraeterPathVariable(\n        @PathVariable(value = "id" , required = false) Integer id,\n        @PathVariable(value = "name" , required = false) String name,\n        @PathVariable(value = "age" , required = false) Integer age,\n        @PathVariable(value = "location" , required = false) String location){\n    System.out.println("通过 @PathVariable 接收 URL中的请求参数===============");\n    System.out.println("id : " + id);\n    System.out.println("name : " + name);\n    System.out.println("age : " + age);\n    System.out.println("location : " + location);\n    ModelAndView mv = new ModelAndView();\n    mv.setViewName("jsp/ok");\n    return mv;\n}\n\n\n\n# @RequestParam 接收\n\n通过 @RequestParam注解 进行匹配参数逐个接收，和上面有些类似，但接收形式不一样！\n\n接收形式：\n\n 1. 不同请求头 form默认提交的请求头是 ==content-type: form-data、x-www-form-urlencoded== , 因此填充填充参数可以直接用 @RequestParam注解 进行接收获取\n\n 2. url参数填充\n    \n    在已经固定请求头的类型且又想获取数据是 可以直接在url拼接获取如：\n    \n    http://localhost:8080/login?code=123 (传递 code)\n\nparameterTest.jsp\n\n<form action="/user/parameterRequestParam" method="post">\n    <span>id：</span> <input type="text" name="userId" > <br>\n    <span>name：</span> <input type="text" name="userName" > <br>\n    <span>age：</span> <input type="text" name="userAge" > <br>\n    <span>location：</span> <input type="text" name="userLocation" > <br>\n    <button type="submit">提交</button>\n</form>\n\n\nUserController类\n\n/**\n * 通过 @RequestParam 进行参数传递\n * 作用：矫正 前端属性名 与 方法参数名 不一致\n * 属性：\n *      String value：对应前端属性名\n *      boolean required（默认true）：参数是否必须，如果 获取前端数有丝毫问题就会报400异常（获取并非指定的参数值为null）\n */\n@RequestMapping("parameterRequestParam")\npublic ModelAndView parameterRequestParam(\n        @RequestParam("userId") int id,\n        @RequestParam("userName") String name,\n        @RequestParam("userAge") int age,\n        //制造参数名不匹配 （获取参数结果为null，并非400页面）\n        @RequestParam(value = "userLocationABC", required = false) String location){\n    System.out.println("@RequestParam 进行参数传递===============");\n    System.out.println("id : " + id);\n    System.out.println("name : " + name);\n    System.out.println("age : " + age);\n    System.out.println("location : " + location);\n    ModelAndView mv = new ModelAndView();\n    mv.setViewName("jsp/ok");\n    return mv;\n}\n\n\n\n# @RequestBody 接收\n\n@RequestBody注解 来处理Content-Type为 application/json, application/xml 数据，他们传递形式是已JSON形式进行的 , 后端接收的可直接封装成实体对象（前提key名称必须与 实体类的属性名一致！！！）\n\naxios.defaults.headers.post[\'Content-Type\'] = \'application/json;charset=UTF-8\';\naxios.post("/user/login", {\n    userName: this.userName,\n    userPassword: this.userPassword,\n    code: this.code\n}).then(res => {...});\n\n@RequestMapping("/login")\npublic void login(@RequestBody User user) {\n    ...\n}\n\n\n> 请求和响应必须都使用 JSON形式进行传递数据\n\n\n# 获取 不同类型的对象\n\n\n# 日期\n\nuser类\n\npublic class User {\n    private int id;\n    private String name;\n    private int age;\n    private String location;\n    @DateTimeFormat(pattern = "yyyy-MM-dd")\n    private Date createTime;\n    \n    ·····\n}\n\n\nparameterTest.jsp\n\n<form action="/user/parameterDate" method="post">\n    <span>id：</span> <input type="text" name="id" > <br>\n    <span>name：</span> <input type="text" name="name" > <br>\n    <span>age：</span> <input type="text" name="age" > <br>\n    <span>location：</span> <input type="text" name="location" > <br>\n    <span>createTime：</span> <input type="text" name="createTime" > <br>\n    <button type="submit">提交</button>\n</form>\n\n\nUserController类\n\n/**\n * 日期\n * 通过 方法对象参数传递（包含日期类型）\n * 条件：实体对象的日期类型必须包含 @DateTimeFormat(pattern = "yyyy-MM-dd") 注解\n * 前提：传输格式符合：（"yyyy-MM-dd"）格式且是日期值范围内，否则报400\n */\n@RequestMapping("parameterDate")\npublic ModelAndView parameterDate(User user){\n    System.out.println("传递日期类型===============");\n    System.out.println(user);\n    ModelAndView mv = new ModelAndView();\n    mv.setViewName("jsp/ok");\n    return mv;\n}\n\n\n\n# 数组\n\nparameterTest.jsp\n\n<form action="/user/parameterArrays" method="post">\n    <span>name1：</span> <input type="text" name="names" > <br>\n    <span>name2：</span> <input type="text" name="names" > <br>\n    <span>name3：</span> <input type="text" name="names" > <br>\n    <button type="submit">提交</button>\n</form>\n\n\nUserController类\n\n/*\n* 数组\n* 传递数组对象\n* 获取方式：\n*       1.参数直接获取（变量名 与 前端的属性名一致）\n*       2. HttpServletRequest原生对象获取\n* */\n@RequestMapping("parameterArrays")\npublic ModelAndView parameterArrays(String[] names , HttpServletRequest rs){\n    System.out.println("传递数组对象===============");\n    System.out.println("方式1：");\n    //方式1：（参数数组形式获取）\n    for (String n : names) {\n        System.out.println("\\t"+n);\n    }\n    System.out.println("==========");\n    System.out.println("方式2：");\n    //方式2：（原生对象获取）\n    String[] names2 = rs.getParameterValues("names");\n    for (String n : names2) {\n        System.out.println("\\t"+n);\n    }\n    \n    ModelAndView mv = new ModelAndView();\n    mv.setViewName("jsp/ok");\n    return mv;\n}\n\n\n\n# 集合\n\nparameterTest.jsp\n\n<form action="/user/parameterSet" method="post">\n    <span>name1：</span> <input type="text" name="names" > <br>\n    <span>name2：</span> <input type="text" name="names" > <br>\n    <span>name3：</span> <input type="text" name="names" > <br>\n    <button type="submit">提交</button>\n</form>\n\n\nUserController类\n\n/*\n* 集合\n* 前提：需要 @RequestParam() 指定value 前端属性名 （属性类型不匹配较为特殊需自行配置）\n* */\n@RequestMapping("parameterSet")\npublic ModelAndView parameterSet(@RequestParam("names") List<String> nameList){\n    System.out.println("传递集合对象===============");\n    for (String name : nameList) {\n        System.out.println(name);\n    }\n    ModelAndView mv = new ModelAndView();\n    mv.setViewName("jsp/ok");\n    return mv;\n}\n\n\n\n# 对象集合\n\nQueryVO类\n\npackage com.vo;\nimport com.User;\nimport java.util.List;\n\npublic class QueryVO {\n    private List<User> userList;\n    \n    public List<User> getUserList() {\n        return userList;\n    }\n    \n    public void setUserList(List<User> userList) {\n        this.userList = userList;\n    }\n}\n\n\nparameterTest.jsp\n\n<form action="/user/parameterObjectSet" method="post">\n    <span>id1：</span> <input type="text" name="userList[0].id" > <br>\n    <span>id2：</span> <input type="text" name="userList[1].id" > <br>\n    <span>id3：</span> <input type="text" name="userList[2].id" > <br>\n    <span>name1：</span> <input type="text" name="userList[0].name" > <br>\n    <span>name2：</span> <input type="text" name="userList[1].name" > <br>\n    <span>name3：</span> <input type="text" name="userList[2].name" > <br>\n    <span>age1：</span> <input type="text" name="userList[0].age" > <br>\n    <span>age2：</span> <input type="text" name="userList[1].age" > <br>\n    <span>age3：</span> <input type="text" name="userList[2].age" > <br>\n    <button type="submit">提交</button>\n</form>\n\n\nUserController类\n\n/*\n* 对象集合\n* 提前：\n*     2. QueryVO类 中指定的 变量名 与 前端集合属性名 必须一致\n*     1. 对象集合中指定的 User实体类变量名（属性名）与 前端属性名 必须一致\n* */\n@RequestMapping("parameterObjectSet")\npublic ModelAndView parameterObjectSet(QueryVO vo){\n    System.out.println("传递对象集合===============");\n    for (User user : vo.getUserList()) {\n        System.out.println(user);\n    }\n    ModelAndView mv = new ModelAndView();\n    mv.setViewName("jsp/ok");\n    return mv;\n}\n\n\n\n# 中文乱码解决\n\n在web.xml配置文件直接 过滤器 解决编码\n\n\x3c!--    字符编码过滤器--\x3e\n<filter>\n    \x3c!--指定封装好的过滤器类 和 指定名称--\x3e\n    <filter-name>characterEncodingFilter</filter-name>\n    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>\n    \x3c!--指定字符集--\x3e\n    <init-param>\n        <param-name>encoding</param-name>\n        <param-value>UTF-8</param-value>\n    </init-param>\n    \x3c!--强制 request(请求) 使用 UTF-8--\x3e\n    <init-param>\n        <param-name>forceRequestEncoding</param-name>\n        <param-value>true</param-value>\n    </init-param>\n    \x3c!--强制 response(响应) 使用 UTF-8--\x3e\n    <init-param>\n        <param-name>forceResponseEncoding</param-name>\n        <param-value>true</param-value>\n    </init-param>\n</filter>\n\x3c!--对应映射名称 指定 url地址 进行过滤--\x3e\n<filter-mapping>\n    <filter-name>characterEncodingFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n\n\n\n# SpringMVC 响应返回参数\n\n使用@Controller 注解的处理器的处理器方法，其返回值常用的有四种类型：\n\n>  * ModelAndView\n>  * String\n>  * 返回自定义类型对象\n>  * 无返回值 void\n\n项目结构说明：（主要测试文件其余省略）\n\n  .\n  |\n  ├── com\n  │   ├── controller\n  |\t  |\t\t  └── ResultController\n  |   User\n  |   \n  └── webapp\n         └── jsp\n      \t\t  └── resultTest.jsp\n\n\n> 说明：\n> \n>  * ResultController类 添加了 @RequestMapping 注解路径\n>    \n>    @Controller\n>    @RequestMapping("/user")\n>    public class ResultController {···}\n>    \n> \n>  * User类 有 (int)id、(String)name、(int)age、(String)location 属性，分别有各自的 get和set方法 和 toString方法\n\n\n# ModelAndView 响应\n\n如果是前后端不分的开发，大部分情况下，返回 ModelAndView，即数据模型+视图：（跳转才能传递数据）\n\nresultTest.jsp\n\n<h3>通过 ModelAndView 进行返回</h3>\n<div>\n    <span>id: ${id}</span> <br>\n    <span>name: ${name}</span> <br>\n    <span>age: ${age}</span> <br>\n    <span>location: ${location}</span> <br>\n</div>\n\n\nResultController类\n\n/**\n *  通过 ModelAndView 形式跳转返回\n *  响应传参 需要 addObject()方法 进行\n */\n@RequestMapping("resultMAV")\npublic ModelAndView resultMAV() {\n    ModelAndView mv = new ModelAndView();\n\n    //返回参数 (逐个传参)\n    mv.addObject("id","001");\n    mv.addObject("name","Sanscan12");\n    mv.addObject("age","21");\n    mv.addObject("location","福州");\n    \n    //需要经过视图解析器转换物理路径\n    mv.setViewName("jsp/resultTest");\n    return mv;\n}\n\n\n\n# String 响应\n\nresultTest.jsp\n\n<h3>通过 String 进行返回</h3>\n<h4>requestScope 作用区域测试</h4>\n<div>\n    <span>id: ${requestScope.user.id}</span> <br>\n    <span>name: ${requestScope.user.name}</span> <br>\n    <span>age: ${requestScope.user.age}</span> <br>\n    <span>location: ${requestScope.user.location}</span> <br>\n</div>\n<h4>Session 作用区域测试</h4>\n<div>\n    <span>id: ${sessionScope.user.id}</span> <br>\n    <span>name: ${sessionScope.user.name}</span> <br>\n    <span>age: ${sessionScope.user.age}</span> <br>\n    <span>location: ${sessionScope.user.location}</span> <br>\n</div>\n\n\nResultController类\n\n/*\n* 通过 String 形式跳转返回\n* 响应传参 需要 HttpServletRequest原生对象 进行\n* */\n@RequestMapping("resultString")\npublic String resultString(HttpServletRequest request){\n    //实例对象\n    User user = new User(002,"柏竹",21,"平南");\n    //携带参数进行传递\n    request.setAttribute("user",user);\n    request.getSession().setAttribute("user",user);\n    return "jsp/resultTest";\n}\n\n\n\n# 自定义类型对象 响应\n\n自定义对象类型常用的有：Integer、Double、List、Map （返回并非逻辑视图名称，而是数据返回）\n\n以上数据类型一般搭配 ajax 请求使用，将 JSON格式 的数据直接响应返回\n\n> 应用前提&说明：\n> \n>  * 方法需要添加 @ResponseBody注解\n> \n>  * 引入依赖 Maven项目引入\n>    \n>    <dependency>\n>    \t<groupId>com.fasterxml.jackson.core</groupId>\n>    \t<artifactId>jackson-core</artifactId>\n>    \t<version>2.9.0</version>\n>    </dependency>\n>    <dependency>\n>    \t<groupId>com.fasterxml.jackson.core</groupId>\n>    \t<artifactId>jackson-databind</artifactId>\n>    \t<version>2.9.0</version>\n>    </dependency>\n>    \n> \n>  * 数据的返回用 AJAX进行响应呈现\n\n# Integer 整型\n\nresultTest.jsp\n\n<h4>Integer 整型</h4>\n<div id="Integer"></div>\n<button id="IntegerAjax">ajax请求</button>\n···\n\x3c!--ajax测试--\x3e\n$("#IntegerAjax").click(function(){\n    $.ajax({\n        type:"POST",\n        url: "resultInteger",\n        data: "",\n        success: function(msg){\n            $("#Integer").html("值："+msg);\n        }\n    });\n});\n\n\nResultController类\n\n/*\n* Integer 整型\n* 搭配 ajax 请求使用，将 JSON格式 的数据直接响应返回\n* */\n@ResponseBody\n@RequestMapping("resultInteger")\npublic Integer resultInteger(){\n    return 2188;\n}\n\n\n# String 字符型\n\n同样是返回数据，因 @ResponseBody注解\n\nresultTest.jsp\n\n<h4>String 字符型</h4>\n<div id="String"></div>\n<button id="StringAjax">ajax请求</button>\n···\n\x3c!--ajax测试--\x3e\n$("#StringAjax").click(function(){\n    $.ajax({\n        type: "POST",\n        url: "resultString2",\n        data: "",\n        success: function(msg){\n            $("#String").html("值："+msg);\n        }\n    });\n});\n\n\nResultController类\n\n/*\n* String 整型\n* 搭配 ajax 请求使用，将 JSON格式 的数据直接响应返回\n* */\n@ResponseBody\n@RequestMapping("resultString2")\npublic String resultString(){\n    return "resultString2";\n}\n\n\n# Double 浮点型\n\nresultTest.jsp\n\n<h4>Double 浮点型</h4>\n<div id="Double"></div>\n<button id="DoubleAjax">ajax请求</button>\n···\n\x3c!--ajax测试--\x3e\n$("#DoubleAjax").click(function(){\n    $.ajax({\n        type: "POST",\n        url: "resultDouble",\n        data: "",\n        success: function(msg){\n            $("#Double").html("值："+msg);\n        }\n    });\n});\n\n\nResultController类\n\n/*\n* Double 浮点型\n* 搭配 ajax 请求使用，将 JSON格式 的数据直接响应返回\n* */\n@ResponseBody\n@RequestMapping("resultDouble")\npublic double resultDouble(){\n    return 3.14;\n}\n\n\n# List 列表\n\nresultTest.jsp\n\n<h4>List 列表</h4>\n<div id="List"></div>\n<button id="ListAjax">ajax请求</button>\n···\n\x3c!--ajax测试--\x3e\n$("#ListAjax").click(function(){\n    $.ajax({\n        type: "POST",\n        url: "resultList",\n        data: "",\n        success: function(msg){\n            var str = "";\n            for (let i = 0; i < msg.length; i++) {\n                str= str+" "+i+"."+msg[i];\n            }\n            $("#List").html("值："+str);\n        }\n    });\n});\n\n\nResultController类\n\n/*\n* List 列表\n* 搭配 ajax 请求使用，将 JSON格式 的数据直接响应返回\n* */\n@ResponseBody\n@RequestMapping("resultList")\npublic List resultList(){\n    List list = new ArrayList();\n    list.add("张三");\n    list.add("李四");\n    list.add("王五");\n    list.add("赵六");\n    return list;\n}\n\n\n# Map 哈希表\n\nresultTest.jsp\n\n<h4>Map 哈希表</h4>\n<div id="Map"></div>\n<button id="MapAjax">ajax请求</button>\n···\n\x3c!--ajax测试--\x3e\n$("#MapAjax").click(function(){\n    $.ajax({\n        type: "POST",\n        url: "resultMap",\n        data: "",\n        success: function(msg){\n            var str= "id: "+msg.id+\n                "，name: "+msg.name+\n                "，age: "+msg.age+\n                "，location: "+msg.location;\n            $("#Map").html("值："+str);\n        }\n    });\n});\n\n\nResultController类\n\n/*\n* Map 哈希表\n* 搭配 ajax 请求使用，将 JSON格式 的数据直接响应返回\n* */\n@ResponseBody\n@RequestMapping("resultMap")\npublic Map resultMap(){\n    Map map = new HashMap();\n    map.put("id","04");\n    map.put("name","李四");\n    map.put("age","23");\n    map.put("location","深圳");\n    return map;\n}\n\n\n# 对象\n\nresultTest.jsp\n\n<h4>User 对象</h4>\n<div id="User"></div>\n<button id="UserAjax">ajax请求</button>\n···\n\x3c!--ajax测试--\x3e\n$("#UserAjax").click(function(){\n    $.ajax({\n        type: "POST",\n        url: "resultUser",\n        data: "",\n        success: function(msg){\n            var str= "id: "+msg.id+\n                "，name: "+msg.name+\n                "，age: "+msg.age+\n                "，location: "+msg.location;\n            $("#User").html("值："+str);\n        }\n    });\n});\n\n\nResultController类\n\n/*\n* User 对象\n* 搭配 ajax 请求使用，将 JSON格式 的数据直接响应返回\n* */\n@ResponseBody\n@RequestMapping("resultUser")\npublic User resultUser(){\n    return new User(002,"张三",23,"南宁");\n}\n\n\n整体结果：\n\n响应返回值\n通过 ModelAndView 进行返回\n\tid:\n\tname:\n\tage:\n\tlocation:\n通过 String 进行返回\nrequestScope 作用区域测试\n\tid: 2\n\tname: 柏竹\n\tage: 21\n\tlocation: 平南\nSession 作用区域测试\n\tid: 2\n\tname: 柏竹\n\tage: 21\n\tlocation: 平南\n返回自定义对象类型 进行返回\nInteger 整型\n\t值：2188\n\tajax请求\nString 字符型\n\t值：resultString2\n\tajax请求\nDouble 浮点型\n\t值：3.14\n\tajax请求\nList 列表\n\t值： 0.张三 1.李四 2.王五 3.赵六\n\tajax请求\nMap 哈希表\n\t值：id: 04，name: 李四，age: 23，location: 深圳\n\tajax请求\nUser 对象\n\t值：id: 2，name: 张三，age: 23，location: 南宁\n\tajax请求\n\n\n\n# 无返回值 void 响应\n\n方法的返回值为 void，并不一定真的没有返回值，可以通过其他方式给前端返回。实际上，这种方 式也可以理解为 Servlet 中的的处理方案。响应一般为：跳转、重定向\n\n//页面转换形式： 跳转\n@RequestMapping("resultVoid1")\npublic void resultVoid1(HttpServletRequest rs, HttpServletResponse resp) throws ServletException, IOException {\n    System.out.println("resultVoid1");\n    rs.getRequestDispatcher("/jsp/ok.jsp").forward(rs,resp);\n}\n\n\n//页面转换形式： 重定向\n@RequestMapping("resultVoid2")\npublic void resultVoid2(HttpServletRequest rs, HttpServletResponse resp) throws IOException {\n    System.out.println("resultVoid2");\n    resp.sendRedirect("/jsp/ok.jsp");\n}\n\n\n//void类型 ajax应用\n@RequestMapping("resultVoid3")\npublic void resultVoid3(HttpServletResponse resp) throws IOException {\n    System.out.println("resultVoid3");\n    resp.setCharacterEncoding("UTF-8");\n    resp.setContentType("text/html;charset=UTF-8");\n    PrintWriter pw = resp.getWriter();\n    pw.flush();\n    pw.close();\n}\n\n\n//页面转换形式： 重定向响应码 302\n@RequestMapping("resultVoid4")\npublic void resultVoid4(HttpServletResponse resp) {\n    System.out.println("resultVoid4");\n    resp.setStatus(302);\n    resp.setHeader("Location","/jsp/ok.jsp");\n}\n',normalizedContent:'# spring mvc请求接收\n\nspring mvc controller 接收请求参数的方式有很多种，有的适合 get 请求方式，有的适合 post 请求方式，有的两者都适合。主要有以下几种方式：\n\n * 通过 处理方法的形参接收请求参数\n * 通过 httpservletrequest 接收请求参数\n * 通过 @pathvariable 接收 url 中的请求参数\n * 通过 @requestparam 接收请求参数\n * 通过 @requestbody 接收请求参数\n * 获取 不同类型的对象 （日期、数组、集合、...）\n\n项目结构：（主要测试文件其余省略）\n\n  .\n  |\n  ├── com\n  │   ├── controller\n  |\t  |\t\t  └── usercontroller\n  │   ├── ov\n  |   |\t  └── queryvo\n  |   user\n  |   \n  └── webapp\n         └── jsp\n      \t\t  ├── parametertest.jsp\n      \t\t  └── ok.jsp\n\n\n> 说明：\n> \n>  * usercontroller类 添加了 @requestmapping 注解路径\n>    \n>    @controller\n>    @requestmapping("/user")\n>    public class usercontroller {···}\n>    \n> \n>  * user类 有 (int)id、(string)name、(int)age、(string)location 属性，分别有各自的 get和set方法 和 tostring方法\n\n\n# 逐个参数接收\n\n逐个传递参数\n\nparametertest.jsp\n\n<form action="/user/parametermethod" method="post">\n    <span>id：</span> <input type="text" name="id" > <br>\n    <span>name：</span> <input type="text" name="name" > <br>\n    <span>age：</span> <input type="text" name="age" > <br>\n    <span>location：</span> <input type="text" name="location" > <br>\n    <button type="submit">提交</button>\n</form>\n\n\nusercontroller类\n\n/**\n * 通过 方法逐个参数传递\n * 前提：前端属性名 与 实体类属性名 保持一致，否则获取不到\n */\n@requestmapping("parametermethod")\npublic modelandview parametermethod(int id, string name, int age, string location){\n    system.out.println("方法逐个参数传递===============");\n    system.out.println("id : " + id);\n    system.out.println("name : " + name);\n    system.out.println("age : " + age);\n    system.out.println("location : " + location);\n    modelandview mv = new modelandview();\n    mv.setviewname("jsp/ok");\n    return mv;\n}\n\n\n**对象传递参数 **\n\nparametertest.jsp\n\n<form action="/user/parametermethod2" method="post">\n    <span>id：</span> <input type="text" name="id" > <br>\n    <span>name：</span> <input type="text" name="name" > <br>\n    <span>age：</span> <input type="text" name="age" > <br>\n    <span>location：</span> <input type="text" name="location" > <br>\n    <button type="submit">提交</button>\n</form>\n\n\nusercontroller类\n\n/**\n * 通过 方法对象参数传递\n * 条件：传参要有对应的实体对象\n * 前提：前端属性名 与 实体类属性名 保持一致，否则获取不到\n */\n@requestmapping("parametermethod2")\npublic modelandview parametermethod2(user user){\n    system.out.println("方法对象参数传递===============");\n    system.out.println(user);\n    modelandview mv = new modelandview();\n    mv.setviewname("jsp/ok");\n    return mv;\n}\n\n\n\n# 原生servlet接收\n\nparametertest.jsp\n\n<form action="/user/parameterservletrequest" method="post">\n    <span>id：</span> <input type="text" name="id"> <br>\n    <span>name：</span> <input type="text" name="name"> <br>\n    <span>age：</span> <input type="text" name="age"> <br>\n    <span>location：</span> <input type="text" name="location"> <br>\n    <button type="submit">提交</button>\n</form>\n\n\nusercontroller类\n\n/**\n * 通过 httpservletrequest 进行参数传递\n */\n@requestmapping("parameterservletrequest")\npublic modelandview parameterservletrequest(httpservletrequest rs){\n    system.out.println("httpservletrequest对象传递===============");\n    system.out.println("id : " + rs.getparameter("id"));\n    system.out.println("name : " + rs.getparameter("name"));\n    system.out.println("age : " + rs.getparameter("age"));\n    system.out.println("location : " + rs.getparameter("location"));\n    modelandview mv = new modelandview();\n    mv.setviewname("jsp/ok");\n    return mv;\n}\n\n\n\n# @pathvariable 注解接收\n\n通过 @pathvariable注解 进行匹配参数逐个接收\n\n它的独特之处在于它能够通过 url的restful风格 传递参数，以下是应用实例\n\nusercontroller类\n\n/**\n * 通过 @pathvariable 接收 url中的请求参数\n * 地址应用：http://localhost:8088/user/parameterpathvariable/1003/zhu/23/jsp\n * 属性：\n *      string value：对应前端属性名\n *      boolean required（默认true）：参数是否必须，如果 获取前端数有丝毫问题就会报400异常（获取并非指定的参数值为null）\n */\n@requestmapping("parameterpathvariable/{id}/{name}/{age}/{location}")\npublic modelandview paraeterpathvariable(\n        @pathvariable(value = "id" , required = false) integer id,\n        @pathvariable(value = "name" , required = false) string name,\n        @pathvariable(value = "age" , required = false) integer age,\n        @pathvariable(value = "location" , required = false) string location){\n    system.out.println("通过 @pathvariable 接收 url中的请求参数===============");\n    system.out.println("id : " + id);\n    system.out.println("name : " + name);\n    system.out.println("age : " + age);\n    system.out.println("location : " + location);\n    modelandview mv = new modelandview();\n    mv.setviewname("jsp/ok");\n    return mv;\n}\n\n\n\n# @requestparam 接收\n\n通过 @requestparam注解 进行匹配参数逐个接收，和上面有些类似，但接收形式不一样！\n\n接收形式：\n\n 1. 不同请求头 form默认提交的请求头是 ==content-type: form-data、x-www-form-urlencoded== , 因此填充填充参数可以直接用 @requestparam注解 进行接收获取\n\n 2. url参数填充\n    \n    在已经固定请求头的类型且又想获取数据是 可以直接在url拼接获取如：\n    \n    http://localhost:8080/login?code=123 (传递 code)\n\nparametertest.jsp\n\n<form action="/user/parameterrequestparam" method="post">\n    <span>id：</span> <input type="text" name="userid" > <br>\n    <span>name：</span> <input type="text" name="username" > <br>\n    <span>age：</span> <input type="text" name="userage" > <br>\n    <span>location：</span> <input type="text" name="userlocation" > <br>\n    <button type="submit">提交</button>\n</form>\n\n\nusercontroller类\n\n/**\n * 通过 @requestparam 进行参数传递\n * 作用：矫正 前端属性名 与 方法参数名 不一致\n * 属性：\n *      string value：对应前端属性名\n *      boolean required（默认true）：参数是否必须，如果 获取前端数有丝毫问题就会报400异常（获取并非指定的参数值为null）\n */\n@requestmapping("parameterrequestparam")\npublic modelandview parameterrequestparam(\n        @requestparam("userid") int id,\n        @requestparam("username") string name,\n        @requestparam("userage") int age,\n        //制造参数名不匹配 （获取参数结果为null，并非400页面）\n        @requestparam(value = "userlocationabc", required = false) string location){\n    system.out.println("@requestparam 进行参数传递===============");\n    system.out.println("id : " + id);\n    system.out.println("name : " + name);\n    system.out.println("age : " + age);\n    system.out.println("location : " + location);\n    modelandview mv = new modelandview();\n    mv.setviewname("jsp/ok");\n    return mv;\n}\n\n\n\n# @requestbody 接收\n\n@requestbody注解 来处理content-type为 application/json, application/xml 数据，他们传递形式是已json形式进行的 , 后端接收的可直接封装成实体对象（前提key名称必须与 实体类的属性名一致！！！）\n\naxios.defaults.headers.post[\'content-type\'] = \'application/json;charset=utf-8\';\naxios.post("/user/login", {\n    username: this.username,\n    userpassword: this.userpassword,\n    code: this.code\n}).then(res => {...});\n\n@requestmapping("/login")\npublic void login(@requestbody user user) {\n    ...\n}\n\n\n> 请求和响应必须都使用 json形式进行传递数据\n\n\n# 获取 不同类型的对象\n\n\n# 日期\n\nuser类\n\npublic class user {\n    private int id;\n    private string name;\n    private int age;\n    private string location;\n    @datetimeformat(pattern = "yyyy-mm-dd")\n    private date createtime;\n    \n    ·····\n}\n\n\nparametertest.jsp\n\n<form action="/user/parameterdate" method="post">\n    <span>id：</span> <input type="text" name="id" > <br>\n    <span>name：</span> <input type="text" name="name" > <br>\n    <span>age：</span> <input type="text" name="age" > <br>\n    <span>location：</span> <input type="text" name="location" > <br>\n    <span>createtime：</span> <input type="text" name="createtime" > <br>\n    <button type="submit">提交</button>\n</form>\n\n\nusercontroller类\n\n/**\n * 日期\n * 通过 方法对象参数传递（包含日期类型）\n * 条件：实体对象的日期类型必须包含 @datetimeformat(pattern = "yyyy-mm-dd") 注解\n * 前提：传输格式符合：（"yyyy-mm-dd"）格式且是日期值范围内，否则报400\n */\n@requestmapping("parameterdate")\npublic modelandview parameterdate(user user){\n    system.out.println("传递日期类型===============");\n    system.out.println(user);\n    modelandview mv = new modelandview();\n    mv.setviewname("jsp/ok");\n    return mv;\n}\n\n\n\n# 数组\n\nparametertest.jsp\n\n<form action="/user/parameterarrays" method="post">\n    <span>name1：</span> <input type="text" name="names" > <br>\n    <span>name2：</span> <input type="text" name="names" > <br>\n    <span>name3：</span> <input type="text" name="names" > <br>\n    <button type="submit">提交</button>\n</form>\n\n\nusercontroller类\n\n/*\n* 数组\n* 传递数组对象\n* 获取方式：\n*       1.参数直接获取（变量名 与 前端的属性名一致）\n*       2. httpservletrequest原生对象获取\n* */\n@requestmapping("parameterarrays")\npublic modelandview parameterarrays(string[] names , httpservletrequest rs){\n    system.out.println("传递数组对象===============");\n    system.out.println("方式1：");\n    //方式1：（参数数组形式获取）\n    for (string n : names) {\n        system.out.println("\\t"+n);\n    }\n    system.out.println("==========");\n    system.out.println("方式2：");\n    //方式2：（原生对象获取）\n    string[] names2 = rs.getparametervalues("names");\n    for (string n : names2) {\n        system.out.println("\\t"+n);\n    }\n    \n    modelandview mv = new modelandview();\n    mv.setviewname("jsp/ok");\n    return mv;\n}\n\n\n\n# 集合\n\nparametertest.jsp\n\n<form action="/user/parameterset" method="post">\n    <span>name1：</span> <input type="text" name="names" > <br>\n    <span>name2：</span> <input type="text" name="names" > <br>\n    <span>name3：</span> <input type="text" name="names" > <br>\n    <button type="submit">提交</button>\n</form>\n\n\nusercontroller类\n\n/*\n* 集合\n* 前提：需要 @requestparam() 指定value 前端属性名 （属性类型不匹配较为特殊需自行配置）\n* */\n@requestmapping("parameterset")\npublic modelandview parameterset(@requestparam("names") list<string> namelist){\n    system.out.println("传递集合对象===============");\n    for (string name : namelist) {\n        system.out.println(name);\n    }\n    modelandview mv = new modelandview();\n    mv.setviewname("jsp/ok");\n    return mv;\n}\n\n\n\n# 对象集合\n\nqueryvo类\n\npackage com.vo;\nimport com.user;\nimport java.util.list;\n\npublic class queryvo {\n    private list<user> userlist;\n    \n    public list<user> getuserlist() {\n        return userlist;\n    }\n    \n    public void setuserlist(list<user> userlist) {\n        this.userlist = userlist;\n    }\n}\n\n\nparametertest.jsp\n\n<form action="/user/parameterobjectset" method="post">\n    <span>id1：</span> <input type="text" name="userlist[0].id" > <br>\n    <span>id2：</span> <input type="text" name="userlist[1].id" > <br>\n    <span>id3：</span> <input type="text" name="userlist[2].id" > <br>\n    <span>name1：</span> <input type="text" name="userlist[0].name" > <br>\n    <span>name2：</span> <input type="text" name="userlist[1].name" > <br>\n    <span>name3：</span> <input type="text" name="userlist[2].name" > <br>\n    <span>age1：</span> <input type="text" name="userlist[0].age" > <br>\n    <span>age2：</span> <input type="text" name="userlist[1].age" > <br>\n    <span>age3：</span> <input type="text" name="userlist[2].age" > <br>\n    <button type="submit">提交</button>\n</form>\n\n\nusercontroller类\n\n/*\n* 对象集合\n* 提前：\n*     2. queryvo类 中指定的 变量名 与 前端集合属性名 必须一致\n*     1. 对象集合中指定的 user实体类变量名（属性名）与 前端属性名 必须一致\n* */\n@requestmapping("parameterobjectset")\npublic modelandview parameterobjectset(queryvo vo){\n    system.out.println("传递对象集合===============");\n    for (user user : vo.getuserlist()) {\n        system.out.println(user);\n    }\n    modelandview mv = new modelandview();\n    mv.setviewname("jsp/ok");\n    return mv;\n}\n\n\n\n# 中文乱码解决\n\n在web.xml配置文件直接 过滤器 解决编码\n\n\x3c!--    字符编码过滤器--\x3e\n<filter>\n    \x3c!--指定封装好的过滤器类 和 指定名称--\x3e\n    <filter-name>characterencodingfilter</filter-name>\n    <filter-class>org.springframework.web.filter.characterencodingfilter</filter-class>\n    \x3c!--指定字符集--\x3e\n    <init-param>\n        <param-name>encoding</param-name>\n        <param-value>utf-8</param-value>\n    </init-param>\n    \x3c!--强制 request(请求) 使用 utf-8--\x3e\n    <init-param>\n        <param-name>forcerequestencoding</param-name>\n        <param-value>true</param-value>\n    </init-param>\n    \x3c!--强制 response(响应) 使用 utf-8--\x3e\n    <init-param>\n        <param-name>forceresponseencoding</param-name>\n        <param-value>true</param-value>\n    </init-param>\n</filter>\n\x3c!--对应映射名称 指定 url地址 进行过滤--\x3e\n<filter-mapping>\n    <filter-name>characterencodingfilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n\n\n\n# springmvc 响应返回参数\n\n使用@controller 注解的处理器的处理器方法，其返回值常用的有四种类型：\n\n>  * modelandview\n>  * string\n>  * 返回自定义类型对象\n>  * 无返回值 void\n\n项目结构说明：（主要测试文件其余省略）\n\n  .\n  |\n  ├── com\n  │   ├── controller\n  |\t  |\t\t  └── resultcontroller\n  |   user\n  |   \n  └── webapp\n         └── jsp\n      \t\t  └── resulttest.jsp\n\n\n> 说明：\n> \n>  * resultcontroller类 添加了 @requestmapping 注解路径\n>    \n>    @controller\n>    @requestmapping("/user")\n>    public class resultcontroller {···}\n>    \n> \n>  * user类 有 (int)id、(string)name、(int)age、(string)location 属性，分别有各自的 get和set方法 和 tostring方法\n\n\n# modelandview 响应\n\n如果是前后端不分的开发，大部分情况下，返回 modelandview，即数据模型+视图：（跳转才能传递数据）\n\nresulttest.jsp\n\n<h3>通过 modelandview 进行返回</h3>\n<div>\n    <span>id: ${id}</span> <br>\n    <span>name: ${name}</span> <br>\n    <span>age: ${age}</span> <br>\n    <span>location: ${location}</span> <br>\n</div>\n\n\nresultcontroller类\n\n/**\n *  通过 modelandview 形式跳转返回\n *  响应传参 需要 addobject()方法 进行\n */\n@requestmapping("resultmav")\npublic modelandview resultmav() {\n    modelandview mv = new modelandview();\n\n    //返回参数 (逐个传参)\n    mv.addobject("id","001");\n    mv.addobject("name","sanscan12");\n    mv.addobject("age","21");\n    mv.addobject("location","福州");\n    \n    //需要经过视图解析器转换物理路径\n    mv.setviewname("jsp/resulttest");\n    return mv;\n}\n\n\n\n# string 响应\n\nresulttest.jsp\n\n<h3>通过 string 进行返回</h3>\n<h4>requestscope 作用区域测试</h4>\n<div>\n    <span>id: ${requestscope.user.id}</span> <br>\n    <span>name: ${requestscope.user.name}</span> <br>\n    <span>age: ${requestscope.user.age}</span> <br>\n    <span>location: ${requestscope.user.location}</span> <br>\n</div>\n<h4>session 作用区域测试</h4>\n<div>\n    <span>id: ${sessionscope.user.id}</span> <br>\n    <span>name: ${sessionscope.user.name}</span> <br>\n    <span>age: ${sessionscope.user.age}</span> <br>\n    <span>location: ${sessionscope.user.location}</span> <br>\n</div>\n\n\nresultcontroller类\n\n/*\n* 通过 string 形式跳转返回\n* 响应传参 需要 httpservletrequest原生对象 进行\n* */\n@requestmapping("resultstring")\npublic string resultstring(httpservletrequest request){\n    //实例对象\n    user user = new user(002,"柏竹",21,"平南");\n    //携带参数进行传递\n    request.setattribute("user",user);\n    request.getsession().setattribute("user",user);\n    return "jsp/resulttest";\n}\n\n\n\n# 自定义类型对象 响应\n\n自定义对象类型常用的有：integer、double、list、map （返回并非逻辑视图名称，而是数据返回）\n\n以上数据类型一般搭配 ajax 请求使用，将 json格式 的数据直接响应返回\n\n> 应用前提&说明：\n> \n>  * 方法需要添加 @responsebody注解\n> \n>  * 引入依赖 maven项目引入\n>    \n>    <dependency>\n>    \t<groupid>com.fasterxml.jackson.core</groupid>\n>    \t<artifactid>jackson-core</artifactid>\n>    \t<version>2.9.0</version>\n>    </dependency>\n>    <dependency>\n>    \t<groupid>com.fasterxml.jackson.core</groupid>\n>    \t<artifactid>jackson-databind</artifactid>\n>    \t<version>2.9.0</version>\n>    </dependency>\n>    \n> \n>  * 数据的返回用 ajax进行响应呈现\n\n# integer 整型\n\nresulttest.jsp\n\n<h4>integer 整型</h4>\n<div id="integer"></div>\n<button id="integerajax">ajax请求</button>\n···\n\x3c!--ajax测试--\x3e\n$("#integerajax").click(function(){\n    $.ajax({\n        type:"post",\n        url: "resultinteger",\n        data: "",\n        success: function(msg){\n            $("#integer").html("值："+msg);\n        }\n    });\n});\n\n\nresultcontroller类\n\n/*\n* integer 整型\n* 搭配 ajax 请求使用，将 json格式 的数据直接响应返回\n* */\n@responsebody\n@requestmapping("resultinteger")\npublic integer resultinteger(){\n    return 2188;\n}\n\n\n# string 字符型\n\n同样是返回数据，因 @responsebody注解\n\nresulttest.jsp\n\n<h4>string 字符型</h4>\n<div id="string"></div>\n<button id="stringajax">ajax请求</button>\n···\n\x3c!--ajax测试--\x3e\n$("#stringajax").click(function(){\n    $.ajax({\n        type: "post",\n        url: "resultstring2",\n        data: "",\n        success: function(msg){\n            $("#string").html("值："+msg);\n        }\n    });\n});\n\n\nresultcontroller类\n\n/*\n* string 整型\n* 搭配 ajax 请求使用，将 json格式 的数据直接响应返回\n* */\n@responsebody\n@requestmapping("resultstring2")\npublic string resultstring(){\n    return "resultstring2";\n}\n\n\n# double 浮点型\n\nresulttest.jsp\n\n<h4>double 浮点型</h4>\n<div id="double"></div>\n<button id="doubleajax">ajax请求</button>\n···\n\x3c!--ajax测试--\x3e\n$("#doubleajax").click(function(){\n    $.ajax({\n        type: "post",\n        url: "resultdouble",\n        data: "",\n        success: function(msg){\n            $("#double").html("值："+msg);\n        }\n    });\n});\n\n\nresultcontroller类\n\n/*\n* double 浮点型\n* 搭配 ajax 请求使用，将 json格式 的数据直接响应返回\n* */\n@responsebody\n@requestmapping("resultdouble")\npublic double resultdouble(){\n    return 3.14;\n}\n\n\n# list 列表\n\nresulttest.jsp\n\n<h4>list 列表</h4>\n<div id="list"></div>\n<button id="listajax">ajax请求</button>\n···\n\x3c!--ajax测试--\x3e\n$("#listajax").click(function(){\n    $.ajax({\n        type: "post",\n        url: "resultlist",\n        data: "",\n        success: function(msg){\n            var str = "";\n            for (let i = 0; i < msg.length; i++) {\n                str= str+" "+i+"."+msg[i];\n            }\n            $("#list").html("值："+str);\n        }\n    });\n});\n\n\nresultcontroller类\n\n/*\n* list 列表\n* 搭配 ajax 请求使用，将 json格式 的数据直接响应返回\n* */\n@responsebody\n@requestmapping("resultlist")\npublic list resultlist(){\n    list list = new arraylist();\n    list.add("张三");\n    list.add("李四");\n    list.add("王五");\n    list.add("赵六");\n    return list;\n}\n\n\n# map 哈希表\n\nresulttest.jsp\n\n<h4>map 哈希表</h4>\n<div id="map"></div>\n<button id="mapajax">ajax请求</button>\n···\n\x3c!--ajax测试--\x3e\n$("#mapajax").click(function(){\n    $.ajax({\n        type: "post",\n        url: "resultmap",\n        data: "",\n        success: function(msg){\n            var str= "id: "+msg.id+\n                "，name: "+msg.name+\n                "，age: "+msg.age+\n                "，location: "+msg.location;\n            $("#map").html("值："+str);\n        }\n    });\n});\n\n\nresultcontroller类\n\n/*\n* map 哈希表\n* 搭配 ajax 请求使用，将 json格式 的数据直接响应返回\n* */\n@responsebody\n@requestmapping("resultmap")\npublic map resultmap(){\n    map map = new hashmap();\n    map.put("id","04");\n    map.put("name","李四");\n    map.put("age","23");\n    map.put("location","深圳");\n    return map;\n}\n\n\n# 对象\n\nresulttest.jsp\n\n<h4>user 对象</h4>\n<div id="user"></div>\n<button id="userajax">ajax请求</button>\n···\n\x3c!--ajax测试--\x3e\n$("#userajax").click(function(){\n    $.ajax({\n        type: "post",\n        url: "resultuser",\n        data: "",\n        success: function(msg){\n            var str= "id: "+msg.id+\n                "，name: "+msg.name+\n                "，age: "+msg.age+\n                "，location: "+msg.location;\n            $("#user").html("值："+str);\n        }\n    });\n});\n\n\nresultcontroller类\n\n/*\n* user 对象\n* 搭配 ajax 请求使用，将 json格式 的数据直接响应返回\n* */\n@responsebody\n@requestmapping("resultuser")\npublic user resultuser(){\n    return new user(002,"张三",23,"南宁");\n}\n\n\n整体结果：\n\n响应返回值\n通过 modelandview 进行返回\n\tid:\n\tname:\n\tage:\n\tlocation:\n通过 string 进行返回\nrequestscope 作用区域测试\n\tid: 2\n\tname: 柏竹\n\tage: 21\n\tlocation: 平南\nsession 作用区域测试\n\tid: 2\n\tname: 柏竹\n\tage: 21\n\tlocation: 平南\n返回自定义对象类型 进行返回\ninteger 整型\n\t值：2188\n\tajax请求\nstring 字符型\n\t值：resultstring2\n\tajax请求\ndouble 浮点型\n\t值：3.14\n\tajax请求\nlist 列表\n\t值： 0.张三 1.李四 2.王五 3.赵六\n\tajax请求\nmap 哈希表\n\t值：id: 04，name: 李四，age: 23，location: 深圳\n\tajax请求\nuser 对象\n\t值：id: 2，name: 张三，age: 23，location: 南宁\n\tajax请求\n\n\n\n# 无返回值 void 响应\n\n方法的返回值为 void，并不一定真的没有返回值，可以通过其他方式给前端返回。实际上，这种方 式也可以理解为 servlet 中的的处理方案。响应一般为：跳转、重定向\n\n//页面转换形式： 跳转\n@requestmapping("resultvoid1")\npublic void resultvoid1(httpservletrequest rs, httpservletresponse resp) throws servletexception, ioexception {\n    system.out.println("resultvoid1");\n    rs.getrequestdispatcher("/jsp/ok.jsp").forward(rs,resp);\n}\n\n\n//页面转换形式： 重定向\n@requestmapping("resultvoid2")\npublic void resultvoid2(httpservletrequest rs, httpservletresponse resp) throws ioexception {\n    system.out.println("resultvoid2");\n    resp.sendredirect("/jsp/ok.jsp");\n}\n\n\n//void类型 ajax应用\n@requestmapping("resultvoid3")\npublic void resultvoid3(httpservletresponse resp) throws ioexception {\n    system.out.println("resultvoid3");\n    resp.setcharacterencoding("utf-8");\n    resp.setcontenttype("text/html;charset=utf-8");\n    printwriter pw = resp.getwriter();\n    pw.flush();\n    pw.close();\n}\n\n\n//页面转换形式： 重定向响应码 302\n@requestmapping("resultvoid4")\npublic void resultvoid4(httpservletresponse resp) {\n    system.out.println("resultvoid4");\n    resp.setstatus(302);\n    resp.setheader("location","/jsp/ok.jsp");\n}\n',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"SpringMVC 异常",frontmatter:{title:"SpringMVC 异常",author:"柏竹",permalink:"/backend/2sohbn",date:"2020-02-18T00:00:00.000Z",categories:["后端"],tags:["SpringMVC","Java"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/08.SpringMVC/05.%E5%BC%82%E5%B8%B8.html",relativePath:"01.后端/08.SpringMVC/05.异常.md",key:"v-4f61d496",path:"/backend/2sohbn/",headers:[{level:2,title:"Java实现",slug:"java实现",normalizedTitle:"java实现",charIndex:148},{level:2,title:"注解实现",slug:"注解实现",normalizedTitle:"注解实现",charIndex:139}],headersStr:"Java实现 注解实现",content:'# SpringMVC 异常\n\n在该框架 开发过程中，难免都会有些可预知的异常，和不可预知的异常，但可以捕捉到它们，在捕捉这一过程，异常处理保证在出现问题的前提也不会终止程序！！\n\nSpringMVC 自定义异常实现方式有两种：\n\n * Java程序搭配Spring实现\n * 注解实现\n\n\n# Java实现\n\n实现步骤：\n\n 1. 创建 自定义异常类 ，并实现 HandlerExceptionResolver接口重写 resolveException()方法\n 2. 在 resolveException()方法 当中 可以当做一个请求进行处理，响应形式为 ModelAndView\n 3. 在 spring loc容器 配置中 添加 bean对象 即可\n\n\n# 注解实现\n\n通过 ==@ControllerAdvice/@ExceptionHandler== 实现\n\n实现步骤：\n\n 1. 创建 自定义异常类，在类中添加注解 @ControllerAdvice (控制器增强)\n 2. 在方法当中添加指定 类型的异常注解 @ExceptionHandler({异常类,...})\n 3. 在 spring loc容器 需要进行包扫描，否则无法创建对象\n\n实例实现：（项目结构）\n\n  .\n  |\n  ├── com\n  │   ├── controller\n  |\t  |\t\t  └── ExController\n  │   ├── exceptions\n  |\t  |\t  ├── GlobalExceptionHandler\n  |   |\t  ├── UserException\n  |   |   ├── UserIdException\n  |   |   └── UserNameException\n  |   User\n  |   \n  └── webapp\n         └── jsp\n      \t\t  ├── error.jsp\n      \t\t  ├── idError.jsp\n      \t\t  ├── nameError.jsp\n      \t\t  └── ok.jsp\n\n\n创建自定义异常\n\nUserException 类 自定义异常\n\npackage com.exceptions;\n\n/**\n * 自定义异常\n */\npublic class UserException extends Exception{\n    \n    public UserException() {\n    }\n    public UserException(String message) {\n        super(message);\n    }\n    \n}\n\n\nUserIdException类 自定义异常\n\npackage com.exceptions;\n\npublic class UserIdException extends UserException{\n    public UserIdException() {\n    }\n    \n    public UserIdException(String message) {\n        super(message);\n    }\n}\n\n\nUserNameException类 自定义异常\n\npackage com.exceptions;\n\npublic class UserNameException extends UserException {\n    public UserNameException() {\n    }\n    \n    public UserNameException(String message) {\n        super(message);\n    }\n}\n\n\nExController类 异常处理器\n\npackage com.controller;\n\nimport com.exceptions.UserException;\nimport com.exceptions.UserIdException;\nimport com.exceptions.UserNameException;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.servlet.ModelAndView;\n\n@Controller\n@RequestMapping("/ex")\npublic class ExController extends UserException {\n    \n    @RequestMapping("exReceive/{id}/{name}")\n    public ModelAndView test01(\n            @PathVariable("id") int user_id,\n            @PathVariable("name") String user_name) throws UserIdException, UserNameException {\n        ModelAndView mv = new ModelAndView();\n        if (user_id<1000){\n            throw new UserIdException("id不合法，id不能少于1000");\n        }\n        if ("test".equals(user_name)){\n            throw new UserNameException("name不合法，不能使用“test”");\n        }\n        //System.out.println(10/0);\n        //正常返回 ok\n        mv.setViewName("jsp/ok");\n        return mv;\n    }\n        \n    // 异常处理 异常处理方法1\n    ///**\n    // * 异常处理 (异常处理方法1)\n    // * 注解参数：添加指定 异常类\n    // * @param ex 产生异常的对象\n    // * @return 指定响应结果\n    // */\n    //@ExceptionHandler(value = {UserIdException.class, UserNameException.class, Exception.class})\n    //public ModelAndView exHandler(Exception ex) {\n    //    ModelAndView mv = new ModelAndView();\n    //    //添加异常信息（响应给前台的）\n    //    mv.addObject("exceptionMsg",ex.getMessage());\n    //    \n    //    //判断 异常对象 是否为 该对象的父类（实现类）\n    //    if (ex instanceof UserIdException){\n    //        mv.setViewName("jsp/idError");\n    //    }else{\n    //        if (ex instanceof UserNameException) {\n    //            mv.setViewName("jsp/nameError");\n    //        }else{\n    //            mv.setViewName("jsp/error");\n    //        }\n    //    }\n    //    return mv;\n    //}\n    //\n}\n\n\nGlobalExceptionHandler类 全局异常处理类 (异常处理方法2)\n\n一般将异常处理方法专门定义在一个类中，作为全局的异常处理类\n\n>  * 使用注解@ControllerAdvice，就是“控制器增强”，是给控制器对象增强功能的。使用 @ControllerAdvice 修饰的类中可以使用@ExceptionHandler\n>  * 当使用@RequestMapping 注解修饰的方法抛出异常时，会执行@ControllerAdvice 修饰的类中的异常 处理方法\n>  * @ControllerAdvice 注解所在的类需要进行包扫描，否则无法创建对象\n> \n> <context:component-scan base-package="com.exceptions"/>\n\npackage com.exceptions;\n\nimport org.springframework.web.bind.annotation.ControllerAdvice;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.servlet.ModelAndView;\n\n/**\n * 自定义 全局异常处理类\n * 在触发对应类的异常为前提 参会触发异常处理！！！\n * @author Sans\n */\n@ControllerAdvice\npublic class GlobalExceptionHandler {\n    \n    @ExceptionHandler (UserIdException.class)\n    public ModelAndView exceptionUserId(Exception ex) {\n        ModelAndView mv = new ModelAndView();\n        mv.addObject("msg",ex.getMessage());\n        mv.setViewName("jsp/idError");\n        return mv;\n    }\n    \n    @ExceptionHandler (UserNameException.class)\n    public ModelAndView exceptionUserUserName(Exception ex) {\n        ModelAndView mv = new ModelAndView();\n        mv.addObject("msg",ex.getMessage());\n        mv.setViewName("jsp/nameError");\n        return mv;\n    }\n    \n    @ExceptionHandler (Exception.class)\n    public ModelAndView exception(Exception ex) {\n        ModelAndView mv = new ModelAndView();\n        mv.addObject("msg",ex.getMessage());\n        mv.setViewName("jsp/error");\n        return mv;\n    }\n    \n}\n\n\nJSP页面\n\nerror.jsp\n\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n    <h1>error------${exceptionMsg}</h1>\n</body>\n</html>\n\n\nidError.jsp\n\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>id error</title>\n</head>\n<body>\n    <h1>id error------${exceptionMsg}</h1>\n</body>\n</html>\n\n\nnameError.jsp\n\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>name Error</title>\n</head>\n<body>\n    <h1>name Error------${exceptionMsg}</h1>\n</body>\n</html>\n\n\nok.jsp\n\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n    <title>Title</title>\n</head>\n<body>\n    <h1>OK============</h1>\n</body>\n</html>\n\n\n> 异常测试：\n> \n> id异常：http://localhost:8088/ex/exReceive/100/Sanscan12\n> \n> name异常：http://localhost:8088/ex/exReceive/1002/test\n> \n> Error异常：（控制器中制造异常）',normalizedContent:'# springmvc 异常\n\n在该框架 开发过程中，难免都会有些可预知的异常，和不可预知的异常，但可以捕捉到它们，在捕捉这一过程，异常处理保证在出现问题的前提也不会终止程序！！\n\nspringmvc 自定义异常实现方式有两种：\n\n * java程序搭配spring实现\n * 注解实现\n\n\n# java实现\n\n实现步骤：\n\n 1. 创建 自定义异常类 ，并实现 handlerexceptionresolver接口重写 resolveexception()方法\n 2. 在 resolveexception()方法 当中 可以当做一个请求进行处理，响应形式为 modelandview\n 3. 在 spring loc容器 配置中 添加 bean对象 即可\n\n\n# 注解实现\n\n通过 ==@controlleradvice/@exceptionhandler== 实现\n\n实现步骤：\n\n 1. 创建 自定义异常类，在类中添加注解 @controlleradvice (控制器增强)\n 2. 在方法当中添加指定 类型的异常注解 @exceptionhandler({异常类,...})\n 3. 在 spring loc容器 需要进行包扫描，否则无法创建对象\n\n实例实现：（项目结构）\n\n  .\n  |\n  ├── com\n  │   ├── controller\n  |\t  |\t\t  └── excontroller\n  │   ├── exceptions\n  |\t  |\t  ├── globalexceptionhandler\n  |   |\t  ├── userexception\n  |   |   ├── useridexception\n  |   |   └── usernameexception\n  |   user\n  |   \n  └── webapp\n         └── jsp\n      \t\t  ├── error.jsp\n      \t\t  ├── iderror.jsp\n      \t\t  ├── nameerror.jsp\n      \t\t  └── ok.jsp\n\n\n创建自定义异常\n\nuserexception 类 自定义异常\n\npackage com.exceptions;\n\n/**\n * 自定义异常\n */\npublic class userexception extends exception{\n    \n    public userexception() {\n    }\n    public userexception(string message) {\n        super(message);\n    }\n    \n}\n\n\nuseridexception类 自定义异常\n\npackage com.exceptions;\n\npublic class useridexception extends userexception{\n    public useridexception() {\n    }\n    \n    public useridexception(string message) {\n        super(message);\n    }\n}\n\n\nusernameexception类 自定义异常\n\npackage com.exceptions;\n\npublic class usernameexception extends userexception {\n    public usernameexception() {\n    }\n    \n    public usernameexception(string message) {\n        super(message);\n    }\n}\n\n\nexcontroller类 异常处理器\n\npackage com.controller;\n\nimport com.exceptions.userexception;\nimport com.exceptions.useridexception;\nimport com.exceptions.usernameexception;\nimport org.springframework.stereotype.controller;\nimport org.springframework.web.bind.annotation.exceptionhandler;\nimport org.springframework.web.bind.annotation.pathvariable;\nimport org.springframework.web.bind.annotation.requestmapping;\nimport org.springframework.web.servlet.modelandview;\n\n@controller\n@requestmapping("/ex")\npublic class excontroller extends userexception {\n    \n    @requestmapping("exreceive/{id}/{name}")\n    public modelandview test01(\n            @pathvariable("id") int user_id,\n            @pathvariable("name") string user_name) throws useridexception, usernameexception {\n        modelandview mv = new modelandview();\n        if (user_id<1000){\n            throw new useridexception("id不合法，id不能少于1000");\n        }\n        if ("test".equals(user_name)){\n            throw new usernameexception("name不合法，不能使用“test”");\n        }\n        //system.out.println(10/0);\n        //正常返回 ok\n        mv.setviewname("jsp/ok");\n        return mv;\n    }\n        \n    // 异常处理 异常处理方法1\n    ///**\n    // * 异常处理 (异常处理方法1)\n    // * 注解参数：添加指定 异常类\n    // * @param ex 产生异常的对象\n    // * @return 指定响应结果\n    // */\n    //@exceptionhandler(value = {useridexception.class, usernameexception.class, exception.class})\n    //public modelandview exhandler(exception ex) {\n    //    modelandview mv = new modelandview();\n    //    //添加异常信息（响应给前台的）\n    //    mv.addobject("exceptionmsg",ex.getmessage());\n    //    \n    //    //判断 异常对象 是否为 该对象的父类（实现类）\n    //    if (ex instanceof useridexception){\n    //        mv.setviewname("jsp/iderror");\n    //    }else{\n    //        if (ex instanceof usernameexception) {\n    //            mv.setviewname("jsp/nameerror");\n    //        }else{\n    //            mv.setviewname("jsp/error");\n    //        }\n    //    }\n    //    return mv;\n    //}\n    //\n}\n\n\nglobalexceptionhandler类 全局异常处理类 (异常处理方法2)\n\n一般将异常处理方法专门定义在一个类中，作为全局的异常处理类\n\n>  * 使用注解@controlleradvice，就是“控制器增强”，是给控制器对象增强功能的。使用 @controlleradvice 修饰的类中可以使用@exceptionhandler\n>  * 当使用@requestmapping 注解修饰的方法抛出异常时，会执行@controlleradvice 修饰的类中的异常 处理方法\n>  * @controlleradvice 注解所在的类需要进行包扫描，否则无法创建对象\n> \n> <context:component-scan base-package="com.exceptions"/>\n\npackage com.exceptions;\n\nimport org.springframework.web.bind.annotation.controlleradvice;\nimport org.springframework.web.bind.annotation.exceptionhandler;\nimport org.springframework.web.servlet.modelandview;\n\n/**\n * 自定义 全局异常处理类\n * 在触发对应类的异常为前提 参会触发异常处理！！！\n * @author sans\n */\n@controlleradvice\npublic class globalexceptionhandler {\n    \n    @exceptionhandler (useridexception.class)\n    public modelandview exceptionuserid(exception ex) {\n        modelandview mv = new modelandview();\n        mv.addobject("msg",ex.getmessage());\n        mv.setviewname("jsp/iderror");\n        return mv;\n    }\n    \n    @exceptionhandler (usernameexception.class)\n    public modelandview exceptionuserusername(exception ex) {\n        modelandview mv = new modelandview();\n        mv.addobject("msg",ex.getmessage());\n        mv.setviewname("jsp/nameerror");\n        return mv;\n    }\n    \n    @exceptionhandler (exception.class)\n    public modelandview exception(exception ex) {\n        modelandview mv = new modelandview();\n        mv.addobject("msg",ex.getmessage());\n        mv.setviewname("jsp/error");\n        return mv;\n    }\n    \n}\n\n\njsp页面\n\nerror.jsp\n\n<%@ page contenttype="text/html;charset=utf-8" language="java" %>\n<html>\n<head>\n    <title>title</title>\n</head>\n<body>\n    <h1>error------${exceptionmsg}</h1>\n</body>\n</html>\n\n\niderror.jsp\n\n<%@ page contenttype="text/html;charset=utf-8" language="java" %>\n<html>\n<head>\n    <title>id error</title>\n</head>\n<body>\n    <h1>id error------${exceptionmsg}</h1>\n</body>\n</html>\n\n\nnameerror.jsp\n\n<%@ page contenttype="text/html;charset=utf-8" language="java" %>\n<html>\n<head>\n    <title>name error</title>\n</head>\n<body>\n    <h1>name error------${exceptionmsg}</h1>\n</body>\n</html>\n\n\nok.jsp\n\n<%@ page contenttype="text/html;charset=utf-8" language="java" %>\n<html>\n<head>\n    <title>title</title>\n</head>\n<body>\n    <h1>ok============</h1>\n</body>\n</html>\n\n\n> 异常测试：\n> \n> id异常：http://localhost:8088/ex/exreceive/100/sanscan12\n> \n> name异常：http://localhost:8088/ex/exreceive/1002/test\n> \n> error异常：（控制器中制造异常）',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"SpringMVC 上传&下载",frontmatter:{title:"SpringMVC 上传&下载",author:"柏竹",permalink:"/backend/i3cqqj",date:"2020-02-18T00:00:00.000Z",categories:["后端"],tags:["SpringMVC","Java"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/08.SpringMVC/07.%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD.html",relativePath:"01.后端/08.SpringMVC/07.上传下载.md",key:"v-02f39703",path:"/backend/i3cqqj/",headers:[{level:2,title:"上传",slug:"上传",normalizedTitle:"上传",charIndex:12},{level:3,title:"文件上传",slug:"文件上传",normalizedTitle:"文件上传",charIndex:38},{level:3,title:"优化上传",slug:"优化上传",normalizedTitle:"优化上传",charIndex:2780},{level:2,title:"下载",slug:"下载",normalizedTitle:"下载",charIndex:15}],headersStr:"上传 文件上传 优化上传 下载",content:'# SpringMVC 上传&下载\n\n\n# 上传\n\nSpringMVC框架 文件上传是基于 commons-fileupload组件 ，并且对该组件 进一步的封装。文件上传提供支持可直接 用 MultpartResolver接口 。该接口用于处理上传请求，请求包装成 可直接获取文件的数据！！\n\nMultpartResolver接口方法：\n\npublic interface MultipartFile extends InputStreamSource {\n\t\n    // 返回请求参数的名称\n\tString getName();\n\n    // 返回客户端提交的原始文件名称\n\t@Nullable\n\tString getOriginalFilename();\n\t\n    // 返回文件内容类型\n\t@Nullable\n\tString getContentType();\n\t\n    // 判断被上传文件是否为空\n\tboolean isEmpty();\n\n    // 文件大小 ；单位字节\n\tlong getSize();\n    \n\t// 以字节数组形式返回文件的内容\n\tbyte[] getBytes() throws IOException;\n\t\n    // 读取文件的内容\n\t@Override\n\tInputStream getInputStream() throws IOException;\n\n\tdefault Resource getResource() {\n\t\treturn new MultipartFileResource(this);\n\t}\n    \n\t// 将上传文件保存都目标目录下\n\tvoid transferTo(File dest) throws IOException, IllegalStateException;\n\n\tdefault void transferTo(Path dest) throws IOException, IllegalStateException {\n\t\tFileCopyUtils.copy(getInputStream(), Files.newOutputStream(dest));\n\t}\n\n}\n\n\n上传组件&构架\n\n项目结构（主要部分）\n\n  .\n  |\n  ├── com\n  │    ├── controller\n  |\t   |\t  └── FileController\n  │    ├── interceptor\n  |\t   |\t  └── Fileinterceptor\n  |   User\n  |   \n  └── webapp\n         └── jsp \n         \t  ├── fileHandle.jsp\n      \t\t  └── ok.jsp\n\n\n依赖导入\n\n<dependency>\n\t<groupId>commons-fileupload</groupId>\n\t<artifactId>commons-fileupload</artifactId>\n\t<version>1.3.1</version>\n</dependency>\n\n\n\n# 文件上传\n\nspringmvc.xml 文件配置 MultipartResolver\n\n<bean id="multipartResolver"\nclass="org.springframework.web.multipart.commons.CommonsMultipartResolver">\n</bean>\n\n\nfileHandle.jsp页面表单（上传表单编码类型必须multipart/form-data）\n\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<html>\n<head>\n\t<title>文件操作</title>\n</head>\n<body>\n\t<form action="/file/upload" method="post" \tenctype="multipart/form-data">\n\t请选择文件：<input type="file" name="myFile" /><br/>\n\t<button type="submit">上传文件</button>\n\t</form>\n</body>\n</html>\n\x3c!--\n表单 enctype属性 说明: 表单数据的编码方式\n - application/x-www-form-urlencoded：这是默认的编码方式，它只处理表单域里的 value 属性值\n - multipart/form-data：该编码方式以二进制流的方式来处理表单数据，并将文件域指定文件的内容封装到请求参数里\n - text/plain：该编码方式只有当表单的 action 属性为“mailto：”URL 的形式时才使用，主要适用于直接通过表单发送邮件的方式\n--\x3e\n\n\nFileController类 控制器类\n\n/**\n *  单个文件上传\n */\n@RequestMapping("upload")\npublic String upload(@RequestParam("myFile") MultipartFile file, HttpServletRequest request) throws IOException {\n    //文件路径及文件名称\n    String realPath = request.getServletContext().getRealPath("uploadfiles");\n    // 文件原始名称\n    String fileName = file.getOriginalFilename();\n    System.out.println("fileName : " + fileName);\n    System.out.println("realPath : " + realPath);\n    File targetFile = new File(realPath,fileName);\n    if (!targetFile.exists()) {\n        targetFile.mkdirs();\n    }\n    //真正上传到服务器指定的名称\n    file.transferTo(targetFile);\n    System.out.println("上传成功："+realPath+fileName);\n    return "jsp/ok";\n}\n\n\n\n# 优化上传\n\nFileController类 控制器类\n\n意图：实际开发中，一般都要将文件重新命名存储（避免相同名称）\n\n/**\n * 上传文件\n * @param file 请求中接收的上传文件\n * @return 跳转页\n */\n@RequestMapping("upload")\npublic String upload(@RequestParam("myFile") MultipartFile file, HttpServletRequest request) throws IOException {\n    //获取文件原始名称 (包含后缀）\n    String originalFilename = file.getOriginalFilename();\n    //randomUUID()生成随机数;replace()替换指定字符\n    //存储服务器的名称 = 随机字符串 + 原文件后缀\n    String fileName = UUID.randomUUID().toString().replace("-","") + originalFilename.substring(originalFilename.lastIndexOf("."));\n    \n    //存储路径\n    String realPath = request.getServletContext().getRealPath("/uploadFile")+"\\\\";\n    \n    //存储路径 路径 + 文件名称\n    file.transferTo(new File(realPath+fileName));\n    System.out.println("上传成功："+realPath+fileName);\n    return "jsp/ok";\n}\n\n\nspringmvc.xml配置文件\n\n意图：限制文件的大小\n\n\x3c!--    上传文件--\x3e\n<bean id="multipartResolver"\n      class="org.springframework.web.multipart.commons.CommonsMultipartResolver">\n    \x3c!--限制文件大小（单位：字节）1024*1024*5 KB : 5MB = --\x3e\n    <property name="maxUploadSize" value="5242880"/>\n    <property name="defaultEncoding" value="utf-8"/>\n</bean>\n\n\nFileinterceptor拦截器类\n\n意图：限制文件后缀形式\n\n应用前提需配置拦截器 springmvc.xml\n\n<mvc:interceptors>\n    ····\n    \x3c!--指定干活的拦截器(判断上传文件类型)--\x3e\n    <mvc:interceptor>\n        <mvc:mapping path="/**"/>\n        <bean class="com.interceptor.Fileinterceptor" id="fileinterceptor"></bean>\n    </mvc:interceptor>\n\n</mvc:interceptors>\n\n\npublic class Fileinterceptor implements HandlerInterceptor {\n    \n    /**\n     * 在文件上传之前判定文件是否合法\n     * @param request\n     * @param response\n     * @param handler\n     * @return 是否允许请求通行\n     * @throws Exception\n     */\n    @Override\n    public boolean preHandle(HttpServletRequest request , HttpServletResponse response , Object handler) throws Exception {\n        boolean flag = true;\n        \n        if (request instanceof MultipartHttpServletRequest) {\n            MultipartHttpServletRequest multipartHttpServletRequest = (MultipartHttpServletRequest) request;\n            //获取请求返回的 多个文件\n            Map<String, MultipartFile> fileMap = multipartHttpServletRequest.getFileMap();\n            //遍历文件\n            Iterator<String> iterator = fileMap.keySet().iterator();\n            while(iterator.hasNext()){\n                String key = iterator.next();\n                MultipartFile file = multipartHttpServletRequest.getFile(key);\n                //查看 原始文件名\n                String originalFilename = file.getOriginalFilename();\n                String substring = originalFilename.substring(originalFilename.lastIndexOf("."));\n                //判断后缀许可\n                if (!substring.equalsIgnoreCase(".png") && !substring.equalsIgnoreCase(".jpg")) {\n                    //不符合条件的\n                    request.getRequestDispatcher("/jsp/fileTypeError.jsp").forward(request,response);\n                    flag = false;\n                }\n            }\n        }\n        return flag;\n    }\n}\n\n\n\n# 下载\n\n前端下载请求\n\n<form action="/file/download" method="post" enctype="multipart/form-data">\n    <button type="submit">下载</button>\n</form>\n\n\nFileController类 控制器类\n\n/**\n * 下载文件\n * @return 字节形式传输\n */\n@RequestMapping("download")\npublic ResponseEntity<byte[]> download(HttpServletRequest request) throws IOException {\n    //指定文件名\n    String fileName = "5593fe61c683494a91849c0346b2b528.jpg";\n    //指定 文件名及文件路径（下载文件的路径）\n    String path = request.getServletContext().getRealPath("/uploadFile")+"/"+fileName;\n    //创建响应 的头信息对象\n    HttpHeaders httpHeaders = new HttpHeaders();\n    //标记的流方式作出响应\n    httpHeaders.setContentType(MediaType.APPLICATION_OCTET_STREAM);\n    //以附件形式响应给用户\n    httpHeaders.setContentDispositionFormData("attachment", URLEncoder.encode(fileName,"utf-8"));\n    File file = new File(path);\n    ResponseEntity<byte[]> resp = new ResponseEntity<>(FileUtils.readFileToByteArray(file),httpHeaders, HttpStatus.CREATED);\n    return resp;\n}\n',normalizedContent:'# springmvc 上传&下载\n\n\n# 上传\n\nspringmvc框架 文件上传是基于 commons-fileupload组件 ，并且对该组件 进一步的封装。文件上传提供支持可直接 用 multpartresolver接口 。该接口用于处理上传请求，请求包装成 可直接获取文件的数据！！\n\nmultpartresolver接口方法：\n\npublic interface multipartfile extends inputstreamsource {\n\t\n    // 返回请求参数的名称\n\tstring getname();\n\n    // 返回客户端提交的原始文件名称\n\t@nullable\n\tstring getoriginalfilename();\n\t\n    // 返回文件内容类型\n\t@nullable\n\tstring getcontenttype();\n\t\n    // 判断被上传文件是否为空\n\tboolean isempty();\n\n    // 文件大小 ；单位字节\n\tlong getsize();\n    \n\t// 以字节数组形式返回文件的内容\n\tbyte[] getbytes() throws ioexception;\n\t\n    // 读取文件的内容\n\t@override\n\tinputstream getinputstream() throws ioexception;\n\n\tdefault resource getresource() {\n\t\treturn new multipartfileresource(this);\n\t}\n    \n\t// 将上传文件保存都目标目录下\n\tvoid transferto(file dest) throws ioexception, illegalstateexception;\n\n\tdefault void transferto(path dest) throws ioexception, illegalstateexception {\n\t\tfilecopyutils.copy(getinputstream(), files.newoutputstream(dest));\n\t}\n\n}\n\n\n上传组件&构架\n\n项目结构（主要部分）\n\n  .\n  |\n  ├── com\n  │    ├── controller\n  |\t   |\t  └── filecontroller\n  │    ├── interceptor\n  |\t   |\t  └── fileinterceptor\n  |   user\n  |   \n  └── webapp\n         └── jsp \n         \t  ├── filehandle.jsp\n      \t\t  └── ok.jsp\n\n\n依赖导入\n\n<dependency>\n\t<groupid>commons-fileupload</groupid>\n\t<artifactid>commons-fileupload</artifactid>\n\t<version>1.3.1</version>\n</dependency>\n\n\n\n# 文件上传\n\nspringmvc.xml 文件配置 multipartresolver\n\n<bean id="multipartresolver"\nclass="org.springframework.web.multipart.commons.commonsmultipartresolver">\n</bean>\n\n\nfilehandle.jsp页面表单（上传表单编码类型必须multipart/form-data）\n\n<%@ page contenttype="text/html;charset=utf-8" language="java" %>\n<html>\n<head>\n\t<title>文件操作</title>\n</head>\n<body>\n\t<form action="/file/upload" method="post" \tenctype="multipart/form-data">\n\t请选择文件：<input type="file" name="myfile" /><br/>\n\t<button type="submit">上传文件</button>\n\t</form>\n</body>\n</html>\n\x3c!--\n表单 enctype属性 说明: 表单数据的编码方式\n - application/x-www-form-urlencoded：这是默认的编码方式，它只处理表单域里的 value 属性值\n - multipart/form-data：该编码方式以二进制流的方式来处理表单数据，并将文件域指定文件的内容封装到请求参数里\n - text/plain：该编码方式只有当表单的 action 属性为“mailto：”url 的形式时才使用，主要适用于直接通过表单发送邮件的方式\n--\x3e\n\n\nfilecontroller类 控制器类\n\n/**\n *  单个文件上传\n */\n@requestmapping("upload")\npublic string upload(@requestparam("myfile") multipartfile file, httpservletrequest request) throws ioexception {\n    //文件路径及文件名称\n    string realpath = request.getservletcontext().getrealpath("uploadfiles");\n    // 文件原始名称\n    string filename = file.getoriginalfilename();\n    system.out.println("filename : " + filename);\n    system.out.println("realpath : " + realpath);\n    file targetfile = new file(realpath,filename);\n    if (!targetfile.exists()) {\n        targetfile.mkdirs();\n    }\n    //真正上传到服务器指定的名称\n    file.transferto(targetfile);\n    system.out.println("上传成功："+realpath+filename);\n    return "jsp/ok";\n}\n\n\n\n# 优化上传\n\nfilecontroller类 控制器类\n\n意图：实际开发中，一般都要将文件重新命名存储（避免相同名称）\n\n/**\n * 上传文件\n * @param file 请求中接收的上传文件\n * @return 跳转页\n */\n@requestmapping("upload")\npublic string upload(@requestparam("myfile") multipartfile file, httpservletrequest request) throws ioexception {\n    //获取文件原始名称 (包含后缀）\n    string originalfilename = file.getoriginalfilename();\n    //randomuuid()生成随机数;replace()替换指定字符\n    //存储服务器的名称 = 随机字符串 + 原文件后缀\n    string filename = uuid.randomuuid().tostring().replace("-","") + originalfilename.substring(originalfilename.lastindexof("."));\n    \n    //存储路径\n    string realpath = request.getservletcontext().getrealpath("/uploadfile")+"\\\\";\n    \n    //存储路径 路径 + 文件名称\n    file.transferto(new file(realpath+filename));\n    system.out.println("上传成功："+realpath+filename);\n    return "jsp/ok";\n}\n\n\nspringmvc.xml配置文件\n\n意图：限制文件的大小\n\n\x3c!--    上传文件--\x3e\n<bean id="multipartresolver"\n      class="org.springframework.web.multipart.commons.commonsmultipartresolver">\n    \x3c!--限制文件大小（单位：字节）1024*1024*5 kb : 5mb = --\x3e\n    <property name="maxuploadsize" value="5242880"/>\n    <property name="defaultencoding" value="utf-8"/>\n</bean>\n\n\nfileinterceptor拦截器类\n\n意图：限制文件后缀形式\n\n应用前提需配置拦截器 springmvc.xml\n\n<mvc:interceptors>\n    ····\n    \x3c!--指定干活的拦截器(判断上传文件类型)--\x3e\n    <mvc:interceptor>\n        <mvc:mapping path="/**"/>\n        <bean class="com.interceptor.fileinterceptor" id="fileinterceptor"></bean>\n    </mvc:interceptor>\n\n</mvc:interceptors>\n\n\npublic class fileinterceptor implements handlerinterceptor {\n    \n    /**\n     * 在文件上传之前判定文件是否合法\n     * @param request\n     * @param response\n     * @param handler\n     * @return 是否允许请求通行\n     * @throws exception\n     */\n    @override\n    public boolean prehandle(httpservletrequest request , httpservletresponse response , object handler) throws exception {\n        boolean flag = true;\n        \n        if (request instanceof multiparthttpservletrequest) {\n            multiparthttpservletrequest multiparthttpservletrequest = (multiparthttpservletrequest) request;\n            //获取请求返回的 多个文件\n            map<string, multipartfile> filemap = multiparthttpservletrequest.getfilemap();\n            //遍历文件\n            iterator<string> iterator = filemap.keyset().iterator();\n            while(iterator.hasnext()){\n                string key = iterator.next();\n                multipartfile file = multiparthttpservletrequest.getfile(key);\n                //查看 原始文件名\n                string originalfilename = file.getoriginalfilename();\n                string substring = originalfilename.substring(originalfilename.lastindexof("."));\n                //判断后缀许可\n                if (!substring.equalsignorecase(".png") && !substring.equalsignorecase(".jpg")) {\n                    //不符合条件的\n                    request.getrequestdispatcher("/jsp/filetypeerror.jsp").forward(request,response);\n                    flag = false;\n                }\n            }\n        }\n        return flag;\n    }\n}\n\n\n\n# 下载\n\n前端下载请求\n\n<form action="/file/download" method="post" enctype="multipart/form-data">\n    <button type="submit">下载</button>\n</form>\n\n\nfilecontroller类 控制器类\n\n/**\n * 下载文件\n * @return 字节形式传输\n */\n@requestmapping("download")\npublic responseentity<byte[]> download(httpservletrequest request) throws ioexception {\n    //指定文件名\n    string filename = "5593fe61c683494a91849c0346b2b528.jpg";\n    //指定 文件名及文件路径（下载文件的路径）\n    string path = request.getservletcontext().getrealpath("/uploadfile")+"/"+filename;\n    //创建响应 的头信息对象\n    httpheaders httpheaders = new httpheaders();\n    //标记的流方式作出响应\n    httpheaders.setcontenttype(mediatype.application_octet_stream);\n    //以附件形式响应给用户\n    httpheaders.setcontentdispositionformdata("attachment", urlencoder.encode(filename,"utf-8"));\n    file file = new file(path);\n    responseentity<byte[]> resp = new responseentity<>(fileutils.readfiletobytearray(file),httpheaders, httpstatus.created);\n    return resp;\n}\n',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"SpringMVC RESTful API",frontmatter:{title:"SpringMVC RESTful API",author:"柏竹",permalink:"/backend/ggmgk1",date:"2020-02-18T00:00:00.000Z",categories:["后端"],tags:["SpringMVC","Java"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/08.SpringMVC/08.RESTful%E9%A3%8E%E6%A0%BC.html",relativePath:"01.后端/08.SpringMVC/08.RESTful风格.md",key:"v-5854de66",path:"/backend/ggmgk1/",headers:[{level:2,title:"REST特性",slug:"rest特性",normalizedTitle:"rest特性",charIndex:123},{level:2,title:"HTTP Method",slug:"http-method",normalizedTitle:"http method",charIndex:322},{level:2,title:"HTTP 状态码",slug:"http-状态码",normalizedTitle:"http 状态码",charIndex:6517},{level:2,title:"Swagger 规范API",slug:"swagger-规范api",normalizedTitle:"swagger 规范api",charIndex:6736},{level:2,title:"REST Q&A",slug:"rest-q-a",normalizedTitle:"rest q&amp;a",charIndex:null},{level:3,title:"避免多级URL",slug:"避免多级url",normalizedTitle:"避免多级url",charIndex:8845},{level:3,title:"传参问题",slug:"传参问题",normalizedTitle:"传参问题",charIndex:8958}],headersStr:"REST特性 HTTP Method HTTP 状态码 Swagger 规范API REST Q&A 避免多级URL 传参问题",content:'# SpringMVC RESTful API\n\nRESTful 表述性状态转移 , 是目前最流行的一种软件架构风格\n\nREST指的是一组架构 约束条件/原则 . 不是一个标准 , 而是 设计理念/设计原则 , 使得代码 API更加简洁\n\n\n# REST特性\n\n * **资源(Resources) : ** 每个URI代表一个资源 ==PS: URI , 统一资源标志符 , 表示的是web上每一种可用的资源==\n\n * 表现层(Representation) : 把资源具体呈现出来的形式 JSON/HTML\n\n * **状态转换(State Transfer) : ** 每发出一个请求 , 就代表了客户端和服务器的一次交互过程\n\n\n# HTTP Method\n\n使用 URL 表示资源时 , 每个资源都用一个独一无二的 URL 来表示 , 并使用 HTTP 方法表示操作 , 即准确描述服务器对资源的处理动作 (GET、POST、PUT、DELETE) , 实现资源的增删改查\n\n类型       操作               返回值                   特定返回\nGET      Read(获取资源)       200(获取 列表/...)        404(资源不存在)\nPSOT     Create(创建资源)     201(提交/保存 )           404(未找到)/409(资源已存在)\nPUT      Update(更新资源)     200(修改资源)/204(暂无内容)   404(资源不存在)/405(禁止使用)\nPATCH    Update(更新部分资源)   200(修改资源)/204(暂无内容)   404(资源不存在)\nDELETE   Delete(删除资源)     200(删除成功)             404资源不存在/405(禁止使用)\n\n传统URL 与 REST风格 的URL区别\n\n传统URL                                     REST风格URL                                资源操作方式\nhttp://localhost:8080/getUser.do?id=12    GET : http://localhost:8080/user/12      获取用户信息\nhttp://localhost:8080/saveUser.do         POST : http://localhost:8080/user        新建用户信息\nhttp://localhost:8080/updateUser.do?=12   PUT : http://localhost:8080/user/12      更新用户信息\nhttp://localhost:8080/deleteUser.do?=12   DELETE : http://localhost:8080/user/12   删除用户信息\n\nREST应用\n\n> **应用前提&注意 : **\n> \n>  * 添加 过滤器 org.springframework.web.filter.HiddenHttpMethodFilter 指定 请求 or 所有请求\n>  * PUT 和 DELETE 请求类型 需要以POST请求 添加 _method 属性 值为 指定的 请求类型\n\nweb.xml配置过滤器 HiddenHttpMethodFilter\n\n\x3c!-- HiddenHttpMethodFilter过滤器可以将POST请求转化为put请求和delete请求! --\x3e\n<filter>\n    <filter-name>hiddenHttpMethodFilter</filter-name>\n    <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>hiddenHttpMethodFilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n\n\nrest.jsp 页面\n\n<%@ page contentType="text/html;charset=UTF-8" language="java" %>\n<script src="/js/jquery-1.11.1.js"><\/script>\n<html>\n<head>\n    <title>REST风格</title>\n</head>\n<body>\n    <h1>REST风格 URL 测试</h1>\n    \n    <h2>普通请求 测试</h2>\n    \n    <h3>get请求</h3>\n    <a href="/rest/12">Get</a>\n\n    <h3>post请求</h3>\n    <form action="/rest/12" method="post">\n        <input type="submit" value="POST"/>\n    </form>\n    \n    <h3>put请求</h3>\n    <form action="/rest/12" method="post">\n        <input type="hidden" name="_method" value="PUT" />\n        <input type="submit" value="PUT" />\n    </form>\n    \n    <h3>delete请求</h3>\n    <input type="hidden" name="_method" value="DELETE"/>\n    <form action="/rest/12" method="post">\n        <input type="hidden" name="_method" value="DELETE" />\n        <input type="submit" value="DELETE" />\n    </form>\n    \n    <h2>AJAX请求 测试</h2>\n    <form action="" id="myForm" method="post">\n        id: <input type="text" id="id"> <br>\n        name: <input type="text" id="name"> <br>\n        age: <input type="text" id="age"> <br>\n        <button type="button" id="getAjax">GET</button> <br>\n        <button type="button" id="postAjax">POST</button>   <br>\n        <button type="button" id="putAjax">PUT</button> <br>\n        <button type="button" id="deleteAjax">DELETE</button>   <br>\n    </form>\n\n    <script>\n        $(function(){\n            // get\n            $("#getAjax").click(function(){\n                $.ajax({\n                    type: "GET",\n                    url: "/rest/"+$("#id").val(),\n                    data:"name="+$("#name").val()+"&age="+$("#age").val(),\n                    dataType:"json",\n                    success: function(){}\n                });\n            });\n            \n            // post\n            $("#postAjax").click(function(){\n                $.ajax({\n                    type: "POST",\n                    url: "/rest/"+$("#id").val(),\n                    data:{\n                        "name":$("#name").val(),\n                        "age":$("#age").val() },\n                    dataType:"json",\n                    success: function(){}\n                });\n            });\n            \n            // put\n            $("#putAjax").click(function(){\n                $.ajax({\n                    type: "POST",\n                    url: "/rest/"+$("#id").val(),\n                    data:{\n                        "_method":"PUT",\n                        "name":$("#name").val(),\n                        "age":$("#age").val() },\n                    dataType:"json",\n                    success: function(){}\n                });\n            });\n            \n            //delect\n            $("#deleteAjax").click(function(){\n                $.ajax({\n                    type: "POST",\n                    url: "/rest/"+$("#id").val(),\n                    data:{\n                        "_method":"DELETE",\n                        "name":$("#name").val(),\n                        "age":$("#age").val() },\n                    dataType:"json",\n                    success: function(){}\n                });\n            });\n        });\n    <\/script>\n</body>\n</html>\n\n\nRestController类 控制器\n\npackage com.controller;\n\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\n\n@Controller\n@RequestMapping("rest")\npublic class RestController {\n    \n    @RequestMapping("torest")\n    public String torest() {\n        return "jsp/rEST";\n    }\n    \n    @RequestMapping(value = "{id}",method = RequestMethod.GET)\n    public String getTest(String name ,Integer age) {\n        System.out.println("get请求");\n        System.out.println("name : " + name);\n        System.out.println("age : " + age);\n        return "jsp/ok";\n    }\n    \n    @RequestMapping(value = "{id}",method = RequestMethod.POST)\n    public String postTest(String name ,Integer age) {\n        System.out.println("post请求");\n        System.out.println("name : " + name);\n        System.out.println("age : " + age);\n        return "jsp/ok";\n    }\n    \n    @RequestMapping(value = "{id}",method = RequestMethod.PUT)\n    public String putTest(String name ,Integer age) {\n        System.out.println("put请求");\n        System.out.println("name : " + name);\n        System.out.println("age : " + age);\n        return "jsp/ok";\n    }\n    \n    @RequestMapping(value = "{id}",method = RequestMethod.DELETE)\n    public String deleteTest(String name ,Integer age) {\n        System.out.println("delete请求");\n        System.out.println("name : " + name);\n        System.out.println("age : " + age);\n        return "jsp/ok";\n    }\n    \n}\n\n\n> 通过进入页面进行点\n\n\n# HTTP 状态码\n\nHTTP状态码是服务向用户返回状态码和提示信息 , 每次请求都会包含有 , HTTP状态码有40种 , 分为五大类 :\n\n 1. 1xx : 信息 , 通信传输协议级信息\n 2. 2xx : 成功 , 表示请求已接受\n 3. 3xx : 重定向 , 表示执行其他操作完成其请求\n 4. 4xx : 客户端错误 , 客户端自身问题\n 5. 5xx : 服务器错误 , 服务器自身问题\n\n> 详细了解自行百度即可\n\n\n# Swagger 规范API\n\nSwagger是个规范和完整的框架 , 用于 生成/描述/调用/可视化 API应用 , 流行的API表达工具\n\n应用\n\n 1. pon.xml\n    \n    \x3c!-- Swagger API表达 --\x3e\n    <dependency>\n        <groupId>io.springfox</groupId>\n        <artifactId>springfox-swagger2</artifactId>\n        <version>2.9.2</version>\n    </dependency>\n    \x3c!-- swagger UI --\x3e\n    <dependency>\n        <groupId>io.springfox</groupId>\n        <artifactId>springfox-swagger-ui</artifactId>\n        <version>2.9.2</version>\n    </dependency>\n    \n\n 2. 添加 SwaggerConfig配置类\n    \n    // Swagger 配置类\n    @Configuration\n    @EnableSwagger2 // 启动Swagger2功能\n    public class SwaggerConfig {\n    \n        @Bean\n        public Docket createRestApi() {\n            return new Docket(DocumentationType.SWAGGER_2)\n                    .apiInfo(apiInfo())\n                    .select()\n                    // com包下所有API由Swagger2管理\n                    .apis(RequestHandlerSelectors.basePackage("com"))\n                    .paths(PathSelectors.any())\n                    .build();\n        }\n    \n        // API文档显示的信息\n        private ApiInfo apiInfo() {\n            return new ApiInfoBuilder()\n                    .title("API演示")\n                    .description("项目演示")\n                    .version("1.0")\n                    .build();\n        }\n    }\n    \n\n 3. Spring Boot 2.6.x版本后 与 Swagger版本冲突问题 , 需要 application.properties配置\n    \n    spring.mvc.pathmatch.matching-strategy=ant_path_matcher\n    \n    \n    > Spring Boot 2.6.x版本后版本 , Swagger 版本也需要改为 3.0.0\n\n 4. 运行访问 以下链接即可 http://localhost:8080/swagger-ui.html\n\nSwagger常用注解\n\n注解                                     作用范围                        说明\n@Api                                   class                       控制整个类生成接口信息的内容\n@ApiOperation                          method                      对方法进行总体描述\n@ApiParam                              parameter                   对参数进行描述说明\n@ApiImplicitParams/@ApilmplicitParam   method/@ApiImplicitParams   对单个请求参数进行描述说明\n@ApiResponses/@ApiResponse             method/@ApiResponse         表示一个响应信息 , 一般用来描述错误信息\n@ApiModel/@ApiModelProperty            property/@ApiModel          描述一个 Model 的属性\n\n\n# REST Q&A\n\n\n# 避免多级URL\n\n如果资源有多级分类 , 不建议写多级URL如 :\n\nGET : /class/12/student/1002 建议=> GET : /class/12?student=1002 (查班级中指定学生）\n\n\n# 传参问题\n\n采用Restful风格 PUT 和 DELETE 请求传递参数无效 , 传递到后台的参数值为 null\n\n> 封装请求说明 :\n> \n>  * 将请求中的数据封装成map\n>  * request.getParameter(Key)会获取map中的值\n>  * SpringMVC封装了POJO对象 , 但POJO会通过 request.getParameter(Key) 进行获取 , 因此 UPT 和 DELETE 请求时 request.getParameter(Key) 会拿不到\n>  * Tomcat检测到 PUT、DELETE不会封装请求 数据map\n\n解决方案\n\n利用POST请求 添加 _method 属性 值为 指定的 请求类型 (PUT、DELETE、..) , 前提需要过滤器\n\n 1. web.xml配置过滤器 HiddenHttpMethodFilter\n    \n    \x3c!-- HiddenHttpMethodFilter过滤器可以将POST请求转化为put请求和delete请求! --\x3e\n    <filter>\n        <filter-name>hiddenHttpMethodFilter</filter-name>\n        <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>\n    </filter>\n    <filter-mapping>\n        <filter-name>hiddenHttpMethodFilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n    \n\n 2. 页面 请求\n    \n    ···\n    \x3c!--form表单请求\n    \t添加隐藏 属性 _method\n    \t请求类型为  :  PUT\n    --\x3e\n    <form action="/rest/12" method="post">\n        <input type="hidden" name="_method" value="PUT" />\n        <input type="submit" value="PUT" />\n    </form>\n    ···\n    \x3c!--ajax请求\n    \t添加 属性 _method\n    \t请求类型为  : DELETE\n    --\x3e\n    <button id="deleteAjax">DELETE请求</button>\n    ···\n    <script>\n        $(function(){\n            //delect\n            $("#deleteAjax").click(function(){\n                $.ajax({\n                    type: "POST",\n                    url: "/rest/12",\n                    data:{"_method":"DELETE"},\n                    dataType:"json",\n                    success: function(){}\n                });\n            });\n        });\n    <\/script>\n    ',normalizedContent:'# springmvc restful api\n\nrestful 表述性状态转移 , 是目前最流行的一种软件架构风格\n\nrest指的是一组架构 约束条件/原则 . 不是一个标准 , 而是 设计理念/设计原则 , 使得代码 api更加简洁\n\n\n# rest特性\n\n * **资源(resources) : ** 每个uri代表一个资源 ==ps: uri , 统一资源标志符 , 表示的是web上每一种可用的资源==\n\n * 表现层(representation) : 把资源具体呈现出来的形式 json/html\n\n * **状态转换(state transfer) : ** 每发出一个请求 , 就代表了客户端和服务器的一次交互过程\n\n\n# http method\n\n使用 url 表示资源时 , 每个资源都用一个独一无二的 url 来表示 , 并使用 http 方法表示操作 , 即准确描述服务器对资源的处理动作 (get、post、put、delete) , 实现资源的增删改查\n\n类型       操作               返回值                   特定返回\nget      read(获取资源)       200(获取 列表/...)        404(资源不存在)\npsot     create(创建资源)     201(提交/保存 )           404(未找到)/409(资源已存在)\nput      update(更新资源)     200(修改资源)/204(暂无内容)   404(资源不存在)/405(禁止使用)\npatch    update(更新部分资源)   200(修改资源)/204(暂无内容)   404(资源不存在)\ndelete   delete(删除资源)     200(删除成功)             404资源不存在/405(禁止使用)\n\n传统url 与 rest风格 的url区别\n\n传统url                                     rest风格url                                资源操作方式\nhttp://localhost:8080/getuser.do?id=12    get : http://localhost:8080/user/12      获取用户信息\nhttp://localhost:8080/saveuser.do         post : http://localhost:8080/user        新建用户信息\nhttp://localhost:8080/updateuser.do?=12   put : http://localhost:8080/user/12      更新用户信息\nhttp://localhost:8080/deleteuser.do?=12   delete : http://localhost:8080/user/12   删除用户信息\n\nrest应用\n\n> **应用前提&注意 : **\n> \n>  * 添加 过滤器 org.springframework.web.filter.hiddenhttpmethodfilter 指定 请求 or 所有请求\n>  * put 和 delete 请求类型 需要以post请求 添加 _method 属性 值为 指定的 请求类型\n\nweb.xml配置过滤器 hiddenhttpmethodfilter\n\n\x3c!-- hiddenhttpmethodfilter过滤器可以将post请求转化为put请求和delete请求! --\x3e\n<filter>\n    <filter-name>hiddenhttpmethodfilter</filter-name>\n    <filter-class>org.springframework.web.filter.hiddenhttpmethodfilter</filter-class>\n</filter>\n<filter-mapping>\n    <filter-name>hiddenhttpmethodfilter</filter-name>\n    <url-pattern>/*</url-pattern>\n</filter-mapping>\n\n\nrest.jsp 页面\n\n<%@ page contenttype="text/html;charset=utf-8" language="java" %>\n<script src="/js/jquery-1.11.1.js"><\/script>\n<html>\n<head>\n    <title>rest风格</title>\n</head>\n<body>\n    <h1>rest风格 url 测试</h1>\n    \n    <h2>普通请求 测试</h2>\n    \n    <h3>get请求</h3>\n    <a href="/rest/12">get</a>\n\n    <h3>post请求</h3>\n    <form action="/rest/12" method="post">\n        <input type="submit" value="post"/>\n    </form>\n    \n    <h3>put请求</h3>\n    <form action="/rest/12" method="post">\n        <input type="hidden" name="_method" value="put" />\n        <input type="submit" value="put" />\n    </form>\n    \n    <h3>delete请求</h3>\n    <input type="hidden" name="_method" value="delete"/>\n    <form action="/rest/12" method="post">\n        <input type="hidden" name="_method" value="delete" />\n        <input type="submit" value="delete" />\n    </form>\n    \n    <h2>ajax请求 测试</h2>\n    <form action="" id="myform" method="post">\n        id: <input type="text" id="id"> <br>\n        name: <input type="text" id="name"> <br>\n        age: <input type="text" id="age"> <br>\n        <button type="button" id="getajax">get</button> <br>\n        <button type="button" id="postajax">post</button>   <br>\n        <button type="button" id="putajax">put</button> <br>\n        <button type="button" id="deleteajax">delete</button>   <br>\n    </form>\n\n    <script>\n        $(function(){\n            // get\n            $("#getajax").click(function(){\n                $.ajax({\n                    type: "get",\n                    url: "/rest/"+$("#id").val(),\n                    data:"name="+$("#name").val()+"&age="+$("#age").val(),\n                    datatype:"json",\n                    success: function(){}\n                });\n            });\n            \n            // post\n            $("#postajax").click(function(){\n                $.ajax({\n                    type: "post",\n                    url: "/rest/"+$("#id").val(),\n                    data:{\n                        "name":$("#name").val(),\n                        "age":$("#age").val() },\n                    datatype:"json",\n                    success: function(){}\n                });\n            });\n            \n            // put\n            $("#putajax").click(function(){\n                $.ajax({\n                    type: "post",\n                    url: "/rest/"+$("#id").val(),\n                    data:{\n                        "_method":"put",\n                        "name":$("#name").val(),\n                        "age":$("#age").val() },\n                    datatype:"json",\n                    success: function(){}\n                });\n            });\n            \n            //delect\n            $("#deleteajax").click(function(){\n                $.ajax({\n                    type: "post",\n                    url: "/rest/"+$("#id").val(),\n                    data:{\n                        "_method":"delete",\n                        "name":$("#name").val(),\n                        "age":$("#age").val() },\n                    datatype:"json",\n                    success: function(){}\n                });\n            });\n        });\n    <\/script>\n</body>\n</html>\n\n\nrestcontroller类 控制器\n\npackage com.controller;\n\nimport org.springframework.stereotype.controller;\nimport org.springframework.web.bind.annotation.requestmapping;\nimport org.springframework.web.bind.annotation.requestmethod;\n\n@controller\n@requestmapping("rest")\npublic class restcontroller {\n    \n    @requestmapping("torest")\n    public string torest() {\n        return "jsp/rest";\n    }\n    \n    @requestmapping(value = "{id}",method = requestmethod.get)\n    public string gettest(string name ,integer age) {\n        system.out.println("get请求");\n        system.out.println("name : " + name);\n        system.out.println("age : " + age);\n        return "jsp/ok";\n    }\n    \n    @requestmapping(value = "{id}",method = requestmethod.post)\n    public string posttest(string name ,integer age) {\n        system.out.println("post请求");\n        system.out.println("name : " + name);\n        system.out.println("age : " + age);\n        return "jsp/ok";\n    }\n    \n    @requestmapping(value = "{id}",method = requestmethod.put)\n    public string puttest(string name ,integer age) {\n        system.out.println("put请求");\n        system.out.println("name : " + name);\n        system.out.println("age : " + age);\n        return "jsp/ok";\n    }\n    \n    @requestmapping(value = "{id}",method = requestmethod.delete)\n    public string deletetest(string name ,integer age) {\n        system.out.println("delete请求");\n        system.out.println("name : " + name);\n        system.out.println("age : " + age);\n        return "jsp/ok";\n    }\n    \n}\n\n\n> 通过进入页面进行点\n\n\n# http 状态码\n\nhttp状态码是服务向用户返回状态码和提示信息 , 每次请求都会包含有 , http状态码有40种 , 分为五大类 :\n\n 1. 1xx : 信息 , 通信传输协议级信息\n 2. 2xx : 成功 , 表示请求已接受\n 3. 3xx : 重定向 , 表示执行其他操作完成其请求\n 4. 4xx : 客户端错误 , 客户端自身问题\n 5. 5xx : 服务器错误 , 服务器自身问题\n\n> 详细了解自行百度即可\n\n\n# swagger 规范api\n\nswagger是个规范和完整的框架 , 用于 生成/描述/调用/可视化 api应用 , 流行的api表达工具\n\n应用\n\n 1. pon.xml\n    \n    \x3c!-- swagger api表达 --\x3e\n    <dependency>\n        <groupid>io.springfox</groupid>\n        <artifactid>springfox-swagger2</artifactid>\n        <version>2.9.2</version>\n    </dependency>\n    \x3c!-- swagger ui --\x3e\n    <dependency>\n        <groupid>io.springfox</groupid>\n        <artifactid>springfox-swagger-ui</artifactid>\n        <version>2.9.2</version>\n    </dependency>\n    \n\n 2. 添加 swaggerconfig配置类\n    \n    // swagger 配置类\n    @configuration\n    @enableswagger2 // 启动swagger2功能\n    public class swaggerconfig {\n    \n        @bean\n        public docket createrestapi() {\n            return new docket(documentationtype.swagger_2)\n                    .apiinfo(apiinfo())\n                    .select()\n                    // com包下所有api由swagger2管理\n                    .apis(requesthandlerselectors.basepackage("com"))\n                    .paths(pathselectors.any())\n                    .build();\n        }\n    \n        // api文档显示的信息\n        private apiinfo apiinfo() {\n            return new apiinfobuilder()\n                    .title("api演示")\n                    .description("项目演示")\n                    .version("1.0")\n                    .build();\n        }\n    }\n    \n\n 3. spring boot 2.6.x版本后 与 swagger版本冲突问题 , 需要 application.properties配置\n    \n    spring.mvc.pathmatch.matching-strategy=ant_path_matcher\n    \n    \n    > spring boot 2.6.x版本后版本 , swagger 版本也需要改为 3.0.0\n\n 4. 运行访问 以下链接即可 http://localhost:8080/swagger-ui.html\n\nswagger常用注解\n\n注解                                     作用范围                        说明\n@api                                   class                       控制整个类生成接口信息的内容\n@apioperation                          method                      对方法进行总体描述\n@apiparam                              parameter                   对参数进行描述说明\n@apiimplicitparams/@apilmplicitparam   method/@apiimplicitparams   对单个请求参数进行描述说明\n@apiresponses/@apiresponse             method/@apiresponse         表示一个响应信息 , 一般用来描述错误信息\n@apimodel/@apimodelproperty            property/@apimodel          描述一个 model 的属性\n\n\n# rest q&a\n\n\n# 避免多级url\n\n如果资源有多级分类 , 不建议写多级url如 :\n\nget : /class/12/student/1002 建议=> get : /class/12?student=1002 (查班级中指定学生）\n\n\n# 传参问题\n\n采用restful风格 put 和 delete 请求传递参数无效 , 传递到后台的参数值为 null\n\n> 封装请求说明 :\n> \n>  * 将请求中的数据封装成map\n>  * request.getparameter(key)会获取map中的值\n>  * springmvc封装了pojo对象 , 但pojo会通过 request.getparameter(key) 进行获取 , 因此 upt 和 delete 请求时 request.getparameter(key) 会拿不到\n>  * tomcat检测到 put、delete不会封装请求 数据map\n\n解决方案\n\n利用post请求 添加 _method 属性 值为 指定的 请求类型 (put、delete、..) , 前提需要过滤器\n\n 1. web.xml配置过滤器 hiddenhttpmethodfilter\n    \n    \x3c!-- hiddenhttpmethodfilter过滤器可以将post请求转化为put请求和delete请求! --\x3e\n    <filter>\n        <filter-name>hiddenhttpmethodfilter</filter-name>\n        <filter-class>org.springframework.web.filter.hiddenhttpmethodfilter</filter-class>\n    </filter>\n    <filter-mapping>\n        <filter-name>hiddenhttpmethodfilter</filter-name>\n        <url-pattern>/*</url-pattern>\n    </filter-mapping>\n    \n\n 2. 页面 请求\n    \n    ···\n    \x3c!--form表单请求\n    \t添加隐藏 属性 _method\n    \t请求类型为  :  put\n    --\x3e\n    <form action="/rest/12" method="post">\n        <input type="hidden" name="_method" value="put" />\n        <input type="submit" value="put" />\n    </form>\n    ···\n    \x3c!--ajax请求\n    \t添加 属性 _method\n    \t请求类型为  : delete\n    --\x3e\n    <button id="deleteajax">delete请求</button>\n    ···\n    <script>\n        $(function(){\n            //delect\n            $("#deleteajax").click(function(){\n                $.ajax({\n                    type: "post",\n                    url: "/rest/12",\n                    data:{"_method":"delete"},\n                    datatype:"json",\n                    success: function(){}\n                });\n            });\n        });\n    <\/script>\n    ',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Ribbon 负载均衡",frontmatter:{title:"Ribbon 负载均衡",author:"柏竹",permalink:"/backend/s4wg1j",date:"2020-02-18T00:00:00.000Z",categories:["后端"],tags:["SpringClound","Java"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/09.SpringClound/03.Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1.html",relativePath:"01.后端/09.SpringClound/03.Ribbon负载均衡.md",key:"v-16d518b6",path:"/backend/s4wg1j/",headers:[{level:2,title:"负载均衡示例",slug:"负载均衡示例",normalizedTitle:"负载均衡示例",charIndex:110},{level:2,title:"Ribbon 负载均衡策略",slug:"ribbon-负载均衡策略",normalizedTitle:"ribbon 负载均衡策略",charIndex:3586},{level:3,title:"策略应用示例",slug:"策略应用示例",normalizedTitle:"策略应用示例",charIndex:4149}],headersStr:"负载均衡示例 Ribbon 负载均衡策略 策略应用示例",content:'# Ribbon 负载均衡\n\nSpring Cloud Ribbon 是一个基于 Http、TCP 的客服端负载均衡工具，它是基于 Netflix Ribbon 实现的。主要解决高量访问均匀的分布到每个节点\n\n\n\n\n# 负载均衡示例\n\n> 提供者需要形成集群，负载均衡的功能集成到消费方，进行请求均衡分配\n\n提供者\n\n提供者 pom.xml\n\n<?xml version="1.0" encoding="UTF-8"?>\n<project xmlns="http://maven.apache.org/POM/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n\n    <parent>\n        <artifactId>springcloud-father</artifactId>\n        <groupId>com.sans</groupId>\n        <version>1.0-SNAPSHOT</version>\n    </parent>\n    <modelVersion>4.0.0</modelVersion>\n\n    <artifactId>user-service</artifactId>\n\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        \x3c!-- 通用Mapper启动器 --\x3e\n        <dependency>\n            <groupId>tk.mybatis</groupId>\n            <artifactId>mapper-spring-boot-starter</artifactId>\n        </dependency>\n        \x3c!-- mysql驱动 --\x3e\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n        </dependency>\n    </dependencies>\n\n</project>\n\n\n提供者 application.yml\n\nserver :\n    port : ${prot:9000}\nspring :\n    application:\n        name : user-service\neureka :\n    client :\n        service-url :\n     \t\t# 注册的服务端地址\n            defaultZone : HTTP://127.0.0.1:10086/eureka\n# ··· 其他\n\n\n提供者项目 大致流程 （==controller、mapper、pojo、service、启动类 组件==\n\n>  * 配置需要改 端口号 ， 提供者 和 调用者 端口以防冲突\n>  * controller提供的接口： http://localhost:8080/user/2 (按ID查用户)\n\nuser-service 形成集群\n\n启动配置组件 配置参数 prot 分别为：9000、9001、9002\n\n虚拟机选项参数：-Dprot=9000 （重复创建3个user-service不同端口\n\n\n\n消费者\n\n消费者 pom.xml\n\n\x3c!--调用者只需一个web依赖--\x3e\n<dependencies>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-web</artifactId>\n    </dependency>\n</dependencies>\n\n\n消费者 application.yml\n\nspring :\n    application :\n        name : consumer-demo\neureka :\n    client :\n        service-url :\n            defaultZone : http://127.0.0.1:10086/eureka\n\n\n消费者项目 启动器类 ，在RestTemplate方法上添加 @LoadBalanced\n\n@SpringBootApplication\npublic class Application {\n    \n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);\n    }\n    \n    @Bean\n    // Ribbon 启动负载均衡\n    @LoadBalanced\n    public RestTemplate restTemplate() {\n        return new RestTemplate();\n    }\n    \n}\n\n\n> Eureka中已经集成了Ribbon，因此无需引入新依赖\n\n消费者 contoller\n\n@RestController\n@RequestMapping("consumer")\npublic class ConsumerController {\n    \n    @Autowired\n    private RestTemplate restTemplate;\n    @Autowired\n    private DiscoveryClient discoveryClient;\n    \n    @RequestMapping("{id}")\n    public User findById(@PathVariable Long id) {\n        // 方式1 : 绝对路径\n        // String url = "HTTP://localhost:9091/user/"+id;\n        \n        // 方式2 : 通过 discoveryClient对象 获取 ip、port\n        // List<ServiceInstance> list = discoveryClient.getInstances("user-service");\n        // ServiceInstance instance = list.get(0);\n        // String url = "HTTP://"+instance.getHost()+":"+instance.getPort()+"/user/"+id;\n        \n        // 方式3 : 通过 Ribbon 拦截替换获取 (service名称 会自动替换为 ip、port\n        String url = "HTTP://user-service/user/"+id;\n        \n        return restTemplate.getForObject(url , User.class);\n    }\n    \n}\n\n\n> Ribbon会拦截请求进行识别服务名称进行分析 ip、port ，自动替换 ip、port\n\n测试\n\n\n\n访问 http://localhost:8080/consumer/1 （查看服务节点，根据端口判断节点\n\n 1. 跟踪 LoadBalancerInterceptor类 拦截器\n\n 2. 跟踪 execute() 方法\n\n 3. 跟踪 断点\n\n 4. 控制器检查断点变量\n    \n    > 每次访问 ，节点都是不一样的！！！\n\n\n# Ribbon 负载均衡策略\n\nRibbon 负载均衡策略方式是通过内置集成的算法获取到预期的节点，默认是 轮询策略。\n\n以下列出更多有关负载均衡的策略：\n\n策略类                         策略名      说明\nRandomRule                  随机策略     随机选择server\nRoundRobinRule              轮询策略     server集合，遍历server集合，并有序的选中 servcer\nRetryRule                   失败重试策略   首先以 轮询策略\n                                     执行，当某个server失败，重试下一个server，则以此类推，直至遍历完server，如果都不成功，直接返回失败\nBestAvailableRule           最低并发策略   选择 负载压力最小的 server\nAvailabilityFilteringRule   可用过滤策略   选择 无连接失败、无高并发 且健康的server\nZoneAvoidanceRule           区域权重策略   选择 指定区域 、可用 的server （自定义\n\n\n# 策略应用示例\n\n在以上的基础上进行修改\n\n消费者 application.yml 添加 负载均衡策略\n\nuser-service:\n    ribbon:\n        NFLoadBalancerRuleClassName : com.netflix.loadbalancer.RandomRule\n\n\n> 配置的格式说明：\n> \n> {服务器名称}.ribbon.NFLoadBalancerRuleClassName : com.netflix.loadbalancer.{策略类}\n\n测试\n\n@RunWith (SpringRunner.class)\n@SpringBootTest(classes = ConsumerApplication.class)\npublic class ConsumerControllerTest {\n    \n    @Autowired\n    RibbonLoadBalancerClient client;\n    \n    @Test\n    public void test() {\n        for (int i = 0 ; i < 100 ; i++) {\n            ServiceInstance instance = this.client.choose("user-service");\n            System.out.println(instance.getHost() +" : "+ instance.getPort());\n        }\n    }\n    \n}\n\n/*\n观察不同端口的访问 顺序 进行辨别\n*/\n\n\n> 自行添加测试依赖\n\n----------------------------------------\n\n仓库代码 : https://gitee.com/Sanscan12/spring-cloud-examples.git',normalizedContent:'# ribbon 负载均衡\n\nspring cloud ribbon 是一个基于 http、tcp 的客服端负载均衡工具，它是基于 netflix ribbon 实现的。主要解决高量访问均匀的分布到每个节点\n\n\n\n\n# 负载均衡示例\n\n> 提供者需要形成集群，负载均衡的功能集成到消费方，进行请求均衡分配\n\n提供者\n\n提供者 pom.xml\n\n<?xml version="1.0" encoding="utf-8"?>\n<project xmlns="http://maven.apache.org/pom/4.0.0"\n         xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n         xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n\n    <parent>\n        <artifactid>springcloud-father</artifactid>\n        <groupid>com.sans</groupid>\n        <version>1.0-snapshot</version>\n    </parent>\n    <modelversion>4.0.0</modelversion>\n\n    <artifactid>user-service</artifactid>\n\n    <dependencies>\n        <dependency>\n            <groupid>org.springframework.boot</groupid>\n            <artifactid>spring-boot-starter-web</artifactid>\n        </dependency>\n        \x3c!-- 通用mapper启动器 --\x3e\n        <dependency>\n            <groupid>tk.mybatis</groupid>\n            <artifactid>mapper-spring-boot-starter</artifactid>\n        </dependency>\n        \x3c!-- mysql驱动 --\x3e\n        <dependency>\n            <groupid>mysql</groupid>\n            <artifactid>mysql-connector-java</artifactid>\n        </dependency>\n    </dependencies>\n\n</project>\n\n\n提供者 application.yml\n\nserver :\n    port : ${prot:9000}\nspring :\n    application:\n        name : user-service\neureka :\n    client :\n        service-url :\n     \t\t# 注册的服务端地址\n            defaultzone : http://127.0.0.1:10086/eureka\n# ··· 其他\n\n\n提供者项目 大致流程 （==controller、mapper、pojo、service、启动类 组件==\n\n>  * 配置需要改 端口号 ， 提供者 和 调用者 端口以防冲突\n>  * controller提供的接口： http://localhost:8080/user/2 (按id查用户)\n\nuser-service 形成集群\n\n启动配置组件 配置参数 prot 分别为：9000、9001、9002\n\n虚拟机选项参数：-dprot=9000 （重复创建3个user-service不同端口\n\n\n\n消费者\n\n消费者 pom.xml\n\n\x3c!--调用者只需一个web依赖--\x3e\n<dependencies>\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-web</artifactid>\n    </dependency>\n</dependencies>\n\n\n消费者 application.yml\n\nspring :\n    application :\n        name : consumer-demo\neureka :\n    client :\n        service-url :\n            defaultzone : http://127.0.0.1:10086/eureka\n\n\n消费者项目 启动器类 ，在resttemplate方法上添加 @loadbalanced\n\n@springbootapplication\npublic class application {\n    \n    public static void main(string[] args) {\n        springapplication.run(application.class, args);\n    }\n    \n    @bean\n    // ribbon 启动负载均衡\n    @loadbalanced\n    public resttemplate resttemplate() {\n        return new resttemplate();\n    }\n    \n}\n\n\n> eureka中已经集成了ribbon，因此无需引入新依赖\n\n消费者 contoller\n\n@restcontroller\n@requestmapping("consumer")\npublic class consumercontroller {\n    \n    @autowired\n    private resttemplate resttemplate;\n    @autowired\n    private discoveryclient discoveryclient;\n    \n    @requestmapping("{id}")\n    public user findbyid(@pathvariable long id) {\n        // 方式1 : 绝对路径\n        // string url = "http://localhost:9091/user/"+id;\n        \n        // 方式2 : 通过 discoveryclient对象 获取 ip、port\n        // list<serviceinstance> list = discoveryclient.getinstances("user-service");\n        // serviceinstance instance = list.get(0);\n        // string url = "http://"+instance.gethost()+":"+instance.getport()+"/user/"+id;\n        \n        // 方式3 : 通过 ribbon 拦截替换获取 (service名称 会自动替换为 ip、port\n        string url = "http://user-service/user/"+id;\n        \n        return resttemplate.getforobject(url , user.class);\n    }\n    \n}\n\n\n> ribbon会拦截请求进行识别服务名称进行分析 ip、port ，自动替换 ip、port\n\n测试\n\n\n\n访问 http://localhost:8080/consumer/1 （查看服务节点，根据端口判断节点\n\n 1. 跟踪 loadbalancerinterceptor类 拦截器\n\n 2. 跟踪 execute() 方法\n\n 3. 跟踪 断点\n\n 4. 控制器检查断点变量\n    \n    > 每次访问 ，节点都是不一样的！！！\n\n\n# ribbon 负载均衡策略\n\nribbon 负载均衡策略方式是通过内置集成的算法获取到预期的节点，默认是 轮询策略。\n\n以下列出更多有关负载均衡的策略：\n\n策略类                         策略名      说明\nrandomrule                  随机策略     随机选择server\nroundrobinrule              轮询策略     server集合，遍历server集合，并有序的选中 servcer\nretryrule                   失败重试策略   首先以 轮询策略\n                                     执行，当某个server失败，重试下一个server，则以此类推，直至遍历完server，如果都不成功，直接返回失败\nbestavailablerule           最低并发策略   选择 负载压力最小的 server\navailabilityfilteringrule   可用过滤策略   选择 无连接失败、无高并发 且健康的server\nzoneavoidancerule           区域权重策略   选择 指定区域 、可用 的server （自定义\n\n\n# 策略应用示例\n\n在以上的基础上进行修改\n\n消费者 application.yml 添加 负载均衡策略\n\nuser-service:\n    ribbon:\n        nfloadbalancerruleclassname : com.netflix.loadbalancer.randomrule\n\n\n> 配置的格式说明：\n> \n> {服务器名称}.ribbon.nfloadbalancerruleclassname : com.netflix.loadbalancer.{策略类}\n\n测试\n\n@runwith (springrunner.class)\n@springboottest(classes = consumerapplication.class)\npublic class consumercontrollertest {\n    \n    @autowired\n    ribbonloadbalancerclient client;\n    \n    @test\n    public void test() {\n        for (int i = 0 ; i < 100 ; i++) {\n            serviceinstance instance = this.client.choose("user-service");\n            system.out.println(instance.gethost() +" : "+ instance.getport());\n        }\n    }\n    \n}\n\n/*\n观察不同端口的访问 顺序 进行辨别\n*/\n\n\n> 自行添加测试依赖\n\n----------------------------------------\n\n仓库代码 : https://gitee.com/sanscan12/spring-cloud-examples.git',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Spring Cloud 认知",frontmatter:{title:"Spring Cloud 认知",author:"柏竹",permalink:"/backend/ibtuuq",date:"2020-02-18T00:00:00.000Z",categories:["后端"],tags:["SpringClound","Java"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/09.SpringClound/01.%E6%A6%82%E5%BF%B5.html",relativePath:"01.后端/09.SpringClound/01.概念.md",key:"v-28e963c8",path:"/backend/ibtuuq/",headers:[{level:2,title:"Spring Cloud版本",slug:"spring-cloud版本",normalizedTitle:"spring cloud版本",charIndex:332},{level:2,title:"首次应用",slug:"首次应用",normalizedTitle:"首次应用",charIndex:612}],headersStr:"Spring Cloud版本 首次应用",content:'# Spring Cloud 认知\n\nSpring Cloud 是一系列框架的集合，它整合了优秀框架到自己项目中。其中实现了：配置管理、服务发现、智能路由、负载均衡、熔断器、控制总线等功能。\n\n主要涉及到的组件：\n\n * Eureka：服务注册中心，用于服务管理\n * Ribbon：基于客户端的负载均衡组件\n * Hystrix：容错框架，能够防止服务的雪崩效应\n * Feign：Web 服务客户端，能够简化 HTTP 接口的调用\n * Zuul：API 网关，提供路由转发、请求过滤等功能\n * Config：分布式配置管理\n * Sleuth：服务跟踪\n * Stream：构建消息驱动的微服务应用程序的框架\n * Bus：消息代理的集群消息总线\n\n\n# Spring Cloud版本\n\nSpring Cloud 是个众多 子项目 综合起来的大项目，因此对 微服务构架 解决方案有 综合的组件，其中组件之间都是独立的，它们各自维持着自己版本号的 迭代与更新\n\nSpring Cloud 和 Spring Boot版本 对应关系\n\nRELEASE TRAIN   BOOT VERSION\nHoxton          2.2.x\nGreenwich       2.1.x\nFinchley        2.0.x\nEdgware         1.5.x\nDalston         1.5.x\n\n\n# 首次应用\n\n微服务模拟场景\n\n微服务是由多个子项目组合而成的父项目。以下首次应用模拟 服务 提供 和 调用 应用（查数据测试\n\n 1.  创建 ==父项目== 无骨架Maven项目\n\n 2.  配置父项目 pom.xml\n     \n     <?xml version="1.0" encoding="UTF-8"?>\n     <project xmlns="http://maven.apache.org/POM/4.0.0"\n              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n              xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n         <modelVersion>4.0.0</modelVersion>\n     \n         <groupId>com.sans</groupId>\n         <artifactId>springcloud-father</artifactId>\n         \x3c!--配置 聚合父工程--\x3e\n         <packaging>pom</packaging>\n         <version>1.0-SNAPSHOT</version>\n     \n         <modules>\n             <module>user-service</module>\n             <module>consumer-demo</module>\n         </modules>\n     \n         \x3c!--配置 父项目--\x3e\n         <parent>\n             <groupId>org.springframework.boot</groupId>\n             <artifactId>spring-boot-starter-parent</artifactId>\n             <version>2.1.5.RELEASE</version>\n             <relativePath/>\n         </parent>\n     \n         \x3c!--Spring 与 Spring Cloud 版本号必须对应--\x3e\n         <properties>\n             <java.version>1.8</java.version>\n             <spring-cloud.version>Greenwich.SR1</spring-cloud.version>\n             <mapper.starter.version>2.1.5</mapper.starter.version>\n             <mysql.version>5.1.46</mysql.version>\n         </properties>\n     \n         \x3c!-- 统一管理依赖 --\x3e\n         <dependencyManagement>\n             <dependencies>\n                 \x3c!-- springCloud --\x3e\n                 <dependency>\n                     <groupId>org.springframework.cloud</groupId>\n                     <artifactId>spring-cloud-dependencies</artifactId>\n                     <version>${spring-cloud.version}</version>\n                     <type>pom</type>\n                     <scope>import</scope>\n                 </dependency>\n                 \x3c!-- 通用Mapper启动器 --\x3e\n                 <dependency>\n                     <groupId>tk.mybatis</groupId>\n                     <artifactId>mapper-spring-boot-starter</artifactId>\n                     <version>${mapper.starter.version}</version>\n                 </dependency>\n                 \x3c!-- mysql驱动 --\x3e\n                 <dependency>\n                     <groupId>mysql</groupId>\n                     <artifactId>mysql-connector-java</artifactId>\n                     <version>${mysql.version}</version>\n                 </dependency>\n             </dependencies>\n         </dependencyManagement>\n     \n         <dependencies>\n             <dependency>\n                 <groupId>org.projectlombok</groupId>\n                 <artifactId>lombok</artifactId>\n             </dependency>\n         </dependencies>\n     \n         <build>\n             <plugins>\n                 <plugin>\n                     <groupId>org.springframework.boot</groupId>\n                     <artifactId>spring-boot-maven-plugin</artifactId>\n                 </plugin>\n             </plugins>\n         </build>\n     \n     </project>\n     \n     \n     >  * <dependencyManagement> 可统一配置 子项目的版本号 （子项目无需在进行版本号的锁定\n     >  * Spring Cloud 和 Spring Boot 版本 必须严格对应指定版本\n     >  * 配置该项目为聚合父工程 <packaging>pom</packaging>\n\n 3.  在父项目下创建 ==提供者== 无骨架Maven项目（用于 用户业务操作服务\n\n 4.  提供者项目 pom.xml\n     \n     <?xml version="1.0" encoding="UTF-8"?>\n     <project xmlns="http://maven.apache.org/POM/4.0.0"\n              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"\n              xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n     \n         <parent>\n             <artifactId>springcloud-father</artifactId>\n             <groupId>com.sans</groupId>\n             <version>1.0-SNAPSHOT</version>\n         </parent>\n         <modelVersion>4.0.0</modelVersion>\n     \n         <artifactId>user-service</artifactId>\n     \n         <dependencies>\n             <dependency>\n                 <groupId>org.springframework.boot</groupId>\n                 <artifactId>spring-boot-starter-web</artifactId>\n             </dependency>\n             \x3c!-- 通用Mapper启动器 --\x3e\n             <dependency>\n                 <groupId>tk.mybatis</groupId>\n                 <artifactId>mapper-spring-boot-starter</artifactId>\n             </dependency>\n             \x3c!-- mysql驱动 --\x3e\n             <dependency>\n                 <groupId>mysql</groupId>\n                 <artifactId>mysql-connector-java</artifactId>\n             </dependency>\n         </dependencies>\n     \n     </project>\n     \n     \n     > 组件依赖的版本号由父项目的pom进行配置\n\n 5.  提供者项目 大致流程 （==controller、mapper、pojo、service、启动类 组件==\n     \n     >  * 配置需要改 端口号 ， 提供者 和 调用者 端口以防冲突\n     >  * controller提供的接口： http://localhost:80/user/2 (按ID查用户)\n\n 6.  在父项目下创建 ==调用者== 无骨架Maven项目 （通过提供者获取接口进行 用户业务操作服务\n\n 7.  调用者项目 只需 ==添加web依赖 、模板方法、实体pojo、contoller==\n\n 8.  调用者项目 pom.xml\n     \n     \x3c!--调用者只需一个web依赖--\x3e\n     <dependencies>\n         <dependency>\n             <groupId>org.springframework.boot</groupId>\n             <artifactId>spring-boot-starter-web</artifactId>\n         </dependency>\n     </dependencies>\n     \n\n 9.  调用者项目 启动器类 添加模板工具方法\n     \n     @SpringBootApplication\n     public class Application {\n         \n         public static void main(String[] args) {\n             SpringApplication.run(Application.class, args);\n         }\n         \n         @Bean\n         public RestTemplate restTemplate() {\n             return new RestTemplate();\n         }\n         \n     }\n     \n\n 10. 调用者项目 contoller （ pojo的User实体类、端口无配置默认8080\n     \n     @RestController\n     @RequestMapping("consumer")\n     public class ConsumerController {\n         \n         @Autowired\n         private RestTemplate restTemplate;\n         \n          @RequestMapping("{id}")\n         public User findById(@PathVariable Long id) {\n             String url = "HTTP://localhost:9091/user/"+id;\n             return restTemplate.getForObject(url , User.class);\n         }\n         \n     }\n     \n     \n     > Spring提供了一个 RestTemplate模板工具类，对基于HTTP的客户端进行了封装，并且实现了 对象 与 json的序列化 、反序列化，非常方便。RestTemplate并没有限定HTTP的客户端类型，而是进行了抽象，目前常用的3种都有支持：\n     > \n     >  * HTTPClient\n     >  * OkHTTP\n     >  * JDK原生的URLConnection（默认的）\n\n 11. 测试 分别启动两个子项目\n     \n     通过 调用者接口中应用 提供者的接口\n     \n     访问 http://localhost:8080/consumer/2 (按ID查用户)\n     \n     ----------------------------------------\n     \n     仓库代码 : https://gitee.com/Sanscan12/spring-cloud-examples.git',normalizedContent:'# spring cloud 认知\n\nspring cloud 是一系列框架的集合，它整合了优秀框架到自己项目中。其中实现了：配置管理、服务发现、智能路由、负载均衡、熔断器、控制总线等功能。\n\n主要涉及到的组件：\n\n * eureka：服务注册中心，用于服务管理\n * ribbon：基于客户端的负载均衡组件\n * hystrix：容错框架，能够防止服务的雪崩效应\n * feign：web 服务客户端，能够简化 http 接口的调用\n * zuul：api 网关，提供路由转发、请求过滤等功能\n * config：分布式配置管理\n * sleuth：服务跟踪\n * stream：构建消息驱动的微服务应用程序的框架\n * bus：消息代理的集群消息总线\n\n\n# spring cloud版本\n\nspring cloud 是个众多 子项目 综合起来的大项目，因此对 微服务构架 解决方案有 综合的组件，其中组件之间都是独立的，它们各自维持着自己版本号的 迭代与更新\n\nspring cloud 和 spring boot版本 对应关系\n\nrelease train   boot version\nhoxton          2.2.x\ngreenwich       2.1.x\nfinchley        2.0.x\nedgware         1.5.x\ndalston         1.5.x\n\n\n# 首次应用\n\n微服务模拟场景\n\n微服务是由多个子项目组合而成的父项目。以下首次应用模拟 服务 提供 和 调用 应用（查数据测试\n\n 1.  创建 ==父项目== 无骨架maven项目\n\n 2.  配置父项目 pom.xml\n     \n     <?xml version="1.0" encoding="utf-8"?>\n     <project xmlns="http://maven.apache.org/pom/4.0.0"\n              xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n              xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n         <modelversion>4.0.0</modelversion>\n     \n         <groupid>com.sans</groupid>\n         <artifactid>springcloud-father</artifactid>\n         \x3c!--配置 聚合父工程--\x3e\n         <packaging>pom</packaging>\n         <version>1.0-snapshot</version>\n     \n         <modules>\n             <module>user-service</module>\n             <module>consumer-demo</module>\n         </modules>\n     \n         \x3c!--配置 父项目--\x3e\n         <parent>\n             <groupid>org.springframework.boot</groupid>\n             <artifactid>spring-boot-starter-parent</artifactid>\n             <version>2.1.5.release</version>\n             <relativepath/>\n         </parent>\n     \n         \x3c!--spring 与 spring cloud 版本号必须对应--\x3e\n         <properties>\n             <java.version>1.8</java.version>\n             <spring-cloud.version>greenwich.sr1</spring-cloud.version>\n             <mapper.starter.version>2.1.5</mapper.starter.version>\n             <mysql.version>5.1.46</mysql.version>\n         </properties>\n     \n         \x3c!-- 统一管理依赖 --\x3e\n         <dependencymanagement>\n             <dependencies>\n                 \x3c!-- springcloud --\x3e\n                 <dependency>\n                     <groupid>org.springframework.cloud</groupid>\n                     <artifactid>spring-cloud-dependencies</artifactid>\n                     <version>${spring-cloud.version}</version>\n                     <type>pom</type>\n                     <scope>import</scope>\n                 </dependency>\n                 \x3c!-- 通用mapper启动器 --\x3e\n                 <dependency>\n                     <groupid>tk.mybatis</groupid>\n                     <artifactid>mapper-spring-boot-starter</artifactid>\n                     <version>${mapper.starter.version}</version>\n                 </dependency>\n                 \x3c!-- mysql驱动 --\x3e\n                 <dependency>\n                     <groupid>mysql</groupid>\n                     <artifactid>mysql-connector-java</artifactid>\n                     <version>${mysql.version}</version>\n                 </dependency>\n             </dependencies>\n         </dependencymanagement>\n     \n         <dependencies>\n             <dependency>\n                 <groupid>org.projectlombok</groupid>\n                 <artifactid>lombok</artifactid>\n             </dependency>\n         </dependencies>\n     \n         <build>\n             <plugins>\n                 <plugin>\n                     <groupid>org.springframework.boot</groupid>\n                     <artifactid>spring-boot-maven-plugin</artifactid>\n                 </plugin>\n             </plugins>\n         </build>\n     \n     </project>\n     \n     \n     >  * <dependencymanagement> 可统一配置 子项目的版本号 （子项目无需在进行版本号的锁定\n     >  * spring cloud 和 spring boot 版本 必须严格对应指定版本\n     >  * 配置该项目为聚合父工程 <packaging>pom</packaging>\n\n 3.  在父项目下创建 ==提供者== 无骨架maven项目（用于 用户业务操作服务\n\n 4.  提供者项目 pom.xml\n     \n     <?xml version="1.0" encoding="utf-8"?>\n     <project xmlns="http://maven.apache.org/pom/4.0.0"\n              xmlns:xsi="http://www.w3.org/2001/xmlschema-instance"\n              xsi:schemalocation="http://maven.apache.org/pom/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">\n     \n         <parent>\n             <artifactid>springcloud-father</artifactid>\n             <groupid>com.sans</groupid>\n             <version>1.0-snapshot</version>\n         </parent>\n         <modelversion>4.0.0</modelversion>\n     \n         <artifactid>user-service</artifactid>\n     \n         <dependencies>\n             <dependency>\n                 <groupid>org.springframework.boot</groupid>\n                 <artifactid>spring-boot-starter-web</artifactid>\n             </dependency>\n             \x3c!-- 通用mapper启动器 --\x3e\n             <dependency>\n                 <groupid>tk.mybatis</groupid>\n                 <artifactid>mapper-spring-boot-starter</artifactid>\n             </dependency>\n             \x3c!-- mysql驱动 --\x3e\n             <dependency>\n                 <groupid>mysql</groupid>\n                 <artifactid>mysql-connector-java</artifactid>\n             </dependency>\n         </dependencies>\n     \n     </project>\n     \n     \n     > 组件依赖的版本号由父项目的pom进行配置\n\n 5.  提供者项目 大致流程 （==controller、mapper、pojo、service、启动类 组件==\n     \n     >  * 配置需要改 端口号 ， 提供者 和 调用者 端口以防冲突\n     >  * controller提供的接口： http://localhost:80/user/2 (按id查用户)\n\n 6.  在父项目下创建 ==调用者== 无骨架maven项目 （通过提供者获取接口进行 用户业务操作服务\n\n 7.  调用者项目 只需 ==添加web依赖 、模板方法、实体pojo、contoller==\n\n 8.  调用者项目 pom.xml\n     \n     \x3c!--调用者只需一个web依赖--\x3e\n     <dependencies>\n         <dependency>\n             <groupid>org.springframework.boot</groupid>\n             <artifactid>spring-boot-starter-web</artifactid>\n         </dependency>\n     </dependencies>\n     \n\n 9.  调用者项目 启动器类 添加模板工具方法\n     \n     @springbootapplication\n     public class application {\n         \n         public static void main(string[] args) {\n             springapplication.run(application.class, args);\n         }\n         \n         @bean\n         public resttemplate resttemplate() {\n             return new resttemplate();\n         }\n         \n     }\n     \n\n 10. 调用者项目 contoller （ pojo的user实体类、端口无配置默认8080\n     \n     @restcontroller\n     @requestmapping("consumer")\n     public class consumercontroller {\n         \n         @autowired\n         private resttemplate resttemplate;\n         \n          @requestmapping("{id}")\n         public user findbyid(@pathvariable long id) {\n             string url = "http://localhost:9091/user/"+id;\n             return resttemplate.getforobject(url , user.class);\n         }\n         \n     }\n     \n     \n     > spring提供了一个 resttemplate模板工具类，对基于http的客户端进行了封装，并且实现了 对象 与 json的序列化 、反序列化，非常方便。resttemplate并没有限定http的客户端类型，而是进行了抽象，目前常用的3种都有支持：\n     > \n     >  * httpclient\n     >  * okhttp\n     >  * jdk原生的urlconnection（默认的）\n\n 11. 测试 分别启动两个子项目\n     \n     通过 调用者接口中应用 提供者的接口\n     \n     访问 http://localhost:8080/consumer/2 (按id查用户)\n     \n     ----------------------------------------\n     \n     仓库代码 : https://gitee.com/sanscan12/spring-cloud-examples.git',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Eureka 注册中心",frontmatter:{title:"Eureka 注册中心",author:"柏竹",permalink:"/backend/wx8zdz",date:"2020-02-18T00:00:00.000Z",categories:["后端"],tags:["SpringClound","Java"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/09.SpringClound/02.Eureka%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83.html",relativePath:"01.后端/09.SpringClound/02.Eureka服务注册中心.md",key:"v-57f0b14b",path:"/backend/wx8zdz/",headers:[{level:2,title:"Eureka 组件",slug:"eureka-组件",normalizedTitle:"eureka 组件",charIndex:76},{level:2,title:"Eureka 配置",slug:"eureka-配置",normalizedTitle:"eureka 配置",charIndex:1161},{level:3,title:"服务注册",slug:"服务注册",normalizedTitle:"服务注册",charIndex:104},{level:3,title:"服务续约",slug:"服务续约",normalizedTitle:"服务续约",charIndex:1954},{level:3,title:"失效剔除&自我保护",slug:"失效剔除-自我保护",normalizedTitle:"失效剔除&amp;自我保护",charIndex:null},{level:3,title:"开发者配置",slug:"开发者配置",normalizedTitle:"开发者配置",charIndex:3724}],headersStr:"Eureka 组件 Eureka 配置 服务注册 服务续约 失效剔除&自我保护 开发者配置",content:"# Eureka 注册中心\n\nEureka 是 微服务的套件，基于 REST服务 。用于定位服务，以实现云端中间层服务发现 和 故障转移等功能\n\n\n# Eureka 组件\n\n * Eureka Server 服务注册中心（服务方） 提供 服务注册 和 发现 功能\n * Service Provider 服务器 （提供方） 将自身服务注册到 Eureka ，使 客户端 可业务服务功能\n * Service Consumer 客户端（应用方） 从 Eureka 获取注册服务列表，实现 业务服务 功能\n\n\n\nEureka Serve 也可是一个集群。如果Eureka Serve是个集群，当 提供者在集群的某个节点注册时，该节点会把服务的信息同步到每一个集群节点中，从而实现任意节点都可获取完整的服务列表！\n\nEureka Serve集群示例\n\n以下示范用三个 Eureka Server ，每个都需要注册其他 Eureka 服务中\n\n例如：分别有 8000、8001、8002，则他们分别注册的有：\n\n * 8000 注册到 8001、8002上\n * 8001 注册到 8000、8002上\n * 8002 注册到 8000、8001上\n\n# 8000 配置\n---\nspring:\n  application:\n    name: eureka-server\nserver:\n  port: 8000\neureka:\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:8001/eureka/,http://localhost:8002/eureka/\n---\n\n# 8001 配置\n---\nspring:\n  application:\n    name: eureka-server\nserver:\n  port: 8001\neureka:\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:8000/eureka/,http://localhost:8002/eureka/\n---\n\n# 8002 配置\n---\nspring:\n  application:\n    name: eureka-server\nserver:\n  port: 8002\neureka:\n  client:\n    serviceUrl:\n      defaultZone: http://localhost:8000/eureka/,http://localhost:8001/eureka/\n---\n\n\n随意访问一个 Eureka Server 的节点。效果图如下：\n\n\n\n\n# Eureka 配置\n\n主要说明 Eureka有关组件的配置：\n\n * Eureka客户端\n   * 服务提供\n     * 服务地址ip\n     * 续约（心跳\n   * 消费服务\n     * 获取服务频率\n * Eureka-server 工程\n   * 失效剔除\n   * 自我保护\n\n善用 Ctrl+F\n\n配置属性                                                   值 (默认)            说明\neureka.client.register-with-erueka                     boolean (true)    注册自己\neureka.client.fetch-registry                           boolean (true)    读取服务列表\neureka.client.registry-fetch-interval-seconds          int (30s)         获取注册列表的频率\neureka.instance.ip-address                             String            指定ip地址\neureka.instance.prefer-ip-address                      boolean (false)   获取ip优先于host\neureka.instance.lease-expiration-duration-in-seconds   int (90s)         续约等待时长\neureka.instance.lease-renewal-interval-in-seconds      int (30s)         服务续约间隔\neureka.client.service-url.defaultZone                  String            服务注册地址\neureka.server.enable-self-preservation                 boolean (true)    自我保护模式\neureka.server.eviction-interval-timer-in-ms            int (60000ms)     扫描失效服务间隔\n\n\n# 服务注册\n\neureka.lient.register-with-erueka 注册信息允许他人发现（包括自己，该配置如果为true，会向 Eureka Server 发起Rest请求，携带本身元数据信息，Eureka Server 会把这些信息 以双层Map结构进行保存\n\nMAP层级   KEY              VALUE\n第一层     服务名称             第二层Map\n第二层     IP + 服务名 + 端口号   服务的实例对象\n\n> 例如： map<String1 , map<String2 , ServiceInstance>>\n> \n> String1 : user-service\n> \n> String2 : 127.0.0.1:user-service:8082\n\n涉及 服务注册 的配置属性\n\n# 指定ip地址\neureka.instance.ip-address : 127.0.0.1 \n# 优先应用ip，并非 host\neureka.instance.prefer-ip-address : false\n# 向 Eureka Server 注册其信息以供其他人发现\neureka.client.register-with-eureka: true\n# 从 Eureka Server 获取注册服务的频率 ，默认30s\neureka.client.registry-fetch-interval-seconds : 30\n# 消费者向注册服务的地址。Eureka Server 地址,多个地址以','隔开（提高成功率\neureka.client.service-url.defaultZone : url\n\n\n\n# 服务续约\n\n在服务注册完成后，提供者会维持一个心跳，定时向Eureka Server发起Rest请求。以心跳的形式表明它仍然活着就（可称为服务的续约\n\n涉及 服务续约 的配置属性\n\n# 指示 Eureka Server 等待时长接收心跳，一旦超出等待时间且没有心跳信号，则移出服务列表\neureka.instance.lease-expiration-duration-in-seconds : 90 \n# 提供者发送心跳的频率，默认30s\neureka.instance.lease-renewal-interval-in-seconds : 30 \n\n\n\n# 失效剔除&自我保护\n\n涉及 Eureka Server 的配置\n\n# 自我保护模式 关闭 （默认打开\neureka.server.enable-self-preservation : true\n# 扫描失效服务的间隔时间 (默认: 60000ms\neureka.server.eviction-interval-timer-in-ms : 60000\n\n\n失效剔除\n\n当 Eureka Server 在启动完成后 ，eureka.server.eviction-interval-timer-in-ms : 60000 会每隔60000ms检查服务失效情况，如果某个服务节点超过90秒未收到心跳信号，那么 Eureka Server 会视为故障，将该服务剔除 （默认情况下 最长的剔除周期：90s+60s\n\n自我保护\n\nEureka Server 统计最近15min心跳失败的提供者比例，比例一旦到达85%，则触发自我保护机制，Eureka Server 视为网络故障等问题，Eureka Server 会锁定服务列表（以防失效剔除），这一过程保证了服务仍然可用，但不能保证访问的成功率\n\n\n# 开发者配置\n\n为了开发环境下，能够快速得到服务的最新状态，我们可以将其设置小一点\n\n提供者\n\neureka:\n  instance:\n    lease-expiration-duration-in-seconds: 10 # 10秒即过期\n    lease-renewal-interval-in-seconds: 5 # 5秒一次心跳\n\n\n消费者\n\neureka:\n  client:\n    registry-fetch-interval-seconds: 5 # 获取注册列表间隔\n\n\nEureka Server\n\neureka:\n  server:\n    enable-self-preservation: false # 关闭自我保护模式\n    eviction-interval-timer-in-ms: 1000 # 扫描失效服务的间隔\n\n\n----------------------------------------\n\n仓库代码 : https://gitee.com/Sanscan12/spring-cloud-examples.git",normalizedContent:"# eureka 注册中心\n\neureka 是 微服务的套件，基于 rest服务 。用于定位服务，以实现云端中间层服务发现 和 故障转移等功能\n\n\n# eureka 组件\n\n * eureka server 服务注册中心（服务方） 提供 服务注册 和 发现 功能\n * service provider 服务器 （提供方） 将自身服务注册到 eureka ，使 客户端 可业务服务功能\n * service consumer 客户端（应用方） 从 eureka 获取注册服务列表，实现 业务服务 功能\n\n\n\neureka serve 也可是一个集群。如果eureka serve是个集群，当 提供者在集群的某个节点注册时，该节点会把服务的信息同步到每一个集群节点中，从而实现任意节点都可获取完整的服务列表！\n\neureka serve集群示例\n\n以下示范用三个 eureka server ，每个都需要注册其他 eureka 服务中\n\n例如：分别有 8000、8001、8002，则他们分别注册的有：\n\n * 8000 注册到 8001、8002上\n * 8001 注册到 8000、8002上\n * 8002 注册到 8000、8001上\n\n# 8000 配置\n---\nspring:\n  application:\n    name: eureka-server\nserver:\n  port: 8000\neureka:\n  client:\n    serviceurl:\n      defaultzone: http://localhost:8001/eureka/,http://localhost:8002/eureka/\n---\n\n# 8001 配置\n---\nspring:\n  application:\n    name: eureka-server\nserver:\n  port: 8001\neureka:\n  client:\n    serviceurl:\n      defaultzone: http://localhost:8000/eureka/,http://localhost:8002/eureka/\n---\n\n# 8002 配置\n---\nspring:\n  application:\n    name: eureka-server\nserver:\n  port: 8002\neureka:\n  client:\n    serviceurl:\n      defaultzone: http://localhost:8000/eureka/,http://localhost:8001/eureka/\n---\n\n\n随意访问一个 eureka server 的节点。效果图如下：\n\n\n\n\n# eureka 配置\n\n主要说明 eureka有关组件的配置：\n\n * eureka客户端\n   * 服务提供\n     * 服务地址ip\n     * 续约（心跳\n   * 消费服务\n     * 获取服务频率\n * eureka-server 工程\n   * 失效剔除\n   * 自我保护\n\n善用 ctrl+f\n\n配置属性                                                   值 (默认)            说明\neureka.client.register-with-erueka                     boolean (true)    注册自己\neureka.client.fetch-registry                           boolean (true)    读取服务列表\neureka.client.registry-fetch-interval-seconds          int (30s)         获取注册列表的频率\neureka.instance.ip-address                             string            指定ip地址\neureka.instance.prefer-ip-address                      boolean (false)   获取ip优先于host\neureka.instance.lease-expiration-duration-in-seconds   int (90s)         续约等待时长\neureka.instance.lease-renewal-interval-in-seconds      int (30s)         服务续约间隔\neureka.client.service-url.defaultzone                  string            服务注册地址\neureka.server.enable-self-preservation                 boolean (true)    自我保护模式\neureka.server.eviction-interval-timer-in-ms            int (60000ms)     扫描失效服务间隔\n\n\n# 服务注册\n\neureka.lient.register-with-erueka 注册信息允许他人发现（包括自己，该配置如果为true，会向 eureka server 发起rest请求，携带本身元数据信息，eureka server 会把这些信息 以双层map结构进行保存\n\nmap层级   key              value\n第一层     服务名称             第二层map\n第二层     ip + 服务名 + 端口号   服务的实例对象\n\n> 例如： map<string1 , map<string2 , serviceinstance>>\n> \n> string1 : user-service\n> \n> string2 : 127.0.0.1:user-service:8082\n\n涉及 服务注册 的配置属性\n\n# 指定ip地址\neureka.instance.ip-address : 127.0.0.1 \n# 优先应用ip，并非 host\neureka.instance.prefer-ip-address : false\n# 向 eureka server 注册其信息以供其他人发现\neureka.client.register-with-eureka: true\n# 从 eureka server 获取注册服务的频率 ，默认30s\neureka.client.registry-fetch-interval-seconds : 30\n# 消费者向注册服务的地址。eureka server 地址,多个地址以','隔开（提高成功率\neureka.client.service-url.defaultzone : url\n\n\n\n# 服务续约\n\n在服务注册完成后，提供者会维持一个心跳，定时向eureka server发起rest请求。以心跳的形式表明它仍然活着就（可称为服务的续约\n\n涉及 服务续约 的配置属性\n\n# 指示 eureka server 等待时长接收心跳，一旦超出等待时间且没有心跳信号，则移出服务列表\neureka.instance.lease-expiration-duration-in-seconds : 90 \n# 提供者发送心跳的频率，默认30s\neureka.instance.lease-renewal-interval-in-seconds : 30 \n\n\n\n# 失效剔除&自我保护\n\n涉及 eureka server 的配置\n\n# 自我保护模式 关闭 （默认打开\neureka.server.enable-self-preservation : true\n# 扫描失效服务的间隔时间 (默认: 60000ms\neureka.server.eviction-interval-timer-in-ms : 60000\n\n\n失效剔除\n\n当 eureka server 在启动完成后 ，eureka.server.eviction-interval-timer-in-ms : 60000 会每隔60000ms检查服务失效情况，如果某个服务节点超过90秒未收到心跳信号，那么 eureka server 会视为故障，将该服务剔除 （默认情况下 最长的剔除周期：90s+60s\n\n自我保护\n\neureka server 统计最近15min心跳失败的提供者比例，比例一旦到达85%，则触发自我保护机制，eureka server 视为网络故障等问题，eureka server 会锁定服务列表（以防失效剔除），这一过程保证了服务仍然可用，但不能保证访问的成功率\n\n\n# 开发者配置\n\n为了开发环境下，能够快速得到服务的最新状态，我们可以将其设置小一点\n\n提供者\n\neureka:\n  instance:\n    lease-expiration-duration-in-seconds: 10 # 10秒即过期\n    lease-renewal-interval-in-seconds: 5 # 5秒一次心跳\n\n\n消费者\n\neureka:\n  client:\n    registry-fetch-interval-seconds: 5 # 获取注册列表间隔\n\n\neureka server\n\neureka:\n  server:\n    enable-self-preservation: false # 关闭自我保护模式\n    eviction-interval-timer-in-ms: 1000 # 扫描失效服务的间隔\n\n\n----------------------------------------\n\n仓库代码 : https://gitee.com/sanscan12/spring-cloud-examples.git",charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Hystrix 熔断器",frontmatter:{title:"Hystrix 熔断器",author:"柏竹",permalink:"/backend/ask5pn",date:"2020-02-18T00:00:00.000Z",categories:["后端"],tags:["SpringClound","Java"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/09.SpringClound/04.Hystrix%E7%86%94%E6%96%AD%E5%99%A8.html",relativePath:"01.后端/09.SpringClound/04.Hystrix熔断器.md",key:"v-1a1104fd",path:"/backend/ask5pn/",headers:[{level:2,title:"雪崩效应",slug:"雪崩效应",normalizedTitle:"雪崩效应",charIndex:276},{level:2,title:"线程隔离&服务降级",slug:"线程隔离-服务降级",normalizedTitle:"线程隔离&amp;服务降级",charIndex:null},{level:3,title:"示例",slug:"示例",normalizedTitle:"示例",charIndex:559},{level:3,title:"超时设置",slug:"超时设置",normalizedTitle:"超时设置",charIndex:2759},{level:2,title:"熔断器",slug:"熔断器",normalizedTitle:"熔断器",charIndex:10},{level:3,title:"示例",slug:"示例-2",normalizedTitle:"示例",charIndex:559},{level:3,title:"配置熔断策略",slug:"配置熔断策略",normalizedTitle:"配置熔断策略",charIndex:4560}],headersStr:"雪崩效应 线程隔离&服务降级 示例 超时设置 熔断器 示例 配置熔断策略",content:'# Hystrix 熔断器\n\nHystrix 是一个用于分布式系统的 ==延迟==、==容错== 的开源库。在分布式系统里，许多依赖不可避免的调用失败，比如超时、异常等。==Hystrix能够保证在一个依赖出问题的情况下，不会导致整个服务失败==，避免级联故障，以提高分布式系统的弹性。\n\nHystrix 能为系统做：\n\n * 保护并控制通过第三方客户库访问的 延迟 和 故障（通常是通过网络访问的依赖关系）\n * 停止复杂分布式系统中的级联故障\n * 失败快速和快速恢复\n * 回退，并尽可能优雅地降级\n * 实现近实时监控、警报和操作控制\n\n\n# 雪崩效应\n\n在 分布式系统 中通常有多个服务进行调用，这一高并发的过程难免会有故障的时候，消费者一旦请求出现故障，请求会被堵塞，tomcat不会释放该线程，于是请求越来越多，最终导致服务器资源耗尽，形成了雪崩效应\n\n\n\n> 提供者E 突然发生故障，导致线程堵塞\n\n\n# 线程隔离&服务降级\n\n线程隔离：将请求资源用 ==线程池== 进行隔离，如果线程池已满，将不进行排队，直接判定为失败\n\n服务降级：请求失败，会返回失败的提示（如 ：对不起，网络太拥堵了 请求服务降级有以下两种的情况\n\n 1. 被分配到已满的线程池\n 2. 请求超时（超时时长自行配置\n\n\n\n\n# 示例\n\n代码在上篇文章的基础上进行添加编辑：Java学习记录 03Spring Cloud 负载均衡Ribbon\n\n 1. 消费者 添加依赖\n    \n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-netflix-hystrix</artifactId>\n    </dependency>\n    \n\n 2. 消费者 启动类 ，添加注解 @EnableCircuitBreaker\n    \n    // @EnableDiscoveryClient // Eureka客户端\n    // @EnableCircuitBreaker  // 熔断器\n    // @SpringBootApplication\n    // 该注解组合以上3个注解\n    @SpringCloudApplication\n    public class ConsumerApplication {\n        // ....\n    }\n    \n    \n    > @SpringCloudApplication 注解整合了 Eureka、Hystrix、启动器 注解\n\n 3. 消费者 服务降级处理 ，controller\n    \n    降级处理有两种方式：\n    \n    方式   注解                                                   用于                     优点\n    1    @HystrixCommand(fallbackMethod = "{降级服务的方法名}")       方法                     降级服务的方法可获取方法的参数\n    2    @DefaultProperties(defaultFallback = "{降级服务的方法名}")   类、接口、枚举、Annotation类型   可统一降级服务，降低维护成本\n    \n    @RestController\n    @RequestMapping("consumer")\n    @Slf4j\n    // 方式2.1 多接口响应\n    @DefaultProperties (defaultFallback = "defaultFallback")\n    public class ConsumerController {\n        \n        @Autowired\n        private RestTemplate restTemplate;\n        \n        //...\n        \n        @RequestMapping("{id}")\n        // 方式1.1 单个接口响应\n        // @HystrixCommand(fallbackMethod = "queryByIdFallback")\n        // 方式2.2\n        @HystrixCommand\n        public String findById(@PathVariable Long id) throws InterruptedException {\n            String url = "HTTP://user-service/user/"+id;\n            return restTemplate.getForObject(url , String.class);\n        }\n        \n        // 方式1.2（方式1有参数接收，因 方式1 写在方法里！\n        public String queryByIdFallback(Long id) {\n            log.error("查询信息失败1，id : {}",id);\n            return "对不起，网络太拥堵了！(Test1";\n        }\n        \n        // 方式2.3\n        public String defaultFallback() {\n            log.error("查询信息失败2");\n            return "对不起，网络太拥挤了！(Test2";\n        }\n        \n    }\n    \n    \n    > 修改了 findById()方法 的返回值，从 提供者 那获取也是json格式，为了也方便降级数据的返回，因此返回值为String\n\n 4. 测试\n    \n    1. 依次打开 Eureka、server、consumer 三个服务\n    2. 访问 http://localhost:8080/consumer/1 （返回 数据\n    3. 关闭 server 再次访问以上请求\n    4. 页面返回："对不起，网络太拥挤了！(Test2 " （成功降级服务处理\n\n\n# 超时设置\n\n 1. 消费者 application.yml ，添加超时配置\n    \n    # 请求超过2s回返回错误，默认1s（测试用\n    hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=2000\n    \n\n 2. 提供者 controller 休眠 （只为触发超时 休眠写 被调用服务的方法里\n    \n    @RequestMapping("{id}")\n    public User findById(@PathVariable Long id) {\n        /* \n           测试 : 超时请求延迟 \n           识别判断：保留1为小数\n        */\n        Thread.sleep(2000);\n        // Thread.sleep(1900);\n        return service.findById(id);\n    }\n    \n\n 3. 测试\n    \n    1. 依次打开 Eureka、server、consumer 三个服务\n    2. 打开浏览器F12 检查请求的时长，访问 http://localhost:8080/consumer/1 （返回 数据\n    3. 休眠2s返回结果："对不起，网络太拥挤了！(Test2 " （成功降级服务处理\n    4. 休眠1.9s返回结果：数据\n\n\n# 熔断器\n\n熔断器它会在一段时间内检测请求异常，如果末段时间内异常超出一定比例时，则迫使请求进行 降级服务 ，并非 调用提供者，从而防止更多请求发生同样的失败操作。一旦触发熔断器打开，需要等待休眠，休眠结束后会释放少部分请求进行测试，如果还是出现问题，则继续打开熔断器，否则关闭熔断器\n\n> 日常例子：\n> \n> 好比家用的漏电开关，一旦电压不稳定，就打开电闸，断开电源\n\n\n\n熔断器计算 出来的状态分别有：\n\n * Closed (关闭)：所有请求正常访问\n * Open (打开)：所有请求降级服务\n * Half-Open (半打开)：当打开的熔断器休眠结束后，会释放部分请求，如果都是健康，就关闭熔断器，否则保持打开熔断器\n\n熔断器的 默认配置&触发条件：\n\n * 最小请求次数 20次\n * 异常比例阈值 50%\n * 熔断休眠时长 5s\n\n> 解释：5s内访问次数20次，如果超过10次的是异常，则打开熔断器 休眠5s\n\n\n# 示例\n\n在以上代码的基础上进行编辑\n\n 1. 消费者 controller 制造异常 （上面的 Hystrix依赖 也要有！！！）\n    \n    @RequestMapping("{id}")\n    @HystrixCommand\n    public String findById(@PathVariable Long id) throws InterruptedException {\n    \n        // 测试 ：异常制造 （实现熔断器报错预期\n        if (id == 1) {\n            throw new RuntimeException("忙碌");\n        }\n        \n       \t//..\n        \n        String url = "HTTP://user-service/user/"+id;\n        \n        return restTemplate.getForObject(url , String.class);\n    }\n    \n    \n    > 注意：上面测试代码，如果打开有休眠，先清空添加的休眠代码\n\n 2. 测试 流程：先访问 ==请求1== 20+次 (制造异常触发熔断器)，然后在访问 ==请求2== (访问失败)\n    \n    1. 触发阈值的请求：http://localhost:8080/consumer/1 （注定失败\n    2. 测试熔断的请求：http://localhost:8080/consumer/2 （测试熔断\n    \n    > 熔断器的触发条件上面说有，就不赘述了\n\n\n# 配置熔断策略\n\n修改熔断器的 默认配置：\n\n# 熔断触发最小请求次数，默认值是20\nhystrix.command.default.circuitBreaker.requestVolumeThreshold=10\n# 熔断后休眠时长，默认值5000ms\nhystrix.command.default.circuitBreaker.sleepWindowInMilliseconds=10000\n# 触发熔断错误比例阈值，默认值50%\nhystrix.command.default.circuitBreaker.errorThresholdPercentage=50\n# 请求超过2s回返回错误，默认1000ms\nhystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=2000\n\n\n> 以上配置可自行尝试调用\n\n----------------------------------------\n\n仓库代码 : https://gitee.com/Sanscan12/spring-cloud-examples.git',normalizedContent:'# hystrix 熔断器\n\nhystrix 是一个用于分布式系统的 ==延迟==、==容错== 的开源库。在分布式系统里，许多依赖不可避免的调用失败，比如超时、异常等。==hystrix能够保证在一个依赖出问题的情况下，不会导致整个服务失败==，避免级联故障，以提高分布式系统的弹性。\n\nhystrix 能为系统做：\n\n * 保护并控制通过第三方客户库访问的 延迟 和 故障（通常是通过网络访问的依赖关系）\n * 停止复杂分布式系统中的级联故障\n * 失败快速和快速恢复\n * 回退，并尽可能优雅地降级\n * 实现近实时监控、警报和操作控制\n\n\n# 雪崩效应\n\n在 分布式系统 中通常有多个服务进行调用，这一高并发的过程难免会有故障的时候，消费者一旦请求出现故障，请求会被堵塞，tomcat不会释放该线程，于是请求越来越多，最终导致服务器资源耗尽，形成了雪崩效应\n\n\n\n> 提供者e 突然发生故障，导致线程堵塞\n\n\n# 线程隔离&服务降级\n\n线程隔离：将请求资源用 ==线程池== 进行隔离，如果线程池已满，将不进行排队，直接判定为失败\n\n服务降级：请求失败，会返回失败的提示（如 ：对不起，网络太拥堵了 请求服务降级有以下两种的情况\n\n 1. 被分配到已满的线程池\n 2. 请求超时（超时时长自行配置\n\n\n\n\n# 示例\n\n代码在上篇文章的基础上进行添加编辑：java学习记录 03spring cloud 负载均衡ribbon\n\n 1. 消费者 添加依赖\n    \n    <dependency>\n        <groupid>org.springframework.cloud</groupid>\n        <artifactid>spring-cloud-starter-netflix-hystrix</artifactid>\n    </dependency>\n    \n\n 2. 消费者 启动类 ，添加注解 @enablecircuitbreaker\n    \n    // @enablediscoveryclient // eureka客户端\n    // @enablecircuitbreaker  // 熔断器\n    // @springbootapplication\n    // 该注解组合以上3个注解\n    @springcloudapplication\n    public class consumerapplication {\n        // ....\n    }\n    \n    \n    > @springcloudapplication 注解整合了 eureka、hystrix、启动器 注解\n\n 3. 消费者 服务降级处理 ，controller\n    \n    降级处理有两种方式：\n    \n    方式   注解                                                   用于                     优点\n    1    @hystrixcommand(fallbackmethod = "{降级服务的方法名}")       方法                     降级服务的方法可获取方法的参数\n    2    @defaultproperties(defaultfallback = "{降级服务的方法名}")   类、接口、枚举、annotation类型   可统一降级服务，降低维护成本\n    \n    @restcontroller\n    @requestmapping("consumer")\n    @slf4j\n    // 方式2.1 多接口响应\n    @defaultproperties (defaultfallback = "defaultfallback")\n    public class consumercontroller {\n        \n        @autowired\n        private resttemplate resttemplate;\n        \n        //...\n        \n        @requestmapping("{id}")\n        // 方式1.1 单个接口响应\n        // @hystrixcommand(fallbackmethod = "querybyidfallback")\n        // 方式2.2\n        @hystrixcommand\n        public string findbyid(@pathvariable long id) throws interruptedexception {\n            string url = "http://user-service/user/"+id;\n            return resttemplate.getforobject(url , string.class);\n        }\n        \n        // 方式1.2（方式1有参数接收，因 方式1 写在方法里！\n        public string querybyidfallback(long id) {\n            log.error("查询信息失败1，id : {}",id);\n            return "对不起，网络太拥堵了！(test1";\n        }\n        \n        // 方式2.3\n        public string defaultfallback() {\n            log.error("查询信息失败2");\n            return "对不起，网络太拥挤了！(test2";\n        }\n        \n    }\n    \n    \n    > 修改了 findbyid()方法 的返回值，从 提供者 那获取也是json格式，为了也方便降级数据的返回，因此返回值为string\n\n 4. 测试\n    \n    1. 依次打开 eureka、server、consumer 三个服务\n    2. 访问 http://localhost:8080/consumer/1 （返回 数据\n    3. 关闭 server 再次访问以上请求\n    4. 页面返回："对不起，网络太拥挤了！(test2 " （成功降级服务处理\n\n\n# 超时设置\n\n 1. 消费者 application.yml ，添加超时配置\n    \n    # 请求超过2s回返回错误，默认1s（测试用\n    hystrix.command.default.execution.isolation.thread.timeoutinmilliseconds=2000\n    \n\n 2. 提供者 controller 休眠 （只为触发超时 休眠写 被调用服务的方法里\n    \n    @requestmapping("{id}")\n    public user findbyid(@pathvariable long id) {\n        /* \n           测试 : 超时请求延迟 \n           识别判断：保留1为小数\n        */\n        thread.sleep(2000);\n        // thread.sleep(1900);\n        return service.findbyid(id);\n    }\n    \n\n 3. 测试\n    \n    1. 依次打开 eureka、server、consumer 三个服务\n    2. 打开浏览器f12 检查请求的时长，访问 http://localhost:8080/consumer/1 （返回 数据\n    3. 休眠2s返回结果："对不起，网络太拥挤了！(test2 " （成功降级服务处理\n    4. 休眠1.9s返回结果：数据\n\n\n# 熔断器\n\n熔断器它会在一段时间内检测请求异常，如果末段时间内异常超出一定比例时，则迫使请求进行 降级服务 ，并非 调用提供者，从而防止更多请求发生同样的失败操作。一旦触发熔断器打开，需要等待休眠，休眠结束后会释放少部分请求进行测试，如果还是出现问题，则继续打开熔断器，否则关闭熔断器\n\n> 日常例子：\n> \n> 好比家用的漏电开关，一旦电压不稳定，就打开电闸，断开电源\n\n\n\n熔断器计算 出来的状态分别有：\n\n * closed (关闭)：所有请求正常访问\n * open (打开)：所有请求降级服务\n * half-open (半打开)：当打开的熔断器休眠结束后，会释放部分请求，如果都是健康，就关闭熔断器，否则保持打开熔断器\n\n熔断器的 默认配置&触发条件：\n\n * 最小请求次数 20次\n * 异常比例阈值 50%\n * 熔断休眠时长 5s\n\n> 解释：5s内访问次数20次，如果超过10次的是异常，则打开熔断器 休眠5s\n\n\n# 示例\n\n在以上代码的基础上进行编辑\n\n 1. 消费者 controller 制造异常 （上面的 hystrix依赖 也要有！！！）\n    \n    @requestmapping("{id}")\n    @hystrixcommand\n    public string findbyid(@pathvariable long id) throws interruptedexception {\n    \n        // 测试 ：异常制造 （实现熔断器报错预期\n        if (id == 1) {\n            throw new runtimeexception("忙碌");\n        }\n        \n       \t//..\n        \n        string url = "http://user-service/user/"+id;\n        \n        return resttemplate.getforobject(url , string.class);\n    }\n    \n    \n    > 注意：上面测试代码，如果打开有休眠，先清空添加的休眠代码\n\n 2. 测试 流程：先访问 ==请求1== 20+次 (制造异常触发熔断器)，然后在访问 ==请求2== (访问失败)\n    \n    1. 触发阈值的请求：http://localhost:8080/consumer/1 （注定失败\n    2. 测试熔断的请求：http://localhost:8080/consumer/2 （测试熔断\n    \n    > 熔断器的触发条件上面说有，就不赘述了\n\n\n# 配置熔断策略\n\n修改熔断器的 默认配置：\n\n# 熔断触发最小请求次数，默认值是20\nhystrix.command.default.circuitbreaker.requestvolumethreshold=10\n# 熔断后休眠时长，默认值5000ms\nhystrix.command.default.circuitbreaker.sleepwindowinmilliseconds=10000\n# 触发熔断错误比例阈值，默认值50%\nhystrix.command.default.circuitbreaker.errorthresholdpercentage=50\n# 请求超过2s回返回错误，默认1000ms\nhystrix.command.default.execution.isolation.thread.timeoutinmilliseconds=2000\n\n\n> 以上配置可自行尝试调用\n\n----------------------------------------\n\n仓库代码 : https://gitee.com/sanscan12/spring-cloud-examples.git',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Feign",frontmatter:{title:"Feign",author:"柏竹",permalink:"/backend/kej3du",date:"2020-02-18T00:00:00.000Z",categories:["后端"],tags:["SpringClound","Java"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/09.SpringClound/05.Feign.html",relativePath:"01.后端/09.SpringClound/05.Feign.md",key:"v-1b4d203a",path:"/backend/kej3du/",headers:[{level:2,title:"Feign-Ribbon",slug:"feign-ribbon",normalizedTitle:"feign-ribbon",charIndex:1725},{level:2,title:"Feign-Hystrix",slug:"feign-hystrix",normalizedTitle:"feign-hystrix",charIndex:2278},{level:2,title:"Feign-日志",slug:"feign-日志",normalizedTitle:"feign-日志",charIndex:4089},{level:3,title:"http压缩",slug:"http压缩",normalizedTitle:"http压缩",charIndex:5492}],headersStr:"Feign-Ribbon Feign-Hystrix Feign-日志 http压缩",content:'# Feign\n\nFeign 是一个声明式的 REST客户端，它能让 REST 调用更加简单\n\nFeign 供了 HTTP 请求的模板，通过 接口 、注解的形式，定义好 HTTP 参数\n\n示例\n\n大致流程概述：\n\n>  1. 消费者 引入依赖\n>  2. 消费者 启动器类 添加注解 @EnableFeignClients\n>  3. 消费者 创建 服务客户端接口 （用于访问请求的\n>  4. 消费者 创建 新的controller （用于测试 步骤3访问可行\n\n 1. 消费者 pom.xml (主要依赖\n    \n    \x3c!-- Feign --\x3e\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-openfeign</artifactId>\n    </dependency>\n    \n\n 2. 消费者 启动类，添加注解 @EnableFeignClients\n    \n    @SpringCloudApplication\n    @EnableFeignClients // 启动 feign功能\n    public class ConsumerApplication {\n        \n        public static void main(String[] args) {\n            SpringApplication.run(ConsumerApplication.class, args);\n        }\n        \n        @Bean\n        // Ribbon 启动负载均衡\n        @LoadBalanced\n        public RestTemplate restTemplate() {\n            return new RestTemplate();\n        }\n        \n    }\n    \n\n 3. 消费者 创建Feign客户端，以接口形式存在\n    \n    //标识 Feign客户端\n    @FeignClient("user-service")\n    public interface UserService {\n        \n        // http://user-service/user/1 （前提：该url可访问\n        @GetMapping("user/{id}")\n        User queryById(@PathVariable ("id")Long id);\n        \n    }\n    \n    \n    >  * 该接口主要作用是 无需手动拼接 url，通过注释进行拼接url（不同方法都有各自的拼接结果\n    >  * @FeignClient 注释的value需要指定 ==服务名称==\n\n 4. 消费者 创建新的 controller ConsumerFeignController类\n    \n    @RestController\n    public class ConsumerFeignController {\n        \n        @Autowired\n        private UserService client;\n        \n        @GetMapping ("/cf/{id}")\n        public User queryById(@PathVariable Long id) {\n            return client.queryById(id);\n        }\n        \n    }\n    \n    \n    > 用于测试接口访问\n\n 5. 测试 访问 http://localhost:8080/cf/1 （代码以上篇文章为基础，因此访问IP一样\n\n\n# Feign-Ribbon\n\nRibbon主要用于配置请求时长、重新访问等相关配置\n\nFeign本身集成了 Ribbon依赖 和 自动配置（无需再次配置Ribbon\n\n由于自动配置的缘故，我们只需关注主要的配置信息\n\n配置                                值 (默认)            说明\nribbon.ConnectTimeout             int (1000ms)      连接超时时长 (两端连接最长时长，超出则超时)\nribbon.ReadTimeout                int (1000ms)      请求处理超时时长 (连接后读取资源最长时长，超出则超时)！\nribbon.MaxAutoRetries             int (0)           对请求的失败重试次数\nribbon.MaxAutoRetriesNextServer   int (1)           对请求失败重试换节点次数\nribbon.OkToRetryOnAllOperations   boolean (false)   是否对所有的请求方式都重试\n\n> 支持 全局配置 或 单个服务配置\n\n以上参数自行在浏览器测试\n\n\n# Feign-Hystrix\n\nFeign 默认也集成 Hystrix依赖\n\n详细了解：04Spring Cloud 熔断器Hystrix\n\n应用说明：\n\n * 默认是关闭Hystrix ，需要手动配置Hystrix打开\n * 需要为 Feign客户端 注解添加降级服务的指定类\n * 需要为 Feign客户端 编写falback作为降级处理\n\n示例\n\n在以上代码基础上进行编辑测试\n\n 1. 启动Hystrix。消费者 配置启动\n    \n    # feign-hystrix\n    feign :\n        hystrix :\n            # 熔断器打开\n            enabled : true\n    \n\n 2. 启动类 添加 @EnableHystrix注解\n    \n    @SpringCloudApplication\n    @EnableEurekaClient\n    @EnableFeignClients // 启动 feign功能\n    public class ConsumerApplication {\n        \n        public static void main(String[] args) {\n            SpringApplication.run(ConsumerApplication.class, args);\n        }\n        \n        @Bean\n        // Ribbon 启动负载均衡\n        @LoadBalanced\n        public RestTemplate restTemplate() {\n            return new RestTemplate();\n        }\n        \n    }\n    \n\n 3. 降级服务模板。为 Feign客户端 创建 Fallback模板\n    \n    // 为UserService接口 Fallback降级服务\n    @Component\n    @Slf4j\n    public class UserServiceFallback implements UserService{\n        \n        @Override\n        public User queryById(Long id) {\n            User user = new User();\n            user.setId(id);\n            user.setName("用户异常");\n            log.error("访问拥堵！{}",id);\n            return user;\n        }\n        \n    }\n    \n    \n    >  * @Component注解 自动扫描对象 （添加容器自动注入的应用\n    >  * 实现 指定服务的接口\n\n 4. Feign客户端 降级服务。注解 fallback值：需要指定Fallback模板类\n    \n    //标识 Feign客户端 (添加 Fallback降级服务\n    @FeignClient(value = "user-service",fallback = UserServiceFallback.class)\n    public interface UserService {\n        \n        // http://user-service/user/1\n        @GetMapping("user/{id}")\n        User queryById(@PathVariable ("id")Long id);\n        \n    }\n    \n\n 5. 测试\n    \n    1. 依次打开 Eureka、server、consumer 三个服务\n    2. 浏览器访问 http://localhost:8080/cf/1 （访问成功\n    3. 关闭 server 再次访问以上请求\n    4. 再次访问以上链接，会返回 降级的fallback模板\n\n\n# Feign-日志\n\nFeign日志 专门记录 请求/响应 的信息\n\nLevel级别\n\nLevel级别 会根据不同的配置，分别记录不同的信息\n\nLEVEL级别     说明\nNONE (默认)   不记录任何信息\nBASIC       只记录请求方法，URL以及响应状态码、执行时间\nHEADERS     在BASIC的基础上，额外记录 请求/响应 头信息\nFULL        记录 请求/响应 明细信息（请求头、请求体、元数据）\n\n应用说明：\n\n * Feign日志 需要在指定包下配置 日志级别\n * Feign客户端 也需添加注解 configuration值 指定 Feign日志配置类\n\n示例\n\n 1. 配置日志级别。消费者 配置 日志级别 debug\n    \n    # 日志级别\n    logging :\n        level :\n            com.sans : debug\n    \n\n 2. 创建 Feign日志配置类 。消费者 创建 Feign日志配置类 指定 level级别\n    \n    package com.sans.config;\n    \n    // 配置类\n    @Configuration\n    public class FeignConfig {\n        \n        /* 请求级别：\n            - NONE：不记录任何信息(默认值)\n            - BASIC：只记录请求方法，URL以及响应状态码、执行时间\n            - HEADERS：在BASIC的基础上，额外记录 请求/响应 头信息\n            - FULL：记录 请求/响应 明细信息（请求头、请求体、元数据）\n        * */\n        \n        @Bean\n        public Logger.Level feignLoggerLevel() {\n            return Logger.Level.FULL;\n        }\n        \n    }\n    \n\n 3. 接口注释。消费者 Feign客户端 @FeignClient注解 configuration值 添加 Feign日志配置类\n    \n    @FeignClient(value = "user-service",fallback = UserServiceFallback.class,configuration = FeignConfig.class)\n    public interface UserService {\n        \n        // http://user-service/user/1\n        @GetMapping("user/{id}")\n        User queryById(@PathVariable ("id")Long id);\n        \n    }\n    \n\n 4. 测试\n    \n    1. 依次打开 Eureka、server、consumer 三个服务\n    2. 浏览器访问 http://localhost:8080/cf/1 （访问成功\n    3. 查看控制台日志\n\n\n# http压缩\n\nFeign 也支持 请求/响应 进行GZIP压缩，减少传输性能损耗\n\n需要手动启动 配置示例：\n\nfeign :\n    # 日志 请求/响应 分别启动\n    compression:\n        request:\n\t        # 开启请求压缩\n            enabled: true \n            # 设置压缩的数据类型 (默认)\n            mime-types: text/html,application/xml,application/json \n            # 设置触发压缩的大小下限 (默认)\n            min-request-size: 2048 \n        response:\n\t        # 开启响应压缩\n            enabled: true \n\n\n> 以上配置除了 压缩 启动，其他应用默认值即可\n\n----------------------------------------\n\n仓库代码 : https://gitee.com/Sanscan12/spring-cloud-examples.git',normalizedContent:'# feign\n\nfeign 是一个声明式的 rest客户端，它能让 rest 调用更加简单\n\nfeign 供了 http 请求的模板，通过 接口 、注解的形式，定义好 http 参数\n\n示例\n\n大致流程概述：\n\n>  1. 消费者 引入依赖\n>  2. 消费者 启动器类 添加注解 @enablefeignclients\n>  3. 消费者 创建 服务客户端接口 （用于访问请求的\n>  4. 消费者 创建 新的controller （用于测试 步骤3访问可行\n\n 1. 消费者 pom.xml (主要依赖\n    \n    \x3c!-- feign --\x3e\n    <dependency>\n        <groupid>org.springframework.cloud</groupid>\n        <artifactid>spring-cloud-starter-openfeign</artifactid>\n    </dependency>\n    \n\n 2. 消费者 启动类，添加注解 @enablefeignclients\n    \n    @springcloudapplication\n    @enablefeignclients // 启动 feign功能\n    public class consumerapplication {\n        \n        public static void main(string[] args) {\n            springapplication.run(consumerapplication.class, args);\n        }\n        \n        @bean\n        // ribbon 启动负载均衡\n        @loadbalanced\n        public resttemplate resttemplate() {\n            return new resttemplate();\n        }\n        \n    }\n    \n\n 3. 消费者 创建feign客户端，以接口形式存在\n    \n    //标识 feign客户端\n    @feignclient("user-service")\n    public interface userservice {\n        \n        // http://user-service/user/1 （前提：该url可访问\n        @getmapping("user/{id}")\n        user querybyid(@pathvariable ("id")long id);\n        \n    }\n    \n    \n    >  * 该接口主要作用是 无需手动拼接 url，通过注释进行拼接url（不同方法都有各自的拼接结果\n    >  * @feignclient 注释的value需要指定 ==服务名称==\n\n 4. 消费者 创建新的 controller consumerfeigncontroller类\n    \n    @restcontroller\n    public class consumerfeigncontroller {\n        \n        @autowired\n        private userservice client;\n        \n        @getmapping ("/cf/{id}")\n        public user querybyid(@pathvariable long id) {\n            return client.querybyid(id);\n        }\n        \n    }\n    \n    \n    > 用于测试接口访问\n\n 5. 测试 访问 http://localhost:8080/cf/1 （代码以上篇文章为基础，因此访问ip一样\n\n\n# feign-ribbon\n\nribbon主要用于配置请求时长、重新访问等相关配置\n\nfeign本身集成了 ribbon依赖 和 自动配置（无需再次配置ribbon\n\n由于自动配置的缘故，我们只需关注主要的配置信息\n\n配置                                值 (默认)            说明\nribbon.connecttimeout             int (1000ms)      连接超时时长 (两端连接最长时长，超出则超时)\nribbon.readtimeout                int (1000ms)      请求处理超时时长 (连接后读取资源最长时长，超出则超时)！\nribbon.maxautoretries             int (0)           对请求的失败重试次数\nribbon.maxautoretriesnextserver   int (1)           对请求失败重试换节点次数\nribbon.oktoretryonalloperations   boolean (false)   是否对所有的请求方式都重试\n\n> 支持 全局配置 或 单个服务配置\n\n以上参数自行在浏览器测试\n\n\n# feign-hystrix\n\nfeign 默认也集成 hystrix依赖\n\n详细了解：04spring cloud 熔断器hystrix\n\n应用说明：\n\n * 默认是关闭hystrix ，需要手动配置hystrix打开\n * 需要为 feign客户端 注解添加降级服务的指定类\n * 需要为 feign客户端 编写falback作为降级处理\n\n示例\n\n在以上代码基础上进行编辑测试\n\n 1. 启动hystrix。消费者 配置启动\n    \n    # feign-hystrix\n    feign :\n        hystrix :\n            # 熔断器打开\n            enabled : true\n    \n\n 2. 启动类 添加 @enablehystrix注解\n    \n    @springcloudapplication\n    @enableeurekaclient\n    @enablefeignclients // 启动 feign功能\n    public class consumerapplication {\n        \n        public static void main(string[] args) {\n            springapplication.run(consumerapplication.class, args);\n        }\n        \n        @bean\n        // ribbon 启动负载均衡\n        @loadbalanced\n        public resttemplate resttemplate() {\n            return new resttemplate();\n        }\n        \n    }\n    \n\n 3. 降级服务模板。为 feign客户端 创建 fallback模板\n    \n    // 为userservice接口 fallback降级服务\n    @component\n    @slf4j\n    public class userservicefallback implements userservice{\n        \n        @override\n        public user querybyid(long id) {\n            user user = new user();\n            user.setid(id);\n            user.setname("用户异常");\n            log.error("访问拥堵！{}",id);\n            return user;\n        }\n        \n    }\n    \n    \n    >  * @component注解 自动扫描对象 （添加容器自动注入的应用\n    >  * 实现 指定服务的接口\n\n 4. feign客户端 降级服务。注解 fallback值：需要指定fallback模板类\n    \n    //标识 feign客户端 (添加 fallback降级服务\n    @feignclient(value = "user-service",fallback = userservicefallback.class)\n    public interface userservice {\n        \n        // http://user-service/user/1\n        @getmapping("user/{id}")\n        user querybyid(@pathvariable ("id")long id);\n        \n    }\n    \n\n 5. 测试\n    \n    1. 依次打开 eureka、server、consumer 三个服务\n    2. 浏览器访问 http://localhost:8080/cf/1 （访问成功\n    3. 关闭 server 再次访问以上请求\n    4. 再次访问以上链接，会返回 降级的fallback模板\n\n\n# feign-日志\n\nfeign日志 专门记录 请求/响应 的信息\n\nlevel级别\n\nlevel级别 会根据不同的配置，分别记录不同的信息\n\nlevel级别     说明\nnone (默认)   不记录任何信息\nbasic       只记录请求方法，url以及响应状态码、执行时间\nheaders     在basic的基础上，额外记录 请求/响应 头信息\nfull        记录 请求/响应 明细信息（请求头、请求体、元数据）\n\n应用说明：\n\n * feign日志 需要在指定包下配置 日志级别\n * feign客户端 也需添加注解 configuration值 指定 feign日志配置类\n\n示例\n\n 1. 配置日志级别。消费者 配置 日志级别 debug\n    \n    # 日志级别\n    logging :\n        level :\n            com.sans : debug\n    \n\n 2. 创建 feign日志配置类 。消费者 创建 feign日志配置类 指定 level级别\n    \n    package com.sans.config;\n    \n    // 配置类\n    @configuration\n    public class feignconfig {\n        \n        /* 请求级别：\n            - none：不记录任何信息(默认值)\n            - basic：只记录请求方法，url以及响应状态码、执行时间\n            - headers：在basic的基础上，额外记录 请求/响应 头信息\n            - full：记录 请求/响应 明细信息（请求头、请求体、元数据）\n        * */\n        \n        @bean\n        public logger.level feignloggerlevel() {\n            return logger.level.full;\n        }\n        \n    }\n    \n\n 3. 接口注释。消费者 feign客户端 @feignclient注解 configuration值 添加 feign日志配置类\n    \n    @feignclient(value = "user-service",fallback = userservicefallback.class,configuration = feignconfig.class)\n    public interface userservice {\n        \n        // http://user-service/user/1\n        @getmapping("user/{id}")\n        user querybyid(@pathvariable ("id")long id);\n        \n    }\n    \n\n 4. 测试\n    \n    1. 依次打开 eureka、server、consumer 三个服务\n    2. 浏览器访问 http://localhost:8080/cf/1 （访问成功\n    3. 查看控制台日志\n\n\n# http压缩\n\nfeign 也支持 请求/响应 进行gzip压缩，减少传输性能损耗\n\n需要手动启动 配置示例：\n\nfeign :\n    # 日志 请求/响应 分别启动\n    compression:\n        request:\n\t        # 开启请求压缩\n            enabled: true \n            # 设置压缩的数据类型 (默认)\n            mime-types: text/html,application/xml,application/json \n            # 设置触发压缩的大小下限 (默认)\n            min-request-size: 2048 \n        response:\n\t        # 开启响应压缩\n            enabled: true \n\n\n> 以上配置除了 压缩 启动，其他应用默认值即可\n\n----------------------------------------\n\n仓库代码 : https://gitee.com/sanscan12/spring-cloud-examples.git',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Config 配置中心",frontmatter:{title:"Config 配置中心",author:"柏竹",permalink:"/backend/4iocm4",date:"2020-02-18T00:00:00.000Z",categories:["后端"],tags:["SpringClound","Java"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/09.SpringClound/07.Config%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83.html",relativePath:"01.后端/09.SpringClound/07.Config配置中心.md",key:"v-020f8ced",path:"/backend/4iocm4/",headers:[{level:2,title:"搭建远端仓库",slug:"搭建远端仓库",normalizedTitle:"搭建远端仓库",charIndex:161},{level:3,title:"配置文件命名规则",slug:"配置文件命名规则",normalizedTitle:"配置文件命名规则",charIndex:571},{level:2,title:"搭建配置中心",slug:"搭建配置中心",normalizedTitle:"搭建配置中心",charIndex:938},{level:2,title:"服务获取配置",slug:"服务获取配置",normalizedTitle:"服务获取配置",charIndex:3046}],headersStr:"搭建远端仓库 配置文件命名规则 搭建配置中心 服务获取配置",content:"# Config 配置中心\n\nSpring Cloud Config 为微服务提供了集中式的配置方案，它主要通过远端仓库进行获取相关配置文件\n\n\n\n> 配置中心也是微服务，需要注册到 Eureka 服务注册中心\n\n主要功能：\n\n * 提供 配置服务支持\n * 集中管理各个环境的配置文件\n * 仓库 版本管理模式\n\n\n# 搭建远端仓库\n\n远端仓库搭建于 gitee，把之前配置好的 application.yml 文件信息，推送到远端仓库中，进行服务！\n\n>  * 由于GitHub国内访问较慢，因此应用 gitee 示例\n>  * 对 Git 不了解？ 点击 Git 应用 了解\n\n示例\n\n 1. 创建仓库\n    \n    > 如果创建仓库为 公开 ，配置中心 无需配置密码\n\n 2. 创建两个文件夹 API、config\n    \n    > 待会测试不同子目录访问\n\n 3. 根据以往配置有 user-server、consumer、gateway 。分别将这些服务的配置存储到仓库的不同目录中，并重新命名 (命名很重要)\n    \n    * ==/user-dev.yml== （仓库根目录）\n    * ==API/gateway-dev.yml==\n    * ==config/consumer-dev.yml==\n\n\n# 配置文件命名规则\n\n一般情况配置中心会通过远端的配置文件名称进行锁定应用，正因如此 配置文件的命名会直接关系到 服务的配置是否生效\n\n命名方式：\n\n * =={application}-{profile}.yml==\n * =={application}-{profile}.properties==\n\napplication ：服务名称\n\nprofile ：区分 环境 。分别有 dev (开发环境) ; test (测试环境) ; pro (生产环境)\n\n这是 user-server 服务的配置 重命为 user-dev.yml ，其他服务也如此\n\n\n\n> 其实命名参数的内容可以自定义，后面会根据这些参数 application ; profile ; 分支 进行锁定配置文件 (它们之间要有 - 分割，且顺序严格)\n\n\n# 搭建配置中心\n\nConfig 配置中心 是与远端仓库交互的微服务（由上图可以看到），前提也需注册到Eureka上进行服务 。主要用于配置 连接远端仓库、访问目录、账号密码 等相关 连接远端的配置\n\n示例\n\n基于以上篇章的基础进行测试\n\n 1. 创建 新Maven工程(无骨架) 我创建的工程名称 config-server\n\n 2. config-server 配置依赖 pom.xml\n    \n    \x3c!-- eureka --\x3e\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n    </dependency>\n    \x3c!-- config --\x3e\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-config-server</artifactId>\n    </dependency>\n    \n\n 3. config-server 启动类\n    \n    // Eureka客户端\n    @EnableDiscoveryClient\n    @SpringBootApplication\n    // 启用配置服务\n    @EnableConfigServer\n    public class ConfigApplication {\n        public static void main(String[] args) {\n            SpringApplication.run(ConfigApplication.class, args);\n        }\n    }\n    \n\n 4. config-server 配置文件 application.yml\n    \n    server :\n        port : 14000\n    eureka :\n        client :\n            service-url :\n                defaultZone : http://localhost:10086/eureka\n    spring :\n        application :\n            name : config-server\n        cloud:\n            config :\n                server :\n                    git :\n                        # 仓库 url\n                        uri : https://gitee.com/xxxx/my-config-test.git\n                        # 需要访问目录 (默认根路径开始) \n                        search-paths : 'API,config'\n                        # 以下配置在 仓库为私有的前提配置；公开无需配置\n                        # 用户名\n                        username : {gitee账号}\n                        # 密码\n                        password : {gitee密码}\n    \n                # 读取分支 (默认master)\n    #            label : test\n    \n    \n    > 注意：\n    > \n    >  * 公开仓库无需配置账号密码\n    >  * 指定子目录的配置需要 ' 符号括住；多个子目录需要 , 分隔符进行分隔\n\n 5. 测试\n    \n    依次启动 Eureka 、config-server 两个服务，分别访问一下地址：\n    \n    * http://localhost:14000/user-dev.yml\n    * http://localhost:14000/gateway-dev.yml\n    * http://localhost:14000/consumer-dev.yml\n    >  * 不用指定子路径可直接访问到 远端仓库的配置资源\n    >  * 访问 gateway 的资源时可能会出现被过滤器过滤的问题，因此需要 关闭跨域相关配置 或 赋予地址权限（不过 不关闭跨域也不会影响配置信息的读取，也就浏览器看不到而已）\n\n\n# 服务获取配置\n\n上面已经 搭建了 仓库、配置中心 ，因此可直接舍弃 user-server、consumer、gateway 三个微服务的配置，重新配置，主要访问远端的配置信息\n\n示例\n\n> 说明： 有三个微服务，我围绕 user-server 微服务进行配置，其他也如此，就不赘述了\n\n 1. user-server 添加依赖\n    \n    \x3c!-- config --\x3e\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-config</artifactId>\n    </dependency>\n    \n\n 2. user-server 删除 原有的 application.yml , 替换成 bootstrap.yml\n    \n    eureka :\n        client :\n            service-url :\n                defaultZone : http://127.0.0.1:10086/eureka\n    spring :\n        cloud : \n            config : \n                # 以下 指定 命名格式 进行查找\n                # 与仓库中配置文件的 application 保持一致\n                name : user\n                # 与仓库中的配置文件的 profile 保持一致\n                profile : dev\n                # 指定配置所属分支\n                label : master\n                discovery:\n                    # 使用配置中心\n                    enabled : true\n                    # 配置中心服务名\n                    service-id : config-server\n    \n\n 3. 测试\n    \n    1. 依次启动 Eureka 、config-server 、user-server 三个服务\n    2. 访问 http://localhost:9091/user/1 (返回数据表示成功)\n\n说明：\n\n * bootstrap.yml 也是默认配置文件 且比 application.yml 加载早\n * 锁定仓库中的配置有：name (服务名称) ; profile (环境) ; label (分支)\n * bootstrap.yml 相当于项目启动的引导文件\n\nbootstrap.yml 与 application.yml 的区别\n\n       BOOTSTRAP.YML   APPLICATION.YML\n配置级别   系统              应用\n加载时段   较早              较迟\n配置参数   较少变动            较多变动\n\n----------------------------------------\n\n----------------------------------------\n\n仓库代码 : https://gitee.com/Sanscan12/spring-cloud-examples.git\n\n官方文档 : Spring Cloud Config",normalizedContent:"# config 配置中心\n\nspring cloud config 为微服务提供了集中式的配置方案，它主要通过远端仓库进行获取相关配置文件\n\n\n\n> 配置中心也是微服务，需要注册到 eureka 服务注册中心\n\n主要功能：\n\n * 提供 配置服务支持\n * 集中管理各个环境的配置文件\n * 仓库 版本管理模式\n\n\n# 搭建远端仓库\n\n远端仓库搭建于 gitee，把之前配置好的 application.yml 文件信息，推送到远端仓库中，进行服务！\n\n>  * 由于github国内访问较慢，因此应用 gitee 示例\n>  * 对 git 不了解？ 点击 git 应用 了解\n\n示例\n\n 1. 创建仓库\n    \n    > 如果创建仓库为 公开 ，配置中心 无需配置密码\n\n 2. 创建两个文件夹 api、config\n    \n    > 待会测试不同子目录访问\n\n 3. 根据以往配置有 user-server、consumer、gateway 。分别将这些服务的配置存储到仓库的不同目录中，并重新命名 (命名很重要)\n    \n    * ==/user-dev.yml== （仓库根目录）\n    * ==api/gateway-dev.yml==\n    * ==config/consumer-dev.yml==\n\n\n# 配置文件命名规则\n\n一般情况配置中心会通过远端的配置文件名称进行锁定应用，正因如此 配置文件的命名会直接关系到 服务的配置是否生效\n\n命名方式：\n\n * =={application}-{profile}.yml==\n * =={application}-{profile}.properties==\n\napplication ：服务名称\n\nprofile ：区分 环境 。分别有 dev (开发环境) ; test (测试环境) ; pro (生产环境)\n\n这是 user-server 服务的配置 重命为 user-dev.yml ，其他服务也如此\n\n\n\n> 其实命名参数的内容可以自定义，后面会根据这些参数 application ; profile ; 分支 进行锁定配置文件 (它们之间要有 - 分割，且顺序严格)\n\n\n# 搭建配置中心\n\nconfig 配置中心 是与远端仓库交互的微服务（由上图可以看到），前提也需注册到eureka上进行服务 。主要用于配置 连接远端仓库、访问目录、账号密码 等相关 连接远端的配置\n\n示例\n\n基于以上篇章的基础进行测试\n\n 1. 创建 新maven工程(无骨架) 我创建的工程名称 config-server\n\n 2. config-server 配置依赖 pom.xml\n    \n    \x3c!-- eureka --\x3e\n    <dependency>\n        <groupid>org.springframework.cloud</groupid>\n        <artifactid>spring-cloud-starter-netflix-eureka-client</artifactid>\n    </dependency>\n    \x3c!-- config --\x3e\n    <dependency>\n        <groupid>org.springframework.cloud</groupid>\n        <artifactid>spring-cloud-config-server</artifactid>\n    </dependency>\n    \n\n 3. config-server 启动类\n    \n    // eureka客户端\n    @enablediscoveryclient\n    @springbootapplication\n    // 启用配置服务\n    @enableconfigserver\n    public class configapplication {\n        public static void main(string[] args) {\n            springapplication.run(configapplication.class, args);\n        }\n    }\n    \n\n 4. config-server 配置文件 application.yml\n    \n    server :\n        port : 14000\n    eureka :\n        client :\n            service-url :\n                defaultzone : http://localhost:10086/eureka\n    spring :\n        application :\n            name : config-server\n        cloud:\n            config :\n                server :\n                    git :\n                        # 仓库 url\n                        uri : https://gitee.com/xxxx/my-config-test.git\n                        # 需要访问目录 (默认根路径开始) \n                        search-paths : 'api,config'\n                        # 以下配置在 仓库为私有的前提配置；公开无需配置\n                        # 用户名\n                        username : {gitee账号}\n                        # 密码\n                        password : {gitee密码}\n    \n                # 读取分支 (默认master)\n    #            label : test\n    \n    \n    > 注意：\n    > \n    >  * 公开仓库无需配置账号密码\n    >  * 指定子目录的配置需要 ' 符号括住；多个子目录需要 , 分隔符进行分隔\n\n 5. 测试\n    \n    依次启动 eureka 、config-server 两个服务，分别访问一下地址：\n    \n    * http://localhost:14000/user-dev.yml\n    * http://localhost:14000/gateway-dev.yml\n    * http://localhost:14000/consumer-dev.yml\n    >  * 不用指定子路径可直接访问到 远端仓库的配置资源\n    >  * 访问 gateway 的资源时可能会出现被过滤器过滤的问题，因此需要 关闭跨域相关配置 或 赋予地址权限（不过 不关闭跨域也不会影响配置信息的读取，也就浏览器看不到而已）\n\n\n# 服务获取配置\n\n上面已经 搭建了 仓库、配置中心 ，因此可直接舍弃 user-server、consumer、gateway 三个微服务的配置，重新配置，主要访问远端的配置信息\n\n示例\n\n> 说明： 有三个微服务，我围绕 user-server 微服务进行配置，其他也如此，就不赘述了\n\n 1. user-server 添加依赖\n    \n    \x3c!-- config --\x3e\n    <dependency>\n        <groupid>org.springframework.cloud</groupid>\n        <artifactid>spring-cloud-starter-config</artifactid>\n    </dependency>\n    \n\n 2. user-server 删除 原有的 application.yml , 替换成 bootstrap.yml\n    \n    eureka :\n        client :\n            service-url :\n                defaultzone : http://127.0.0.1:10086/eureka\n    spring :\n        cloud : \n            config : \n                # 以下 指定 命名格式 进行查找\n                # 与仓库中配置文件的 application 保持一致\n                name : user\n                # 与仓库中的配置文件的 profile 保持一致\n                profile : dev\n                # 指定配置所属分支\n                label : master\n                discovery:\n                    # 使用配置中心\n                    enabled : true\n                    # 配置中心服务名\n                    service-id : config-server\n    \n\n 3. 测试\n    \n    1. 依次启动 eureka 、config-server 、user-server 三个服务\n    2. 访问 http://localhost:9091/user/1 (返回数据表示成功)\n\n说明：\n\n * bootstrap.yml 也是默认配置文件 且比 application.yml 加载早\n * 锁定仓库中的配置有：name (服务名称) ; profile (环境) ; label (分支)\n * bootstrap.yml 相当于项目启动的引导文件\n\nbootstrap.yml 与 application.yml 的区别\n\n       bootstrap.yml   application.yml\n配置级别   系统              应用\n加载时段   较早              较迟\n配置参数   较少变动            较多变动\n\n----------------------------------------\n\n----------------------------------------\n\n仓库代码 : https://gitee.com/sanscan12/spring-cloud-examples.git\n\n官方文档 : spring cloud config",charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Gateway 网关",frontmatter:{title:"Gateway 网关",author:"柏竹",permalink:"/backend/y2b432",date:"2020-02-18T00:00:00.000Z",categories:["后端"],tags:["SpringClound","Java"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/09.SpringClound/06.Gateway%E7%BD%91%E5%85%B3.html",relativePath:"01.后端/09.SpringClound/06.Gateway网关.md",key:"v-75e3f174",path:"/backend/y2b432/",headers:[{level:2,title:"核心功能",slug:"核心功能",normalizedTitle:"核心功能",charIndex:187},{level:2,title:"工作流程",slug:"工作流程",normalizedTitle:"工作流程",charIndex:401},{level:2,title:"过滤器",slug:"过滤器",normalizedTitle:"过滤器",charIndex:47},{level:3,title:"自定义局部过滤器",slug:"自定义局部过滤器",normalizedTitle:"自定义局部过滤器",charIndex:6237},{level:3,title:"自定义全局过滤器",slug:"自定义全局过滤器",normalizedTitle:"自定义全局过滤器",charIndex:9287},{level:2,title:"跨域配置",slug:"跨域配置",normalizedTitle:"跨域配置",charIndex:11016},{level:2,title:"负载均衡&熔断器",slug:"负载均衡-熔断器",normalizedTitle:"负载均衡&amp;熔断器",charIndex:null},{level:2,title:"Gateway与Feign的区别",slug:"gateway与feign的区别",normalizedTitle:"gateway与feign的区别",charIndex:12339}],headersStr:"核心功能 工作流程 过滤器 自定义局部过滤器 自定义全局过滤器 跨域配置 负载均衡&熔断器 Gateway与Feign的区别",content:'# Gateway 网关\n\nSpring Cloud Gateway 网关 组件核心是一系列的过滤器，通过这些过滤器可以将客户端发送的请求转发（路由）到对 应的服务。\n\n补充说明&优点\n\n * Gateway 替换了 Netflix Zuul 的一套解决方案\n * 隐藏 服务的 IP/端口 等信息\n * 提供统一的API路由管理方式 （url管理）\n * Gateway 核心功能 过滤/路由/断言\n * Gateway 也是个微服务，需要注册到 Eureka\n\n\n# 核心功能\n\n * Route (路由) ：路由信息由 ID、目标URL、一组断言、一组Filter 组成 （一般情况会通过断言进行判断 路由匹配）\n * Predicate (断言) ：定义匹配的 HTTP 中的任何信息（如：请求头/参数等...\n * Filter (过滤器) ：可在 请求/响应 进行一些业务上的处理\n\n\n# 工作流程\n\n\n\n说明：\n\n>  * 客户端 发出请求，如果请求与网关程序定义的路由匹配，则该请求就会被发送到网关 的微服务中进行处理，此时处理运行特定的请求过滤器链\n> \n>  * 过滤器虚线分开的原因：会在发送代理请求的 请求/响应 执行逻辑（所有 pre 过滤器逻辑先执行，然后执行 代理请求；代理请求完成后，执行 post 过滤器逻辑，进行响应）\n\n示例\n\n代码在 01Spring Cloud 的基础上进行编辑\n\n 1. 创建新Maven工程(无骨架) 我创建的工程名称 gateway\n\n 2. gateway 依赖配置 pom.xml\n    \n    \x3c!-- gateway --\x3e\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-gateway</artifactId>\n    </dependency>\n    \x3c!-- eureka --\x3e\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-starter-netflix-eureka-client</artifactId>\n    </dependency>\n    \n\n 3. gateway 启动类\n    \n    @SpringBootApplication\n    @EnableDiscoveryClient // Eureka客户端\n    public class GatewayApplication {\n        public static void main(String[] args) {\n            SpringApplication.run(GatewayApplication.class, args);\n        }\n    }\n    \n\n 4. gateway 配置 application.yml\n    \n    server :\n        port : 10010\n    spring :\n        application :\n            name : api-gateway\n        cloud :\n            gateway :\n                routes :\n                    # 路由id (随意)\n                    - id : user-service-route\n                      # 代理服务的地址\n    #                 uri: http://localhost:9091  # 方式1 固定代理\n                      uri : lb://user-service  # 方式2 动态代理\n                      # 路由断言，可以配置的映射路径\n                      predicates:\n                        - Path=/user/**\n    eureka :\n        client :\n            service-url :\n                defaultZone : http://localhost:10086/eureka\n        instance :\n            # 优先应用ip，并非 host\n            prefer-ip-address : true\n    \n    \n    > 注意：\n    > \n    >  * 填写路由断言的路径 不能存在空格 - Path=/user/**\n    > \n    > 说明：\n    > \n    >  * 代理路径 http://localhost:10010/user/1 ==> http://localhost:9091/user/1\n    >  * 代理路由 有两种方式写，但一般不会写死，因此应用第二种方式\n    >  * 路由配置中uri所用的协议为lb时，gateway 将使用 LoadBalancerClient 把 user-service 通过 eureka 解析为 实际IP 和 端口，并进行ribbon负载均衡\n\n 5. 测试\n    \n    1. 依次打开 Eureka、server、gateway 三个服务\n    2. 访问 http://localhost:10010/user/1（返回 数据代表成功）\n\n\n# 过滤器\n\n通过以上工作流程可得知 ，Gateway 的路由 过滤器允许 修改传入 请求/响应 的HTTP，只作用于特定的路由\n\n过滤器生命周期\n\nSpring Cloud Gateway 的 Filter 有两种： pre(请求被执行前调用)、post(请求被执行后调用) ，以上的工作流程可看出\n\n使用场景\n\n * 请求鉴权：过滤器链式 调用到 filter()方法 前，如果发现无权限，返回Null\n * 异常处理：过滤器链式 调用到 filter()方法 后，记录异常并返回\n * 服务调用时长统计：过滤器链式 调用到 filter()方法 前后，根据时长统计\n\n常用过滤器工厂\n\nGateway 中有很多内置的过滤器工厂，我们只需了解常用的过滤器\n\n过滤器工厂名称               说明\nAddRequestHeader      对匹配上的请求加上Header(请求头)\nRemoveRequestHeader   对匹配上的请求去除Header(请求头)\nAddRequestParameter   对匹配上的请求路由添加参数\nSetStatus             设置 HTTP请求 的响应码\nAddResponseHeader     对从网关返回的响应添加Header(响应头)\nStripPrefix           对匹配上的请求路径去除前缀\nPrefixPath            对匹配上的请求路径添加前缀\n\n更多详细参考 官网链接\n\n过滤器示例\n\nAddRequestHeader 添加请求头\n\n符合规则匹配成功的请求，将添加 X-Request-Foo:bar 请求头，将其传递到后端服务中\n\nspring :\n    application :\n        name : api-gateway\n    cloud :\n        gateway :\n            routes :\n                - id : user-service-route\n                  uri : lb://user-service\n                  predicates:\n                      - Path=/user/**\n                  filters:\n                  \t  # 参数：请求头，值\n\t\t\t\t\t  - AddRequestHeader=X-Request-Foo,Bar\n\n\nRemoveRequestHeader 移除请求头\n\n可以在请求转发到后端服务之前进行 Header 的移除操作\n\nspring :\n    application :\n        name : api-gateway\n    cloud :\n        gateway :\n            routes :\n                - id : user-service-route\n                  uri : lb://user-service\n                  predicates:\n                      - Path=/user/**\n                  filters:\n                  \t  # 参数：移除请求头 X-Request-Foo\n\t\t\t\t\t  - RemoveRequestHeader=X-Request-Foo\n\n\nAddRequestParameter 请求添加参数\n\n符合规则匹配成功的请求，将会附加 MyName=Sans 参数\n\nspring :\n    application :\n        name : api-gateway\n    cloud :\n        gateway :\n            routes :\n                - id : user-service-route\n                  uri : lb://user-service\n                  predicates:\n                      - Path=/user/**\n                  filters:\n                  \t  # 参数：名称，值 （类似于 K , V）\n\t\t\t\t\t  - AddRequestParameter=MyName,Sans\n\n\nSetStatus 响应返回码\n\n用于设置 HTTP请求 的响应码 ; 支持 整数/枚举 (org.springframework.http.HttpStatus类 查看枚举)\n\nspring :\n    application :\n        name : api-gateway\n    cloud :\n        gateway :\n            routes :\n                - id : user-service-route\n                  uri : lb://user-service\n                  predicates:\n                      - Path=/user/**\n                  filters:\n\t\t\t\t\t  - SetStatus=401\n\n\nAddResponseHeader 添加响应头\n\n网关响应添加响应头\n\nspring :\n    application :\n        name : api-gateway\n    cloud :\n        gateway :\n        \tdefault-filters:\n        \t\t- AddResponseHeader=X-Request-Foo,Bar\n\n\nStripPrefix 去除路由前缀\n\n对请求地址前缀去除后，再作为 代理地址\n\nspring :\n    application :\n        name : api-gateway\n    cloud :\n        gateway :\n            routes :\n                # 路由id (随意)\n                - id : user-service-route\n                  # 代理服务的地址\n#                  uri: http://localhost:9091  # 方式1\n                  uri : lb://user-service  # 方式2\n                  # 路由断言，可以配置的映射路径\n                  predicates:\n                    - Path=/api/user/**\n                  filters:\n                    - StripPrefix=1\n···\n\n\n如： http://localhost:10010/api/user/1 ==> http://localhost:9091/user/1 (去除/api)\n\nPrefixPath 添加路由前缀\n\n对请求地址添加前缀后，再作为 代理地址\n\nspring :\n    application :\n        name : api-gateway\n    cloud :\n        gateway :\n            routes :\n                # 路由id (随意)\n                - id : user-service-route\n                  # 代理服务的地址\n#                  uri: http://localhost:9091  # 方式1\n                  uri : lb://user-service  # 方式2\n                  # 路由断言，可以配置的映射路径\n                  predicates:\n                    - Path=/**\n                  filters:\n                    - PrefixPath=/user\n···\n\n\n如： http://localhost:10010/1 ==> http://localhost:9091/user/1 (添加/user)\n\n> 测试可自行在以下的自定义过滤器工厂测试检查属性变化\n\n\n# 自定义局部过滤器\n\nSpring Cloud Gateway 过滤器工厂 ，在请求传递的过程中，对请求进行 编辑/验证。（应用场景一般有：身份验证、选择集群中指定的微服务 等...\n\n示例\n\n> 说明：\n> \n>  * 自定义过滤器工厂需要继承 AbstractGatewayFilterFactory类，重写 apply()方法 , 且过滤器类命名以 GatewayFilterFactory 为后缀\n>  * 测试 请求参数 在控制台展示\n\n 1. 创建 自定义局部过滤器 (我创建的MyParamGatewayFilterFactory\n    \n    package com.sans.gateway.filter;\n    \n    import org.springframework.cloud.gateway.filter.GatewayFilter;\n    import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;\n    import org.springframework.http.server.reactive.ServerHttpRequest;\n    import org.springframework.stereotype.Component;\n    \n    import java.util.Arrays;\n    import java.util.List;\n    \n    @Component\n    public class MyParamGatewayFilterFactory extends AbstractGatewayFilterFactory<MyParamGatewayFilterFactory.Config> {\n        \n        /**构造函数*/\n        public MyParamGatewayFilterFactory() {\n            super(Config.class);\n        }\n        /** 初始化\n         * 读取配置文件中的参数，赋值到配置类中\n         * */\n        @Override\n        public List<String> shortcutFieldOrder() {\n            //一个参数\n            return Arrays.asList("params");\n        }\n        \n        /**过滤器逻辑*/\n        @Override\n        public GatewayFilter apply(Config config) {\n            // 实例化 GatewayFilter.filter()\n            //      exchange - 请求属性\n            //      chain - 提供一种委托给下一个过滤器的方法\n            return (exchange , chain) -> {\n                // 前置\n                ServerHttpRequest request = exchange.getRequest();\n                // 路由包含 name参数 则执行\n                if (request.getQueryParams().containsKey(config.params)) {\n                    request.getQueryParams().get(config.params).forEach((v)->{\n                        System.out.printf("局部过滤器 => %s = %s\\n",config.params,v);\n                    });\n                }\n        \n        /**读取过滤器配置的参数 (以对象形式存储*/\n        public static class Config {\n            // 对应配置在 application.yml 配置文件中的过滤参数\n            private String params;\n        \n            public String getParams() {\n                return params;\n            }\n        \n            public void setParams(String params) {\n                this.params = params;\n            }\n        }\n        \n        \n    }\n    \n\n 2. 配置 application.yml 添加 自定义过滤器\n    \n    spring :\n        cloud :\n            gateway :\n                routes :\n                    # 路由id (随意)\n                    - id : user-service-route\n                      # 代理服务的地址\n    #                  uri: http://localhost:9091  # 方式1\n                      uri : lb://user-service  # 方式2\n                      # 路由断言，可以配置的映射路径\n                      predicates:\n                          - Path=/user/**\n                      filters:\n                          # 添加自定义过滤器\n                          - MyParam=name\n    \n    \n    > 说明：\n    > \n    >  * 在配置中 过滤器指定可省略 GatewayFilterFactory 后缀\n    >  * 以上对应参数是 shortcutFieldOrder()方法 返回指定参数数量的List （以上我指定返回一个参数params 的List）\n\n 3. 测试\n    \n    1. 依次打开 Eureka、server、gateway 三个服务\n    2. 访问 http://localhost:10010/user/1?name=Sans\n    \n    > 访问后，控制台会打印，若参数名name不匹配，则不打印\n\n\n# 自定义全局过滤器\n\n全局过滤器作用于所有路由, 无需其他配置！！！一般情况用于权限统一验证，安全验证等功能...\n\n示例\n\n> 说明：\n> \n>  * 全局过滤器 需要实现 GlobalFilter接口\n>  * 过滤器顺序 需要实现 Ordered接口 指定数值（值越小越快\n>  * 测试 请求是否授权 。判断是否包含 token 的请求头\n\n 1. 创建 自定义全局过滤器 (我创建的MyGlobalFilter\n    \n    package com.sans.gateway.filter;\n    \n    import org.apache.commons.lang.StringUtils;\n    import org.springframework.cloud.gateway.filter.GatewayFilterChain;\n    import org.springframework.cloud.gateway.filter.GlobalFilter;\n    import org.springframework.core.Ordered;\n    import org.springframework.http.HttpStatus;\n    import org.springframework.stereotype.Component;\n    import org.springframework.web.server.ServerWebExchange;\n    import reactor.core.publisher.Mono;\n    \n    @Component\n    public class MyGlobalFilter implements GlobalFilter, Ordered {\n        \n        @Override\n        public Mono<Void> filter(ServerWebExchange exchange , GatewayFilterChain chain) {\n            System.out.println("=================全局过滤器MyGlobalFilter=================");\n            \n            String token = exchange.getRequest().getHeaders().getFirst("token");\n            if (StringUtils.isBlank(token)) {\n                // 设置响应状态码为未授权 401\n                exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);\n                return exchange.getResponse().setComplete();\n            }\n            \n            return chain.filter(exchange);\n        }\n        \n        /**设置过滤器优先顺序*/\n        @Override\n        public int getOrder() {\n            return 1;\n        }\n    }\n    \n\n 2. 测试 （由于需要为请求添加请求头）\n    \n    1. 依次打开 Eureka、server、gateway 三个服务\n    2. 通过 以下的IDEA内置的HTTP测试 以下有示例\n    \n    > 说明： 请求成功会 返回数据 ；请求失败会返回401 (未授权)\n\nIDEA内置HTTP调试\n\n 1. 创建测试 HTTP请求 草稿文件\n\n 2. 设置请求url测试\n    \n    > 有示例查看使用方式等功能...\n\n\n# 跨域配置\n\n跨域：当一个请求URL的 协议/域名/端口 之间任意一个与当前页面URL不同，称为跨域\n\n当前 URL                      被请求URL                            是否跨域   原因      比较\nhttp://www.test.com/        http://www.test.com/index.html    N      -       -\nhttp://www.test.com/        https://www.test.com/index.html   Y      协议不同    http/https\nhttp://www.test.com/        http://www.baidu.com/             Y      主域名不同   test/baidu\nhttp://www.test.com/        http://blog.test.com/             Y      子域名不同   www/blog\nhttp://www.test.com:8080/   http://www.test.com:7001/         Y      端口号不同   8080/7001\n\n这一跨域问题可通过 Gateway 网关服务器中配置即可。配置如下：\n\nspring :\n    application :\n        name : api-gateway\n    cloud :\n        gateway :\n            globalcors :\n                cors-configurations :\n                    # 代表所有访问到网关服务器上的地址\n                    \'[/**]\' :\n                    \t# 允许指定服务器地址访问 \n#                        allowedOrigins : *     # *代表全部支持访问\n                        allowedOrigins :\n                            - "http://demo.sans.top"\n                        allowedMethods :\n                            - GET\n\n\n> 上述配置 允许来自 http://demo.sans.top 的 GET请求 获取服务数据\n\n官方具体了解：CORS Configuration (spring.io)\n\n\n# 负载均衡&熔断器\n\nGateway 默认集成 Ribbon、Hystrix (配置策略也如此)。如有其它策略配置可点击一下链接了解相关配置\n\n * Spring Cloud Feign\n * Spring Cloud Hystrix_熔断器\n * Spring Cloud Ribbon_负载均衡\n\n\n# Gateway与Feign的区别\n\n       GATEWAY     FEIGN\n接口入口   统一服务入口      单一微服务入口\n接口安全   接口隐蔽应用      接口暴露应用\n路由处理   可以处理        固有。不能处理\n应用场景   权限检查、控制流量   微服务内部调用更方便\n\n----------------------------------------\n\n仓库代码 : https://gitee.com/Sanscan12/spring-cloud-examples.git',normalizedContent:'# gateway 网关\n\nspring cloud gateway 网关 组件核心是一系列的过滤器，通过这些过滤器可以将客户端发送的请求转发（路由）到对 应的服务。\n\n补充说明&优点\n\n * gateway 替换了 netflix zuul 的一套解决方案\n * 隐藏 服务的 ip/端口 等信息\n * 提供统一的api路由管理方式 （url管理）\n * gateway 核心功能 过滤/路由/断言\n * gateway 也是个微服务，需要注册到 eureka\n\n\n# 核心功能\n\n * route (路由) ：路由信息由 id、目标url、一组断言、一组filter 组成 （一般情况会通过断言进行判断 路由匹配）\n * predicate (断言) ：定义匹配的 http 中的任何信息（如：请求头/参数等...\n * filter (过滤器) ：可在 请求/响应 进行一些业务上的处理\n\n\n# 工作流程\n\n\n\n说明：\n\n>  * 客户端 发出请求，如果请求与网关程序定义的路由匹配，则该请求就会被发送到网关 的微服务中进行处理，此时处理运行特定的请求过滤器链\n> \n>  * 过滤器虚线分开的原因：会在发送代理请求的 请求/响应 执行逻辑（所有 pre 过滤器逻辑先执行，然后执行 代理请求；代理请求完成后，执行 post 过滤器逻辑，进行响应）\n\n示例\n\n代码在 01spring cloud 的基础上进行编辑\n\n 1. 创建新maven工程(无骨架) 我创建的工程名称 gateway\n\n 2. gateway 依赖配置 pom.xml\n    \n    \x3c!-- gateway --\x3e\n    <dependency>\n        <groupid>org.springframework.cloud</groupid>\n        <artifactid>spring-cloud-starter-gateway</artifactid>\n    </dependency>\n    \x3c!-- eureka --\x3e\n    <dependency>\n        <groupid>org.springframework.cloud</groupid>\n        <artifactid>spring-cloud-starter-netflix-eureka-client</artifactid>\n    </dependency>\n    \n\n 3. gateway 启动类\n    \n    @springbootapplication\n    @enablediscoveryclient // eureka客户端\n    public class gatewayapplication {\n        public static void main(string[] args) {\n            springapplication.run(gatewayapplication.class, args);\n        }\n    }\n    \n\n 4. gateway 配置 application.yml\n    \n    server :\n        port : 10010\n    spring :\n        application :\n            name : api-gateway\n        cloud :\n            gateway :\n                routes :\n                    # 路由id (随意)\n                    - id : user-service-route\n                      # 代理服务的地址\n    #                 uri: http://localhost:9091  # 方式1 固定代理\n                      uri : lb://user-service  # 方式2 动态代理\n                      # 路由断言，可以配置的映射路径\n                      predicates:\n                        - path=/user/**\n    eureka :\n        client :\n            service-url :\n                defaultzone : http://localhost:10086/eureka\n        instance :\n            # 优先应用ip，并非 host\n            prefer-ip-address : true\n    \n    \n    > 注意：\n    > \n    >  * 填写路由断言的路径 不能存在空格 - path=/user/**\n    > \n    > 说明：\n    > \n    >  * 代理路径 http://localhost:10010/user/1 ==> http://localhost:9091/user/1\n    >  * 代理路由 有两种方式写，但一般不会写死，因此应用第二种方式\n    >  * 路由配置中uri所用的协议为lb时，gateway 将使用 loadbalancerclient 把 user-service 通过 eureka 解析为 实际ip 和 端口，并进行ribbon负载均衡\n\n 5. 测试\n    \n    1. 依次打开 eureka、server、gateway 三个服务\n    2. 访问 http://localhost:10010/user/1（返回 数据代表成功）\n\n\n# 过滤器\n\n通过以上工作流程可得知 ，gateway 的路由 过滤器允许 修改传入 请求/响应 的http，只作用于特定的路由\n\n过滤器生命周期\n\nspring cloud gateway 的 filter 有两种： pre(请求被执行前调用)、post(请求被执行后调用) ，以上的工作流程可看出\n\n使用场景\n\n * 请求鉴权：过滤器链式 调用到 filter()方法 前，如果发现无权限，返回null\n * 异常处理：过滤器链式 调用到 filter()方法 后，记录异常并返回\n * 服务调用时长统计：过滤器链式 调用到 filter()方法 前后，根据时长统计\n\n常用过滤器工厂\n\ngateway 中有很多内置的过滤器工厂，我们只需了解常用的过滤器\n\n过滤器工厂名称               说明\naddrequestheader      对匹配上的请求加上header(请求头)\nremoverequestheader   对匹配上的请求去除header(请求头)\naddrequestparameter   对匹配上的请求路由添加参数\nsetstatus             设置 http请求 的响应码\naddresponseheader     对从网关返回的响应添加header(响应头)\nstripprefix           对匹配上的请求路径去除前缀\nprefixpath            对匹配上的请求路径添加前缀\n\n更多详细参考 官网链接\n\n过滤器示例\n\naddrequestheader 添加请求头\n\n符合规则匹配成功的请求，将添加 x-request-foo:bar 请求头，将其传递到后端服务中\n\nspring :\n    application :\n        name : api-gateway\n    cloud :\n        gateway :\n            routes :\n                - id : user-service-route\n                  uri : lb://user-service\n                  predicates:\n                      - path=/user/**\n                  filters:\n                  \t  # 参数：请求头，值\n\t\t\t\t\t  - addrequestheader=x-request-foo,bar\n\n\nremoverequestheader 移除请求头\n\n可以在请求转发到后端服务之前进行 header 的移除操作\n\nspring :\n    application :\n        name : api-gateway\n    cloud :\n        gateway :\n            routes :\n                - id : user-service-route\n                  uri : lb://user-service\n                  predicates:\n                      - path=/user/**\n                  filters:\n                  \t  # 参数：移除请求头 x-request-foo\n\t\t\t\t\t  - removerequestheader=x-request-foo\n\n\naddrequestparameter 请求添加参数\n\n符合规则匹配成功的请求，将会附加 myname=sans 参数\n\nspring :\n    application :\n        name : api-gateway\n    cloud :\n        gateway :\n            routes :\n                - id : user-service-route\n                  uri : lb://user-service\n                  predicates:\n                      - path=/user/**\n                  filters:\n                  \t  # 参数：名称，值 （类似于 k , v）\n\t\t\t\t\t  - addrequestparameter=myname,sans\n\n\nsetstatus 响应返回码\n\n用于设置 http请求 的响应码 ; 支持 整数/枚举 (org.springframework.http.httpstatus类 查看枚举)\n\nspring :\n    application :\n        name : api-gateway\n    cloud :\n        gateway :\n            routes :\n                - id : user-service-route\n                  uri : lb://user-service\n                  predicates:\n                      - path=/user/**\n                  filters:\n\t\t\t\t\t  - setstatus=401\n\n\naddresponseheader 添加响应头\n\n网关响应添加响应头\n\nspring :\n    application :\n        name : api-gateway\n    cloud :\n        gateway :\n        \tdefault-filters:\n        \t\t- addresponseheader=x-request-foo,bar\n\n\nstripprefix 去除路由前缀\n\n对请求地址前缀去除后，再作为 代理地址\n\nspring :\n    application :\n        name : api-gateway\n    cloud :\n        gateway :\n            routes :\n                # 路由id (随意)\n                - id : user-service-route\n                  # 代理服务的地址\n#                  uri: http://localhost:9091  # 方式1\n                  uri : lb://user-service  # 方式2\n                  # 路由断言，可以配置的映射路径\n                  predicates:\n                    - path=/api/user/**\n                  filters:\n                    - stripprefix=1\n···\n\n\n如： http://localhost:10010/api/user/1 ==> http://localhost:9091/user/1 (去除/api)\n\nprefixpath 添加路由前缀\n\n对请求地址添加前缀后，再作为 代理地址\n\nspring :\n    application :\n        name : api-gateway\n    cloud :\n        gateway :\n            routes :\n                # 路由id (随意)\n                - id : user-service-route\n                  # 代理服务的地址\n#                  uri: http://localhost:9091  # 方式1\n                  uri : lb://user-service  # 方式2\n                  # 路由断言，可以配置的映射路径\n                  predicates:\n                    - path=/**\n                  filters:\n                    - prefixpath=/user\n···\n\n\n如： http://localhost:10010/1 ==> http://localhost:9091/user/1 (添加/user)\n\n> 测试可自行在以下的自定义过滤器工厂测试检查属性变化\n\n\n# 自定义局部过滤器\n\nspring cloud gateway 过滤器工厂 ，在请求传递的过程中，对请求进行 编辑/验证。（应用场景一般有：身份验证、选择集群中指定的微服务 等...\n\n示例\n\n> 说明：\n> \n>  * 自定义过滤器工厂需要继承 abstractgatewayfilterfactory类，重写 apply()方法 , 且过滤器类命名以 gatewayfilterfactory 为后缀\n>  * 测试 请求参数 在控制台展示\n\n 1. 创建 自定义局部过滤器 (我创建的myparamgatewayfilterfactory\n    \n    package com.sans.gateway.filter;\n    \n    import org.springframework.cloud.gateway.filter.gatewayfilter;\n    import org.springframework.cloud.gateway.filter.factory.abstractgatewayfilterfactory;\n    import org.springframework.http.server.reactive.serverhttprequest;\n    import org.springframework.stereotype.component;\n    \n    import java.util.arrays;\n    import java.util.list;\n    \n    @component\n    public class myparamgatewayfilterfactory extends abstractgatewayfilterfactory<myparamgatewayfilterfactory.config> {\n        \n        /**构造函数*/\n        public myparamgatewayfilterfactory() {\n            super(config.class);\n        }\n        /** 初始化\n         * 读取配置文件中的参数，赋值到配置类中\n         * */\n        @override\n        public list<string> shortcutfieldorder() {\n            //一个参数\n            return arrays.aslist("params");\n        }\n        \n        /**过滤器逻辑*/\n        @override\n        public gatewayfilter apply(config config) {\n            // 实例化 gatewayfilter.filter()\n            //      exchange - 请求属性\n            //      chain - 提供一种委托给下一个过滤器的方法\n            return (exchange , chain) -> {\n                // 前置\n                serverhttprequest request = exchange.getrequest();\n                // 路由包含 name参数 则执行\n                if (request.getqueryparams().containskey(config.params)) {\n                    request.getqueryparams().get(config.params).foreach((v)->{\n                        system.out.printf("局部过滤器 => %s = %s\\n",config.params,v);\n                    });\n                }\n        \n        /**读取过滤器配置的参数 (以对象形式存储*/\n        public static class config {\n            // 对应配置在 application.yml 配置文件中的过滤参数\n            private string params;\n        \n            public string getparams() {\n                return params;\n            }\n        \n            public void setparams(string params) {\n                this.params = params;\n            }\n        }\n        \n        \n    }\n    \n\n 2. 配置 application.yml 添加 自定义过滤器\n    \n    spring :\n        cloud :\n            gateway :\n                routes :\n                    # 路由id (随意)\n                    - id : user-service-route\n                      # 代理服务的地址\n    #                  uri: http://localhost:9091  # 方式1\n                      uri : lb://user-service  # 方式2\n                      # 路由断言，可以配置的映射路径\n                      predicates:\n                          - path=/user/**\n                      filters:\n                          # 添加自定义过滤器\n                          - myparam=name\n    \n    \n    > 说明：\n    > \n    >  * 在配置中 过滤器指定可省略 gatewayfilterfactory 后缀\n    >  * 以上对应参数是 shortcutfieldorder()方法 返回指定参数数量的list （以上我指定返回一个参数params 的list）\n\n 3. 测试\n    \n    1. 依次打开 eureka、server、gateway 三个服务\n    2. 访问 http://localhost:10010/user/1?name=sans\n    \n    > 访问后，控制台会打印，若参数名name不匹配，则不打印\n\n\n# 自定义全局过滤器\n\n全局过滤器作用于所有路由, 无需其他配置！！！一般情况用于权限统一验证，安全验证等功能...\n\n示例\n\n> 说明：\n> \n>  * 全局过滤器 需要实现 globalfilter接口\n>  * 过滤器顺序 需要实现 ordered接口 指定数值（值越小越快\n>  * 测试 请求是否授权 。判断是否包含 token 的请求头\n\n 1. 创建 自定义全局过滤器 (我创建的myglobalfilter\n    \n    package com.sans.gateway.filter;\n    \n    import org.apache.commons.lang.stringutils;\n    import org.springframework.cloud.gateway.filter.gatewayfilterchain;\n    import org.springframework.cloud.gateway.filter.globalfilter;\n    import org.springframework.core.ordered;\n    import org.springframework.http.httpstatus;\n    import org.springframework.stereotype.component;\n    import org.springframework.web.server.serverwebexchange;\n    import reactor.core.publisher.mono;\n    \n    @component\n    public class myglobalfilter implements globalfilter, ordered {\n        \n        @override\n        public mono<void> filter(serverwebexchange exchange , gatewayfilterchain chain) {\n            system.out.println("=================全局过滤器myglobalfilter=================");\n            \n            string token = exchange.getrequest().getheaders().getfirst("token");\n            if (stringutils.isblank(token)) {\n                // 设置响应状态码为未授权 401\n                exchange.getresponse().setstatuscode(httpstatus.unauthorized);\n                return exchange.getresponse().setcomplete();\n            }\n            \n            return chain.filter(exchange);\n        }\n        \n        /**设置过滤器优先顺序*/\n        @override\n        public int getorder() {\n            return 1;\n        }\n    }\n    \n\n 2. 测试 （由于需要为请求添加请求头）\n    \n    1. 依次打开 eureka、server、gateway 三个服务\n    2. 通过 以下的idea内置的http测试 以下有示例\n    \n    > 说明： 请求成功会 返回数据 ；请求失败会返回401 (未授权)\n\nidea内置http调试\n\n 1. 创建测试 http请求 草稿文件\n\n 2. 设置请求url测试\n    \n    > 有示例查看使用方式等功能...\n\n\n# 跨域配置\n\n跨域：当一个请求url的 协议/域名/端口 之间任意一个与当前页面url不同，称为跨域\n\n当前 url                      被请求url                            是否跨域   原因      比较\nhttp://www.test.com/        http://www.test.com/index.html    n      -       -\nhttp://www.test.com/        https://www.test.com/index.html   y      协议不同    http/https\nhttp://www.test.com/        http://www.baidu.com/             y      主域名不同   test/baidu\nhttp://www.test.com/        http://blog.test.com/             y      子域名不同   www/blog\nhttp://www.test.com:8080/   http://www.test.com:7001/         y      端口号不同   8080/7001\n\n这一跨域问题可通过 gateway 网关服务器中配置即可。配置如下：\n\nspring :\n    application :\n        name : api-gateway\n    cloud :\n        gateway :\n            globalcors :\n                cors-configurations :\n                    # 代表所有访问到网关服务器上的地址\n                    \'[/**]\' :\n                    \t# 允许指定服务器地址访问 \n#                        allowedorigins : *     # *代表全部支持访问\n                        allowedorigins :\n                            - "http://demo.sans.top"\n                        allowedmethods :\n                            - get\n\n\n> 上述配置 允许来自 http://demo.sans.top 的 get请求 获取服务数据\n\n官方具体了解：cors configuration (spring.io)\n\n\n# 负载均衡&熔断器\n\ngateway 默认集成 ribbon、hystrix (配置策略也如此)。如有其它策略配置可点击一下链接了解相关配置\n\n * spring cloud feign\n * spring cloud hystrix_熔断器\n * spring cloud ribbon_负载均衡\n\n\n# gateway与feign的区别\n\n       gateway     feign\n接口入口   统一服务入口      单一微服务入口\n接口安全   接口隐蔽应用      接口暴露应用\n路由处理   可以处理        固有。不能处理\n应用场景   权限检查、控制流量   微服务内部调用更方便\n\n----------------------------------------\n\n仓库代码 : https://gitee.com/sanscan12/spring-cloud-examples.git',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Netty概述",frontmatter:{title:"Netty概述",author:"柏竹",permalink:"/backend/6nss7s",date:"2020-03-14T00:00:00.000Z",categories:["后端","网络","Java"],tags:["Netty","网络通信"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/10.Netty%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/01%E6%A6%82%E8%BF%B0.html",relativePath:"01.后端/10.Netty网络编程/01概述.md",key:"v-123114c4",path:"/backend/6nss7s/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:2},{level:2,title:"入门应用",slug:"入门应用",normalizedTitle:"入门应用",charIndex:146},{level:3,title:"BIO",slug:"bio",normalizedTitle:"bio",charIndex:118},{level:3,title:"NIO",slug:"nio",normalizedTitle:"nio",charIndex:13}],headersStr:"概述 入门应用 BIO NIO",content:'# 概述\n\nNetty是 NIO客户端服务器连接的框架 , 能够进行简单开发网络通信应用程序 , 只要有 服务器 连接至 客户端 就可称之为 IO 通信\n\nNetty测试需要JDK版本 1.8以上\n\nJava中IO程序分类 :\n\n * BIO (不建议)\n * NIO\n * AIO\n\n\n# 入门应用\n\n\n# BIO\n\n采用JavaSE库中的 Socket类 (套接字) , 了解可以看会我以前笔记 点击跳转\n\n简单应用\n\n通过 Java 运行的服务端 和 cmd telnet指令 通信\n\n 1. Java服务端代码\n    \n    点击代码展开\n    \n    \n    \n    \n    \n    \n    \n    \n    \n     \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    public class SocketServer {\n    \n        public static void main(String[] args) throws IOException {\n            // 监听本机端口\n            ServerSocket serverSocket = new ServerSocket(9099);\n            while (true) {\n                // 阻塞等待 客户端 连接\n                System.out.println("等待连接...");\n                Socket clientSocket = serverSocket.accept();\n                System.out.println("有客户连接了...");\n                handler(clientSocket);\n            }\n        }\n    \n        /**\n         * 接收消息\n         * @param clientSocket 客户套接字\n         */\n        private static void handler(Socket clientSocket) throws IOException {\n            byte[] bs = new byte[1024];\n            int read = clientSocket.getInputStream().read(bs);\n            System.out.println("read 完成..");\n            if (read != 1) {\n                System.out.println("收到数据: " + new String(bs, 0, read));\n            }\n        }\n    \n    }\n    \n\n 2. cmd 进入 , 执行 telent命令\n    \n    # 连接 本机:9099\n    telent localhost 9099 \n    # 更改模式 Ctrl+] \n    send {内容}\n    # 关闭连接 \n    quit\n    \n    \n    > cmd食用 telent命令 , 需要启动Windows功能\n    > \n    > 控制面板 -> 程序 -> Windows功能 -> 启动Telnet\n\n 3. 断点测试观察 代码块高亮阻塞点\n\n通过上面的测试 , 可以得知BIO机制是 阻塞等待 消息 , 可以看出不能多客户端连接 .\n\nBIO不能同一时间处理大量连接的数据 , 即使多线程也招架不住百万用户(内存爆炸) , 因此不建议使用 . 因此BIO告一段落...\n\n\n# NIO\n\nNIO是Netty主流使用的通信方式 , 在简单应用中 NIO和BIO使用的方式相差不大 , 但它们的API不同\n\n简单应用\n\n通过 Java 运行的服务端 和 cmd telnet指令 通信\n\n 1. Java服务端代码\n    \n    点击代码展开\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n     \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    public class SocketServer {\n    \n        /**\n         * 保存客户端连接\n         */\n        static List<SocketChannel> channelList=  new ArrayList<>();\n    \n        public static void main(String[] args) throws IOException {\n            // 创建NIO (和BIO ServerSocket类似\n            ServerSocketChannel serverSocket = ServerSocketChannel.open();\n            // 让客户端绑定端口\n            serverSocket.socket().bind(new InetSocketAddress(9099));\n            // 设置 非阻塞\n            serverSocket.configureBlocking(false);\n            System.out.println("服务器 启动...");\n    \n            while (true) {\n                // accept方法 不会阻塞(设置了false\n                SocketChannel socketChannel = serverSocket.accept();\n                // 未连接null 一致处于循环状态\n                if (socketChannel != null) {\n                    System.out.println("连接成功");\n                    // 设置 SocketChannel 为非阻塞\n                    socketChannel.configureBlocking(false);\n                    // 保存客户端连接List\n                    channelList.add(socketChannel);\n                }\n                // 遍历连接 进行读取数据\n                Iterator<SocketChannel> iterator = channelList.iterator();\n                while (iterator.hasNext()) {\n                    SocketChannel next = iterator.next();\n                    // 字节缓存区\n                    ByteBuffer byteBuffer = ByteBuffer.allocate(6);\n                    // read方法 不会阻塞\n                    int len = next.read(byteBuffer);\n                    if (len > 0) {\n                        System.out.println("收到消息: "+new String(byteBuffer.array()));\n                    }\n                    if (len == -1) {\n                        iterator.remove();\n                        System.out.println("客户端断开连接");\n                    }\n                }\n    \n            }\n    \n        }\n    }\n    \n\n 2. 打开多个cmd 连接 , 支持一个信道多个连接\n    \n    # 连接 本机:9099\n    telent localhost 9099 \n    # 更改模式 Ctrl+] \n    send {内容}\n    # 关闭连接 \n    quit\n    \n\n在简单应用方式中 NIO网络通信虽然解决了阻塞问题 , 但是如果大量用户连接 , 但真正通讯的只有那么几个 , 遍历的时 , 大多都是无效遍历 , 也就意味着会造成浪费内存 !\n\n解决方案 :\n\n用一个大型集合存储 channelList 和 小集合存 触发收发数据的 channel , 循环遍历 小集合处理',normalizedContent:'# 概述\n\nnetty是 nio客户端服务器连接的框架 , 能够进行简单开发网络通信应用程序 , 只要有 服务器 连接至 客户端 就可称之为 io 通信\n\nnetty测试需要jdk版本 1.8以上\n\njava中io程序分类 :\n\n * bio (不建议)\n * nio\n * aio\n\n\n# 入门应用\n\n\n# bio\n\n采用javase库中的 socket类 (套接字) , 了解可以看会我以前笔记 点击跳转\n\n简单应用\n\n通过 java 运行的服务端 和 cmd telnet指令 通信\n\n 1. java服务端代码\n    \n    点击代码展开\n    \n    \n    \n    \n    \n    \n    \n    \n    \n     \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    public class socketserver {\n    \n        public static void main(string[] args) throws ioexception {\n            // 监听本机端口\n            serversocket serversocket = new serversocket(9099);\n            while (true) {\n                // 阻塞等待 客户端 连接\n                system.out.println("等待连接...");\n                socket clientsocket = serversocket.accept();\n                system.out.println("有客户连接了...");\n                handler(clientsocket);\n            }\n        }\n    \n        /**\n         * 接收消息\n         * @param clientsocket 客户套接字\n         */\n        private static void handler(socket clientsocket) throws ioexception {\n            byte[] bs = new byte[1024];\n            int read = clientsocket.getinputstream().read(bs);\n            system.out.println("read 完成..");\n            if (read != 1) {\n                system.out.println("收到数据: " + new string(bs, 0, read));\n            }\n        }\n    \n    }\n    \n\n 2. cmd 进入 , 执行 telent命令\n    \n    # 连接 本机:9099\n    telent localhost 9099 \n    # 更改模式 ctrl+] \n    send {内容}\n    # 关闭连接 \n    quit\n    \n    \n    > cmd食用 telent命令 , 需要启动windows功能\n    > \n    > 控制面板 -> 程序 -> windows功能 -> 启动telnet\n\n 3. 断点测试观察 代码块高亮阻塞点\n\n通过上面的测试 , 可以得知bio机制是 阻塞等待 消息 , 可以看出不能多客户端连接 .\n\nbio不能同一时间处理大量连接的数据 , 即使多线程也招架不住百万用户(内存爆炸) , 因此不建议使用 . 因此bio告一段落...\n\n\n# nio\n\nnio是netty主流使用的通信方式 , 在简单应用中 nio和bio使用的方式相差不大 , 但它们的api不同\n\n简单应用\n\n通过 java 运行的服务端 和 cmd telnet指令 通信\n\n 1. java服务端代码\n    \n    点击代码展开\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n     \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    public class socketserver {\n    \n        /**\n         * 保存客户端连接\n         */\n        static list<socketchannel> channellist=  new arraylist<>();\n    \n        public static void main(string[] args) throws ioexception {\n            // 创建nio (和bio serversocket类似\n            serversocketchannel serversocket = serversocketchannel.open();\n            // 让客户端绑定端口\n            serversocket.socket().bind(new inetsocketaddress(9099));\n            // 设置 非阻塞\n            serversocket.configureblocking(false);\n            system.out.println("服务器 启动...");\n    \n            while (true) {\n                // accept方法 不会阻塞(设置了false\n                socketchannel socketchannel = serversocket.accept();\n                // 未连接null 一致处于循环状态\n                if (socketchannel != null) {\n                    system.out.println("连接成功");\n                    // 设置 socketchannel 为非阻塞\n                    socketchannel.configureblocking(false);\n                    // 保存客户端连接list\n                    channellist.add(socketchannel);\n                }\n                // 遍历连接 进行读取数据\n                iterator<socketchannel> iterator = channellist.iterator();\n                while (iterator.hasnext()) {\n                    socketchannel next = iterator.next();\n                    // 字节缓存区\n                    bytebuffer bytebuffer = bytebuffer.allocate(6);\n                    // read方法 不会阻塞\n                    int len = next.read(bytebuffer);\n                    if (len > 0) {\n                        system.out.println("收到消息: "+new string(bytebuffer.array()));\n                    }\n                    if (len == -1) {\n                        iterator.remove();\n                        system.out.println("客户端断开连接");\n                    }\n                }\n    \n            }\n    \n        }\n    }\n    \n\n 2. 打开多个cmd 连接 , 支持一个信道多个连接\n    \n    # 连接 本机:9099\n    telent localhost 9099 \n    # 更改模式 ctrl+] \n    send {内容}\n    # 关闭连接 \n    quit\n    \n\n在简单应用方式中 nio网络通信虽然解决了阻塞问题 , 但是如果大量用户连接 , 但真正通讯的只有那么几个 , 遍历的时 , 大多都是无效遍历 , 也就意味着会造成浪费内存 !\n\n解决方案 :\n\n用一个大型集合存储 channellist 和 小集合存 触发收发数据的 channel , 循环遍历 小集合处理',charsets:{cjk:!0}},{title:"Bus 服务总线",frontmatter:{title:"Bus 服务总线",author:"柏竹",permalink:"/backend/0qlndf",date:"2020-02-18T00:00:00.000Z",categories:["后端"],tags:["SpringClound","Java"]},regularPath:"/01.%E5%90%8E%E7%AB%AF/09.SpringClound/08.Bus%E6%9C%8D%E5%8A%A1%E6%80%BB%E7%BA%BF.html",relativePath:"01.后端/09.SpringClound/08.Bus服务总线.md",key:"v-01efe0dc",path:"/backend/0qlndf/",headers:[{level:2,title:"存在问题",slug:"存在问题",normalizedTitle:"存在问题",charIndex:161},{level:2,title:"Bus应用",slug:"bus应用",normalizedTitle:"bus应用",charIndex:1325}],headersStr:"存在问题 Bus应用",content:'# Bus 服务总线\n\nSpring Cloud Bus 是轻量的消息代理，将分布式节点连接，用于广播配置文件的更新 或 监控管理\n\n补充说明&优点\n\n * Bus 是轻量级消息代理\n * Bus 主要实现 配置的自动更新 （无需配置）\n * Bus 底层基于 RabbitMQ实现\n * 广播配置文件、监控管理\n\n\n# 存在问题\n\n上篇文章的 Config配置中心 启动后，此时更改 远端仓库 中某一微服务的配置文件，是不会同步本地缓存中的配置文件。因此在某一微服务运行后是不会及时更新配置文件，而是需要重启微服务才能更新生效\n\n问题示例\n\n>  * 以下主要展示 更改配置不会同步的问题\n>  * 上篇章代码测试\n\n 1. 修改仓库 user-service 微服务的配置文件 user-dev.yml\n    \n    添加 test.name 属性 (用于测试)\n    \n    \n    \n    > 依旧应用 user-service 进行测试\n\n 2. 修改Controller user-service (在接口进行测试返回数据)\n    \n    @RestController\n    @RequestMapping ("user")\n    public class UserController {\n        \n        @Autowired\n        private UserService service;\n        \n        @Value("${test.name}")\n        private String name;\n        \n        @GetMapping ("name")\n        public String testConfig() {\n            return name;\n        }\n        \n        //···\n    }\n    \n    \n    > 添加一个接口用于返回配置中的属性name的接口\n\n 3. 运行测试1(查看刚刚在仓库中添加的属性) 依次启动 Eureka 、config-server 、user-server 三个服务 访问 http://localhost:9091/user/name ，下图返回表示成功\n    \n    \n\n 4. 修改仓库 user-service 微服务的配置文件 user-dev.yml 主要修改 test.name 属性的值\n    \n    # 其他就不展示了\n    test : \n        name : Sanscan12\n    \n\n 5. 浏览器再次访问 http://localhost:9091/user/name\n    \n    > 此时 配置中的 test.name 属性值没有更变\n\n 6. 重启 user-service 微服务 ，再次访问http://localhost:9091/user/name\n    \n    > Git仓库中配置文件的修改并没有及时更新到 微服务，只有重启微服务才能生效\n\n\n# Bus应用\n\nBus 构架图\n\n\n\n说明：\n\n * 应用前提需要安装 RabbitMQ 才能实现功能\n * 配置中心 需要自行暴露触发总线地址 ==/actuator/bus-refresh==\n * 请求 ==/actuator/bus-refresh== 是固定的\n * 当配置中心微服务接收到 ==/actuator/bus-refresh== 请求时，向 RabbitMQ发送配置改变消息，这时也会更新本地缓存\n * 微服务 会监听 RabbitMQ ，如果坚监听到有仓库配置改变的消息，会重新读取本地缓存中的配置文件（实现不用重启提醒更新的效果）\n\n应用示例\n\n 1. 首先安装 RabbitMQ ，安装即可无需配置\n\n 2. config-server 添加 Bus依赖\n    \n    \x3c!-- Bus --\x3e\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-bus</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-stream-binder-rabbit</artifactId>\n    </dependency>\n    \n\n 3. config-server 添加配置 application.yml\n    \n    # ...\n    spring :\n        # ···\n        # 配置 rabbitmq信息，如果都是与默认值一致无需配置\n        rabbitmq :\n            host : localhost\n            port : 5672\n            username : guest\n            password : guest\n    \n    management :\n        endpoints :\n            web :\n                exposure :\n                \t# 暴露触发消息总线的地址 \n                \t# POST /actuator/bus-refresh\n                    include : bus-refresh\n    \n    \n    > 消息总线的地址，主要用途在触发更新配置的请求！\n\n 4. user-service 添加依赖 Bus、监控管理\n    \n    \x3c!-- Bus 监听 --\x3e\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-bus</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.cloud</groupId>\n        <artifactId>spring-cloud-stream-binder-rabbit</artifactId>\n    </dependency>\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-actuator</artifactId>\n    </dependency>\n    \n\n 5. user-service 添加配置 bootstrap.yml (配置与默认一致可跳过)\n    \n    # ....\n    # 配置 rabbitmq信息，如果都是与默认值一致无需配置\n    rabbitmq :\n        host : localhost\n        port : 5672\n        username : guest\n        password : guest\n    \n\n 6. user-service 修改 UserController 添加注解 @RefreshScope\n    \n    @RestController\n    @RequestMapping ("user")\n    @RefreshScope // 自动刷新配置文件\n    public class UserController {\n    \t// ....\n    }\n    \n\n 7. 测试\n    \n    1. 依次启动 Eureka 、config-server 、user-server 三个服务\n    2. 访问 http://localhost:9091/user/name ，查看页面返回的属性值\n    3. 修改 Git仓库 user-service 微服务的配置文件 user-dev.yml 主要修改 test.name 属性的值 （值可以随意，自要展示效果即可）\n    4. POST请求：http://localhost:14000/actuator/bus-refresh （配置中心的端口 14000）触发消息总线进行刷新配置\n    5. 重新访问 http://localhost:9091/user/name （返回更改后的值表示成功）\n    \n    > 说明： POST请求可通过 IDEA内置HTTP调用 （善用Ctrl+F）\n\n----------------------------------------\n\n仓库代码 : https://gitee.com/Sanscan12/spring-cloud-examples.git\n\n官方文档 : Spring Cloud Bus 参考手册',normalizedContent:'# bus 服务总线\n\nspring cloud bus 是轻量的消息代理，将分布式节点连接，用于广播配置文件的更新 或 监控管理\n\n补充说明&优点\n\n * bus 是轻量级消息代理\n * bus 主要实现 配置的自动更新 （无需配置）\n * bus 底层基于 rabbitmq实现\n * 广播配置文件、监控管理\n\n\n# 存在问题\n\n上篇文章的 config配置中心 启动后，此时更改 远端仓库 中某一微服务的配置文件，是不会同步本地缓存中的配置文件。因此在某一微服务运行后是不会及时更新配置文件，而是需要重启微服务才能更新生效\n\n问题示例\n\n>  * 以下主要展示 更改配置不会同步的问题\n>  * 上篇章代码测试\n\n 1. 修改仓库 user-service 微服务的配置文件 user-dev.yml\n    \n    添加 test.name 属性 (用于测试)\n    \n    \n    \n    > 依旧应用 user-service 进行测试\n\n 2. 修改controller user-service (在接口进行测试返回数据)\n    \n    @restcontroller\n    @requestmapping ("user")\n    public class usercontroller {\n        \n        @autowired\n        private userservice service;\n        \n        @value("${test.name}")\n        private string name;\n        \n        @getmapping ("name")\n        public string testconfig() {\n            return name;\n        }\n        \n        //···\n    }\n    \n    \n    > 添加一个接口用于返回配置中的属性name的接口\n\n 3. 运行测试1(查看刚刚在仓库中添加的属性) 依次启动 eureka 、config-server 、user-server 三个服务 访问 http://localhost:9091/user/name ，下图返回表示成功\n    \n    \n\n 4. 修改仓库 user-service 微服务的配置文件 user-dev.yml 主要修改 test.name 属性的值\n    \n    # 其他就不展示了\n    test : \n        name : sanscan12\n    \n\n 5. 浏览器再次访问 http://localhost:9091/user/name\n    \n    > 此时 配置中的 test.name 属性值没有更变\n\n 6. 重启 user-service 微服务 ，再次访问http://localhost:9091/user/name\n    \n    > git仓库中配置文件的修改并没有及时更新到 微服务，只有重启微服务才能生效\n\n\n# bus应用\n\nbus 构架图\n\n\n\n说明：\n\n * 应用前提需要安装 rabbitmq 才能实现功能\n * 配置中心 需要自行暴露触发总线地址 ==/actuator/bus-refresh==\n * 请求 ==/actuator/bus-refresh== 是固定的\n * 当配置中心微服务接收到 ==/actuator/bus-refresh== 请求时，向 rabbitmq发送配置改变消息，这时也会更新本地缓存\n * 微服务 会监听 rabbitmq ，如果坚监听到有仓库配置改变的消息，会重新读取本地缓存中的配置文件（实现不用重启提醒更新的效果）\n\n应用示例\n\n 1. 首先安装 rabbitmq ，安装即可无需配置\n\n 2. config-server 添加 bus依赖\n    \n    \x3c!-- bus --\x3e\n    <dependency>\n        <groupid>org.springframework.cloud</groupid>\n        <artifactid>spring-cloud-bus</artifactid>\n    </dependency>\n    <dependency>\n        <groupid>org.springframework.cloud</groupid>\n        <artifactid>spring-cloud-stream-binder-rabbit</artifactid>\n    </dependency>\n    \n\n 3. config-server 添加配置 application.yml\n    \n    # ...\n    spring :\n        # ···\n        # 配置 rabbitmq信息，如果都是与默认值一致无需配置\n        rabbitmq :\n            host : localhost\n            port : 5672\n            username : guest\n            password : guest\n    \n    management :\n        endpoints :\n            web :\n                exposure :\n                \t# 暴露触发消息总线的地址 \n                \t# post /actuator/bus-refresh\n                    include : bus-refresh\n    \n    \n    > 消息总线的地址，主要用途在触发更新配置的请求！\n\n 4. user-service 添加依赖 bus、监控管理\n    \n    \x3c!-- bus 监听 --\x3e\n    <dependency>\n        <groupid>org.springframework.cloud</groupid>\n        <artifactid>spring-cloud-bus</artifactid>\n    </dependency>\n    <dependency>\n        <groupid>org.springframework.cloud</groupid>\n        <artifactid>spring-cloud-stream-binder-rabbit</artifactid>\n    </dependency>\n    <dependency>\n        <groupid>org.springframework.boot</groupid>\n        <artifactid>spring-boot-starter-actuator</artifactid>\n    </dependency>\n    \n\n 5. user-service 添加配置 bootstrap.yml (配置与默认一致可跳过)\n    \n    # ....\n    # 配置 rabbitmq信息，如果都是与默认值一致无需配置\n    rabbitmq :\n        host : localhost\n        port : 5672\n        username : guest\n        password : guest\n    \n\n 6. user-service 修改 usercontroller 添加注解 @refreshscope\n    \n    @restcontroller\n    @requestmapping ("user")\n    @refreshscope // 自动刷新配置文件\n    public class usercontroller {\n    \t// ....\n    }\n    \n\n 7. 测试\n    \n    1. 依次启动 eureka 、config-server 、user-server 三个服务\n    2. 访问 http://localhost:9091/user/name ，查看页面返回的属性值\n    3. 修改 git仓库 user-service 微服务的配置文件 user-dev.yml 主要修改 test.name 属性的值 （值可以随意，自要展示效果即可）\n    4. post请求：http://localhost:14000/actuator/bus-refresh （配置中心的端口 14000）触发消息总线进行刷新配置\n    5. 重新访问 http://localhost:9091/user/name （返回更改后的值表示成功）\n    \n    > 说明： post请求可通过 idea内置http调用 （善用ctrl+f）\n\n----------------------------------------\n\n仓库代码 : https://gitee.com/sanscan12/spring-cloud-examples.git\n\n官方文档 : spring cloud bus 参考手册',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"HTML",frontmatter:{title:"HTML",author:"柏竹",permalink:"/web/1hg7aa",date:"2020-02-18T00:00:00.000Z",categories:["前端","编程语言"],tags:["HTML"]},regularPath:"/02.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87/01.HTML.html",relativePath:"02.前端/01.前端必备/01.HTML.md",key:"v-986ca544",path:"/web/1hg7aa/",headers:[{level:3,title:"html文件,基本构架",slug:"html文件-基本构架",normalizedTitle:"html文件,基本构架",charIndex:78},{level:2,title:"基本标签",slug:"基本标签",normalizedTitle:"基本标签",charIndex:309},{level:3,title:"文本",slug:"文本",normalizedTitle:"文本",charIndex:46},{level:4,title:"标题",slug:"标题",normalizedTitle:"标题",charIndex:256},{level:4,title:"段落",slug:"段落",normalizedTitle:"段落",charIndex:386},{level:4,title:"换行",slug:"换行",normalizedTitle:"换行",charIndex:409},{level:4,title:"水平线",slug:"水平线",normalizedTitle:"水平线",charIndex:434},{level:3,title:"图片",slug:"图片",normalizedTitle:"图片",charIndex:453},{level:4,title:"图片",slug:"图片-2",normalizedTitle:"图片",charIndex:453},{level:4,title:"热点区域",slug:"热点区域",normalizedTitle:"热点区域",charIndex:478},{level:3,title:"列表",slug:"列表",normalizedTitle:"列表",charIndex:522},{level:4,title:"有序列表",slug:"有序列表",normalizedTitle:"有序列表",charIndex:528},{level:4,title:"无序列表",slug:"无序列表",normalizedTitle:"无序列表",charIndex:547},{level:4,title:"列表内容",slug:"列表内容",normalizedTitle:"列表内容",charIndex:566},{level:3,title:"描述",slug:"描述",normalizedTitle:"描述",charIndex:647},{level:3,title:"容器",slug:"容器",normalizedTitle:"容器",charIndex:757},{level:3,title:"标签分类",slug:"标签分类",normalizedTitle:"标签分类",charIndex:787},{level:2,title:"超链接",slug:"超链接",normalizedTitle:"超链接",charIndex:944},{level:3,title:"锚点跳转",slug:"锚点跳转",normalizedTitle:"锚点跳转",charIndex:967},{level:2,title:"表格",slug:"表格",normalizedTitle:"表格",charIndex:1371},{level:3,title:"规则表格",slug:"规则表格",normalizedTitle:"规则表格",charIndex:1434},{level:3,title:"不规则表格",slug:"不规则表格",normalizedTitle:"不规则表格",charIndex:1701},{level:3,title:"逻辑分区",slug:"逻辑分区",normalizedTitle:"逻辑分区",charIndex:1966},{level:2,title:"表单",slug:"表单",normalizedTitle:"表单",charIndex:2555},{level:3,title:"表单标签",slug:"表单标签",normalizedTitle:"表单标签",charIndex:2584},{level:2,title:"框架",slug:"框架",normalizedTitle:"框架",charIndex:4793},{level:3,title:"框架集",slug:"框架集",normalizedTitle:"框架集",charIndex:4859},{level:2,title:"媒体",slug:"媒体",normalizedTitle:"媒体",charIndex:5084},{level:3,title:"音频",slug:"音频",normalizedTitle:"音频",charIndex:5122},{level:3,title:"视频",slug:"视频",normalizedTitle:"视频",charIndex:5119},{level:2,title:"转义符",slug:"转义符",normalizedTitle:"转义符",charIndex:5464}],headersStr:"html文件,基本构架 基本标签 文本 标题 段落 换行 水平线 图片 图片 热点区域 列表 有序列表 无序列表 列表内容 描述 容器 标签分类 超链接 锚点跳转 表格 规则表格 不规则表格 逻辑分区 表单 表单标签 框架 框架集 媒体 音频 视频 转义符",content:'# HTML\n\nHTML是HyperText Markup Language的简称，也是 超文本标记语言 ，是 解释型语言 解释给浏览器展现出来！\n\n\n# html文件,基本构架\n\n<!DOCTYPE HTML> 声明文档 HTML5文档 <hmlt></html> 根元素 <head></head> 头元素 <meta> 编码集 <body></body> 主体内容\n\n<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta charset="utf-8" />\n\t\t<title>页面标题</title>\n\t</head>\n\t<body>\n\t\t\n\t</body>\n</html>\n\n\n\n# 基本标签\n\n属性详细可自行查询！！\n\n\n# 文本\n\n展示文本内容 和 添加效果的功能\n\n# 标题\n\n<h></h> 共有 1 - 6号 大小的标题\n\n# 段落\n\n<p></p> 展示一行文本内容，自动换行\n\n# 换行\n\n<br/> 使文本换行\n\n# 水平线\n\n<hr/> 分割线\n\n\n# 图片\n\n# 图片\n\n<img/> 展示图片\n\n# 热点区域\n\n<map></map> 热点地图，由于指定区域 跳转 或 呈现功能\n\n\n# 列表\n\n# 有序列表\n\n<ol><\\ol>\n\n# 无序列表\n\n<ul><\\ul>\n\n# 列表内容\n\n<li><\\li>\n\n<ol>\n    <li>内容<\\li>\n    <li>内容<\\li>\n    <li>内容<\\li>\n<\\ol>\n\n\n\n# 描述\n\n<dl><\\dl> 定义描述 <dt><\\dt> 标题 <dd><\\dd> 描述\n\n<dl>\n    <dt>标题</dt>\n    <dd>描述</dd>\n    <dd>描述</dd>\n</dl>\n\n\n\n# 容器\n\n<div><\\div> 容纳其他标签的标签\n\n\n# 标签分类\n\nhtml标签分为两种类型 块级元素： 独占一行、宽度100%、可容纳其他标签、可调方框宽高 行内元素： 和相邻行内元素在一行上、宽高限于内容范围、方框不可调\n\n块级元素有：h 、 p 、 hr 、 ol-li 、 ul-li 、 dl-dt-dd 、 div 行内元素有：span 、 img\n\n\n# 超链接\n\n<a><\\a> 实现页面 跳转 和 锚点跳转\n\na标签的默认外观样式\n\n在所有浏览器中，链接的默认外观是：\n\n * 未被访问的链接带有下划线而且是蓝色的\n * 已被访问的链接带有下划线而且是紫色的\n * 活动链接带有下划线而且是红色的\n\na标签详细属性：https://www.w3school.com.cn/tags/tag_a.asp\n\n\n# 锚点跳转\n\nhref 值为 http/#Name/#Id 跳转到指定目的地（属性 name和id 均可兼容\n\n> 注意： 前提 a标签的 target属性(打开方式) 值设置为 _self (也是默认的)，主要作用：在相同窗口中打开链接\n\n<body>\n    <a href="#C2" name="C1">最底</a>\n    <div style="height: 9999px;"></div>\n    <a href="#C1" id="C2">最顶</a>\n</body>\n\n\n\n# 表格\n\n<table><\\table> 定义表格 <tr><\\tr> 行数 <td><\\td> 列数\n\n表格详细说明\n\n\n# 规则表格\n\n<table border="1">\n\t<tr>\n\t\t<td>商品</td>\n\t\t<td>说明</td>\n\t\t<td>价格</td>\n\t</tr>\n\t<tr>\n\t\t<td>电饭煲</td>\n\t\t<td>煮饭</td>\n\t\t<td>100</td>\n\t</tr>\n\t<tr>\n\t\t<td>热水器</td>\n\t\t<td>加热水</td>\n\t\t<td>1200</td>\n\t</tr>\n\t<tr>\n\t\t<td>电风扇</td>\n\t\t<td>散热</td>\n\t\t<td>230</td>\n\t</tr>\n</table>\n\n\n\n# 不规则表格\n\n<table border="1" cellspacing="0">\n\t<tr>\n\t\t<td colspan="6">个人简历</td>\n\t</tr>\n\t<tr>\n\t\t<td>姓名</td><td>柏竹</td>\n\t</tr>\n\t<tr>\n\t\t<td>电话</td><td>18182200384</td>\n\t</tr>\n\t<tr>\n\t\t<td>年龄</td><td>20</td>\n\t</tr>\n\t<tr>\n\t\t<td>邮箱</td><td>123213213</td>\n\t</tr>\n</table>\n\n\n\n# 逻辑分区\n\n<caption><\\caption> 表格标题 <thead><\\thead> 表头 <tbody><\\tbody> 主体 <tfoot><\\tfoot> 页脚\n\n\x3c!-- 标题 --\x3e\n<table border="1" cellspacing="0">\n\t<caption>零花钱花销情况</caption>\n\t\x3c!-- 表头 --\x3e\n\t<thead style="background-color: #DD4A68;">\n\t\t<tr>\n\t\t\t<th>Month</th>\n\t\t\t<th>Savings</th>\n\t\t</tr>\n\t</thead>\n\n\t\x3c!-- 页脚 --\x3e\n\t<tfoot style="background-color: #A1D6FE;">\n\t\t<tr>\n\t\t\t<td>count</td>\n\t\t\t<td>$180</td>\n\t\t</tr>\n\t</tfoot>\n\n\t\x3c!-- 主体 --\x3e\n\t<tbody style="background-color: #aaff7f;">\n\t\t<tr>\n\t\t\t<td>January</td>\n\t\t\t<td>$100</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>February</td>\n\t\t\t<td>$80</td>\n\t\t</tr>\n\t</tbody>\n\n</table>\n\n\n\n# 表单\n\n于和服务器数据交互\n\n<form></form> 表单标签 点击属性说明 属性\n\n功能属性      值           说明\naction    URL         提交目的地\nmethod    get         提交方式\n          post\nname      form_name   表单名称\nenctype   ···         表单编码类型\n···       ···         ···\n\n\n# 表单标签\n\n<input></input> 用于搜集信息 点击属性说明\n\n基本属性    说明\nid      元素的唯一标识\nname    元素名称\nvalue   元素值\ntype    元素呈现方式\nclass   样式名称\n···     ···\n\n<h1>注册账号</h1>\n\x3c!-- 提交结果示意图http://127.0.0.1:8848/Web/%E6%B5%8B%E8%AF%95/%E6%B5%8B%E8%AF%95.html?\n\tuserId=001&\n\tuserName=123&\n\tpassword=456&\n\tgender=man&\n\thobby=basketball&\n\thobby=tennis&\n\theadImg=department.sql&\n\tbirthdayTime=2000-02-10T12%3A31&\n\tage=20\n --\x3e\n<form action="测试.html" enctype="get" name="Myform">\n\t\n\t<input type="hidden" name="userId" value="001">\n\t\n\t<label for="userName">账号： </label>\n\t<input type="text" id="userName" name="userName">\n\t<br>\n\t<label for="password">密码： </label>\n\t<input type="password" id="password" name="password">\n\t<br>\n\t性别： \n\t<input type="radio" name="gender" value="man">男\n\t<input type="radio" name="gender" value="woman">女\n\t<br>\n\t爱好：\n\t<input type="checkbox" name="hobby" value="basketball">篮球\n\t<input type="checkbox" name="hobby" value="tennis">网球\n\t<input type="checkbox" name="hobby" value="badminton">羽毛球\n\t<input type="checkbox" name="hobby" value="pingpong">乒乓球\n\t<br>\n\t头像：\n\t<input type="file" name="headImg">\n\t<br>\n\t生日：\n\t<input type="datetime-local" name="birthdayTime">\n\t<br>\n\t年龄：\n\t<select name="age">\n\t\t<option value="16">16</option>\n\t\t<option value="17">17</option>\n\t\t<option value="18">18</option>\n\t\t<option value="19">19</option>\n\t\t<option value="20">20</option>\n\t\t<option value="21">21</option>\n\t\t<option value="22">22</option>\n\t\t<option value="23">23</option>\n\t</select>\n\t<br>\n\t协议说明\n\t<br>\n\t<textarea rows="10" cols="50">注册说明\n\t\t············································\n\t\t············································\n\t\t············································\n\t\t············································\n\t\t············································\n\t\t············································\n\t\t············································\n\t\t············································\n\t</textarea>\n\t<br>\n\t<input type="submit" value="注册">\n\t<input type="reset" value="重置">\n\t<input type="button" value="测试">\n\t\n</form>\n\n\n\n# 框架\n\n同一窗口显示多个页面\n\n<iframe></iframe> 内嵌框架，创建包含另外一个文档的内联框架 点击属性说明\n\n\n# 框架集\n\n<frameset></frameset> 框架集，它被用来组织多个窗口 点击属性说明\n\n\x3c!-- html4 --\x3e\n<frameset rows="20% , *">\n\t<frame src="top.html">\n\t<frameset cols="20% , *">\n\t\t<frame src="left.html">\n\t\t<frame src="right.html">\n\t</frameset>\n</frameset>\n\n\n\n# 媒体\n\n展示媒体信息 <source></source> 媒介资源 (视频/音频) 点击属性说明\n\n\n# 音频\n\n<audio></audio> 定义音频流，支持 MP3、Ogg、Wav 等格式 使用前提需要 type属性指定类型 点击属性说明\n\n\x3c!--音频源 1.MP3 在项目根路经--\x3e\n<audio controls>\n\t<source src="1.mp3" type="audio/mp3" >\n\t不支持\n</audio>\n\n\n\n# 视频\n\n<video></video> 定义视频流，支持 MP4、Ogg、WebM等格式 使用前提需要 type属性指定类型 点击属性说明\n\n<video controls>\n\t<source src="01.mp4" type="audio/mp4"></source>\n\t不支持\n</video>\n\n\n\n# 转义符\n\nHTML ASCLL表',normalizedContent:'# html\n\nhtml是hypertext markup language的简称，也是 超文本标记语言 ，是 解释型语言 解释给浏览器展现出来！\n\n\n# html文件,基本构架\n\n<!doctype html> 声明文档 html5文档 <hmlt></html> 根元素 <head></head> 头元素 <meta> 编码集 <body></body> 主体内容\n\n<!doctype html>\n<html>\n\t<head>\n\t\t<meta charset="utf-8" />\n\t\t<title>页面标题</title>\n\t</head>\n\t<body>\n\t\t\n\t</body>\n</html>\n\n\n\n# 基本标签\n\n属性详细可自行查询！！\n\n\n# 文本\n\n展示文本内容 和 添加效果的功能\n\n# 标题\n\n<h></h> 共有 1 - 6号 大小的标题\n\n# 段落\n\n<p></p> 展示一行文本内容，自动换行\n\n# 换行\n\n<br/> 使文本换行\n\n# 水平线\n\n<hr/> 分割线\n\n\n# 图片\n\n# 图片\n\n<img/> 展示图片\n\n# 热点区域\n\n<map></map> 热点地图，由于指定区域 跳转 或 呈现功能\n\n\n# 列表\n\n# 有序列表\n\n<ol><\\ol>\n\n# 无序列表\n\n<ul><\\ul>\n\n# 列表内容\n\n<li><\\li>\n\n<ol>\n    <li>内容<\\li>\n    <li>内容<\\li>\n    <li>内容<\\li>\n<\\ol>\n\n\n\n# 描述\n\n<dl><\\dl> 定义描述 <dt><\\dt> 标题 <dd><\\dd> 描述\n\n<dl>\n    <dt>标题</dt>\n    <dd>描述</dd>\n    <dd>描述</dd>\n</dl>\n\n\n\n# 容器\n\n<div><\\div> 容纳其他标签的标签\n\n\n# 标签分类\n\nhtml标签分为两种类型 块级元素： 独占一行、宽度100%、可容纳其他标签、可调方框宽高 行内元素： 和相邻行内元素在一行上、宽高限于内容范围、方框不可调\n\n块级元素有：h 、 p 、 hr 、 ol-li 、 ul-li 、 dl-dt-dd 、 div 行内元素有：span 、 img\n\n\n# 超链接\n\n<a><\\a> 实现页面 跳转 和 锚点跳转\n\na标签的默认外观样式\n\n在所有浏览器中，链接的默认外观是：\n\n * 未被访问的链接带有下划线而且是蓝色的\n * 已被访问的链接带有下划线而且是紫色的\n * 活动链接带有下划线而且是红色的\n\na标签详细属性：https://www.w3school.com.cn/tags/tag_a.asp\n\n\n# 锚点跳转\n\nhref 值为 http/#name/#id 跳转到指定目的地（属性 name和id 均可兼容\n\n> 注意： 前提 a标签的 target属性(打开方式) 值设置为 _self (也是默认的)，主要作用：在相同窗口中打开链接\n\n<body>\n    <a href="#c2" name="c1">最底</a>\n    <div style="height: 9999px;"></div>\n    <a href="#c1" id="c2">最顶</a>\n</body>\n\n\n\n# 表格\n\n<table><\\table> 定义表格 <tr><\\tr> 行数 <td><\\td> 列数\n\n表格详细说明\n\n\n# 规则表格\n\n<table border="1">\n\t<tr>\n\t\t<td>商品</td>\n\t\t<td>说明</td>\n\t\t<td>价格</td>\n\t</tr>\n\t<tr>\n\t\t<td>电饭煲</td>\n\t\t<td>煮饭</td>\n\t\t<td>100</td>\n\t</tr>\n\t<tr>\n\t\t<td>热水器</td>\n\t\t<td>加热水</td>\n\t\t<td>1200</td>\n\t</tr>\n\t<tr>\n\t\t<td>电风扇</td>\n\t\t<td>散热</td>\n\t\t<td>230</td>\n\t</tr>\n</table>\n\n\n\n# 不规则表格\n\n<table border="1" cellspacing="0">\n\t<tr>\n\t\t<td colspan="6">个人简历</td>\n\t</tr>\n\t<tr>\n\t\t<td>姓名</td><td>柏竹</td>\n\t</tr>\n\t<tr>\n\t\t<td>电话</td><td>18182200384</td>\n\t</tr>\n\t<tr>\n\t\t<td>年龄</td><td>20</td>\n\t</tr>\n\t<tr>\n\t\t<td>邮箱</td><td>123213213</td>\n\t</tr>\n</table>\n\n\n\n# 逻辑分区\n\n<caption><\\caption> 表格标题 <thead><\\thead> 表头 <tbody><\\tbody> 主体 <tfoot><\\tfoot> 页脚\n\n\x3c!-- 标题 --\x3e\n<table border="1" cellspacing="0">\n\t<caption>零花钱花销情况</caption>\n\t\x3c!-- 表头 --\x3e\n\t<thead style="background-color: #dd4a68;">\n\t\t<tr>\n\t\t\t<th>month</th>\n\t\t\t<th>savings</th>\n\t\t</tr>\n\t</thead>\n\n\t\x3c!-- 页脚 --\x3e\n\t<tfoot style="background-color: #a1d6fe;">\n\t\t<tr>\n\t\t\t<td>count</td>\n\t\t\t<td>$180</td>\n\t\t</tr>\n\t</tfoot>\n\n\t\x3c!-- 主体 --\x3e\n\t<tbody style="background-color: #aaff7f;">\n\t\t<tr>\n\t\t\t<td>january</td>\n\t\t\t<td>$100</td>\n\t\t</tr>\n\t\t<tr>\n\t\t\t<td>february</td>\n\t\t\t<td>$80</td>\n\t\t</tr>\n\t</tbody>\n\n</table>\n\n\n\n# 表单\n\n于和服务器数据交互\n\n<form></form> 表单标签 点击属性说明 属性\n\n功能属性      值           说明\naction    url         提交目的地\nmethod    get         提交方式\n          post\nname      form_name   表单名称\nenctype   ···         表单编码类型\n···       ···         ···\n\n\n# 表单标签\n\n<input></input> 用于搜集信息 点击属性说明\n\n基本属性    说明\nid      元素的唯一标识\nname    元素名称\nvalue   元素值\ntype    元素呈现方式\nclass   样式名称\n···     ···\n\n<h1>注册账号</h1>\n\x3c!-- 提交结果示意图http://127.0.0.1:8848/web/%e6%b5%8b%e8%af%95/%e6%b5%8b%e8%af%95.html?\n\tuserid=001&\n\tusername=123&\n\tpassword=456&\n\tgender=man&\n\thobby=basketball&\n\thobby=tennis&\n\theadimg=department.sql&\n\tbirthdaytime=2000-02-10t12%3a31&\n\tage=20\n --\x3e\n<form action="测试.html" enctype="get" name="myform">\n\t\n\t<input type="hidden" name="userid" value="001">\n\t\n\t<label for="username">账号： </label>\n\t<input type="text" id="username" name="username">\n\t<br>\n\t<label for="password">密码： </label>\n\t<input type="password" id="password" name="password">\n\t<br>\n\t性别： \n\t<input type="radio" name="gender" value="man">男\n\t<input type="radio" name="gender" value="woman">女\n\t<br>\n\t爱好：\n\t<input type="checkbox" name="hobby" value="basketball">篮球\n\t<input type="checkbox" name="hobby" value="tennis">网球\n\t<input type="checkbox" name="hobby" value="badminton">羽毛球\n\t<input type="checkbox" name="hobby" value="pingpong">乒乓球\n\t<br>\n\t头像：\n\t<input type="file" name="headimg">\n\t<br>\n\t生日：\n\t<input type="datetime-local" name="birthdaytime">\n\t<br>\n\t年龄：\n\t<select name="age">\n\t\t<option value="16">16</option>\n\t\t<option value="17">17</option>\n\t\t<option value="18">18</option>\n\t\t<option value="19">19</option>\n\t\t<option value="20">20</option>\n\t\t<option value="21">21</option>\n\t\t<option value="22">22</option>\n\t\t<option value="23">23</option>\n\t</select>\n\t<br>\n\t协议说明\n\t<br>\n\t<textarea rows="10" cols="50">注册说明\n\t\t············································\n\t\t············································\n\t\t············································\n\t\t············································\n\t\t············································\n\t\t············································\n\t\t············································\n\t\t············································\n\t</textarea>\n\t<br>\n\t<input type="submit" value="注册">\n\t<input type="reset" value="重置">\n\t<input type="button" value="测试">\n\t\n</form>\n\n\n\n# 框架\n\n同一窗口显示多个页面\n\n<iframe></iframe> 内嵌框架，创建包含另外一个文档的内联框架 点击属性说明\n\n\n# 框架集\n\n<frameset></frameset> 框架集，它被用来组织多个窗口 点击属性说明\n\n\x3c!-- html4 --\x3e\n<frameset rows="20% , *">\n\t<frame src="top.html">\n\t<frameset cols="20% , *">\n\t\t<frame src="left.html">\n\t\t<frame src="right.html">\n\t</frameset>\n</frameset>\n\n\n\n# 媒体\n\n展示媒体信息 <source></source> 媒介资源 (视频/音频) 点击属性说明\n\n\n# 音频\n\n<audio></audio> 定义音频流，支持 mp3、ogg、wav 等格式 使用前提需要 type属性指定类型 点击属性说明\n\n\x3c!--音频源 1.mp3 在项目根路经--\x3e\n<audio controls>\n\t<source src="1.mp3" type="audio/mp3" >\n\t不支持\n</audio>\n\n\n\n# 视频\n\n<video></video> 定义视频流，支持 mp4、ogg、webm等格式 使用前提需要 type属性指定类型 点击属性说明\n\n<video controls>\n\t<source src="01.mp4" type="audio/mp4"></source>\n\t不支持\n</video>\n\n\n\n# 转义符\n\nhtml ascll表',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"JavaScript",frontmatter:{title:"JavaScript",author:"柏竹",permalink:"/web/1hg7aw",date:"2020-02-18T00:00:00.000Z",categories:["前端"],tags:["编程语言"]},regularPath:"/02.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87/03.JavaScript.html",relativePath:"02.前端/01.前端必备/03.JavaScript.md",key:"v-28c6e85e",path:"/web/1hg7aw/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:17},{level:2,title:"引入（script）",slug:"引入-script",normalizedTitle:"引入（script）",charIndex:138},{level:3,title:"内部引入",slug:"内部引入",normalizedTitle:"内部引入",charIndex:153},{level:3,title:"外部引入",slug:"外部引入",normalizedTitle:"外部引入",charIndex:384},{level:3,title:"标签属性值引用",slug:"标签属性值引用",normalizedTitle:"标签属性值引用",charIndex:626},{level:2,title:"基本语法",slug:"基本语法",normalizedTitle:"基本语法",charIndex:838},{level:2,title:"数据类型",slug:"数据类型",normalizedTitle:"数据类型",charIndex:1042},{level:3,title:"数值型",slug:"数值型",normalizedTitle:"数值型",charIndex:1051},{level:3,title:"字符串型",slug:"字符串型",normalizedTitle:"字符串型",charIndex:1448},{level:3,title:"布尔型",slug:"布尔型",normalizedTitle:"布尔型",charIndex:1576},{level:3,title:"特殊类型",slug:"特殊类型",normalizedTitle:"特殊类型",charIndex:1623},{level:4,title:"转义字符",slug:"转义字符",normalizedTitle:"转义字符",charIndex:1631},{level:4,title:"空值  (null)",slug:"空值-null",normalizedTitle:"空值  (null)",charIndex:null},{level:4,title:"未定义（undefined）",slug:"未定义-undefined",normalizedTitle:"未定义（undefined）",charIndex:2166},{level:2,title:"常量与变量",slug:"常量与变量",normalizedTitle:"常量与变量",charIndex:2209},{level:2,title:"算术运算符",slug:"算术运算符",normalizedTitle:"算术运算符",charIndex:2357},{level:3,title:"比较运算符",slug:"比较运算符",normalizedTitle:"比较运算符",charIndex:2388},{level:3,title:"赋值运算符",slug:"赋值运算符",normalizedTitle:"赋值运算符",charIndex:2484},{level:3,title:"字符串运算符",slug:"字符串运算符",normalizedTitle:"字符串运算符",charIndex:2538},{level:3,title:"逻辑运算符",slug:"逻辑运算符",normalizedTitle:"逻辑运算符",charIndex:2644},{level:3,title:"条件运算符",slug:"条件运算符",normalizedTitle:"条件运算符",charIndex:2692},{level:3,title:"逗号运算符",slug:"逗号运算符",normalizedTitle:"逗号运算符",charIndex:2740},{level:3,title:"运算符 (typeof)",slug:"运算符-typeof",normalizedTitle:"运算符 (typeof)",charIndex:2866},{level:3,title:"运算符 (new)",slug:"运算符-new",normalizedTitle:"运算符 (new)",charIndex:3079},{level:3,title:"运算符的优先级",slug:"运算符的优先级",normalizedTitle:"运算符的优先级",charIndex:3178},{level:2,title:"表达式",slug:"表达式",normalizedTitle:"表达式",charIndex:2701},{level:3,title:"转换为数值型",slug:"转换为数值型",normalizedTitle:"转换为数值型",charIndex:3787},{level:3,title:"转换为布尔型",slug:"转换为布尔型",normalizedTitle:"转换为布尔型",charIndex:3939},{level:3,title:"转换为字符串型",slug:"转换为字符串型",normalizedTitle:"转换为字符串型",charIndex:4096},{level:2,title:"语句结构",slug:"语句结构",normalizedTitle:"语句结构",charIndex:4300},{level:3,title:"赋值语句",slug:"赋值语句",normalizedTitle:"赋值语句",charIndex:4309},{level:3,title:"判断语句",slug:"判断语句",normalizedTitle:"判断语句",charIndex:4323},{level:4,title:"if[...else]",slug:"if-else",normalizedTitle:"if[...else]",charIndex:4331},{level:4,title:"switch",slug:"switch",normalizedTitle:"switch",charIndex:4525},{level:3,title:"循环语句",slug:"循环语句",normalizedTitle:"循环语句",charIndex:4898},{level:4,title:"while",slug:"while",normalizedTitle:"while",charIndex:4906},{level:4,title:"do...while",slug:"do-while",normalizedTitle:"do...while",charIndex:4951},{level:4,title:"for",slug:"for",normalizedTitle:"for",charIndex:5003},{level:4,title:"for...in",slug:"for-in",normalizedTitle:"for...in",charIndex:5064},{level:4,title:"continue",slug:"continue",normalizedTitle:"continue",charIndex:5173},{level:4,title:"break",slug:"break",normalizedTitle:"break",charIndex:4681},{level:3,title:"异常语句",slug:"异常语句",normalizedTitle:"异常语句",charIndex:5262},{level:4,title:"try...catch...finally",slug:"try-catch-finally",normalizedTitle:"try...catch...finally",charIndex:5270},{level:4,title:"throw",slug:"throw",normalizedTitle:"throw",charIndex:5595},{level:2,title:"对象",slug:"对象",normalizedTitle:"对象",charIndex:63},{level:3,title:"String对象",slug:"string对象",normalizedTitle:"string对象",charIndex:5675},{level:3,title:"Array对象",slug:"array对象",normalizedTitle:"array对象",charIndex:5851},{level:3,title:"Date对象",slug:"date对象",normalizedTitle:"date对象",charIndex:6187},{level:3,title:"Math对象",slug:"math对象",normalizedTitle:"math对象",charIndex:6488},{level:3,title:"自定义对象",slug:"自定义对象",normalizedTitle:"自定义对象",charIndex:6535},{level:3,title:"Window对象",slug:"window对象",normalizedTitle:"window对象",charIndex:7230},{level:4,title:"History对象",slug:"history对象",normalizedTitle:"history对象",charIndex:7770},{level:4,title:"location对象",slug:"location对象",normalizedTitle:"location对象",charIndex:8603},{level:3,title:"RegExp 对象",slug:"regexp-对象",normalizedTitle:"regexp 对象",charIndex:9051},{level:2,title:"函数",slug:"函数",normalizedTitle:"函数",charIndex:895},{level:3,title:"数值内置函数",slug:"数值内置函数",normalizedTitle:"数值内置函数",charIndex:10598},{level:4,title:"isNan",slug:"isnan",normalizedTitle:"isnan",charIndex:10608},{level:4,title:"parseFloat",slug:"parsefloat",normalizedTitle:"parsefloat",charIndex:10745},{level:4,title:"parseInt",slug:"parseint",normalizedTitle:"parseint",charIndex:11089},{level:3,title:"字符串内置函数",slug:"字符串内置函数",normalizedTitle:"字符串内置函数",charIndex:11668},{level:4,title:"eval",slug:"eval",normalizedTitle:"eval",charIndex:11679},{level:4,title:"escape",slug:"escape",normalizedTitle:"escape",charIndex:11723},{level:4,title:"unescape",slug:"unescape",normalizedTitle:"unescape",charIndex:11872},{level:4,title:"encodeURI",slug:"encodeuri",normalizedTitle:"encodeuri",charIndex:12028},{level:4,title:"decodeURI",slug:"decodeuri",normalizedTitle:"decodeuri",charIndex:12069},{level:3,title:"自定义函数",slug:"自定义函数",normalizedTitle:"自定义函数",charIndex:12114},{level:3,title:"匿名函数",slug:"匿名函数",normalizedTitle:"匿名函数",charIndex:12231},{level:2,title:"事件",slug:"事件",normalizedTitle:"事件",charIndex:66},{level:2,title:"DOM模型",slug:"dom模型",normalizedTitle:"dom模型",charIndex:7255},{level:3,title:"Document对象",slug:"document对象",normalizedTitle:"document对象",charIndex:13654},{level:3,title:"Element 对象",slug:"element-对象",normalizedTitle:"element 对象",charIndex:13784},{level:3,title:"HTML文档编辑",slug:"html文档编辑",normalizedTitle:"html文档编辑",charIndex:15566},{level:4,title:"HTML内容",slug:"html内容",normalizedTitle:"html内容",charIndex:15578},{level:4,title:"HTML属性",slug:"html属性",normalizedTitle:"html属性",charIndex:13624},{level:4,title:"CSS元素",slug:"css元素",normalizedTitle:"css元素",charIndex:16241},{level:4,title:"添加节点",slug:"添加节点",normalizedTitle:"添加节点",charIndex:16353},{level:4,title:"删除节点",slug:"删除节点",normalizedTitle:"删除节点",charIndex:16685},{level:4,title:"更改节点",slug:"更改节点",normalizedTitle:"更改节点",charIndex:16931}],headersStr:"概述 引入（script） 内部引入 外部引入 标签属性值引用 基本语法 数据类型 数值型 字符串型 布尔型 特殊类型 转义字符 空值  (null) 未定义（undefined） 常量与变量 算术运算符 比较运算符 赋值运算符 字符串运算符 逻辑运算符 条件运算符 逗号运算符 运算符 (typeof) 运算符 (new) 运算符的优先级 表达式 转换为数值型 转换为布尔型 转换为字符串型 语句结构 赋值语句 判断语句 if[...else] switch 循环语句 while do...while for for...in continue break 异常语句 try...catch...finally throw 对象 String对象 Array对象 Date对象 Math对象 自定义对象 Window对象 History对象 location对象 RegExp 对象 函数 数值内置函数 isNan parseFloat parseInt 字符串内置函数 eval escape unescape encodeURI decodeURI 自定义函数 匿名函数 事件 DOM模型 Document对象 Element 对象 HTML文档编辑 HTML内容 HTML属性 CSS元素 添加节点 删除节点 更改节点",content:'# JavaScript\n\n\n# 概述\n\nJavaScript是Web页面中的一种脚本编程语言，也是一种通用的、跨平台的、基于对象和事件驱动并具有安全性的脚本语言。它不需要进行编译，而是直接嵌入在HTML页面中，把静态页面转变成支持用户交互并响应相应事件的动态页面。\n\n\n# 引入（script）\n\n\n# 内部引入\n\n在HTML文档中可以使用 <script>... <\/script>标记将JavaScript脚本嵌入到其中。 script属性：\n\nSCRIPT属性   说明\nlanguage   不常用\ntype       用于指定使用的脚本类型\nsrc        指定外部脚本文件路径\ndefer      不常用\n\ntype属性的语法格式：\n\n<script type = "text/javascript">\n\t···\n<\/script>\n\n\n\n# 外部引入\n\n多了个src属性 URL 或 本地路径\n\n<script type = "text/javascript" src = "js文件的rul路径">\n\t···\n<\/script>\n\n\n注意：\n\n 1. 外部JavaScript文件中只能包含JavaScript代码，不能包含HTML和<script>标签。\n 2. 在<script>标签内部不要存在其他的JavaScript代码。\n 3. 在链接外部JavaScript文件时<\/script>结束标签不能省略。\n\n\n# 标签属性值引用\n\n在HTML文档中可以在<a>标签、<input>标签 中使用JavaScript脚本作为它们的属性值 通过“JavaScript”调用\n\n<a href="javascript:alert(\'你好JavaScript\')">测试</a>\n\n\n与实践结合调用\n\n<input type="button" value="测试" onclick="alert(\'你好JavaScript \')" />\n\n\n\n# 基本语法\n\n 1. 执行顺序 程序按照在HTML文件中出现的顺序逐行执行\n 2. 大小写敏感 在输入语言的关键字、函数名、变量时，都必须采用正确的大小写形\n 3. 空格与换行 在JavaScript中会忽略程序中的空格、换行和制表符\n 4. 每行结尾的分号可有可 为了养好习惯，经量写上分号\n\n注释\n\n注释就是向文件代码中添加的--些说明性的文字，或者对代码进行暂时屏蔽。//内容ro /*内容*/\n\n\n# 数据类型\n\n\n# 数值型\n\n数值类型          说明\n十进制           由0~9组成的数字序列\n十六进制          “0X”或“0x”开头数字序列\n八进制           以0开头\n浮点型           传统计数法、科学计数法e或E后面的整数表示10的指数次幂\n特殊值Infinity   超出最大值范围，则正\n              超出最小范围，则负\n特殊值NaN        非数字\n\n科学计数法 语法格式：\n\n[digits] [.digits] [E|e[(+| -)]]\n\n\n例子： $$ 4E+2 = 4*10^{2} = 400 $$\n\n$$ 3.14e4 = 3.14*10^{4} = 31400 $$\n\n$$ .14e4 = 0.14*10^{4} = 1400 $$\n\n$$ 314E-2 = 314*10^{-2} = 3.14 $$\n\n\n# 字符串型\n\n字符串型数据是包含在 单引号或双引号 中的\n\n> 由单引号定界的字符串中可以含有双引号 由双引号定界的字符串中也可以含有单引号\n\n"I\'m legend" = I\'m legend \nvar greetings = "hello";\n\n\n\n# 布尔型\n\n布尔数据类型只有两个值，一 个是true （真），一个是false （假）\n\n\n# 特殊类型\n\n# 转义字符\n\n转义字符 是\\，通过转义字符可以在字符串中添加不可显示的特殊字符（例如\\n, \\t），或者防止引号匹配混乱的问题\n\n转义字符     描述\n\\r       回车符\n\\t       水平制表符，Tab空 格\n\\b       退格\n\\v       垂直制表符\n\\f       换页\n\\n       换行符\n\\ \\      反斜杠\n\\OOO     八进制，范围000~777\n\\ \'      单引号\n\\xHH     十六进制整数，范围00~FF\n\\ "      双引号\n\\uhhhh   十六进制编码Unicode字符\n\n在document. write()语句中使用转义字符时，只有将其放在格式化文本块中才会起作用，即脚本必须放在<pre></pre>标签内。 代码：\n\n<script type="text/javascript">\n    document.write("<pre>");\n    document.write("网页基础:\\nHTML\\nCSS\\nJavascript");\n    document.write("<pre>");\n<\/script>\n\n\n# 空值 (null)\n\n用于定义空的或不存在的引用\n\n# 未定义（undefined）\n\n表示还没赋值，类似于java中的 空指针异常\n\n\n# 常量与变量\n\n常量：固定不变数据 变量：存储要用的数据 如果只是声明了变量，并未对其赋值，则其值默认为undef ined。可以使用var语句重复声明同一个变量，也可以在重复声明变量时为该变量赋一个新值。 在JavaScript中的变量必须要先定义后使用，没有定义过的变量不能直接使用。\n\n\n# 算术运算符\n\n用于在程序中进行加、减、乘、除等运算。\n\n\n# 比较运算符\n\n对操作数进行比较，然后返回一个布尔值true或faIse.\n\n> < , <= , > , >= , == , != , === (绝对等于) , !==(绝对不等于)\n\n\n# 赋值运算符\n\n简单赋值运算符： = 符合赋值运算符： += , -= , *= , /= , %=\n\n\n# 字符串运算符\n\n用于两个字符串型数据之间的运算符，它的作用是将两个字符串连接起来。 如果比较字符串，则逐个比较字符的ASCIl码值，ASCII码值大的字符串大。ASCII码值都相等，字符数多的字符串大。\n\n\n# 逻辑运算符\n\n用于对一个或多个布尔值进行逻辑运算：&&（与 ）、||（或） 、!(非）\n\n\n# 条件运算符\n\n> 表达式?结果1:结果2 结果1为: true 结果2为: false\n\n\n# 逗号运算符\n\n用于将多个表达式排在一起，整个表达式的值为最后一个表达式的值。 例子：\n\nvar a , b , c , d;\na = (b=3 , c=4 , d=1);\ndocument.write("a最终值为"+a);\n//结果为 1\n\n\n\n# 运算符 (typeof)\n\ntypeof 用于判断操作数的数据类型。语法格式：\n\ntypeof 操作数;\n\n\n数据类型（操作数）   返回值\n数值型         number\n字符串型        string\n布尔型         boolean\nundefined   nudefined\nnull        object\n对象          object\n函数          functio\n\n\n# 运算符 (new)\n\nnew 用来创建一个新的对象实例。语法格式：\n\n> 格式1： 对象实例名称 = new 对象类型(参数);\n> \n> 格式2： 对象实例名称 = new 对象类型2;\n\n\n# 运算符的优先级\n\n优先级        结合性   运算符\n最高         向左    、[]、()\n由高到低依次排列         ++、--、-、！、delete、new、typeof、void\n           向左    *、/、%\n           向左    +、-\n           向左    <<、>> 、>>\n           向左    <、<=、>、>=、in、instanceof\n           向左    =、!=、=== 、 绝对不等于\n           向左    &\n           向左    ^\n           向左    |\n           向左    &&\n           向左    ||\n           向右    ?:\n           向右    =\n           向右    =、/=、%=、+=、-=、<<=、>>=、>>>=、&=、^=、|=\n最低         向右    ,\n\n结合性 左结合：除了赋值、条件和单目运算符 右结合：赋值运算符、条件运算符\n\n\n# 表达式\n\n是运算符和操作数组合而成的式子。运算结果可分为：算术表达式、字符串表达式、逻辑表达式 表达式是一个相对的概念，在表达式中可以含有若千个子表达式，而且表达式中的一个常量或变量都可以看作是一个表达式。\n\n\n# 转换为数值型\n\n转前类型        转后的数值（数值）\nundefined   NaN\nnull        0\n逻辑型         true,则为 1 ;false,则为 0\n字符串型        若内容为数字，则相应的数字，否则为NaN\n其他对象        NaN（非数字）\n\n\n# 转换为布尔型\n\n转前类型        转后的布尔型\nundefined   false\nnull        false\n数值型         值为0或NaN,则结果为false,否则为true\n字符串型        长度为0，则结果为false,否则为true\n其他对象        true\n\n\n# 转换为字符串型\n\n转前类型        转后的字符串型\nundefined   "undefined"\nnull        "null"\n数值型         NaN、0或者与数值相对应的字符串\n逻辑型         值true,则为"true",值为false,则结果为"false"\n其他对象        若存在，结果为toString()方法的值，否则结果为"undefined"\n\n\n# 语句结构\n\n\n# 赋值语句\n\n···\n\n\n# 判断语句\n\n# if[...else]\n\nif判断语句\n\nif(表达式){\n  ···\n}\n\n\nif语句的嵌套\n\n套娃格式，if中的if\n\nif(表达式1){\n    if(表达式2){\n        ···\n    }else{\n        ···\n    }\n}else{\n    if(表达式3){\n         ···\n    }else{\n      ···\n    }\n}\n\n\n# switch\n\nswitch分支语句，根据一个表达式的值，选择不同的分支执行\n\n> 注意 ：在JavaScript中 case 指定的值可以应用表达式，而Java不能应用表达式\n\nswitch (表达式){\n    case 常量表达式1 :\n        语句1;\n        ···;\n        break;\n    case 常量表达式2 :\n        语句2;\n        ···;\n        break;\n        ···\n    case 常量表达式n :\n        语句n;\n        ···;\n        break;\n    default:\n\t\t语句n+1;\n        break;\n}\n\n\ndefault语句可以省略，case语句没有匹配的则不进行任何操作。\n\n\n# 循环语句\n\n# while\n\n一个表达式来控制循环\n\nwhile(表达式)(\n    ···\n)\n\n\n# do...while\n\n先执行在判断是否循环\n\ndo{\n   ···\n}while(表达式);\n\n\n# for\n\n计次循环，可控制循环数\n\nif(初始化表达式 ; 条件表达式 ; 迭代表达式){\n     ···\n}\n\n\n# for...in\n\n迭代语句，遍历组中的所有元素（循环次数 = 组中的数量）\n\nfor(element in group){\n    ···\n}\n//element：遍历组的元素\n//group：需要遍历的组\n\n\n# continue\n\ncontinue跳转语句 跳过本次循环，并开始下一次循环\n\n# break\n\n**break跳转语句 ** 在循环语句中，break语句用于跳出循环\n\n\n# 异常语句\n\n# try...catch...finally\n\ntry语句会捕捉到Error对象（exception），该对象可以描述错误\n\nError对象属性\n\n> name ：表示异常类型的字符串 message ：实际的异常信息\n\ntry{\n    ...\n   //捕捉异常代码区域\n}catch(exception){\n    var name = exception.name;\n    var message = exception.message;\n    ...\t\n    //异常提示区域\n}finally{\n    ...\n    //最后执行的区域\n}\n\n\n> try： 尝试执行代码 catch： 捕捉异常 finally： 最终处理\n\n# throw\n\nthrow语句抛出异常，有目的性的抛出异常\n\n//以下代码执行直接抛出异常\nthrow new Error("错误");\n\n\n\n# 对象\n\n\n# String对象\n\nString对象是动态对象，对象需要实例后才能引用属性和方法，主要用于处理或格式化文本字符串\n\n点击String对象方法\n\nvar str = "我爱学习 ，学习使我快乐";\nvar str2 = new String("我爱学习 ，学习使我快乐");\nconsole.log("字符串长度："+str.length);\n\n\n\n# Array对象\n\nArray 对象用于在变量中存储多个值，也就是数组\n\n点击Array对象方法\n\n//No.1\nvar nameArray = new Array();\nnameArray[0] = "zhangsan";\nnameArray[1] = "lisi";\nnameArray[2] = "wangwu";\n\n//No.2\nvar nameArray2 = ["zhangsan","lisi","wangwu"];\ndocument.write("遍历 ： <br/>");\nfor(var i = 0 ; i< nameArray2.length ; i++){\n\tdocument.write(nameArray[i]+"<br/>");\n}\n\n\n\n# Date对象\n\nDate对象 实现对日期和时间的控制\n\n点击Date对象方法\n\n//No.1 现在时间\nvar date1 = new Date();\n//No.2 时间戳的偏移量 （1970.1.1开始）\nvar date2 = new Date(milliseconds);\n//No.3 字符串时间（需要补全）\nvar date3 = new Date(dateString);\n//No.4 数值时间值（月份：0 - 11）\nvar date4 = new Date(year, month, day, hours, minutes, seconds, milliseconds);\n\n\n\n# Math对象\n\nMath对象 实现数学应用，和java差不多\n\n点击Math对象方法\n\n\n# 自定义对象\n\n自定义对象可以包含多个值（多个变量）\n\n定义\n\nvar 对象名 = {\n    属性: 值,\n    属性: 值,\n    函数名:function(){\n        //函数体···\n    }\n    ···\n};\n\n\n访问\n\n//No.1 \n对象名.属性名;\n\n//No.2\n对象名["属性名"];\n\n//函数调用\n对象名.函数名();\n\n\n注意：\n\n 1. 定义对象属性需要花括号括住\n 2. 属性与值之间是需要逗号分开 ,\n 3. 属性与属性之间需要冒号分开 : ，最后的属性不需要冒号分开\n 4. 定义对象的末尾需要分号结束 ;\n\n实例\n\nvar student={\n\tid:12,\n\tname:"zhangsan",\n\tage:18,\n\theight:179,\n\tInspirational:function(){\n\t\tprint("","好好学习天天向上");\n\t}\n};\n\nprint("id:",student.id);\nprint("name:",student.name);\nprint("age:",student["age"]);\nprint("height:",student.height);\n//调用函数\nstudent.Inspirational();\n\nfunction print(text,str){\n\tdocument.write(text+str);\n\tdocument.write("<br/>");\n}\n\n/*\nid:12\nname:zhangsan\nage:18\nheight:179\n好好学习天天向上\n*/\n\n\n\n# Window对象\n\nWindow对象 是浏览器对象DOM模型。所有浏览器都支持 window对象 表示一个浏览器窗口或一个框架\n\n点击Window详细\n\nWindow方法\n\nWINDOW方法                      说明\nsetInterval(<函数名>,<时间间隔毫秒>)   指定的周期 调用函数\nclearInterval(<定时对象>)         取消 setInterval() 设置的 定时器\nsetTimeout()                  延迟器 休眠\n提示                            \nalert(<提示信息>)                 提示\nprompt(<提示信息>,<默认值>)          用户输入\nconfirm(<提示信息>)               信息确认\n\n// 启动定时器\nlet time = window.setInterval("renew()",1000);\n\nfunction renew(){\n    console.log("定时加载");\n}\n\n// 关闭定时器\nwindow.clearInterval(time);\n\n\n常用对象属性\n\n# History对象\n\nwindow.history 对象 包含浏览器的历史History 对象\n\nHISTORY方法   说明\nback()      加载历史 history 列表中的前一个 URL\nforward()   加载历史 history 列表中的下一个 URL\ngo(int)     加载历史 history 列表中的某个具体页面\n            整数 前；负数 后\n\n<body>\n\t<a href="https://www.baidu.com/">baidu</a>\n\t<br>\n\t<a href="https://www.google.cn/">google</a>\n\t<br>\n\t<a href="window返回页.html">进入</a>\n\t<br>\n\t<br>\n\t<a  href="#" onclick="winMethods.forward()">前进</a>\n\t<br>\n\t<a href="#" onclick="winMethods.back()">后退</a>\n\t<br>\n\t<a href="#" onclick="winMethods.go(-99)">置低</a>\n\t<br>\n\t<a href="#" onclick="winMethods.go(99)">置顶</a>\n</body>\n<script type="text/javascript">\n\tvar winMethods = {\n\t\tforward:function(){\n\t\t\tjavascript:window.history.forward();\n\t\t},\n\t\tback:function(){\n\t\t\tjavascript:window.history.back();\n\t\t},\n\t\tgo:function(num){\n\t\t\tjavascript:window.history.go(num);\n\t\t}\n\t};\n<\/script>\n\n\n# location对象\n\nwindow.location 对象 获得当前页面地址 (URL)，并把浏览器重定向到新的页面\n\nLOCATION方法     描述\nassign(rul)    加载新的文档\nreload()       重新加载当前文档\nreplace(url)   用新的文档替换当前文档\n\n <a href="javascript:alert(window.location.href)">获取当前页面的URL地址</a>\n<a href="javascript:window.location.reload()">刷新</a>\n<br />\n<a href="javascript:location.replace(\'https://www.baidu.com\')">跳转到百度</a><br\n/>\n<br/>\n<a href="javascript:location.assign(\'https://www.baidu.com\')">跳转到百度</a><br\n/>\n\n\n\n# RegExp 对象\n\nRegExp对象 正则表达式, 用于对 字符串 进行 描述/匹配 规则的字符串, 对其替换或扫描\n\n点击RegExp对象详细 正则匹配网页应用: 链接1 , 链接2\n\nvar reg = new RegExp(正则表达式 [, 修饰符]);\n\n\n修饰符说明\n\n全局匹配、区分大小写的匹配和多行匹配\n\n修饰符   说明\ni     无视大小写匹配\ng     查找所有匹配的 内容\nm     多行匹配\n\n//No.1\nvar reg1 = new RegExp("abc");\nalert(reg2.test("abc"));\n\n//No.2\nalert(/[abc]/.test("bca"));\n\n//应用示范\n/[Abc]/i.test("aac");\t//true\n\n//方法应用\n//search()\nconsole.log("I like javaScript".search(/java/));    //java存在 第七个 字符头\n//match()\nconsole.log("Do you like java?No,I don\'t like java!".match(/java/g));    //Array={\'\n//replace()\nconsole.log("I like javaScript".replace(/javaScript/, "Java"));     //将 Java 覆盖\nconsole.log("\'a\',\'b\',\'c\'".replace(/\'([^\']*)\'/g,\'"$1"\'));    //将单引号替换至双引号 \n//split()\nconsole.log("I like javaScript".split(" "));    //Array={\'I\',\'like\',\'javaScript\'}\nconsole.log("a : b : c".split(/ : /g));    //Array={\'a\',\'b\',\'c\'}\n\n//修饰符\nconsole.log(/[Abc]/i.test("aac"));\t//tuse\nconsole.log("Is this all there is?".match(/is/));    //is\nconsole.log("Is this all there is?".match(/is/g));    //Array={\'is\',\'is\'}\n\n\n常用正则表达式:\n\n 1. 匹配 **身份证号码 **\n    \n    > /^[1-9]\\d{5}(18|19|([23]\\d))\\d{2}((0[1-9])|(10|11|12))(([0-2] [1-9])|10|20|30|31)\\d{3}[0-9Xx]$/\n    > \n    > [1-9]\\d{5} 前六位地区，非0打头 (18|19|([23]\\d))\\d{2} 出身年份，覆盖范围为 1800-3999 年 ((0[1-9])|(10|11|12)) 月份，01-12月 (([0-2][1-9])|10|20|30|31) 日期，01-31天 \\d{3}[0-9Xx] 顺序码三位 + 一位校验码\n\n 2. 匹配 手机号\n    \n    > /^1[3|4|5|7|8][0-9]{9}$/\n\n 3. 匹配 邮箱\n    \n    > /^\\w+@[a-zA-Z0-9]{2,10}(?:\\.[a-z]{2,4}){1,3}$/\n\n 4. 匹配 URL\n    \n    > /http(s)?:\\/\\/[\\w.]+[\\w\\/]*[\\w.]*\\??[\\w=&\\+\\%]*/\n\n\n# 函数\n\n\n# 数值内置函数\n\n# isNan\n\nisNan(param) 检查其参数是否是非数字值\n\nconsole.log(isNaN(666));//false\nconsole.log(isNaN(1+2));//false\nconsole.log(isNaN("hello"));//true\n\n\n# parseFloat\n\nparseFloat(String) 解析一个字符串，返回一个浮点数\n\nconsole.log(parseFloat("66"));//66\nconsole.log(parseFloat("199.99"));//199.99\nconsole.log(parseFloat("1024 2048 4096"));//1024\nconsole.log(parseFloat(" 128 "));//128\nconsole.log(parseFloat("10年"));//10\nconsole.log(parseFloat("今天是8号"));//NaN\n\n\n注意：\n\n 1. 字符串中只返回第一个数值\n 2. 头尾允许空格\n 3. 首字符不为数字，则NaN\n\n# parseInt\n\nparseInt(string[,radix]) 解析一个字符串，并返回一个整数 **string：**解析字符串；**radix：**数字基数(2 - 36) （进制数）\n\nconsole.log(parseInt("66"));//66\nconsole.log(parseInt("199.99"));//199\nconsole.log(parseInt("1024 2048 4096"));//1024\nconsole.log(parseInt(" 128 "));//128\nconsole.log(parseInt("10年"));//10\nconsole.log(parseInt("今天是8号"));//NaN\n\nconsole.log(parseInt("10",10));//10\nconsole.log(parseInt("010"));//10\nconsole.log(parseInt("10",8));//8\nconsole.log(parseInt("0x10"));//16\nconsole.log(parseInt("10",16));//16\n\n\n注意：\n\n 1. 字符串中只返回第一个数值\n 2. 开头和结尾的空格是允许的\n 3. 首字符不为数字，则NaN\n 4. radix 进制数可自选\n\n\n# 字符串内置函数\n\n# eval\n\neval(String) 计算字符串中的表达式的值 将其执行结果返回\n\n# escape\n\nescape(String) 字符串编码 特殊字符(不包括字母和数字字符以及*、@、一、_、+、.和/)进行编码，可将特殊字符转换为“%XX” 格式的数字\n\nescape("You & Me");\n// escape("You & Me") →You%20%26%20Me\n\n\n# unescape\n\nunescape(String) 字符串解码 对应用escape()函数编码后的字符串进行解码。可将字符串中“%XX”格式的数字转换为字符串\n\nunescape("You%20%26%20Me");\n//如: unescape("You%20%26%20Me") →You & Me\n\n\n# encodeURI\n\nencodeURI(uri) 将URL字符串进行编码\n\n# decodeURI\n\ndecodeURI(url) 对已编码URL字符串进行解码\n\n\n# 自定义函数\n\n函数定义\n\nfunction 函数名(参数列表){\n\t//函数体\n\t[return 返回值]\n}\n\n\n注意：\n\n 1. 参数可直接写参数名称，无需定义类型\n 2. 函数是否返回取决于是否有 return 关键字\n\n\n# 匿名函数\n\nvar 变量名 = function(参数列表){\n\t//函数体\n    return 返回值;\n};\n\n\n\n# 事件\n\nHTML页面的元素都有自带的行为, 自要他们进行操作 , 就会触发相应事件\n\n点击事件详细\n\n示例\n\n<script type="text/javascript">\n    function eventOnchange() {\n        alert("元素值更变!!!");\n    }\n    function eventOnclick() {\n        alert("用户点击了元素!!!");\n    }\n    function eventOnmouseover(){\n        document.getElementById("test1").innerHTML = "鼠标移到触发(onmouseover)";\n    }\n    function eventOnmouseout(){\n        document.getElementById("test1").innerHTML = "鼠标移出触发(onmouseout)";\n    }\n    function eventOnkeydown(){\n        document.getElementById("test3").innerHTML = document.getElementById("test2").value;\n    }\n<\/script>\n<body>\n\t<span>元素改变(onchange):</span>\n\t<select name="listTest" id="listTest" onchange="eventOnchange()">\n\t    <option value="no1">1</option>\n\t    <option value="no2">2</option>\n\t    <option value="no3">3</option>\n\t    <option value="no4">4</option>\n\t</select>\n\t\n\t<br>\n\t<br>\n\t<a href="#" onclick="eventOnclick()">点击(onclick)</a>\n\t\n\t<br>\n\t<br>\n\t<span id="test1" onmouseover="eventOnmouseover()" onmouseout="eventOnmouseout()">鼠标移到这里试试(onmouseover | onmouseout)</span>\n\t\n\t<br>\n\t<br>\n\t<span>敲击键盘响应(onkeydown):</span>\n\t<input id="test2" type="text" onkeydown="eventOnkeydown()">\n\t<span id="test3"></span>\n</body>\n\n\n\n# DOM模型\n\nDOM可 访问 HTML文档所有元素的对象 当HMTL页面加载完毕后浏览器会创建文档对象模型\n\nHTML DOM 模型 被构造为对象的数: (html文档示例)\n\nJavaScript01.png\n\n可动态的更改HTNL页面\n\n * 更改元素\n * 更改HTML属性\n * 更改CSS样式\n * 更改事件\n\n\n# Document对象\n\n每个载入浏览器的 HTML 文档都会成为 Document 对象 Document对象 是 HTML文档的 根节点, 通过该对象可访问HTML文档进行编辑\n\n点击Document对象详细\n\n点击XML Document对象详细\n\n\n# Element 对象\n\nElement 对象 表示 HTML 元素. Element 对象拥有类型为元素节点、文本节点、注释节点的子节点\n\n点击Element对象详细\n\n节点对象的获取\n\n返回          方法                                     说明\nElement     document.getElementById()              根据id获取\nElement[]   document.getElementsByName()           根据name属性获取\nElement[]   document.getElementsByTagName(<标签名>)   根据标签名获取\nElement[]   document.getElementsByClass(<类名>)      根据类名获取\n\n节点对象找节点\n\n返回          属性                       说明\nElement[]   childNodes               节点所有子节点\nElement     firstElementChild        节点第一个子节点\nElement     lastElementChild         节点最后一个子节点\nElement     parentNode               当前父节点\nElement     nextElementSibling       当前节点的下一同级节点\nElement     previousElementSibling   当前节点的上一同级节点\n\n示例\n\n<script type="text/javascript">\n    function domTest(){\n        var id = document.getElementById("idTest");\n        id.innerHTML = id.innerHTML+"  以获取节点对象1!";\n\n        // 后面指定 该类名 节点的第几个 (从0开始)\n        var classTest = document.getElementsByClassName("classTest")[0];\n        classTest.innerHTML = classTest.innerHTML + "  以获取节点对象2!";\n\n        var names = document.getElementsByName("nameTest");\n        for(var i = 0 ; i < names.length ; i++){\n            names[i].innerHTML = names[i].innerHTML + "  以获取节点对象!";\n        }\n\n        var tagName = document.getElementsByTagName("li");\n        for (var i = 0; i < tagName.length; i++) {\n            tagName[i].innerHTML = tagName[i].innerHTML + "  以通过li获取对象节点!!!!";\n        }\n    }\n<\/script>\n\x3c!-- 加载完后执行函数 (onload)--\x3e\n<body onload="domTest()">\n    <p id="idTest">ID 测试</p>\n    <p id="idTest">ID2 测试</p>\n    <p class="classTest">Class 测试</p>\n    <p>name 测试:</p>\n    <ol>\n        <li name="nameTest">111</li>\n        <li name="nameTest">222</li>\n        <li name="nameTest">333</li>\n    </ol>\n    <br>    \n</body>\n\n\n\n# HTML文档编辑\n\n# HTML内容\n\ninnerHTML 更改HTML内容\n\ninnerTest 更改标签文本内容\n\n<button>test</button>\n<button>html</button>\n<div>\n    <ul>\n        <li>1</li>\n        <li>2</li>\n        <li>3</li>\n    </ul>\n</div>\n<p id="msg"></p>\n<script>\n    let key = document.getElementById("msg");\n    document.getElementsByTagName("button")[0].onclick = function () {\n        key.innerText = document.getElementsByTagName("div")[0].innerText;\n    };\n    document.getElementsByTagName("button")[1].onclick = function () {\n        key.innerText = document.getElementsByTagName("div")[0].innerHTML;\n    };\n<\/script>\n\n\n# HTML属性\n\nsetAttribute() 更改HMTL属性\n\n//获取节点\nvar node = ...;\nnode.setAttribute(属性名 , 属性值);\n\n\n# CSS元素\n\n内行样式的更改\n\nstyle 更改/添加 内行样式\n\n//获取节点\nvar node = ...;\nnode.style.color="blue";\nnode.style.padding="4px";\n\n\n# 添加节点\n\nappendChild() 添加节点, 在节点最后 insertBefore() 添加节点, 在指定节点前\n\n//创建新节点\nvar newNode = document.createElement("p");\n//文本内容\nnewNode.innerHTML = "新段落!";\n\n//添加方式No.1\n//在节点最后添加 新节点\ndocument.getElementById("test").appendChild(newNode);\n\n//No.2\n//指定节点前面添加 新节点\nvar node = ...;\ndocument.getElementById("test").insertBefore(newNode , node);\n\n\n# 删除节点\n\nremoveChild() 删除节点\n\n// 删除 父节点指定的子节点\n//父节点\nvar parentNode = ...;\n//子节点\nvar childNode = parentNode.[...];\n//删除方式No.1\nparentNode.removeChild(childNode);\n\n//No.2\n//获取节点\nvar node = ...;\n//parentNode: 获取父节点\nnode.parentNode.removeChild(node);\n\n\n# 更改节点\n\nreplaceChild() 替换节点\n\n//创建新节点\nvar newNode = ...;\n//新节点文本内容\nnewNode.innerHTML = "覆盖";\n//旧节点获取\nvar oldNode = ...;\n//parentNode: 获取父节点\noldNode.parentNode.replaceChild(newNode , oldNode);\n',normalizedContent:'# javascript\n\n\n# 概述\n\njavascript是web页面中的一种脚本编程语言，也是一种通用的、跨平台的、基于对象和事件驱动并具有安全性的脚本语言。它不需要进行编译，而是直接嵌入在html页面中，把静态页面转变成支持用户交互并响应相应事件的动态页面。\n\n\n# 引入（script）\n\n\n# 内部引入\n\n在html文档中可以使用 <script>... <\/script>标记将javascript脚本嵌入到其中。 script属性：\n\nscript属性   说明\nlanguage   不常用\ntype       用于指定使用的脚本类型\nsrc        指定外部脚本文件路径\ndefer      不常用\n\ntype属性的语法格式：\n\n<script type = "text/javascript">\n\t···\n<\/script>\n\n\n\n# 外部引入\n\n多了个src属性 url 或 本地路径\n\n<script type = "text/javascript" src = "js文件的rul路径">\n\t···\n<\/script>\n\n\n注意：\n\n 1. 外部javascript文件中只能包含javascript代码，不能包含html和<script>标签。\n 2. 在<script>标签内部不要存在其他的javascript代码。\n 3. 在链接外部javascript文件时<\/script>结束标签不能省略。\n\n\n# 标签属性值引用\n\n在html文档中可以在<a>标签、<input>标签 中使用javascript脚本作为它们的属性值 通过“javascript”调用\n\n<a href="javascript:alert(\'你好javascript\')">测试</a>\n\n\n与实践结合调用\n\n<input type="button" value="测试" onclick="alert(\'你好javascript \')" />\n\n\n\n# 基本语法\n\n 1. 执行顺序 程序按照在html文件中出现的顺序逐行执行\n 2. 大小写敏感 在输入语言的关键字、函数名、变量时，都必须采用正确的大小写形\n 3. 空格与换行 在javascript中会忽略程序中的空格、换行和制表符\n 4. 每行结尾的分号可有可 为了养好习惯，经量写上分号\n\n注释\n\n注释就是向文件代码中添加的--些说明性的文字，或者对代码进行暂时屏蔽。//内容ro /*内容*/\n\n\n# 数据类型\n\n\n# 数值型\n\n数值类型          说明\n十进制           由0~9组成的数字序列\n十六进制          “0x”或“0x”开头数字序列\n八进制           以0开头\n浮点型           传统计数法、科学计数法e或e后面的整数表示10的指数次幂\n特殊值infinity   超出最大值范围，则正\n              超出最小范围，则负\n特殊值nan        非数字\n\n科学计数法 语法格式：\n\n[digits] [.digits] [e|e[(+| -)]]\n\n\n例子： $$ 4e+2 = 4*10^{2} = 400 $$\n\n$$ 3.14e4 = 3.14*10^{4} = 31400 $$\n\n$$ .14e4 = 0.14*10^{4} = 1400 $$\n\n$$ 314e-2 = 314*10^{-2} = 3.14 $$\n\n\n# 字符串型\n\n字符串型数据是包含在 单引号或双引号 中的\n\n> 由单引号定界的字符串中可以含有双引号 由双引号定界的字符串中也可以含有单引号\n\n"i\'m legend" = i\'m legend \nvar greetings = "hello";\n\n\n\n# 布尔型\n\n布尔数据类型只有两个值，一 个是true （真），一个是false （假）\n\n\n# 特殊类型\n\n# 转义字符\n\n转义字符 是\\，通过转义字符可以在字符串中添加不可显示的特殊字符（例如\\n, \\t），或者防止引号匹配混乱的问题\n\n转义字符     描述\n\\r       回车符\n\\t       水平制表符，tab空 格\n\\b       退格\n\\v       垂直制表符\n\\f       换页\n\\n       换行符\n\\ \\      反斜杠\n\\ooo     八进制，范围000~777\n\\ \'      单引号\n\\xhh     十六进制整数，范围00~ff\n\\ "      双引号\n\\uhhhh   十六进制编码unicode字符\n\n在document. write()语句中使用转义字符时，只有将其放在格式化文本块中才会起作用，即脚本必须放在<pre></pre>标签内。 代码：\n\n<script type="text/javascript">\n    document.write("<pre>");\n    document.write("网页基础:\\nhtml\\ncss\\njavascript");\n    document.write("<pre>");\n<\/script>\n\n\n# 空值 (null)\n\n用于定义空的或不存在的引用\n\n# 未定义（undefined）\n\n表示还没赋值，类似于java中的 空指针异常\n\n\n# 常量与变量\n\n常量：固定不变数据 变量：存储要用的数据 如果只是声明了变量，并未对其赋值，则其值默认为undef ined。可以使用var语句重复声明同一个变量，也可以在重复声明变量时为该变量赋一个新值。 在javascript中的变量必须要先定义后使用，没有定义过的变量不能直接使用。\n\n\n# 算术运算符\n\n用于在程序中进行加、减、乘、除等运算。\n\n\n# 比较运算符\n\n对操作数进行比较，然后返回一个布尔值true或faise.\n\n> < , <= , > , >= , == , != , === (绝对等于) , !==(绝对不等于)\n\n\n# 赋值运算符\n\n简单赋值运算符： = 符合赋值运算符： += , -= , *= , /= , %=\n\n\n# 字符串运算符\n\n用于两个字符串型数据之间的运算符，它的作用是将两个字符串连接起来。 如果比较字符串，则逐个比较字符的ascil码值，ascii码值大的字符串大。ascii码值都相等，字符数多的字符串大。\n\n\n# 逻辑运算符\n\n用于对一个或多个布尔值进行逻辑运算：&&（与 ）、||（或） 、!(非）\n\n\n# 条件运算符\n\n> 表达式?结果1:结果2 结果1为: true 结果2为: false\n\n\n# 逗号运算符\n\n用于将多个表达式排在一起，整个表达式的值为最后一个表达式的值。 例子：\n\nvar a , b , c , d;\na = (b=3 , c=4 , d=1);\ndocument.write("a最终值为"+a);\n//结果为 1\n\n\n\n# 运算符 (typeof)\n\ntypeof 用于判断操作数的数据类型。语法格式：\n\ntypeof 操作数;\n\n\n数据类型（操作数）   返回值\n数值型         number\n字符串型        string\n布尔型         boolean\nundefined   nudefined\nnull        object\n对象          object\n函数          functio\n\n\n# 运算符 (new)\n\nnew 用来创建一个新的对象实例。语法格式：\n\n> 格式1： 对象实例名称 = new 对象类型(参数);\n> \n> 格式2： 对象实例名称 = new 对象类型2;\n\n\n# 运算符的优先级\n\n优先级        结合性   运算符\n最高         向左    、[]、()\n由高到低依次排列         ++、--、-、！、delete、new、typeof、void\n           向左    *、/、%\n           向左    +、-\n           向左    <<、>> 、>>\n           向左    <、<=、>、>=、in、instanceof\n           向左    =、!=、=== 、 绝对不等于\n           向左    &\n           向左    ^\n           向左    |\n           向左    &&\n           向左    ||\n           向右    ?:\n           向右    =\n           向右    =、/=、%=、+=、-=、<<=、>>=、>>>=、&=、^=、|=\n最低         向右    ,\n\n结合性 左结合：除了赋值、条件和单目运算符 右结合：赋值运算符、条件运算符\n\n\n# 表达式\n\n是运算符和操作数组合而成的式子。运算结果可分为：算术表达式、字符串表达式、逻辑表达式 表达式是一个相对的概念，在表达式中可以含有若千个子表达式，而且表达式中的一个常量或变量都可以看作是一个表达式。\n\n\n# 转换为数值型\n\n转前类型        转后的数值（数值）\nundefined   nan\nnull        0\n逻辑型         true,则为 1 ;false,则为 0\n字符串型        若内容为数字，则相应的数字，否则为nan\n其他对象        nan（非数字）\n\n\n# 转换为布尔型\n\n转前类型        转后的布尔型\nundefined   false\nnull        false\n数值型         值为0或nan,则结果为false,否则为true\n字符串型        长度为0，则结果为false,否则为true\n其他对象        true\n\n\n# 转换为字符串型\n\n转前类型        转后的字符串型\nundefined   "undefined"\nnull        "null"\n数值型         nan、0或者与数值相对应的字符串\n逻辑型         值true,则为"true",值为false,则结果为"false"\n其他对象        若存在，结果为tostring()方法的值，否则结果为"undefined"\n\n\n# 语句结构\n\n\n# 赋值语句\n\n···\n\n\n# 判断语句\n\n# if[...else]\n\nif判断语句\n\nif(表达式){\n  ···\n}\n\n\nif语句的嵌套\n\n套娃格式，if中的if\n\nif(表达式1){\n    if(表达式2){\n        ···\n    }else{\n        ···\n    }\n}else{\n    if(表达式3){\n         ···\n    }else{\n      ···\n    }\n}\n\n\n# switch\n\nswitch分支语句，根据一个表达式的值，选择不同的分支执行\n\n> 注意 ：在javascript中 case 指定的值可以应用表达式，而java不能应用表达式\n\nswitch (表达式){\n    case 常量表达式1 :\n        语句1;\n        ···;\n        break;\n    case 常量表达式2 :\n        语句2;\n        ···;\n        break;\n        ···\n    case 常量表达式n :\n        语句n;\n        ···;\n        break;\n    default:\n\t\t语句n+1;\n        break;\n}\n\n\ndefault语句可以省略，case语句没有匹配的则不进行任何操作。\n\n\n# 循环语句\n\n# while\n\n一个表达式来控制循环\n\nwhile(表达式)(\n    ···\n)\n\n\n# do...while\n\n先执行在判断是否循环\n\ndo{\n   ···\n}while(表达式);\n\n\n# for\n\n计次循环，可控制循环数\n\nif(初始化表达式 ; 条件表达式 ; 迭代表达式){\n     ···\n}\n\n\n# for...in\n\n迭代语句，遍历组中的所有元素（循环次数 = 组中的数量）\n\nfor(element in group){\n    ···\n}\n//element：遍历组的元素\n//group：需要遍历的组\n\n\n# continue\n\ncontinue跳转语句 跳过本次循环，并开始下一次循环\n\n# break\n\n**break跳转语句 ** 在循环语句中，break语句用于跳出循环\n\n\n# 异常语句\n\n# try...catch...finally\n\ntry语句会捕捉到error对象（exception），该对象可以描述错误\n\nerror对象属性\n\n> name ：表示异常类型的字符串 message ：实际的异常信息\n\ntry{\n    ...\n   //捕捉异常代码区域\n}catch(exception){\n    var name = exception.name;\n    var message = exception.message;\n    ...\t\n    //异常提示区域\n}finally{\n    ...\n    //最后执行的区域\n}\n\n\n> try： 尝试执行代码 catch： 捕捉异常 finally： 最终处理\n\n# throw\n\nthrow语句抛出异常，有目的性的抛出异常\n\n//以下代码执行直接抛出异常\nthrow new error("错误");\n\n\n\n# 对象\n\n\n# string对象\n\nstring对象是动态对象，对象需要实例后才能引用属性和方法，主要用于处理或格式化文本字符串\n\n点击string对象方法\n\nvar str = "我爱学习 ，学习使我快乐";\nvar str2 = new string("我爱学习 ，学习使我快乐");\nconsole.log("字符串长度："+str.length);\n\n\n\n# array对象\n\narray 对象用于在变量中存储多个值，也就是数组\n\n点击array对象方法\n\n//no.1\nvar namearray = new array();\nnamearray[0] = "zhangsan";\nnamearray[1] = "lisi";\nnamearray[2] = "wangwu";\n\n//no.2\nvar namearray2 = ["zhangsan","lisi","wangwu"];\ndocument.write("遍历 ： <br/>");\nfor(var i = 0 ; i< namearray2.length ; i++){\n\tdocument.write(namearray[i]+"<br/>");\n}\n\n\n\n# date对象\n\ndate对象 实现对日期和时间的控制\n\n点击date对象方法\n\n//no.1 现在时间\nvar date1 = new date();\n//no.2 时间戳的偏移量 （1970.1.1开始）\nvar date2 = new date(milliseconds);\n//no.3 字符串时间（需要补全）\nvar date3 = new date(datestring);\n//no.4 数值时间值（月份：0 - 11）\nvar date4 = new date(year, month, day, hours, minutes, seconds, milliseconds);\n\n\n\n# math对象\n\nmath对象 实现数学应用，和java差不多\n\n点击math对象方法\n\n\n# 自定义对象\n\n自定义对象可以包含多个值（多个变量）\n\n定义\n\nvar 对象名 = {\n    属性: 值,\n    属性: 值,\n    函数名:function(){\n        //函数体···\n    }\n    ···\n};\n\n\n访问\n\n//no.1 \n对象名.属性名;\n\n//no.2\n对象名["属性名"];\n\n//函数调用\n对象名.函数名();\n\n\n注意：\n\n 1. 定义对象属性需要花括号括住\n 2. 属性与值之间是需要逗号分开 ,\n 3. 属性与属性之间需要冒号分开 : ，最后的属性不需要冒号分开\n 4. 定义对象的末尾需要分号结束 ;\n\n实例\n\nvar student={\n\tid:12,\n\tname:"zhangsan",\n\tage:18,\n\theight:179,\n\tinspirational:function(){\n\t\tprint("","好好学习天天向上");\n\t}\n};\n\nprint("id:",student.id);\nprint("name:",student.name);\nprint("age:",student["age"]);\nprint("height:",student.height);\n//调用函数\nstudent.inspirational();\n\nfunction print(text,str){\n\tdocument.write(text+str);\n\tdocument.write("<br/>");\n}\n\n/*\nid:12\nname:zhangsan\nage:18\nheight:179\n好好学习天天向上\n*/\n\n\n\n# window对象\n\nwindow对象 是浏览器对象dom模型。所有浏览器都支持 window对象 表示一个浏览器窗口或一个框架\n\n点击window详细\n\nwindow方法\n\nwindow方法                      说明\nsetinterval(<函数名>,<时间间隔毫秒>)   指定的周期 调用函数\nclearinterval(<定时对象>)         取消 setinterval() 设置的 定时器\nsettimeout()                  延迟器 休眠\n提示                            \nalert(<提示信息>)                 提示\nprompt(<提示信息>,<默认值>)          用户输入\nconfirm(<提示信息>)               信息确认\n\n// 启动定时器\nlet time = window.setinterval("renew()",1000);\n\nfunction renew(){\n    console.log("定时加载");\n}\n\n// 关闭定时器\nwindow.clearinterval(time);\n\n\n常用对象属性\n\n# history对象\n\nwindow.history 对象 包含浏览器的历史history 对象\n\nhistory方法   说明\nback()      加载历史 history 列表中的前一个 url\nforward()   加载历史 history 列表中的下一个 url\ngo(int)     加载历史 history 列表中的某个具体页面\n            整数 前；负数 后\n\n<body>\n\t<a href="https://www.baidu.com/">baidu</a>\n\t<br>\n\t<a href="https://www.google.cn/">google</a>\n\t<br>\n\t<a href="window返回页.html">进入</a>\n\t<br>\n\t<br>\n\t<a  href="#" onclick="winmethods.forward()">前进</a>\n\t<br>\n\t<a href="#" onclick="winmethods.back()">后退</a>\n\t<br>\n\t<a href="#" onclick="winmethods.go(-99)">置低</a>\n\t<br>\n\t<a href="#" onclick="winmethods.go(99)">置顶</a>\n</body>\n<script type="text/javascript">\n\tvar winmethods = {\n\t\tforward:function(){\n\t\t\tjavascript:window.history.forward();\n\t\t},\n\t\tback:function(){\n\t\t\tjavascript:window.history.back();\n\t\t},\n\t\tgo:function(num){\n\t\t\tjavascript:window.history.go(num);\n\t\t}\n\t};\n<\/script>\n\n\n# location对象\n\nwindow.location 对象 获得当前页面地址 (url)，并把浏览器重定向到新的页面\n\nlocation方法     描述\nassign(rul)    加载新的文档\nreload()       重新加载当前文档\nreplace(url)   用新的文档替换当前文档\n\n <a href="javascript:alert(window.location.href)">获取当前页面的url地址</a>\n<a href="javascript:window.location.reload()">刷新</a>\n<br />\n<a href="javascript:location.replace(\'https://www.baidu.com\')">跳转到百度</a><br\n/>\n<br/>\n<a href="javascript:location.assign(\'https://www.baidu.com\')">跳转到百度</a><br\n/>\n\n\n\n# regexp 对象\n\nregexp对象 正则表达式, 用于对 字符串 进行 描述/匹配 规则的字符串, 对其替换或扫描\n\n点击regexp对象详细 正则匹配网页应用: 链接1 , 链接2\n\nvar reg = new regexp(正则表达式 [, 修饰符]);\n\n\n修饰符说明\n\n全局匹配、区分大小写的匹配和多行匹配\n\n修饰符   说明\ni     无视大小写匹配\ng     查找所有匹配的 内容\nm     多行匹配\n\n//no.1\nvar reg1 = new regexp("abc");\nalert(reg2.test("abc"));\n\n//no.2\nalert(/[abc]/.test("bca"));\n\n//应用示范\n/[abc]/i.test("aac");\t//true\n\n//方法应用\n//search()\nconsole.log("i like javascript".search(/java/));    //java存在 第七个 字符头\n//match()\nconsole.log("do you like java?no,i don\'t like java!".match(/java/g));    //array={\'\n//replace()\nconsole.log("i like javascript".replace(/javascript/, "java"));     //将 java 覆盖\nconsole.log("\'a\',\'b\',\'c\'".replace(/\'([^\']*)\'/g,\'"$1"\'));    //将单引号替换至双引号 \n//split()\nconsole.log("i like javascript".split(" "));    //array={\'i\',\'like\',\'javascript\'}\nconsole.log("a : b : c".split(/ : /g));    //array={\'a\',\'b\',\'c\'}\n\n//修饰符\nconsole.log(/[abc]/i.test("aac"));\t//tuse\nconsole.log("is this all there is?".match(/is/));    //is\nconsole.log("is this all there is?".match(/is/g));    //array={\'is\',\'is\'}\n\n\n常用正则表达式:\n\n 1. 匹配 **身份证号码 **\n    \n    > /^[1-9]\\d{5}(18|19|([23]\\d))\\d{2}((0[1-9])|(10|11|12))(([0-2] [1-9])|10|20|30|31)\\d{3}[0-9xx]$/\n    > \n    > [1-9]\\d{5} 前六位地区，非0打头 (18|19|([23]\\d))\\d{2} 出身年份，覆盖范围为 1800-3999 年 ((0[1-9])|(10|11|12)) 月份，01-12月 (([0-2][1-9])|10|20|30|31) 日期，01-31天 \\d{3}[0-9xx] 顺序码三位 + 一位校验码\n\n 2. 匹配 手机号\n    \n    > /^1[3|4|5|7|8][0-9]{9}$/\n\n 3. 匹配 邮箱\n    \n    > /^\\w+@[a-za-z0-9]{2,10}(?:\\.[a-z]{2,4}){1,3}$/\n\n 4. 匹配 url\n    \n    > /http(s)?:\\/\\/[\\w.]+[\\w\\/]*[\\w.]*\\??[\\w=&\\+\\%]*/\n\n\n# 函数\n\n\n# 数值内置函数\n\n# isnan\n\nisnan(param) 检查其参数是否是非数字值\n\nconsole.log(isnan(666));//false\nconsole.log(isnan(1+2));//false\nconsole.log(isnan("hello"));//true\n\n\n# parsefloat\n\nparsefloat(string) 解析一个字符串，返回一个浮点数\n\nconsole.log(parsefloat("66"));//66\nconsole.log(parsefloat("199.99"));//199.99\nconsole.log(parsefloat("1024 2048 4096"));//1024\nconsole.log(parsefloat(" 128 "));//128\nconsole.log(parsefloat("10年"));//10\nconsole.log(parsefloat("今天是8号"));//nan\n\n\n注意：\n\n 1. 字符串中只返回第一个数值\n 2. 头尾允许空格\n 3. 首字符不为数字，则nan\n\n# parseint\n\nparseint(string[,radix]) 解析一个字符串，并返回一个整数 **string：**解析字符串；**radix：**数字基数(2 - 36) （进制数）\n\nconsole.log(parseint("66"));//66\nconsole.log(parseint("199.99"));//199\nconsole.log(parseint("1024 2048 4096"));//1024\nconsole.log(parseint(" 128 "));//128\nconsole.log(parseint("10年"));//10\nconsole.log(parseint("今天是8号"));//nan\n\nconsole.log(parseint("10",10));//10\nconsole.log(parseint("010"));//10\nconsole.log(parseint("10",8));//8\nconsole.log(parseint("0x10"));//16\nconsole.log(parseint("10",16));//16\n\n\n注意：\n\n 1. 字符串中只返回第一个数值\n 2. 开头和结尾的空格是允许的\n 3. 首字符不为数字，则nan\n 4. radix 进制数可自选\n\n\n# 字符串内置函数\n\n# eval\n\neval(string) 计算字符串中的表达式的值 将其执行结果返回\n\n# escape\n\nescape(string) 字符串编码 特殊字符(不包括字母和数字字符以及*、@、一、_、+、.和/)进行编码，可将特殊字符转换为“%xx” 格式的数字\n\nescape("you & me");\n// escape("you & me") →you%20%26%20me\n\n\n# unescape\n\nunescape(string) 字符串解码 对应用escape()函数编码后的字符串进行解码。可将字符串中“%xx”格式的数字转换为字符串\n\nunescape("you%20%26%20me");\n//如: unescape("you%20%26%20me") →you & me\n\n\n# encodeuri\n\nencodeuri(uri) 将url字符串进行编码\n\n# decodeuri\n\ndecodeuri(url) 对已编码url字符串进行解码\n\n\n# 自定义函数\n\n函数定义\n\nfunction 函数名(参数列表){\n\t//函数体\n\t[return 返回值]\n}\n\n\n注意：\n\n 1. 参数可直接写参数名称，无需定义类型\n 2. 函数是否返回取决于是否有 return 关键字\n\n\n# 匿名函数\n\nvar 变量名 = function(参数列表){\n\t//函数体\n    return 返回值;\n};\n\n\n\n# 事件\n\nhtml页面的元素都有自带的行为, 自要他们进行操作 , 就会触发相应事件\n\n点击事件详细\n\n示例\n\n<script type="text/javascript">\n    function eventonchange() {\n        alert("元素值更变!!!");\n    }\n    function eventonclick() {\n        alert("用户点击了元素!!!");\n    }\n    function eventonmouseover(){\n        document.getelementbyid("test1").innerhtml = "鼠标移到触发(onmouseover)";\n    }\n    function eventonmouseout(){\n        document.getelementbyid("test1").innerhtml = "鼠标移出触发(onmouseout)";\n    }\n    function eventonkeydown(){\n        document.getelementbyid("test3").innerhtml = document.getelementbyid("test2").value;\n    }\n<\/script>\n<body>\n\t<span>元素改变(onchange):</span>\n\t<select name="listtest" id="listtest" onchange="eventonchange()">\n\t    <option value="no1">1</option>\n\t    <option value="no2">2</option>\n\t    <option value="no3">3</option>\n\t    <option value="no4">4</option>\n\t</select>\n\t\n\t<br>\n\t<br>\n\t<a href="#" onclick="eventonclick()">点击(onclick)</a>\n\t\n\t<br>\n\t<br>\n\t<span id="test1" onmouseover="eventonmouseover()" onmouseout="eventonmouseout()">鼠标移到这里试试(onmouseover | onmouseout)</span>\n\t\n\t<br>\n\t<br>\n\t<span>敲击键盘响应(onkeydown):</span>\n\t<input id="test2" type="text" onkeydown="eventonkeydown()">\n\t<span id="test3"></span>\n</body>\n\n\n\n# dom模型\n\ndom可 访问 html文档所有元素的对象 当hmtl页面加载完毕后浏览器会创建文档对象模型\n\nhtml dom 模型 被构造为对象的数: (html文档示例)\n\njavascript01.png\n\n可动态的更改htnl页面\n\n * 更改元素\n * 更改html属性\n * 更改css样式\n * 更改事件\n\n\n# document对象\n\n每个载入浏览器的 html 文档都会成为 document 对象 document对象 是 html文档的 根节点, 通过该对象可访问html文档进行编辑\n\n点击document对象详细\n\n点击xml document对象详细\n\n\n# element 对象\n\nelement 对象 表示 html 元素. element 对象拥有类型为元素节点、文本节点、注释节点的子节点\n\n点击element对象详细\n\n节点对象的获取\n\n返回          方法                                     说明\nelement     document.getelementbyid()              根据id获取\nelement[]   document.getelementsbyname()           根据name属性获取\nelement[]   document.getelementsbytagname(<标签名>)   根据标签名获取\nelement[]   document.getelementsbyclass(<类名>)      根据类名获取\n\n节点对象找节点\n\n返回          属性                       说明\nelement[]   childnodes               节点所有子节点\nelement     firstelementchild        节点第一个子节点\nelement     lastelementchild         节点最后一个子节点\nelement     parentnode               当前父节点\nelement     nextelementsibling       当前节点的下一同级节点\nelement     previouselementsibling   当前节点的上一同级节点\n\n示例\n\n<script type="text/javascript">\n    function domtest(){\n        var id = document.getelementbyid("idtest");\n        id.innerhtml = id.innerhtml+"  以获取节点对象1!";\n\n        // 后面指定 该类名 节点的第几个 (从0开始)\n        var classtest = document.getelementsbyclassname("classtest")[0];\n        classtest.innerhtml = classtest.innerhtml + "  以获取节点对象2!";\n\n        var names = document.getelementsbyname("nametest");\n        for(var i = 0 ; i < names.length ; i++){\n            names[i].innerhtml = names[i].innerhtml + "  以获取节点对象!";\n        }\n\n        var tagname = document.getelementsbytagname("li");\n        for (var i = 0; i < tagname.length; i++) {\n            tagname[i].innerhtml = tagname[i].innerhtml + "  以通过li获取对象节点!!!!";\n        }\n    }\n<\/script>\n\x3c!-- 加载完后执行函数 (onload)--\x3e\n<body onload="domtest()">\n    <p id="idtest">id 测试</p>\n    <p id="idtest">id2 测试</p>\n    <p class="classtest">class 测试</p>\n    <p>name 测试:</p>\n    <ol>\n        <li name="nametest">111</li>\n        <li name="nametest">222</li>\n        <li name="nametest">333</li>\n    </ol>\n    <br>    \n</body>\n\n\n\n# html文档编辑\n\n# html内容\n\ninnerhtml 更改html内容\n\ninnertest 更改标签文本内容\n\n<button>test</button>\n<button>html</button>\n<div>\n    <ul>\n        <li>1</li>\n        <li>2</li>\n        <li>3</li>\n    </ul>\n</div>\n<p id="msg"></p>\n<script>\n    let key = document.getelementbyid("msg");\n    document.getelementsbytagname("button")[0].onclick = function () {\n        key.innertext = document.getelementsbytagname("div")[0].innertext;\n    };\n    document.getelementsbytagname("button")[1].onclick = function () {\n        key.innertext = document.getelementsbytagname("div")[0].innerhtml;\n    };\n<\/script>\n\n\n# html属性\n\nsetattribute() 更改hmtl属性\n\n//获取节点\nvar node = ...;\nnode.setattribute(属性名 , 属性值);\n\n\n# css元素\n\n内行样式的更改\n\nstyle 更改/添加 内行样式\n\n//获取节点\nvar node = ...;\nnode.style.color="blue";\nnode.style.padding="4px";\n\n\n# 添加节点\n\nappendchild() 添加节点, 在节点最后 insertbefore() 添加节点, 在指定节点前\n\n//创建新节点\nvar newnode = document.createelement("p");\n//文本内容\nnewnode.innerhtml = "新段落!";\n\n//添加方式no.1\n//在节点最后添加 新节点\ndocument.getelementbyid("test").appendchild(newnode);\n\n//no.2\n//指定节点前面添加 新节点\nvar node = ...;\ndocument.getelementbyid("test").insertbefore(newnode , node);\n\n\n# 删除节点\n\nremovechild() 删除节点\n\n// 删除 父节点指定的子节点\n//父节点\nvar parentnode = ...;\n//子节点\nvar childnode = parentnode.[...];\n//删除方式no.1\nparentnode.removechild(childnode);\n\n//no.2\n//获取节点\nvar node = ...;\n//parentnode: 获取父节点\nnode.parentnode.removechild(node);\n\n\n# 更改节点\n\nreplacechild() 替换节点\n\n//创建新节点\nvar newnode = ...;\n//新节点文本内容\nnewnode.innerhtml = "覆盖";\n//旧节点获取\nvar oldnode = ...;\n//parentnode: 获取父节点\noldnode.parentnode.replacechild(newnode , oldnode);\n',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"CSS",frontmatter:{title:"CSS",author:"柏竹",permalink:"/web/1hg7cw",date:"2020-02-18T00:00:00.000Z",categories:["前端","编程语言"],tags:["CSS"]},regularPath:"/02.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87/02.CSS.html",relativePath:"02.前端/01.前端必备/02.CSS.md",key:"v-9077d038",path:"/web/1hg7cw/",headers:[{level:2,title:"概述",slug:"概述",normalizedTitle:"概述",charIndex:10},{level:2,title:"载入样式表",slug:"载入样式表",normalizedTitle:"载入样式表",charIndex:135},{level:3,title:"内部样式表",slug:"内部样式表",normalizedTitle:"内部样式表",charIndex:145},{level:3,title:"行内式",slug:"行内式",normalizedTitle:"行内式",charIndex:276},{level:3,title:"外部样式",slug:"外部样式",normalizedTitle:"外部样式",charIndex:372},{level:3,title:"样式表总结",slug:"样式表总结",normalizedTitle:"样式表总结",charIndex:534},{level:2,title:"选择器",slug:"选择器",normalizedTitle:"选择器",charIndex:217},{level:3,title:"标签选择器",slug:"标签选择器",normalizedTitle:"标签选择器",charIndex:780},{level:3,title:"类选择器",slug:"类选择器",normalizedTitle:"类选择器",charIndex:859},{level:3,title:"id选择器",slug:"id选择器",normalizedTitle:"id选择器",charIndex:913},{level:3,title:"通配符选择器",slug:"通配符选择器",normalizedTitle:"通配符选择器",charIndex:964},{level:3,title:"选择器总结",slug:"选择器总结",normalizedTitle:"选择器总结",charIndex:1008},{level:2,title:"复合选择器",slug:"复合选择器",normalizedTitle:"复合选择器",charIndex:1454},{level:3,title:"交集选择器",slug:"交集选择器",normalizedTitle:"交集选择器",charIndex:1464},{level:3,title:"并集选择器",slug:"并集选择器",normalizedTitle:"并集选择器",charIndex:1587},{level:3,title:"后代选择器",slug:"后代选择器",normalizedTitle:"后代选择器",charIndex:1690},{level:3,title:"子代选择器",slug:"子代选择器",normalizedTitle:"子代选择器",charIndex:1844},{level:3,title:"伪类选择器",slug:"伪类选择器",normalizedTitle:"伪类选择器",charIndex:1957},{level:3,title:"属性选择器",slug:"属性选择器",normalizedTitle:"属性选择器",charIndex:2649},{level:4,title:"属性值的匹配",slug:"属性值的匹配",normalizedTitle:"属性值的匹配",charIndex:2719},{level:2,title:"优先级",slug:"优先级",normalizedTitle:"优先级",charIndex:3175},{level:3,title:"选择器",slug:"选择器-2",normalizedTitle:"选择器",charIndex:217},{level:3,title:"样式表",slug:"样式表",normalizedTitle:"样式表",charIndex:17},{level:2,title:"元素显示模式",slug:"元素显示模式",normalizedTitle:"元素显示模式",charIndex:3287},{level:3,title:"块级元素 (block)",slug:"块级元素-block",normalizedTitle:"块级元素 (block)",charIndex:3298},{level:3,title:"行内元素 (inline)",slug:"行内元素-inline",normalizedTitle:"行内元素 (inline)",charIndex:3526},{level:3,title:"行内块元素 (inline-block)",slug:"行内块元素-inline-block",normalizedTitle:"行内块元素 (inline-block)",charIndex:3853},{level:3,title:"标签显示总结",slug:"标签显示总结",normalizedTitle:"标签显示总结",charIndex:3994},{level:2,title:"字体样式",slug:"字体样式",normalizedTitle:"字体样式",charIndex:4442},{level:3,title:"字体编码",slug:"字体编码",normalizedTitle:"字体编码",charIndex:4867},{level:2,title:"文本样式",slug:"文本样式",normalizedTitle:"文本样式",charIndex:5375},{level:2,title:"背景样式",slug:"背景样式",normalizedTitle:"背景样式",charIndex:6078},{level:2,title:"盒子样式",slug:"盒子样式",normalizedTitle:"盒子样式",charIndex:8170},{level:3,title:"边框写法总结",slug:"边框写法总结",normalizedTitle:"边框写法总结",charIndex:10088},{level:3,title:"盒子扩展",slug:"盒子扩展",normalizedTitle:"盒子扩展",charIndex:11114},{level:4,title:"盒子宽高",slug:"盒子宽高",normalizedTitle:"盒子宽高",charIndex:11122},{level:4,title:"盒子外边距实现居中",slug:"盒子外边距实现居中",normalizedTitle:"盒子外边距实现居中",charIndex:11362},{level:4,title:"清除元素的默认内外边距",slug:"清除元素的默认内外边距",normalizedTitle:"清除元素的默认内外边距",charIndex:11418},{level:2,title:"浮动 (float)",slug:"浮动-float",normalizedTitle:"浮动 (float)",charIndex:11510},{level:3,title:"浮动特性",slug:"浮动特性",normalizedTitle:"浮动特性",charIndex:11659},{level:3,title:"浮动清除",slug:"浮动清除",normalizedTitle:"浮动清除",charIndex:11993},{level:4,title:"额外标签法",slug:"额外标签法",normalizedTitle:"额外标签法",charIndex:12189},{level:4,title:"父级添加overflow属性方法",slug:"父级添加overflow属性方法",normalizedTitle:"父级添加overflow属性方法",charIndex:12351},{level:4,title:"after伪元素清除浮动",slug:"after伪元素清除浮动",normalizedTitle:"after伪元素清除浮动",charIndex:12534},{level:4,title:"使用before和after双伪元素清除浮动",slug:"使用before和after双伪元素清除浮动",normalizedTitle:"使用before和after双伪元素清除浮动",charIndex:12893},{level:2,title:"定位(position)",slug:"定位-position",normalizedTitle:"定位(position)",charIndex:13097},{level:3,title:"静态定位 (static)",slug:"静态定位-static",normalizedTitle:"静态定位 (static)",charIndex:13366},{level:3,title:"相对定位 (relative)",slug:"相对定位-relative",normalizedTitle:"相对定位 (relative)",charIndex:13450},{level:3,title:"绝对定位 (absolute)",slug:"绝对定位-absolute",normalizedTitle:"绝对定位 (absolute)",charIndex:13560},{level:3,title:"固定定位 (fixed)",slug:"固定定位-fixed",normalizedTitle:"固定定位 (fixed)",charIndex:13785},{level:3,title:"叠放次序 (z-index)",slug:"叠放次序-z-index",normalizedTitle:"叠放次序 (z-index)",charIndex:13880},{level:3,title:"定位总结",slug:"定位总结",normalizedTitle:"定位总结",charIndex:14008},{level:2,title:"显示&隐藏",slug:"显示-隐藏",normalizedTitle:"显示&amp;隐藏",charIndex:null},{level:3,title:"显示 (display)",slug:"显示-display",normalizedTitle:"显示 (display)",charIndex:14297},{level:3,title:"可见性 (visibility)",slug:"可见性-visibility",normalizedTitle:"可见性 (visibility)",charIndex:14403},{level:3,title:"溢出隐藏 (overflow)",slug:"溢出隐藏-overflow",normalizedTitle:"溢出隐藏 (overflow)",charIndex:14554},{level:2,title:"高级技巧",slug:"高级技巧",normalizedTitle:"高级技巧",charIndex:14770},{level:3,title:"鼠标样式 (cursor)",slug:"鼠标样式-cursor",normalizedTitle:"鼠标样式 (cursor)",charIndex:14779},{level:3,title:"禁止选中 (select)",slug:"禁止选中-select",normalizedTitle:"禁止选中 (select)",charIndex:14908},{level:3,title:"轮廓 (outline)",slug:"轮廓-outline",normalizedTitle:"轮廓 (outline)",charIndex:15023},{level:3,title:"文本域固定 (resize)",slug:"文本域固定-resize",normalizedTitle:"文本域固定 (resize)",charIndex:15247},{level:3,title:"垂直对齐 (vertical-align)",slug:"垂直对齐-vertical-align",normalizedTitle:"垂直对齐 (vertical-align)",charIndex:15381},{level:3,title:"自动换行 (word-break)",slug:"自动换行-word-break",normalizedTitle:"自动换行 (word-break)",charIndex:15563},{level:3,title:"空格换行 (white-space)",slug:"空格换行-white-space",normalizedTitle:"空格换行 (white-space)",charIndex:15789},{level:3,title:"文字溢出 (text-overflow)",slug:"文字溢出-text-overflow",normalizedTitle:"文字溢出 (text-overflow)",charIndex:16043},{level:2,title:"动画&变形",slug:"动画-变形",normalizedTitle:"动画&amp;变形",charIndex:null},{level:3,title:"元素变化(transform)",slug:"元素变化-transform",normalizedTitle:"元素变化(transform)",charIndex:16918},{level:3,title:"元素中心变换(transform-origin)",slug:"元素中心变换-transform-origin",normalizedTitle:"元素中心变换(transform-origin)",charIndex:17519},{level:3,title:"过渡效果(transition)",slug:"过渡效果-transition",normalizedTitle:"过渡效果(transition)",charIndex:17824},{level:4,title:"参与过渡属性",slug:"参与过渡属性",normalizedTitle:"参与过渡属性",charIndex:17844},{level:4,title:"过渡持续时间",slug:"过渡持续时间",normalizedTitle:"过渡持续时间",charIndex:18031},{level:4,title:"过渡延迟时间",slug:"过渡延迟时间",normalizedTitle:"过渡延迟时间",charIndex:18146},{level:4,title:"过渡动画类型",slug:"过渡动画类型",normalizedTitle:"过渡动画类型",charIndex:18255},{level:4,title:"过渡连写",slug:"过渡连写",normalizedTitle:"过渡连写",charIndex:18782},{level:3,title:"动画(Animation)",slug:"动画-animation",normalizedTitle:"动画(animation)",charIndex:19034},{level:4,title:"关键帧",slug:"关键帧",normalizedTitle:"关键帧",charIndex:19051},{level:4,title:"动画属性",slug:"动画属性",normalizedTitle:"动画属性",charIndex:19452},{level:2,title:"弹性布局 (Flex)",slug:"弹性布局-flex",normalizedTitle:"弹性布局 (flex)",charIndex:20153},{level:3,title:"justify-content",slug:"justify-content",normalizedTitle:"justify-content",charIndex:20169},{level:3,title:"align-items",slug:"align-items",normalizedTitle:"align-items",charIndex:20489},{level:3,title:"flex-direction",slug:"flex-direction",normalizedTitle:"flex-direction",charIndex:20719},{level:3,title:"flex-wrap",slug:"flex-wrap",normalizedTitle:"flex-wrap",charIndex:20925},{level:2,title:"精灵图",slug:"精灵图",normalizedTitle:"精灵图",charIndex:21154},{level:2,title:"滑动门",slug:"滑动门",normalizedTitle:"滑动门",charIndex:22597},{level:2,title:"字体图标",slug:"字体图标",normalizedTitle:"字体图标",charIndex:24163},{level:2,title:"版心和布局流程",slug:"版心和布局流程",normalizedTitle:"版心和布局流程",charIndex:25099},{level:3,title:"版心",slug:"版心",normalizedTitle:"版心",charIndex:25099},{level:3,title:"布局流程",slug:"布局流程",normalizedTitle:"布局流程",charIndex:25102},{level:2,title:"CSS书写规范",slug:"css书写规范",normalizedTitle:"css书写规范",charIndex:25324},{level:3,title:"空格规范",slug:"空格规范",normalizedTitle:"空格规范",charIndex:25336},{level:3,title:"选择器规范",slug:"选择器规范",normalizedTitle:"选择器规范",charIndex:25450},{level:3,title:"属性规范",slug:"属性规范",normalizedTitle:"属性规范",charIndex:25766},{level:3,title:"高度格式",slug:"高度格式",normalizedTitle:"高度格式",charIndex:25917},{level:2,title:"CSS 三大特性",slug:"css-三大特性",normalizedTitle:"css 三大特性",charIndex:26003},{level:3,title:"CSS层叠性",slug:"css层叠性",normalizedTitle:"css层叠性",charIndex:26016},{level:3,title:"CSS继承性",slug:"css继承性",normalizedTitle:"css继承性",charIndex:26122},{level:3,title:"CSS优先级",slug:"css优先级",normalizedTitle:"css优先级",charIndex:26216},{level:3,title:"CSS特殊性",slug:"css特殊性",normalizedTitle:"css特殊性",charIndex:26358},{level:4,title:"权重总结",slug:"权重总结",normalizedTitle:"权重总结",charIndex:26979}],headersStr:"概述 载入样式表 内部样式表 行内式 外部样式 样式表总结 选择器 标签选择器 类选择器 id选择器 通配符选择器 选择器总结 复合选择器 交集选择器 并集选择器 后代选择器 子代选择器 伪类选择器 属性选择器 属性值的匹配 优先级 选择器 样式表 元素显示模式 块级元素 (block) 行内元素 (inline) 行内块元素 (inline-block) 标签显示总结 字体样式 字体编码 文本样式 背景样式 盒子样式 边框写法总结 盒子扩展 盒子宽高 盒子外边距实现居中 清除元素的默认内外边距 浮动 (float) 浮动特性 浮动清除 额外标签法 父级添加overflow属性方法 after伪元素清除浮动 使用before和after双伪元素清除浮动 定位(position) 静态定位 (static) 相对定位 (relative) 绝对定位 (absolute) 固定定位 (fixed) 叠放次序 (z-index) 定位总结 显示&隐藏 显示 (display) 可见性 (visibility) 溢出隐藏 (overflow) 高级技巧 鼠标样式 (cursor) 禁止选中 (select) 轮廓 (outline) 文本域固定 (resize) 垂直对齐 (vertical-align) 自动换行 (word-break) 空格换行 (white-space) 文字溢出 (text-overflow) 动画&变形 元素变化(transform) 元素中心变换(transform-origin) 过渡效果(transition) 参与过渡属性 过渡持续时间 过渡延迟时间 过渡动画类型 过渡连写 动画(Animation) 关键帧 动画属性 弹性布局 (Flex) justify-content align-items flex-direction flex-wrap 精灵图 滑动门 字体图标 版心和布局流程 版心 布局流程 CSS书写规范 空格规范 选择器规范 属性规范 高度格式 CSS 三大特性 CSS层叠性 CSS继承性 CSS优先级 CSS特殊性 权重总结",content:'# CSS\n\n\n# 概述\n\ncss样式表或层叠样式表（级联样式表），用与设置HTML页面的文本内容（字体，大小，对齐样式）、图片外形等外观 CSS以HTML为基础，提供了丰富的功能，如字体、颜色、背景的控制及整体排版等，而且还可以针对不同的浏览器设置不同的样式\n\n\n# 载入样式表\n\n\n# 内部样式表\n\n在 head标签 内，并且用style标签定义属性\n\n<head>\n\t<style type="text/CSS">\n   \t \t选择器 {属性1:属性值1; 属性2:属性值2; 属性3:属性值3;}\n\t</style>\n</head>\n\n\n\n# 行内式\n\n内联样式。通过在标签中的 style属性 来设==置样式==\n\n<标签名 style="属性1:属性值1; 属性2:属性值2; 属性3:属性值3;"> 内容 </标签名>\n\n\n\n# 外部样式\n\n在 head标签 内，定义 link标签 引用外部文件\n\n<head>\n  <link href="CSS文件的路径"  rel="stylesheet" />\n</head>\n\n\nLINK属性   说明\nhreft    URL地址（相对/绝对）\nrel      类型 。值: stylesheet\n\n\n# 样式表总结\n\n样式表     优点             缺点             使用情况      控制范围\n行内样式表   书写方便，权重高       没有实现样式和结构相分离   较少        控制一个标签（少）\n内部样式表   部分结构和样式相分离     没有彻底分离         较多        控制一个页面（中）\n外部样式表   完全实现结构和样式相分离   需要引入           最多，强烈推荐   控制整个站点（多）\n\n\n# 选择器\n\n\n# 标签选择器\n\n标签选择器对指定的 标签 或 元素 作用\n\n标签名 | 元素名{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; ···}\n\n\n\n# 类选择器\n\n类选择器可对指定的对象起作用\n\n.类名{属性1:值; 属性2:值; 属性3:值; }\n\n\n\n# id选择器\n\n只对一个对象起作用\n\n#id名{属性1:值; 属性2:值; 属性3:值; }\n\n\n\n# 通配符选择器\n\n匹配页面中所有的元素\n\n*{ 属性1:值; 属性2:值; }\n\n\n\n# 选择器总结\n\n选择器       例子           例子描述\n.class    .intro       选中 class="intro" 的元素\n#id       #firstname   选中 id="firstname" 的元素\n*         *            选中 所有元素\nelement   p            选中 所有 <p> 元素\n\n选择器      优点                 缺点              使用范围\n标签选择器    快速在同一类型的标签添加样式     不能在同一标签设置不同样式   限制于设置的标签\n类选择器     可为对象单独定义样式，也可多标签                   广泛\nid选择器    可为对象单独定义样式         不能多标签共用         一个标签的范围\n通配符选择器   能匹配页面中所有的元素        不能单独定义样式        范围最广\n\n\n# 复合选择器\n\n\n# 交集选择器\n\n交集选择器由两个选择器构成，两个选择器之间不能有空格\n\n满足两个选择器的条件才能应用样式\n\n比如： p.one   选择的是： 类名为 .one 的段落标签。 \np.class{····}\nh3.class {····}\n\n\n\n# 并集选择器\n\n并集选择器 通过选择器与选择器之间通过逗号连接而成，任何形式的选择器都可作为并集选择器的一部分\n\n逗号连接的选择器 都有样式\n\n.class , h3 {属性:属性值; ····}\n\n\n\n# 后代选择器\n\n后代选择器用于 选择元素 或 元素组的后代 写法：外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代。\n\n指定的父选择器里的 指定选择器有样式\n\n类名选择器 标记选择器{···}\n.class h3{····}\ndiv p{····}\n\n\n\n# 子代选择器\n\n子代选择器又称子元素选择器，只能选择作为某元素子元素的元素\n\n指定的父选择器里的 下一代选择器有样式\n\n类别选择器 > 标记选择器{···}\n.class > h3{···}\ndiv > p{···}\n\n\n\n# 伪类选择器\n\n伪类选择器用于向某些选择器添加特殊的效果。 用“:”做前缀进行标识，后面紧跟伪类名，在style标签中\n\n更多的选择器：https://www.w3school.com.cn/cssref/css_selectors.asp\n\n链接伪类选择器\n\n选择器                 链接显示情况\nlink                未访问的链接\nvisited             已访问的链接\nhover               鼠标移动到链接上\nactive              选定的链接\nfirst-child         选择 父元素内的首个子元素\nlast-child          选择 父元素内的最后一个元素\nnth-child(n)        选择器选取父元素的第n个子元素\nnth-last-child(n)   选择 父元素内的第length-n个元素（重最后一个子元素开始数）\n\n注意写的时候，他们的顺序，尽量不要颠倒，按照选择器开头的 lvha 的顺序。\n\n类别选择器:伪类选择器{···}\na {   /* a是标签选择器  所有的链接 */\n\tfont-weight: 700;\n\tfont-size: 16px;\n\tcolor: gray;\n}\na:hover {   /* :hover 是鼠标经过时*/\n\tcolor: red; /*  鼠标经过的时候，由原来的灰色变成了红色 */\n}\n.myclass:nth-child(1){···}\n#myid:nth-child(2){···}\n\n\n\n# 属性选择器\n\n属性选择器可根据元素的属性及属性值来选择元素\n\n/* 标签[属性名] */\na[href] {color:red;}\n\n\n# 属性值的匹配\n\n属性值选择\n\n选择指定值\n\n/* a标签的href属性的 \'http://www.baidu.com\' 值 */\na[href="http://www.baidu.com"]\n\n\n属性值模糊选择\n\n指定属性中选择可能存在的单词\n\n/* p标签的href属性 存在 \'http\' 字符串值 */\np[href~="http"]\n\n\n属性值子串匹配\n\n类型             描述\n[abc^="def"]   选择 abc 属性值以 "def" 开头的所有元素\n[abc$="def"]   选择 abc 属性值以 "def" 结尾的所有元素\n[abc*="def"]   选择 abc 属性值中包含子串 "def" 的所有元素\n\n/* p标签的class属性以 \'d\' 开头的值 */\np[class^="d"]\n/* p标签的class属性以 \'d\' 结尾的值 */\np[class$="d"]\n/* p标签的class属性包含有 \'d\' 值 */\np[class*="d"]\n\n\n\n# 优先级\n\n\n# 选择器\n\n优先级：ID > 类 > 标签 多个选择器作用一个标签时，先看优先级，不样式叠加\n\n\n# 样式表\n\n优先级：内行 > 内部 > 外部 多个样式作用一个标签时，属性冲突看优先级，否则样式叠加\n\n\n# 元素显示模式\n\n\n# 块级元素 (block)\n\nblock-level块元素通常都会占一整行或多整行。 块级元素可以设置宽度、高度、对齐等··属性，常用于网页布局和网页结构的搭建。\n\n常见的块元素有<h1>~<h6>、<p>、<div>、<ul>、<ol>、<li>等，其中<div>标签是最典型的块元素。\n\n块级元素的特点：\n\n 1. 总是从新行开始\n 2. 高度，行高、外边距以及内边距都可以控制\n 3. 宽度默认是100%\n 4. 可以容纳内联元素和其他块元素\n\n\n# 行内元素 (inline)\n\ninline-level行内元素又称内联元素，单纯字体空间。 自身的字体大小和图像尺寸来支撑结构，一般不可以设置宽度、高度、对齐等属性，常用于控制页面中文本的样式。\n\n常见的行内元素有<a>、<strong>、<b>、<em>、<i>、<del>、<s>、<ins>、<u>、<span>等，其中<span>标签最典型的行内元素\n\n行内元素的特点：\n\n 1. 和相邻行内元素在一行上\n 2. 高、宽无效，但水平方向的padding和margin可以设置，垂直方向的无效\n 3. 行内元素只能容纳文本或则其他行内元素。（a特殊）\n 4. 注意：只有文字才能组成段落 因此 p 里面不能放块级元素。链接里面不能再放链接\n\n\n# 行内块元素 (inline-block)\n\ninline-block：范围只限于内容范围的大小 行内块元素的特点：\n\n 1. 和相邻行内元素（行内块）在一行上,但是之间会有空白缝隙。\n 2. 默认宽度就是它本身内容的宽度。\n 3. 高度，行高、外边距以及内边距都可以控制。\n\n\n# 标签显示总结\n\n属性                        说明\ndisplay : inline;         行内元素\ndisplay : block;          块级元素\ndisplay : inline-block;   行内块元素\n\n元素      特点\n行内元素    总是从新行开始\n        高度，行高、外边距以及内边距都可以控制。\n        宽度默认是容器的100%\n        可以容纳内联元素和其他块元素。\n块级元素    和相邻行内元素在一行上。\n        高、宽无效，但水平方向的padding和margin可以设置，垂直方向的无效。\n        默认宽度就是它本身内容的宽度。\n        行内元素只能容纳文本或则其他行内元素。\n行内块元素   和相邻行内元素（行内块）在一行上,但是之间会有空白缝隙。\n        默认宽度就是它本身内容的宽度。\n        高度，行高、外边距以及内边距都可以控制。\n\n\n# 字体样式\n\n样式属性          值                    说明\nfont-size     em                   字号大小\n              px\nfont-family   （可逗号隔开支持多字体）         字体类型\nfont-weight   normal（400）          字体粗细\n              bold（700）\n              bolder（900）\n              lighter（200）\n              数值（100 ~ 900）\nfont-style    normal（标准）           倾斜字体\n              italic（斜体）\n              oblique（倾斜）\nfont          font: 斜体 粗细 大小 类型;   字体样式（连写）\n\n\n# 字体编码\n\n字体名称        英文名称              UNICODE 编码\n宋体          SimSun            \\5B8B\\4F53\n新宋体         NSimSun           \\65B0\\5B8B\\4F53\n黑体          SimHei            \\9ED1\\4F53\n微软雅黑        Microsoft YaHei   \\5FAE\\8F6F\\96C5\\9ED1\n楷体_GB2312   KaiTi_GB2312      \\6977\\4F53_GB2312\n隶书          LiSu              \\96B6\\4E66\n幼园          YouYuan           \\5E7C\\5706\n华文细黑        STXihei           \\534E\\6587\\7EC6\\9ED1\n细明体         MingLiU           \\7EC6\\660E\\4F53\n新细明体        PMingLiU          \\65B0\\7EC6\\660E\\4F53\n\n\n# 文本样式\n\n样式属性              值                                   说明\ncolor             预定                                  文本颜色\n                  十六进制值\n                  RGB值 rgb(255,0,0)，rgb(100%,0%,0%)\nline-height       像素值、百分比、数值                          字符的高距\nletter-spacing    像素值、百分比、数值                          字符的水平间距\ntext-align        left、right、center                   字体水平对齐方式\ntext-indent       像素值、百分比、字个数(em)                     首行文本缩进\ntext-decoration   none（无装饰）                           链接装饰\n                  underline（下划线）\n                  overline（上划线）\n                  line-through（删除线）\nuser-select       none（不可选）、text（可选）                  文本是否可被选择\n\n字体顶与最顶行的距离=(设置值 - 字体)/2（单位：px）\n\n\n# 背景样式\n\n可以添加背景颜色和背景图片，以及来进行图片设置\n\n属性                      值                                                     说明\nbackground              background:背景颜色 背景图片地址 背景平铺 背景滚动 背景位置;                背景\nbackground-color        预定                                                    背景颜色\n                        十六进制值\n                        RGB值 rgb(255,0,0)，rgb(100%,0%,0%)\nbackground-position     数值、方位词                                                背景位置 （X Y）\n                        background-position : (length | position) (length |\n                        position);\nbackground-size         像素值、数值、auto                                           背景尺寸\nbackground-repeat       repeat（纵向和横向上平铺）                                      背景平铺\n                        no-repeat（不平铺）\n                        repeat-x（横向平铺）\n                        repeat-y（纵向平铺）\nbackground-origin       padding-box（内边距框）                                     背景起点\n                        border-box（边框）\n                        content-box（内容框）\nbackground-clip         border-box （边框剪切）                                     显示范围\n                        padding-box （外边距剪切）\n                        content-box （内容剪切）\n                        text（文本剪切）\nbackground-attachment   scroll（滚动）                                            背景固定还是滚动\n                        fixed（固定）\nbackground-image        url("URL")                                            背景图片地址\nbackground-blend-mode   normal（普通）                                            背景混合模式\n                        multiply（相加）\n                        screen（屏幕）\n                        overlay（覆盖）\n                        darken（变暗）\n                        lighten（变亮）\n                        color-dodge（减淡）\n                        saturation（饱和度）\n                        color（颜色）\n                        luminosity（亮度）\nopacity                 数值（0 - 1）                                             透明度\nrgba                    rgba(0,0,0,value);                                    RGB颜色\n                                                                              可设透明度\n\n\n# 盒子样式\n\n盒子就是把HTML页面中的元素看作是一个矩形的盒子，也就是一个盛装内容的容器\n\n属性                值                                             说明\nborder            border : 边框的粗细 边框的样式 边框的颜色;                   边框（连写）\nborder-width      像素值                                           边框的粗细\nborder-style      none（默认）                                      边框样式\n                  solid 单实线\n                  dashed 虚线\n                  dotted 点线\n                  double 双实线\nborder-color      颜色值                                           边框颜色\n                  #十六进制\n                  rgb(r,g,b)、rgb(r%,g%,b%)\nborder-collapse   separate（分开）                                  表格边框是否合并\n                  collapse（合并）\nborder-spacing    像素值（px）                                       相邻单元格边框间的距离\n                  字符数（em）\nborder-radius     border-radius: 左上角 右上角 右下角 左下角;               变圆角边框\n                  border-radius: [百分比、像素值];\npadding           padding: 上 [右 下 左];                           内边距\npadding-top       像素值（px）                                       上 内边距\n                  字符数（em）\npadding-right     像素值（px）                                       右 内边距\n                  字符数（em）\npadding-bottom    像素值（px）                                       下 内边距\n                  字符数（em）\npadding-left      像素值（px）                                       左 内边距\n                  字符数（em）\nmargin            padding: 上 [右 下 左];                           外边距\nmargin-top        像素值（px）                                       上 外边距\n                  字符数（em）\nmargin-right      像素值（px）                                       右 外边距\n                  字符数（em）\nmargin-bottom     像素值（px）                                       下 外边距\n                  字符数（em）\nmargin-left       像素值（px）                                       左 外边距\n                  字符数（em）\nbox-shadow        box-shadow: 水平阴影 垂直阴影 模糊距离 阴影尺寸 阴影颜色 内/外阴影；   \n                  box-shadow: 10px 10px 5px #888888;\n\n\n# 边框写法总结\n\n样式属性                          常用属性值                      说明\nborder-top-style:样式;                                     上边框\nborder-top-width:宽度;\nborder-top-color:颜色;\nborder-top:宽度 样式 颜色;\nborder-bottom-style:样式;                                  下边框\nborder- bottom-width:宽度;\nborder- bottom-color:颜色;\nborder-bottom:宽度 样式 颜色;\nborder-left-style:样式;                                    左边框\nborder-left-width:宽度;\nborder-left-color:颜色;\nborder-left:宽度 样式 颜色;\nborder-right-style:样式;                                   右边框\nborder-right-width:宽度;\nborder-right-color:颜色;\nborder-right:宽度 样式 颜色;\nborder-style:上边 [右边 下边 左边];   none（默认）                   样式综合\n                              solid 单实线\n                              dashed 虚线\n                              dotted 点线\n                              double 双实线\nborder-width:上边 [右边 下边 左边];   像素值                        宽度综合\nborder-color:上边 [右边 下边 左边];   颜色值                        颜色综合\n                              #十六进制\n                              rgb(r,g,b)、rgb(r%,g%,b%)\n\n\n# 盒子扩展\n\n# 盒子宽高\n\n盒子总宽度 = whidth + padding-right + padding-left + border-right + border-left = 盒子宽度 + 左右内边距 + 左右边框\n\n盒子总高度 = height + padding-top + padding-bottom + border-top + border-bottom = 盒子高度 + 上下内边距 + 上下边框\n\npadding和border会影响盒子原型大小，需要减去本身调节大小\n\n# 盒子外边距实现居中\n\n 1. 必须是块级元素\n 2. 盒子指定宽度\n 3. 左右的外边距都设置为auto\n\n# 清除元素的默认内外边距\n\n* {\n   padding:0;         /* 清除内边距 */\n   margin:0;          /* 清除外边距 */\n}\n\n\n\n# 浮动 (float)\n\nCSS的定位机制有3种：普通流（标准流）、浮动和定位。\n\nfloat 属性来定义浮动，语法格式：\n\n选择器{\n\tfloat: 属性值;\n}\n\n\n属性值        说明\nleft       向右浮动\nright      向左浮动\nnone（默认）   不浮动\n\n\n# 浮动特性\n\n浮动脱离标准流，不占位置，会影响标准流。浮动只有左右浮动。\n\n 1. 如果在一个父类盒子内浮动的子类盒子，浮动的子类盒子不会超出浮动范围\n 2. 一个父盒子里面的子盒子，如果其中一个子级有浮动的，则其他子级都需要浮动。这样才能一行对齐显示\n 3. 元素添加浮动后，元素会具有行内块元素的特性\n\n浮动目的\n\n浮动的目的就是为了让多个块级元素同一行上显示。\n\nfloat 浮 漏 特\n\n浮： 加了浮动的元素盒子是浮起来的，漂浮在其他的标准流盒子上面。 漏： 加了浮动的盒子，不占位置的，它浮起来了，它原来的位置漏 给了标准流的盒子。 特： 特别注意，首先浮动的盒子需要和标准流的父级搭配使用， 其次 特别的注意浮动可以使元素显示模式体现为行内块特性。\n\n\n# 浮动清除\n\n清除浮动主要为了解决父级元素因为子级浮动引起内部高度为 0 的问题。就是把浮动的盒子圈到里面，让父盒子闭合出口和入口不让他们出来影响其他元素。 清除浮动：\n\n clear: 属性值;\n\n\n值       说明\nleft    不允许左侧有浮动元素（清除左侧浮动的影响）\nright   不允许右侧有浮动元素（清除右侧浮动的影响）\nboth    同时清除左右两侧浮动的影响\n\n# 额外标签法\n\n通过在浮动元素末尾添加一个空的标签！ (不建议) 注意：是最后一个空的子标签\n\n<div style=”clear:both;”></div>\n\n\n优点： 通俗易懂，书写方便\n\n缺点： 添加许多无意义的标签，结构化较差\n\n----------------------------------------\n\n# 父级添加overflow属性方法\n\n可以通过触发 BFC 的方式，可以实现清除浮动效果。给父盒子添加！！！\n\noverflow: hidden|auto|scroll;\n\n\n优点： 代码简洁\n\n缺点： 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素\n\n----------------------------------------\n\n# after伪元素清除浮动\n\n:after 方式为空元素的升级版，好处是不用单独加标签了\n\n.clearfix:after {  \n    content: ""; \n    display: block; \n    height: 0; \n    clear: both;\n    visibility: hidden;\n}\n .clearfix {\n    *zoom: 1;\n} \n/*zoom 1就是ie6清除浮动方式 * ie7以下的版本所识别* /\n\n\n父盒子调用 clearfix 类使用即可\n\n优点： 符合闭合浮动思想 结构语义化正确\n\n**缺点：**低版本不支持\n\n注意： content:"" ，尽量不要带点\n\n----------------------------------------\n\n# 使用before和after双伪元素清除浮动\n\n.clearfix:before, .clearfix:after { \n  content:"";\n  display:table;  \n}\n.clearfix:after {\n  clear:both;\n}\n.clearfix {\n  *zoom:1;\n}\n\n\n父盒子调用 clearfix 类使用即可 优点： 代码更简洁\n\n缺点： 低版本不支持\n\n\n# 定位(position)\n\n定位可以建立列式布局，将布局的一部分与另一部分重叠\n\nposition 属性用于定义元素的 定位模式\n\nposition: static | relative | absolute | fixed \n\n\n属性值        说明\nstatic     静态定位，无特殊定位（默认）\nrelative   相对定位，由top、right、bottom、left等属性决定\nabsolute   绝对定位，相对于其上一个已经定位的父元素进行定位\nfixed      固定定位，相对于浏览器窗口进行定位\n\n\n# 静态定位 (static)\n\nposition: static HTML文档流中默认样式\n\n>  1. 无法偏移\n>  2. 可取消定位\n>  3. 跟随滚动\n\n\n# 相对定位 (relative)\n\nposition: relative  多个元素一个搞定，盒子打包\n\n>  1. 可偏移，原有位置继续占有\n>  2. 移动位置，是以元素左上角为基点移动\n>  3. 跟随滚动\n\n\n# 绝对定位 (absolute)\n\nposition: absolute  不占空间的漂浮元素\n\n>  1. 可偏移，原有位置不占有\n>  2. 无父级，以浏览器为基准\n>  3. 有父级，以父级盒子为基准\n>  4. 跟随滚动\n\n口诀技巧\n\n 1. 子绝父相 子级盒子是绝对定位，父级盒子是相对定位\n 2. 子绝父绝 父级盒子是绝对定位，子级盒子是绝对定位\n\n----------------------------------------\n\n\n# 固定定位 (fixed)\n\nposition: fixed; 始终在窗口展示的元素\n\n>  1. 跟父亲没有关系，只认浏览器\n>  2. 完全脱标，不占有位置\n>  3. 不随滚动\n\n\n# 叠放次序 (z-index)\n\nz-index: 4; 调整重叠定位元素的堆叠顺序\n\n>  1. 默认属性值：0，值越大越靠顶层\n>  2. 取值相同，书写顺序，后者居上\n>  3. 没有单位\n>  4. 除了静态，只能用于定位，其他类型，则无效\n\n\n# 定位总结\n\n定位模式            是否脱标占有位置   是否可以使用边偏移   移动位置基准\n静态 static       不脱标，正常模式   不可以         正常模式\n相对定位 relative   脱标，占位置     可以          相对自身位置移动\n绝对定位 absolute   脱标，不占位置    可以          相对于定位父级移动位置\n固定定位 fixed      脱标，不占位置    可以          相对于浏览器移动位置\n\n\n# 显示&隐藏\n\n主要目的是让一个元素在页面中消失，但是不在文档源码中删除\n\n\n# 显示 (display)\n\ndisplay 设置元素如何显示\n\ndisplay : none; 隐藏对象 、不保留位置\n\n----------------------------------------\n\n\n# 可见性 (visibility)\n\nvisibility 设置元素否显示\n\nVISIBILITY属性值   说明\nvisible（默认）     对象可视\nhidden          对象隐藏 、保留位置\n\n----------------------------------------\n\n\n# 溢出隐藏 (overflow)\n\noverflow 当对象的内容超过指定的高度和宽度则隐藏\n\nOVERFLOW属性值    说明\nvisible （默认）   不剪切内容也不添加滚动条\nauto           超出自动显示滚动条，不超不显示\nhidden         超出内容隐藏掉\nscroll         总是显示滚动条\n\n----------------------------------------\n\n\n# 高级技巧\n\n\n# 鼠标样式 (cursor)\n\ncursor 鼠标移到对象上更换预定义光标形状\n\n常用的鼠标样式：\n\nCURSOR属性值   说明\ndefault     默认\npointer     小手\nmove        移动\ntext        文本\n\n\n# 禁止选中 (select)\n\nuser-select 设置用户是否可选中\n\n/* 参数依次为 允许选中/禁止选中/可被选中/单击选中 */\nuser-select: [auto | none | text | all]\n\n\n\n# 轮廓 (outline)\n\noutline 边框边缘的外围，可起到突出元素的作用\n\noutline: color style width\noutline: #fff solid 1px;\n\n\n> 参数： color: 选择颜色 style：样式 width: 宽度\n\n一般情况，我们只关心的直接写法是 outline: 0;、outline: none;\n\n----------------------------------------\n\n\n# 文本域固定 (resize)\n\nresize 调节文本域尺寸大小或固定\n\nRESIZE属性值    说明\nnone         固定大小\nboth         可调节大小\nhorizontal   只可以调节宽\nvertical     只可以调节高\n\n\n# 垂直对齐 (vertical-align)\n\nvertical-align 设置内容与图片\\表单的对齐方式\n\nVERTICAL-ALIGN属性值   说明\nbaseline （默认）       基线对齐\ntop                 顶部对齐\nmiddle              居中对齐\nbottom              底部对齐\n\n\n# 自动换行 (word-break)\n\nword-break 设置文本换行行为\n\nWORD-BREAK属性值   说明\nnormal（默认）      强制显示所有文本\nkeep-all        只能在半角空格或连字符处换行（处理英文）\nbreak-all       遇边界断行，不考虑单词完整\nbreak-word      遇边界断行，考虑单词完整\n\n----------------------------------------\n\n\n# 空格换行 (white-space)\n\nwhite-space 对元素内容的空格处理！br可换行！！！\n\nWHITE-SPACE属性值   说明\nnormal （默认）      默认处理\npre              超出边界不断行\npre-wrap         空白距离不合并，碰边断行\npre-line         合并多余空白，碰边断行\nnowrap           合并多余空白，结束换行\n\n----------------------------------------\n\n\n# 文字溢出 (text-overflow)\n\ntext-overflow 将元素内容溢出时用自定义字符代替\n\nTEXT-OVERFLOW属性值   说明\nclip               切掉溢出部分\nellipsis           溢出部分替换为（...）\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n    <style>\n        div {\n            width: 100px;\n            height: 20px;\n            border: 1px solid red;\n            margin: 20px;\n            overflow: hidden;\n            white-space: nowrap;\n        }\n        .no1 {\n            text-overflow: clip;\n        }\n        .no2 {\n            text-overflow: ellipsis;\n        }\n    </style>\n</head>\n<body>\n<ul>\n    <li>clip<div class="no1">内容内容内容内容内容内容</div></li>\n    <li>ellipsis<div class="no2">内容内容内容内容内容内容</div></li>\n</ul>\n</body>\n</html>\n\n\n> 生效前提：\n> \n>  1. 元素宽度小于内容\n>  2. 超出内容隐藏的属性overflow: hidden\n>  3. 操出边界不换行的属性white-space:( pre | nowrap )\n>  4. 为有内容的文本添加属性 text-overflow\n\n\n# 动画&变形\n\n\n# 元素变化(transform)\n\ntransform 属性实现元素平移、缩放、旋转、倾斜等效果\n\ntransform: none | translate(···) | ···\n\n\n属性值 | 函数                         说明\nnone                             不变形\ntranslate(<length>[,<length>])   平移(X , Y)（参数只有一个则取X一个）\ntranslateX(<length>)             X轴平移\ntranslateY(<length>)             Y轴平移\nscale(<number>[,<number>])       缩放(X , Y)（参数只有一个则XY一样）\nscaleX(<number>)                 X轴缩放\nscaleY(<number>)                 Y轴缩放\nskew(<angle>[,<angle>])          倾斜(X , Y)（参数只有一个则取X一个）\nskewX(<angle>)                   X轴倾斜\nskewY(<angle>)                   Y轴倾斜\nrotate(<angle>)                  旋转角度\n\n\n# 元素中心变换(transform-origin)\n\ntransform-origin 属性实现中心点的变换，默认坐标X：50% ; Y：50%\n\ntransform-origin: [左右] [上下]\ntransform-origin: [<percentage> | <length> | left | center | right]  [<percentage> | <length> | top | center | bottom]\n\n\n尖括号单位说明：\n\n> length： 长度 number： 数值 percentage： 百分比 angle： 角度（deg、grad、rad、turn）\n\n\n# 过渡效果(transition)\n\n# 参与过渡属性\n\ntransition-property 属性 控制元素在指定时间进行渐变式变化\n\ntransition-property: all | none | <property> [, <property>]\n\n\n> all： 默认值，所有可进行过渡的css属性 none： 不指定过渡的css属性 property： 指定过渡的css属性。多属性以, 分隔\n\n# 过渡持续时间\n\ntransition-duration 属性 指定过渡的持续时间\n\ntransition-duration: <time> [, <time>]\n\n\n<time>： 指定过渡时间（默认0）。多属性以, 分隔\n\n# 过渡延迟时间\n\ntransition-delay 属性 指定过渡的延迟时间\n\ntransition-delay: <time> [, <time>]\n\n\n<time>： 指定过渡时间（默认0）。多属性以, 分隔\n\n# 过渡动画类型\n\ntransition-timing-function 属性 指定过渡的动画类型\n\ntransition-timing-function: linear | ease | ease-in | ease-out | ease-in-out | cubic-bezier(x1 , y1 , x2 , y2) [, linear | ease | ease-in | ease-out | ease-in-out | cubic-bezier(x1 , y1 , x2 , y2)]\n\n\n属性值                               说明\nlinear                            线性渡过\nease                              平滑渡过\nease-in                           渐变加速\nease-out                          渐变减速\nease-in-out                       慢》快》慢\ncubic-bezier(x1 , y1 , x2 , y2)   贝塞尔曲线类型\n\n# 过渡连写\n\n/* 两个参数 */\ntransition: <指定属性> <持续时间>;\n/* 三个参数 */\ntransition: <指定属性> <持续时间> <延迟时间>;\n/* 三个参数 */\ntransition: <指定属性> <持续时间> <动画类型>;\n/* 多个属性对象 */\ntransition: <指定属性> <持续时间> , <指定属性> <持续时间> [,...];\n/* 全参 */\ntransition: <指定属性> <持续时间> <动画类型> <延迟时间>；\n\n\n\n# 动画(Animation)\n\n# 关键帧\n\n实现动画前先定义动画帧\n\n@keyframes name \'{\' <keyframes-blocks> \'}\';\n\n\nname： 动画名称 <keyframes-blocks> ： 定义动画在不同时间段的样式规则\n\n实现过渡动画\n\n1.关键字from & to 定义帧位置\n\n从一个状态过渡到另一个状态\n\nfrom{\n    属性值n ：属性值1；\n    ···\n}\nto{\n    属性值n ：属性值1；\n    ···\n}\n/*完整定义*/\n@keyframes myFrame{\n    from{···}\n    to{···}\n}\n\n\n2.百分比定义 关键帧位置\n\n通过百分比指定过渡各个状态\n\n@-keyframes myFrame{\n    0%{···}\n    20%{···}\n    50%{···}\n    80%{···}\n    100%{···}\n}\n\n\n# 动画属性\n\n定义关键帧后，还需要相关属性执行关键帧的变化\n\nanimation: name | duration | timing-function | delay | iteration-count | direction;\n\n\n值                           描述\nanimation                   复合属性\nanimation-name              需要绑定到选择器的 keyframe 名称\nanimation-duration          动画完成时长\nanimation-timing-function   指定对象过渡类型\nanimation-delay             动画开始前延迟时长\nanimation-iteration-count   动画播放的次数（infinite无限循环）\nanimation-direction         是否轮流反向播放动画\n                            值：normal（正方向）、alternate（反方向）\nanimation-play-state        指定对象动画的状态\n                            值：running（运动）、paused（停止）\nanimation-fill-mode         指定对象动画之外的状态\n                            值：none（默认）、forwards（动画后）、backwwards（动画前）、both（两者都有）\n\n\n# 弹性布局 (Flex)\n\n\n# justify-content\n\n对齐内容 , 主轴控制 内容指定分配空间\n\n属性值             说明\nflex-start      项目开头对齐(默认)\ncenter          项目居中对齐\nflex-end        项目结尾对齐\nspace-between   所有项目两端分开对齐 , 其余空间平分\nspace-around    所有项目对齐两端都有一半大小空间\nspace-evenly    所有项目左右两端空间平分\n\nflex-start(默认)\n\n\n\nflex-start\n\n\n\ncenter\n\n\n\nflex-end\n\n\n\nspace-between\n\n\n\nspace-around\n\n\n\n\n# align-items\n\n对齐项目 , 交叉轴控制 项目之间和项目周围垂直分配空间\n\n属性值          说明\nstretch      项目拉伸填充(默认)\ncenter       项目居中对齐\nflex-start   项目开头对齐\nflex-end     项目末端对齐\nbaseline     项目基线对齐\n\nstretch(默认)\n\n\n\ncenter\n\n\n\nflex-start\n\n\n\nflex-end\n\n\n\nbaseline\n\n\n\n\n# flex-direction\n\n轴互换 , 主轴 和 交叉轴 互换\n\n属性值              说明\nrow              行排列 (默认)\nrow-reverse      行反序排列\ncolumn           竖排列\ncolumn-reverse   竖反序排列\n\nrow(默认)\n\n\n\nrow-reverse\n\n\n\ncolumn\n\n\n\ncolumn-reverse\n\n\n\n\n# flex-wrap\n\n让元素进行折行排列，使得每行的元素都不超过容器的宽度\n\n属性值            说明\nnowrap         不换行(默认)\nwrap           换行\nwrap-reverse   反序移出换行\n\nnowrap(默认)\n\n\n\nwrap\n\n\n\nwrap-reverse\n\n\n### Flex 调整\n\nalign-content 对齐内容\n\nalign-items 对齐项目\n\nalign-self 对齐本身\n\n\n# 精灵图\n\n由很多小的背景图像合成的大图被称为 精灵图。可以减少浏览器与服务器数据交换的次数。\n\n精灵图运用\n\n根据大小查找图片,锁定位置\n\n精灵图在css使用到的属性有\n\n/*背景连写*/\nbackground\n/*背景图片*/\nbackground-image: none | url;\n/*背景平铺 */\nbackground-repeat: repeat | no-repeat | repeat-x | repeat-y ;\n/*背景位置*/\nbackground-position: (length | position) (length | position);\n/*length: 精准坐标、position: 方位名词*/\n\n\n原图调用 ：（京东精灵图）\n\n示范代码：\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n    <style>\n        li {\n            margin: 20px;\n            float: left;\n        }\n        .no1 {\n            width: 30px;\n            height: 26px;\n            background: url("img/jd.png") no-repeat;\n        }\n        .no2 {\n            width: 16px;\n            height: 22px;\n            background: url("img/jd.png") no-repeat 0 -68px;\n        }\n        .no3 {\n            width: 230px;\n            height: 52px;\n            background: url("img/jd.png") no-repeat 0 -134px;\n        }\n        .no4 {\n            width: 20px;\n            height: 26px;\n            background: url("img/jd.png") no-repeat 0 -408px;\n        }\n        .no5 {\n            width: 42px;\n            height: 44px;\n            background: url("img/jd.png") no-repeat 0 -442px;\n        }\n    </style>\n</head>\n<body>\n<ul>\n    <li class="no1"></li>\n    <li class="no2"></li>\n    <li class="no3"></li>\n    <li class="no4"></li>\n    <li class="no5"></li>\n</ul>\n</body>\n</html>\n\n\n结果图示\n\n\n\n----------------------------------------\n\n\n# 滑动门\n\n为网页元素设置特殊形状的背景。 以下我网站例子：\n\n\n\n背景原型：\n\n\n\n滑动门应用：\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Title</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n        body {\n            height: 1000px;\n            /*背景*/\n            background: url("img/wx.jpg") repeat-x;\n        }\n        .box li {\n            float: right;\n            margin: 20px;\n            list-style: none;\n        }\n        .box a {\n            height: 33px;\n            line-height: 33px;\n            text-decoration: none;\n            display: inline-block;\n            color: #fff;\n            /*按钮样式背景（左）*/\n            background: url("img/to.png") no-repeat;\n            padding-left: 16px;\n        }\n        .box span {\n            height: 33px;\n            display: inline-block;\n            /*按钮样式背景（右）*/\n            background: url("img/to.png") right;\n            padding-right: 16px;\n        }\n        /*鼠标指定时高亮*/\n        .box a:hover span {\n            background: url("img/ao.png") right;\n        }\n        .box a:hover {\n            background: url("img/ao.png") no-repeat;\n        }\n    </style>\n</head>\n<body>\n    <ul class="box">\n        <li><a href="#"><span>PC平台</span></a></li>\n        <li><a href="#"><span>开放平台</span></a></li>\n        <li><a href="#"><span>帮助与反馈</span></a></li>\n        <li><a href="#"><span>首页</span></a></li>\n    </ul>\n</body>\n</html>\n\n\n\n\n> 说明：\n> \n>  1. a 设置背景左侧，内边距撑开左框中的宽度\n>  2. span 设置背景右侧，内边距撑开有边框的宽度，左边有内容\n>  3. a包含span是因为整体是可以点击的缘故\n\n----------------------------------------\n\n\n# 字体图标\n\n字体图标是以特殊形式的字体呈现出来的图标，可透明、旋转、改颜色等····\n\n> 使用流程：\n> \n>  1. 获取svg格式的效果图\n>  2. 上传生成兼容性的字体文件包\n>  3. 下载到本地的兼容字体文件包\n>  4. 字体文件包引入到HTML页面中\n\n引入网页：\n\n 1. 创建fonts文件夹在根路经里\n\n 2. 在样式里声明字体图标，声明代码可在下载的项目里获取！！！\n    \n    以下是例子：（不同来源网站不同声明代码！！！）\n    \n    @font-face {\n      font-family: \'icomoon\';\n      src:  url(\'fonts/icomoon.eot?7kkyc2\');\n      src:  url(\'fonts/icomoon.eot?7kkyc2#iefix\') format(\'embedded-opentype\'),\n        url(\'fonts/icomoon.ttf?7kkyc2\') format(\'truetype\'),\n        url(\'fonts/icomoon.woff?7kkyc2\') format(\'woff\'),\n        url(\'fonts/icomoon.svg?7kkyc2#icomoon\') format(\'svg\');\n      /*清除粗细*/\n      font-weight: normal;\n      /*清除倾斜*/\n      font-style: normal;\n    }\n    \n\n 3. 盒子使用字体\n    \n    /*盒子字体可用*/\n    span {\n        /*icomoon: 字体图标的名称*/\n        font-family: "icomoon";\n    }\n    \n\n 4. 盒子里添加结构，图标编码可在项目里获取！\n    \n    span::before {\n    \t\t content: "\\e900";\n    \t}\n    /*或者 （一下是特殊字体图标）*/\n    <span>&#xe613;</span> \n    \n\n\n# 版心和布局流程\n\n\n# 版心\n\n是指网页中主体内容所在的区域。一般在浏览器窗口中水平居中显示，常见的宽度值为960px、980px、1000px、1200px等。\n\n\n# 布局流程\n\n布局时通常需要遵守一定的布局流程，具体如下：\n\n 1. 确定页面的版心（可视区）\n 2. 分析页面中的行模块，以及每个行模块中的列模块\n 3. 制作HTML结构\n 4. CSS初始化，然后开始运用盒子模型的原理，通过DIV+CSS布局来控制网页的各个模块。\n\n\n# CSS书写规范\n\n\n# 空格规范\n\n【强制】 选择器 与 { 之间必须包含空格。\n\n.selector { }\n\n\n【强制】 属性名 与之后的 : 之间不允许包含空格， : 与 属性值 之间必须包含空格。\n\nfont-size: 12px;\n\n\n\n# 选择器规范\n\n【强制】 当一个样式包含多个选择器时，每个选择器声明必须独占一行。\n\n/*好习惯*/\n.post,\n.page,\n.comment {\n    line-height: 1.5;\n}\n\n/*坏习惯*/\n.post, .page, .comment {\n    line-height: 1.5;\n}\n\n\n选择器的嵌套层级不大于 3 级，位置靠后的限定条件应尽可能精确。\n\n/* 好习惯 */\n#username input {}\n.comment .avatar {}\n\n/* 坏习惯 */\n.page .header .login #username input {}\n.comment div * {}\n\n\n\n# 属性规范\n\n【强制】 属性定义必须另起一行。 【强制】 属性定义后必须以分号结尾。\n\n/* 好习惯 */\n.selector {\n    margin: 0;\n    padding: 0;\n}\n\n/* 坏习惯 */\n.selector { margin: 0; padding: 0; }\n\n\n\n# 高度格式\n\n顶线(字体最高)，中线(字体中间)，基线(字体底部)，底线(最底部) 基线与基线的距离为行高。 字体上距离=(设置值 - 字体) / 2（单位：px）\n\n\n# CSS 三大特性\n\n\n# CSS层叠性\n\n一般情况下，如果出现样式冲突，则会按照CSS书写的顺序，以最后的样式为准。\n\n 1. 样式冲突，遵循的原则是就近原则。 那个样式离着结构近，就执行那个样式。\n 2. 样式不冲突，不会层叠\n\n\n# CSS继承性\n\n子标签会继承父标签的某些样式。想要设置一个可继承的属性，只需将它应用于父元素即可。 恰当地使用继承可以简化代码，降低CSS样式的复杂性。子元素可以继承父元素的样式\n\n\n# CSS优先级\n\n出现两个或更多规则应用在同一元素上，这时就会出现优先级的问题。注意的特殊情况：\n\n 1. 继承样式的权重为0！！！\n 2. 行内样式优先。\n 3. 权重相同时，CSS遵循就近原则。\n 4. CSS定义了一个!important命令，该命令被赋予最大的优先级。\n\n\n# CSS特殊性\n\n关于CSS权重，需要一套计算公式来去计算，这个就是 CSS Specificity，是衡量CSS值优先级的一个标准。 specificity用一个四位的数字串(CSS2是三位)来表示，更像四个级别，值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越\n\n继承的贡献值（权重）          0,0,0,0\n* 全部                0,0,0,0\n每个元素（标签）            0,0,0,1\n每个类，伪类              0,0,1,0\n每个ID                0,1,0,0\n每个行内样式              1,0,0,0\n每个!important（重要的）   ∞无穷大\n\n权重是可以叠加的 比如的例子：\n\ndiv ul  li   ------\x3e      0,0,0,3\n\n.nav ul li   ------\x3e      0,0,1,2\n\na:hover      ------\x3e      0,0,1,1\n\n.nav a       ------\x3e      0,0,1,1   \n\n#nav p       -----\x3e       0,1,0,1\n\n\n数位之间没有进制。比如说： 0,0,0,5 + 0,0,0,5 =0,0,0,10 而不是 0,0, 1, 0， 所以不会存在10个div能赶上一个类选择器的情况。\n\n# 权重总结\n\n 1. 使用了!important声明的规则。\n 2. 内嵌在HTML元素的style属性里面的声明。\n 3. 使用了ID 选择器的规则。\n 4. 使用了类选择器、属性选择器、伪元素和伪类选择器的规则。\n 5. 使用了元素选择器的规则。\n 6. 只包含一个通用选择器的规则。\n 7. 同一类选择器则遵循就近原则。\n\n权重是优先级的算法，层叠是优先级的表现',normalizedContent:'# css\n\n\n# 概述\n\ncss样式表或层叠样式表（级联样式表），用与设置html页面的文本内容（字体，大小，对齐样式）、图片外形等外观 css以html为基础，提供了丰富的功能，如字体、颜色、背景的控制及整体排版等，而且还可以针对不同的浏览器设置不同的样式\n\n\n# 载入样式表\n\n\n# 内部样式表\n\n在 head标签 内，并且用style标签定义属性\n\n<head>\n\t<style type="text/css">\n   \t \t选择器 {属性1:属性值1; 属性2:属性值2; 属性3:属性值3;}\n\t</style>\n</head>\n\n\n\n# 行内式\n\n内联样式。通过在标签中的 style属性 来设==置样式==\n\n<标签名 style="属性1:属性值1; 属性2:属性值2; 属性3:属性值3;"> 内容 </标签名>\n\n\n\n# 外部样式\n\n在 head标签 内，定义 link标签 引用外部文件\n\n<head>\n  <link href="css文件的路径"  rel="stylesheet" />\n</head>\n\n\nlink属性   说明\nhreft    url地址（相对/绝对）\nrel      类型 。值: stylesheet\n\n\n# 样式表总结\n\n样式表     优点             缺点             使用情况      控制范围\n行内样式表   书写方便，权重高       没有实现样式和结构相分离   较少        控制一个标签（少）\n内部样式表   部分结构和样式相分离     没有彻底分离         较多        控制一个页面（中）\n外部样式表   完全实现结构和样式相分离   需要引入           最多，强烈推荐   控制整个站点（多）\n\n\n# 选择器\n\n\n# 标签选择器\n\n标签选择器对指定的 标签 或 元素 作用\n\n标签名 | 元素名{属性1:属性值1; 属性2:属性值2; 属性3:属性值3; ···}\n\n\n\n# 类选择器\n\n类选择器可对指定的对象起作用\n\n.类名{属性1:值; 属性2:值; 属性3:值; }\n\n\n\n# id选择器\n\n只对一个对象起作用\n\n#id名{属性1:值; 属性2:值; 属性3:值; }\n\n\n\n# 通配符选择器\n\n匹配页面中所有的元素\n\n*{ 属性1:值; 属性2:值; }\n\n\n\n# 选择器总结\n\n选择器       例子           例子描述\n.class    .intro       选中 class="intro" 的元素\n#id       #firstname   选中 id="firstname" 的元素\n*         *            选中 所有元素\nelement   p            选中 所有 <p> 元素\n\n选择器      优点                 缺点              使用范围\n标签选择器    快速在同一类型的标签添加样式     不能在同一标签设置不同样式   限制于设置的标签\n类选择器     可为对象单独定义样式，也可多标签                   广泛\nid选择器    可为对象单独定义样式         不能多标签共用         一个标签的范围\n通配符选择器   能匹配页面中所有的元素        不能单独定义样式        范围最广\n\n\n# 复合选择器\n\n\n# 交集选择器\n\n交集选择器由两个选择器构成，两个选择器之间不能有空格\n\n满足两个选择器的条件才能应用样式\n\n比如： p.one   选择的是： 类名为 .one 的段落标签。 \np.class{····}\nh3.class {····}\n\n\n\n# 并集选择器\n\n并集选择器 通过选择器与选择器之间通过逗号连接而成，任何形式的选择器都可作为并集选择器的一部分\n\n逗号连接的选择器 都有样式\n\n.class , h3 {属性:属性值; ····}\n\n\n\n# 后代选择器\n\n后代选择器用于 选择元素 或 元素组的后代 写法：外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代。\n\n指定的父选择器里的 指定选择器有样式\n\n类名选择器 标记选择器{···}\n.class h3{····}\ndiv p{····}\n\n\n\n# 子代选择器\n\n子代选择器又称子元素选择器，只能选择作为某元素子元素的元素\n\n指定的父选择器里的 下一代选择器有样式\n\n类别选择器 > 标记选择器{···}\n.class > h3{···}\ndiv > p{···}\n\n\n\n# 伪类选择器\n\n伪类选择器用于向某些选择器添加特殊的效果。 用“:”做前缀进行标识，后面紧跟伪类名，在style标签中\n\n更多的选择器：https://www.w3school.com.cn/cssref/css_selectors.asp\n\n链接伪类选择器\n\n选择器                 链接显示情况\nlink                未访问的链接\nvisited             已访问的链接\nhover               鼠标移动到链接上\nactive              选定的链接\nfirst-child         选择 父元素内的首个子元素\nlast-child          选择 父元素内的最后一个元素\nnth-child(n)        选择器选取父元素的第n个子元素\nnth-last-child(n)   选择 父元素内的第length-n个元素（重最后一个子元素开始数）\n\n注意写的时候，他们的顺序，尽量不要颠倒，按照选择器开头的 lvha 的顺序。\n\n类别选择器:伪类选择器{···}\na {   /* a是标签选择器  所有的链接 */\n\tfont-weight: 700;\n\tfont-size: 16px;\n\tcolor: gray;\n}\na:hover {   /* :hover 是鼠标经过时*/\n\tcolor: red; /*  鼠标经过的时候，由原来的灰色变成了红色 */\n}\n.myclass:nth-child(1){···}\n#myid:nth-child(2){···}\n\n\n\n# 属性选择器\n\n属性选择器可根据元素的属性及属性值来选择元素\n\n/* 标签[属性名] */\na[href] {color:red;}\n\n\n# 属性值的匹配\n\n属性值选择\n\n选择指定值\n\n/* a标签的href属性的 \'http://www.baidu.com\' 值 */\na[href="http://www.baidu.com"]\n\n\n属性值模糊选择\n\n指定属性中选择可能存在的单词\n\n/* p标签的href属性 存在 \'http\' 字符串值 */\np[href~="http"]\n\n\n属性值子串匹配\n\n类型             描述\n[abc^="def"]   选择 abc 属性值以 "def" 开头的所有元素\n[abc$="def"]   选择 abc 属性值以 "def" 结尾的所有元素\n[abc*="def"]   选择 abc 属性值中包含子串 "def" 的所有元素\n\n/* p标签的class属性以 \'d\' 开头的值 */\np[class^="d"]\n/* p标签的class属性以 \'d\' 结尾的值 */\np[class$="d"]\n/* p标签的class属性包含有 \'d\' 值 */\np[class*="d"]\n\n\n\n# 优先级\n\n\n# 选择器\n\n优先级：id > 类 > 标签 多个选择器作用一个标签时，先看优先级，不样式叠加\n\n\n# 样式表\n\n优先级：内行 > 内部 > 外部 多个样式作用一个标签时，属性冲突看优先级，否则样式叠加\n\n\n# 元素显示模式\n\n\n# 块级元素 (block)\n\nblock-level块元素通常都会占一整行或多整行。 块级元素可以设置宽度、高度、对齐等··属性，常用于网页布局和网页结构的搭建。\n\n常见的块元素有<h1>~<h6>、<p>、<div>、<ul>、<ol>、<li>等，其中<div>标签是最典型的块元素。\n\n块级元素的特点：\n\n 1. 总是从新行开始\n 2. 高度，行高、外边距以及内边距都可以控制\n 3. 宽度默认是100%\n 4. 可以容纳内联元素和其他块元素\n\n\n# 行内元素 (inline)\n\ninline-level行内元素又称内联元素，单纯字体空间。 自身的字体大小和图像尺寸来支撑结构，一般不可以设置宽度、高度、对齐等属性，常用于控制页面中文本的样式。\n\n常见的行内元素有<a>、<strong>、<b>、<em>、<i>、<del>、<s>、<ins>、<u>、<span>等，其中<span>标签最典型的行内元素\n\n行内元素的特点：\n\n 1. 和相邻行内元素在一行上\n 2. 高、宽无效，但水平方向的padding和margin可以设置，垂直方向的无效\n 3. 行内元素只能容纳文本或则其他行内元素。（a特殊）\n 4. 注意：只有文字才能组成段落 因此 p 里面不能放块级元素。链接里面不能再放链接\n\n\n# 行内块元素 (inline-block)\n\ninline-block：范围只限于内容范围的大小 行内块元素的特点：\n\n 1. 和相邻行内元素（行内块）在一行上,但是之间会有空白缝隙。\n 2. 默认宽度就是它本身内容的宽度。\n 3. 高度，行高、外边距以及内边距都可以控制。\n\n\n# 标签显示总结\n\n属性                        说明\ndisplay : inline;         行内元素\ndisplay : block;          块级元素\ndisplay : inline-block;   行内块元素\n\n元素      特点\n行内元素    总是从新行开始\n        高度，行高、外边距以及内边距都可以控制。\n        宽度默认是容器的100%\n        可以容纳内联元素和其他块元素。\n块级元素    和相邻行内元素在一行上。\n        高、宽无效，但水平方向的padding和margin可以设置，垂直方向的无效。\n        默认宽度就是它本身内容的宽度。\n        行内元素只能容纳文本或则其他行内元素。\n行内块元素   和相邻行内元素（行内块）在一行上,但是之间会有空白缝隙。\n        默认宽度就是它本身内容的宽度。\n        高度，行高、外边距以及内边距都可以控制。\n\n\n# 字体样式\n\n样式属性          值                    说明\nfont-size     em                   字号大小\n              px\nfont-family   （可逗号隔开支持多字体）         字体类型\nfont-weight   normal（400）          字体粗细\n              bold（700）\n              bolder（900）\n              lighter（200）\n              数值（100 ~ 900）\nfont-style    normal（标准）           倾斜字体\n              italic（斜体）\n              oblique（倾斜）\nfont          font: 斜体 粗细 大小 类型;   字体样式（连写）\n\n\n# 字体编码\n\n字体名称        英文名称              unicode 编码\n宋体          simsun            \\5b8b\\4f53\n新宋体         nsimsun           \\65b0\\5b8b\\4f53\n黑体          simhei            \\9ed1\\4f53\n微软雅黑        microsoft yahei   \\5fae\\8f6f\\96c5\\9ed1\n楷体_gb2312   kaiti_gb2312      \\6977\\4f53_gb2312\n隶书          lisu              \\96b6\\4e66\n幼园          youyuan           \\5e7c\\5706\n华文细黑        stxihei           \\534e\\6587\\7ec6\\9ed1\n细明体         mingliu           \\7ec6\\660e\\4f53\n新细明体        pmingliu          \\65b0\\7ec6\\660e\\4f53\n\n\n# 文本样式\n\n样式属性              值                                   说明\ncolor             预定                                  文本颜色\n                  十六进制值\n                  rgb值 rgb(255,0,0)，rgb(100%,0%,0%)\nline-height       像素值、百分比、数值                          字符的高距\nletter-spacing    像素值、百分比、数值                          字符的水平间距\ntext-align        left、right、center                   字体水平对齐方式\ntext-indent       像素值、百分比、字个数(em)                     首行文本缩进\ntext-decoration   none（无装饰）                           链接装饰\n                  underline（下划线）\n                  overline（上划线）\n                  line-through（删除线）\nuser-select       none（不可选）、text（可选）                  文本是否可被选择\n\n字体顶与最顶行的距离=(设置值 - 字体)/2（单位：px）\n\n\n# 背景样式\n\n可以添加背景颜色和背景图片，以及来进行图片设置\n\n属性                      值                                                     说明\nbackground              background:背景颜色 背景图片地址 背景平铺 背景滚动 背景位置;                背景\nbackground-color        预定                                                    背景颜色\n                        十六进制值\n                        rgb值 rgb(255,0,0)，rgb(100%,0%,0%)\nbackground-position     数值、方位词                                                背景位置 （x y）\n                        background-position : (length | position) (length |\n                        position);\nbackground-size         像素值、数值、auto                                           背景尺寸\nbackground-repeat       repeat（纵向和横向上平铺）                                      背景平铺\n                        no-repeat（不平铺）\n                        repeat-x（横向平铺）\n                        repeat-y（纵向平铺）\nbackground-origin       padding-box（内边距框）                                     背景起点\n                        border-box（边框）\n                        content-box（内容框）\nbackground-clip         border-box （边框剪切）                                     显示范围\n                        padding-box （外边距剪切）\n                        content-box （内容剪切）\n                        text（文本剪切）\nbackground-attachment   scroll（滚动）                                            背景固定还是滚动\n                        fixed（固定）\nbackground-image        url("url")                                            背景图片地址\nbackground-blend-mode   normal（普通）                                            背景混合模式\n                        multiply（相加）\n                        screen（屏幕）\n                        overlay（覆盖）\n                        darken（变暗）\n                        lighten（变亮）\n                        color-dodge（减淡）\n                        saturation（饱和度）\n                        color（颜色）\n                        luminosity（亮度）\nopacity                 数值（0 - 1）                                             透明度\nrgba                    rgba(0,0,0,value);                                    rgb颜色\n                                                                              可设透明度\n\n\n# 盒子样式\n\n盒子就是把html页面中的元素看作是一个矩形的盒子，也就是一个盛装内容的容器\n\n属性                值                                             说明\nborder            border : 边框的粗细 边框的样式 边框的颜色;                   边框（连写）\nborder-width      像素值                                           边框的粗细\nborder-style      none（默认）                                      边框样式\n                  solid 单实线\n                  dashed 虚线\n                  dotted 点线\n                  double 双实线\nborder-color      颜色值                                           边框颜色\n                  #十六进制\n                  rgb(r,g,b)、rgb(r%,g%,b%)\nborder-collapse   separate（分开）                                  表格边框是否合并\n                  collapse（合并）\nborder-spacing    像素值（px）                                       相邻单元格边框间的距离\n                  字符数（em）\nborder-radius     border-radius: 左上角 右上角 右下角 左下角;               变圆角边框\n                  border-radius: [百分比、像素值];\npadding           padding: 上 [右 下 左];                           内边距\npadding-top       像素值（px）                                       上 内边距\n                  字符数（em）\npadding-right     像素值（px）                                       右 内边距\n                  字符数（em）\npadding-bottom    像素值（px）                                       下 内边距\n                  字符数（em）\npadding-left      像素值（px）                                       左 内边距\n                  字符数（em）\nmargin            padding: 上 [右 下 左];                           外边距\nmargin-top        像素值（px）                                       上 外边距\n                  字符数（em）\nmargin-right      像素值（px）                                       右 外边距\n                  字符数（em）\nmargin-bottom     像素值（px）                                       下 外边距\n                  字符数（em）\nmargin-left       像素值（px）                                       左 外边距\n                  字符数（em）\nbox-shadow        box-shadow: 水平阴影 垂直阴影 模糊距离 阴影尺寸 阴影颜色 内/外阴影；   \n                  box-shadow: 10px 10px 5px #888888;\n\n\n# 边框写法总结\n\n样式属性                          常用属性值                      说明\nborder-top-style:样式;                                     上边框\nborder-top-width:宽度;\nborder-top-color:颜色;\nborder-top:宽度 样式 颜色;\nborder-bottom-style:样式;                                  下边框\nborder- bottom-width:宽度;\nborder- bottom-color:颜色;\nborder-bottom:宽度 样式 颜色;\nborder-left-style:样式;                                    左边框\nborder-left-width:宽度;\nborder-left-color:颜色;\nborder-left:宽度 样式 颜色;\nborder-right-style:样式;                                   右边框\nborder-right-width:宽度;\nborder-right-color:颜色;\nborder-right:宽度 样式 颜色;\nborder-style:上边 [右边 下边 左边];   none（默认）                   样式综合\n                              solid 单实线\n                              dashed 虚线\n                              dotted 点线\n                              double 双实线\nborder-width:上边 [右边 下边 左边];   像素值                        宽度综合\nborder-color:上边 [右边 下边 左边];   颜色值                        颜色综合\n                              #十六进制\n                              rgb(r,g,b)、rgb(r%,g%,b%)\n\n\n# 盒子扩展\n\n# 盒子宽高\n\n盒子总宽度 = whidth + padding-right + padding-left + border-right + border-left = 盒子宽度 + 左右内边距 + 左右边框\n\n盒子总高度 = height + padding-top + padding-bottom + border-top + border-bottom = 盒子高度 + 上下内边距 + 上下边框\n\npadding和border会影响盒子原型大小，需要减去本身调节大小\n\n# 盒子外边距实现居中\n\n 1. 必须是块级元素\n 2. 盒子指定宽度\n 3. 左右的外边距都设置为auto\n\n# 清除元素的默认内外边距\n\n* {\n   padding:0;         /* 清除内边距 */\n   margin:0;          /* 清除外边距 */\n}\n\n\n\n# 浮动 (float)\n\ncss的定位机制有3种：普通流（标准流）、浮动和定位。\n\nfloat 属性来定义浮动，语法格式：\n\n选择器{\n\tfloat: 属性值;\n}\n\n\n属性值        说明\nleft       向右浮动\nright      向左浮动\nnone（默认）   不浮动\n\n\n# 浮动特性\n\n浮动脱离标准流，不占位置，会影响标准流。浮动只有左右浮动。\n\n 1. 如果在一个父类盒子内浮动的子类盒子，浮动的子类盒子不会超出浮动范围\n 2. 一个父盒子里面的子盒子，如果其中一个子级有浮动的，则其他子级都需要浮动。这样才能一行对齐显示\n 3. 元素添加浮动后，元素会具有行内块元素的特性\n\n浮动目的\n\n浮动的目的就是为了让多个块级元素同一行上显示。\n\nfloat 浮 漏 特\n\n浮： 加了浮动的元素盒子是浮起来的，漂浮在其他的标准流盒子上面。 漏： 加了浮动的盒子，不占位置的，它浮起来了，它原来的位置漏 给了标准流的盒子。 特： 特别注意，首先浮动的盒子需要和标准流的父级搭配使用， 其次 特别的注意浮动可以使元素显示模式体现为行内块特性。\n\n\n# 浮动清除\n\n清除浮动主要为了解决父级元素因为子级浮动引起内部高度为 0 的问题。就是把浮动的盒子圈到里面，让父盒子闭合出口和入口不让他们出来影响其他元素。 清除浮动：\n\n clear: 属性值;\n\n\n值       说明\nleft    不允许左侧有浮动元素（清除左侧浮动的影响）\nright   不允许右侧有浮动元素（清除右侧浮动的影响）\nboth    同时清除左右两侧浮动的影响\n\n# 额外标签法\n\n通过在浮动元素末尾添加一个空的标签！ (不建议) 注意：是最后一个空的子标签\n\n<div style=”clear:both;”></div>\n\n\n优点： 通俗易懂，书写方便\n\n缺点： 添加许多无意义的标签，结构化较差\n\n----------------------------------------\n\n# 父级添加overflow属性方法\n\n可以通过触发 bfc 的方式，可以实现清除浮动效果。给父盒子添加！！！\n\noverflow: hidden|auto|scroll;\n\n\n优点： 代码简洁\n\n缺点： 内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素\n\n----------------------------------------\n\n# after伪元素清除浮动\n\n:after 方式为空元素的升级版，好处是不用单独加标签了\n\n.clearfix:after {  \n    content: ""; \n    display: block; \n    height: 0; \n    clear: both;\n    visibility: hidden;\n}\n .clearfix {\n    *zoom: 1;\n} \n/*zoom 1就是ie6清除浮动方式 * ie7以下的版本所识别* /\n\n\n父盒子调用 clearfix 类使用即可\n\n优点： 符合闭合浮动思想 结构语义化正确\n\n**缺点：**低版本不支持\n\n注意： content:"" ，尽量不要带点\n\n----------------------------------------\n\n# 使用before和after双伪元素清除浮动\n\n.clearfix:before, .clearfix:after { \n  content:"";\n  display:table;  \n}\n.clearfix:after {\n  clear:both;\n}\n.clearfix {\n  *zoom:1;\n}\n\n\n父盒子调用 clearfix 类使用即可 优点： 代码更简洁\n\n缺点： 低版本不支持\n\n\n# 定位(position)\n\n定位可以建立列式布局，将布局的一部分与另一部分重叠\n\nposition 属性用于定义元素的 定位模式\n\nposition: static | relative | absolute | fixed \n\n\n属性值        说明\nstatic     静态定位，无特殊定位（默认）\nrelative   相对定位，由top、right、bottom、left等属性决定\nabsolute   绝对定位，相对于其上一个已经定位的父元素进行定位\nfixed      固定定位，相对于浏览器窗口进行定位\n\n\n# 静态定位 (static)\n\nposition: static html文档流中默认样式\n\n>  1. 无法偏移\n>  2. 可取消定位\n>  3. 跟随滚动\n\n\n# 相对定位 (relative)\n\nposition: relative  多个元素一个搞定，盒子打包\n\n>  1. 可偏移，原有位置继续占有\n>  2. 移动位置，是以元素左上角为基点移动\n>  3. 跟随滚动\n\n\n# 绝对定位 (absolute)\n\nposition: absolute  不占空间的漂浮元素\n\n>  1. 可偏移，原有位置不占有\n>  2. 无父级，以浏览器为基准\n>  3. 有父级，以父级盒子为基准\n>  4. 跟随滚动\n\n口诀技巧\n\n 1. 子绝父相 子级盒子是绝对定位，父级盒子是相对定位\n 2. 子绝父绝 父级盒子是绝对定位，子级盒子是绝对定位\n\n----------------------------------------\n\n\n# 固定定位 (fixed)\n\nposition: fixed; 始终在窗口展示的元素\n\n>  1. 跟父亲没有关系，只认浏览器\n>  2. 完全脱标，不占有位置\n>  3. 不随滚动\n\n\n# 叠放次序 (z-index)\n\nz-index: 4; 调整重叠定位元素的堆叠顺序\n\n>  1. 默认属性值：0，值越大越靠顶层\n>  2. 取值相同，书写顺序，后者居上\n>  3. 没有单位\n>  4. 除了静态，只能用于定位，其他类型，则无效\n\n\n# 定位总结\n\n定位模式            是否脱标占有位置   是否可以使用边偏移   移动位置基准\n静态 static       不脱标，正常模式   不可以         正常模式\n相对定位 relative   脱标，占位置     可以          相对自身位置移动\n绝对定位 absolute   脱标，不占位置    可以          相对于定位父级移动位置\n固定定位 fixed      脱标，不占位置    可以          相对于浏览器移动位置\n\n\n# 显示&隐藏\n\n主要目的是让一个元素在页面中消失，但是不在文档源码中删除\n\n\n# 显示 (display)\n\ndisplay 设置元素如何显示\n\ndisplay : none; 隐藏对象 、不保留位置\n\n----------------------------------------\n\n\n# 可见性 (visibility)\n\nvisibility 设置元素否显示\n\nvisibility属性值   说明\nvisible（默认）     对象可视\nhidden          对象隐藏 、保留位置\n\n----------------------------------------\n\n\n# 溢出隐藏 (overflow)\n\noverflow 当对象的内容超过指定的高度和宽度则隐藏\n\noverflow属性值    说明\nvisible （默认）   不剪切内容也不添加滚动条\nauto           超出自动显示滚动条，不超不显示\nhidden         超出内容隐藏掉\nscroll         总是显示滚动条\n\n----------------------------------------\n\n\n# 高级技巧\n\n\n# 鼠标样式 (cursor)\n\ncursor 鼠标移到对象上更换预定义光标形状\n\n常用的鼠标样式：\n\ncursor属性值   说明\ndefault     默认\npointer     小手\nmove        移动\ntext        文本\n\n\n# 禁止选中 (select)\n\nuser-select 设置用户是否可选中\n\n/* 参数依次为 允许选中/禁止选中/可被选中/单击选中 */\nuser-select: [auto | none | text | all]\n\n\n\n# 轮廓 (outline)\n\noutline 边框边缘的外围，可起到突出元素的作用\n\noutline: color style width\noutline: #fff solid 1px;\n\n\n> 参数： color: 选择颜色 style：样式 width: 宽度\n\n一般情况，我们只关心的直接写法是 outline: 0;、outline: none;\n\n----------------------------------------\n\n\n# 文本域固定 (resize)\n\nresize 调节文本域尺寸大小或固定\n\nresize属性值    说明\nnone         固定大小\nboth         可调节大小\nhorizontal   只可以调节宽\nvertical     只可以调节高\n\n\n# 垂直对齐 (vertical-align)\n\nvertical-align 设置内容与图片\\表单的对齐方式\n\nvertical-align属性值   说明\nbaseline （默认）       基线对齐\ntop                 顶部对齐\nmiddle              居中对齐\nbottom              底部对齐\n\n\n# 自动换行 (word-break)\n\nword-break 设置文本换行行为\n\nword-break属性值   说明\nnormal（默认）      强制显示所有文本\nkeep-all        只能在半角空格或连字符处换行（处理英文）\nbreak-all       遇边界断行，不考虑单词完整\nbreak-word      遇边界断行，考虑单词完整\n\n----------------------------------------\n\n\n# 空格换行 (white-space)\n\nwhite-space 对元素内容的空格处理！br可换行！！！\n\nwhite-space属性值   说明\nnormal （默认）      默认处理\npre              超出边界不断行\npre-wrap         空白距离不合并，碰边断行\npre-line         合并多余空白，碰边断行\nnowrap           合并多余空白，结束换行\n\n----------------------------------------\n\n\n# 文字溢出 (text-overflow)\n\ntext-overflow 将元素内容溢出时用自定义字符代替\n\ntext-overflow属性值   说明\nclip               切掉溢出部分\nellipsis           溢出部分替换为（...）\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>title</title>\n    <style>\n        div {\n            width: 100px;\n            height: 20px;\n            border: 1px solid red;\n            margin: 20px;\n            overflow: hidden;\n            white-space: nowrap;\n        }\n        .no1 {\n            text-overflow: clip;\n        }\n        .no2 {\n            text-overflow: ellipsis;\n        }\n    </style>\n</head>\n<body>\n<ul>\n    <li>clip<div class="no1">内容内容内容内容内容内容</div></li>\n    <li>ellipsis<div class="no2">内容内容内容内容内容内容</div></li>\n</ul>\n</body>\n</html>\n\n\n> 生效前提：\n> \n>  1. 元素宽度小于内容\n>  2. 超出内容隐藏的属性overflow: hidden\n>  3. 操出边界不换行的属性white-space:( pre | nowrap )\n>  4. 为有内容的文本添加属性 text-overflow\n\n\n# 动画&变形\n\n\n# 元素变化(transform)\n\ntransform 属性实现元素平移、缩放、旋转、倾斜等效果\n\ntransform: none | translate(···) | ···\n\n\n属性值 | 函数                         说明\nnone                             不变形\ntranslate(<length>[,<length>])   平移(x , y)（参数只有一个则取x一个）\ntranslatex(<length>)             x轴平移\ntranslatey(<length>)             y轴平移\nscale(<number>[,<number>])       缩放(x , y)（参数只有一个则xy一样）\nscalex(<number>)                 x轴缩放\nscaley(<number>)                 y轴缩放\nskew(<angle>[,<angle>])          倾斜(x , y)（参数只有一个则取x一个）\nskewx(<angle>)                   x轴倾斜\nskewy(<angle>)                   y轴倾斜\nrotate(<angle>)                  旋转角度\n\n\n# 元素中心变换(transform-origin)\n\ntransform-origin 属性实现中心点的变换，默认坐标x：50% ; y：50%\n\ntransform-origin: [左右] [上下]\ntransform-origin: [<percentage> | <length> | left | center | right]  [<percentage> | <length> | top | center | bottom]\n\n\n尖括号单位说明：\n\n> length： 长度 number： 数值 percentage： 百分比 angle： 角度（deg、grad、rad、turn）\n\n\n# 过渡效果(transition)\n\n# 参与过渡属性\n\ntransition-property 属性 控制元素在指定时间进行渐变式变化\n\ntransition-property: all | none | <property> [, <property>]\n\n\n> all： 默认值，所有可进行过渡的css属性 none： 不指定过渡的css属性 property： 指定过渡的css属性。多属性以, 分隔\n\n# 过渡持续时间\n\ntransition-duration 属性 指定过渡的持续时间\n\ntransition-duration: <time> [, <time>]\n\n\n<time>： 指定过渡时间（默认0）。多属性以, 分隔\n\n# 过渡延迟时间\n\ntransition-delay 属性 指定过渡的延迟时间\n\ntransition-delay: <time> [, <time>]\n\n\n<time>： 指定过渡时间（默认0）。多属性以, 分隔\n\n# 过渡动画类型\n\ntransition-timing-function 属性 指定过渡的动画类型\n\ntransition-timing-function: linear | ease | ease-in | ease-out | ease-in-out | cubic-bezier(x1 , y1 , x2 , y2) [, linear | ease | ease-in | ease-out | ease-in-out | cubic-bezier(x1 , y1 , x2 , y2)]\n\n\n属性值                               说明\nlinear                            线性渡过\nease                              平滑渡过\nease-in                           渐变加速\nease-out                          渐变减速\nease-in-out                       慢》快》慢\ncubic-bezier(x1 , y1 , x2 , y2)   贝塞尔曲线类型\n\n# 过渡连写\n\n/* 两个参数 */\ntransition: <指定属性> <持续时间>;\n/* 三个参数 */\ntransition: <指定属性> <持续时间> <延迟时间>;\n/* 三个参数 */\ntransition: <指定属性> <持续时间> <动画类型>;\n/* 多个属性对象 */\ntransition: <指定属性> <持续时间> , <指定属性> <持续时间> [,...];\n/* 全参 */\ntransition: <指定属性> <持续时间> <动画类型> <延迟时间>；\n\n\n\n# 动画(animation)\n\n# 关键帧\n\n实现动画前先定义动画帧\n\n@keyframes name \'{\' <keyframes-blocks> \'}\';\n\n\nname： 动画名称 <keyframes-blocks> ： 定义动画在不同时间段的样式规则\n\n实现过渡动画\n\n1.关键字from & to 定义帧位置\n\n从一个状态过渡到另一个状态\n\nfrom{\n    属性值n ：属性值1；\n    ···\n}\nto{\n    属性值n ：属性值1；\n    ···\n}\n/*完整定义*/\n@keyframes myframe{\n    from{···}\n    to{···}\n}\n\n\n2.百分比定义 关键帧位置\n\n通过百分比指定过渡各个状态\n\n@-keyframes myframe{\n    0%{···}\n    20%{···}\n    50%{···}\n    80%{···}\n    100%{···}\n}\n\n\n# 动画属性\n\n定义关键帧后，还需要相关属性执行关键帧的变化\n\nanimation: name | duration | timing-function | delay | iteration-count | direction;\n\n\n值                           描述\nanimation                   复合属性\nanimation-name              需要绑定到选择器的 keyframe 名称\nanimation-duration          动画完成时长\nanimation-timing-function   指定对象过渡类型\nanimation-delay             动画开始前延迟时长\nanimation-iteration-count   动画播放的次数（infinite无限循环）\nanimation-direction         是否轮流反向播放动画\n                            值：normal（正方向）、alternate（反方向）\nanimation-play-state        指定对象动画的状态\n                            值：running（运动）、paused（停止）\nanimation-fill-mode         指定对象动画之外的状态\n                            值：none（默认）、forwards（动画后）、backwwards（动画前）、both（两者都有）\n\n\n# 弹性布局 (flex)\n\n\n# justify-content\n\n对齐内容 , 主轴控制 内容指定分配空间\n\n属性值             说明\nflex-start      项目开头对齐(默认)\ncenter          项目居中对齐\nflex-end        项目结尾对齐\nspace-between   所有项目两端分开对齐 , 其余空间平分\nspace-around    所有项目对齐两端都有一半大小空间\nspace-evenly    所有项目左右两端空间平分\n\nflex-start(默认)\n\n\n\nflex-start\n\n\n\ncenter\n\n\n\nflex-end\n\n\n\nspace-between\n\n\n\nspace-around\n\n\n\n\n# align-items\n\n对齐项目 , 交叉轴控制 项目之间和项目周围垂直分配空间\n\n属性值          说明\nstretch      项目拉伸填充(默认)\ncenter       项目居中对齐\nflex-start   项目开头对齐\nflex-end     项目末端对齐\nbaseline     项目基线对齐\n\nstretch(默认)\n\n\n\ncenter\n\n\n\nflex-start\n\n\n\nflex-end\n\n\n\nbaseline\n\n\n\n\n# flex-direction\n\n轴互换 , 主轴 和 交叉轴 互换\n\n属性值              说明\nrow              行排列 (默认)\nrow-reverse      行反序排列\ncolumn           竖排列\ncolumn-reverse   竖反序排列\n\nrow(默认)\n\n\n\nrow-reverse\n\n\n\ncolumn\n\n\n\ncolumn-reverse\n\n\n\n\n# flex-wrap\n\n让元素进行折行排列，使得每行的元素都不超过容器的宽度\n\n属性值            说明\nnowrap         不换行(默认)\nwrap           换行\nwrap-reverse   反序移出换行\n\nnowrap(默认)\n\n\n\nwrap\n\n\n\nwrap-reverse\n\n\n### flex 调整\n\nalign-content 对齐内容\n\nalign-items 对齐项目\n\nalign-self 对齐本身\n\n\n# 精灵图\n\n由很多小的背景图像合成的大图被称为 精灵图。可以减少浏览器与服务器数据交换的次数。\n\n精灵图运用\n\n根据大小查找图片,锁定位置\n\n精灵图在css使用到的属性有\n\n/*背景连写*/\nbackground\n/*背景图片*/\nbackground-image: none | url;\n/*背景平铺 */\nbackground-repeat: repeat | no-repeat | repeat-x | repeat-y ;\n/*背景位置*/\nbackground-position: (length | position) (length | position);\n/*length: 精准坐标、position: 方位名词*/\n\n\n原图调用 ：（京东精灵图）\n\n示范代码：\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>title</title>\n    <style>\n        li {\n            margin: 20px;\n            float: left;\n        }\n        .no1 {\n            width: 30px;\n            height: 26px;\n            background: url("img/jd.png") no-repeat;\n        }\n        .no2 {\n            width: 16px;\n            height: 22px;\n            background: url("img/jd.png") no-repeat 0 -68px;\n        }\n        .no3 {\n            width: 230px;\n            height: 52px;\n            background: url("img/jd.png") no-repeat 0 -134px;\n        }\n        .no4 {\n            width: 20px;\n            height: 26px;\n            background: url("img/jd.png") no-repeat 0 -408px;\n        }\n        .no5 {\n            width: 42px;\n            height: 44px;\n            background: url("img/jd.png") no-repeat 0 -442px;\n        }\n    </style>\n</head>\n<body>\n<ul>\n    <li class="no1"></li>\n    <li class="no2"></li>\n    <li class="no3"></li>\n    <li class="no4"></li>\n    <li class="no5"></li>\n</ul>\n</body>\n</html>\n\n\n结果图示\n\n\n\n----------------------------------------\n\n\n# 滑动门\n\n为网页元素设置特殊形状的背景。 以下我网站例子：\n\n\n\n背景原型：\n\n\n\n滑动门应用：\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>title</title>\n    <style>\n        * {\n            margin: 0;\n            padding: 0;\n        }\n        body {\n            height: 1000px;\n            /*背景*/\n            background: url("img/wx.jpg") repeat-x;\n        }\n        .box li {\n            float: right;\n            margin: 20px;\n            list-style: none;\n        }\n        .box a {\n            height: 33px;\n            line-height: 33px;\n            text-decoration: none;\n            display: inline-block;\n            color: #fff;\n            /*按钮样式背景（左）*/\n            background: url("img/to.png") no-repeat;\n            padding-left: 16px;\n        }\n        .box span {\n            height: 33px;\n            display: inline-block;\n            /*按钮样式背景（右）*/\n            background: url("img/to.png") right;\n            padding-right: 16px;\n        }\n        /*鼠标指定时高亮*/\n        .box a:hover span {\n            background: url("img/ao.png") right;\n        }\n        .box a:hover {\n            background: url("img/ao.png") no-repeat;\n        }\n    </style>\n</head>\n<body>\n    <ul class="box">\n        <li><a href="#"><span>pc平台</span></a></li>\n        <li><a href="#"><span>开放平台</span></a></li>\n        <li><a href="#"><span>帮助与反馈</span></a></li>\n        <li><a href="#"><span>首页</span></a></li>\n    </ul>\n</body>\n</html>\n\n\n\n\n> 说明：\n> \n>  1. a 设置背景左侧，内边距撑开左框中的宽度\n>  2. span 设置背景右侧，内边距撑开有边框的宽度，左边有内容\n>  3. a包含span是因为整体是可以点击的缘故\n\n----------------------------------------\n\n\n# 字体图标\n\n字体图标是以特殊形式的字体呈现出来的图标，可透明、旋转、改颜色等····\n\n> 使用流程：\n> \n>  1. 获取svg格式的效果图\n>  2. 上传生成兼容性的字体文件包\n>  3. 下载到本地的兼容字体文件包\n>  4. 字体文件包引入到html页面中\n\n引入网页：\n\n 1. 创建fonts文件夹在根路经里\n\n 2. 在样式里声明字体图标，声明代码可在下载的项目里获取！！！\n    \n    以下是例子：（不同来源网站不同声明代码！！！）\n    \n    @font-face {\n      font-family: \'icomoon\';\n      src:  url(\'fonts/icomoon.eot?7kkyc2\');\n      src:  url(\'fonts/icomoon.eot?7kkyc2#iefix\') format(\'embedded-opentype\'),\n        url(\'fonts/icomoon.ttf?7kkyc2\') format(\'truetype\'),\n        url(\'fonts/icomoon.woff?7kkyc2\') format(\'woff\'),\n        url(\'fonts/icomoon.svg?7kkyc2#icomoon\') format(\'svg\');\n      /*清除粗细*/\n      font-weight: normal;\n      /*清除倾斜*/\n      font-style: normal;\n    }\n    \n\n 3. 盒子使用字体\n    \n    /*盒子字体可用*/\n    span {\n        /*icomoon: 字体图标的名称*/\n        font-family: "icomoon";\n    }\n    \n\n 4. 盒子里添加结构，图标编码可在项目里获取！\n    \n    span::before {\n    \t\t content: "\\e900";\n    \t}\n    /*或者 （一下是特殊字体图标）*/\n    <span>&#xe613;</span> \n    \n\n\n# 版心和布局流程\n\n\n# 版心\n\n是指网页中主体内容所在的区域。一般在浏览器窗口中水平居中显示，常见的宽度值为960px、980px、1000px、1200px等。\n\n\n# 布局流程\n\n布局时通常需要遵守一定的布局流程，具体如下：\n\n 1. 确定页面的版心（可视区）\n 2. 分析页面中的行模块，以及每个行模块中的列模块\n 3. 制作html结构\n 4. css初始化，然后开始运用盒子模型的原理，通过div+css布局来控制网页的各个模块。\n\n\n# css书写规范\n\n\n# 空格规范\n\n【强制】 选择器 与 { 之间必须包含空格。\n\n.selector { }\n\n\n【强制】 属性名 与之后的 : 之间不允许包含空格， : 与 属性值 之间必须包含空格。\n\nfont-size: 12px;\n\n\n\n# 选择器规范\n\n【强制】 当一个样式包含多个选择器时，每个选择器声明必须独占一行。\n\n/*好习惯*/\n.post,\n.page,\n.comment {\n    line-height: 1.5;\n}\n\n/*坏习惯*/\n.post, .page, .comment {\n    line-height: 1.5;\n}\n\n\n选择器的嵌套层级不大于 3 级，位置靠后的限定条件应尽可能精确。\n\n/* 好习惯 */\n#username input {}\n.comment .avatar {}\n\n/* 坏习惯 */\n.page .header .login #username input {}\n.comment div * {}\n\n\n\n# 属性规范\n\n【强制】 属性定义必须另起一行。 【强制】 属性定义后必须以分号结尾。\n\n/* 好习惯 */\n.selector {\n    margin: 0;\n    padding: 0;\n}\n\n/* 坏习惯 */\n.selector { margin: 0; padding: 0; }\n\n\n\n# 高度格式\n\n顶线(字体最高)，中线(字体中间)，基线(字体底部)，底线(最底部) 基线与基线的距离为行高。 字体上距离=(设置值 - 字体) / 2（单位：px）\n\n\n# css 三大特性\n\n\n# css层叠性\n\n一般情况下，如果出现样式冲突，则会按照css书写的顺序，以最后的样式为准。\n\n 1. 样式冲突，遵循的原则是就近原则。 那个样式离着结构近，就执行那个样式。\n 2. 样式不冲突，不会层叠\n\n\n# css继承性\n\n子标签会继承父标签的某些样式。想要设置一个可继承的属性，只需将它应用于父元素即可。 恰当地使用继承可以简化代码，降低css样式的复杂性。子元素可以继承父元素的样式\n\n\n# css优先级\n\n出现两个或更多规则应用在同一元素上，这时就会出现优先级的问题。注意的特殊情况：\n\n 1. 继承样式的权重为0！！！\n 2. 行内样式优先。\n 3. 权重相同时，css遵循就近原则。\n 4. css定义了一个!important命令，该命令被赋予最大的优先级。\n\n\n# css特殊性\n\n关于css权重，需要一套计算公式来去计算，这个就是 css specificity，是衡量css值优先级的一个标准。 specificity用一个四位的数字串(css2是三位)来表示，更像四个级别，值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越\n\n继承的贡献值（权重）          0,0,0,0\n* 全部                0,0,0,0\n每个元素（标签）            0,0,0,1\n每个类，伪类              0,0,1,0\n每个id                0,1,0,0\n每个行内样式              1,0,0,0\n每个!important（重要的）   ∞无穷大\n\n权重是可以叠加的 比如的例子：\n\ndiv ul  li   ------\x3e      0,0,0,3\n\n.nav ul li   ------\x3e      0,0,1,2\n\na:hover      ------\x3e      0,0,1,1\n\n.nav a       ------\x3e      0,0,1,1   \n\n#nav p       -----\x3e       0,1,0,1\n\n\n数位之间没有进制。比如说： 0,0,0,5 + 0,0,0,5 =0,0,0,10 而不是 0,0, 1, 0， 所以不会存在10个div能赶上一个类选择器的情况。\n\n# 权重总结\n\n 1. 使用了!important声明的规则。\n 2. 内嵌在html元素的style属性里面的声明。\n 3. 使用了id 选择器的规则。\n 4. 使用了类选择器、属性选择器、伪元素和伪类选择器的规则。\n 5. 使用了元素选择器的规则。\n 6. 只包含一个通用选择器的规则。\n 7. 同一类选择器则遵循就近原则。\n\n权重是优先级的算法，层叠是优先级的表现',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"ES6",frontmatter:{title:"ES6",author:"柏竹",permalink:"/web/1hg7cd",date:"2020-02-18T00:00:00.000Z",categories:["前端"],tags:["ES6"]},regularPath:"/02.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87/04.ES6.html",relativePath:"02.前端/01.前端必备/04.ES6.md",key:"v-fa7faa54",path:"/web/1hg7cd/",headers:[{level:2,title:"变量",slug:"变量",normalizedTitle:"变量",charIndex:68},{level:3,title:"作用域",slug:"作用域",normalizedTitle:"作用域",charIndex:75},{level:3,title:"空值运算符",slug:"空值运算符",normalizedTitle:"空值运算符",charIndex:353},{level:3,title:"逻辑赋值操作符",slug:"逻辑赋值操作符",normalizedTitle:"逻辑赋值操作符",charIndex:753},{level:2,title:"字符串拓展",slug:"字符串拓展",normalizedTitle:"字符串拓展",charIndex:962},{level:3,title:"字符串方法",slug:"字符串方法",normalizedTitle:"字符串方法",charIndex:972},{level:3,title:"模板字符串",slug:"模板字符串",normalizedTitle:"模板字符串",charIndex:1394},{level:2,title:"数组拓展",slug:"数组拓展",normalizedTitle:"数组拓展",charIndex:1733},{level:3,title:"数组复制",slug:"数组复制",normalizedTitle:"数组复制",charIndex:2615},{level:2,title:"正则拓展",slug:"正则拓展",normalizedTitle:"正则拓展",charIndex:2824},{level:3,title:"正则方法",slug:"正则方法",normalizedTitle:"正则方法",charIndex:2844},{level:2,title:"对象拓展",slug:"对象拓展",normalizedTitle:"对象拓展",charIndex:3872},{level:3,title:"对象简写",slug:"对象简写",normalizedTitle:"对象简写",charIndex:3881},{level:3,title:"属性名表达式",slug:"属性名表达式",normalizedTitle:"属性名表达式",charIndex:3971},{level:3,title:"拓展运算符",slug:"拓展运算符",normalizedTitle:"拓展运算符",charIndex:1739},{level:3,title:"可选链操作符",slug:"可选链操作符",normalizedTitle:"可选链操作符",charIndex:4280},{level:3,title:"对象方法",slug:"对象方法",normalizedTitle:"对象方法",charIndex:979},{level:3,title:"私有特征",slug:"私有特征",normalizedTitle:"私有特征",charIndex:5664},{level:2,title:"函数拓展",slug:"函数拓展",normalizedTitle:"函数拓展",charIndex:5999},{level:3,title:"装配参数",slug:"装配参数",normalizedTitle:"装配参数",charIndex:6008},{level:3,title:"剩余参数",slug:"剩余参数",normalizedTitle:"剩余参数",charIndex:6167},{level:3,title:"函数Name",slug:"函数name",normalizedTitle:"函数name",charIndex:6536},{level:3,title:"箭头函数",slug:"箭头函数",normalizedTitle:"箭头函数",charIndex:6622},{level:2,title:"Symbol",slug:"symbol",normalizedTitle:"symbol",charIndex:6851},{level:3,title:"遍历Symbol",slug:"遍历symbol",normalizedTitle:"遍历symbol",charIndex:7517},{level:2,title:"Iterator",slug:"iterator",normalizedTitle:"iterator",charIndex:8203},{level:2,title:"Set",slug:"set",normalizedTitle:"set",charIndex:8578},{level:2,title:"Map",slug:"map",normalizedTitle:"map",charIndex:2349},{level:2,title:"Proxy",slug:"proxy",normalizedTitle:"proxy",charIndex:10994},{level:2,title:"Promise",slug:"promise",normalizedTitle:"promise",charIndex:11897},{level:3,title:"Promise方法",slug:"promise方法",normalizedTitle:"promise方法",charIndex:13197},{level:4,title:"Promise.all()",slug:"promise-all",normalizedTitle:"promise.all()",charIndex:13210},{level:4,title:"Promise.race()",slug:"promise-race",normalizedTitle:"promise.race()",charIndex:13606},{level:3,title:"Promise手写",slug:"promise手写",normalizedTitle:"promise手写",charIndex:13982},{level:2,title:"Generator",slug:"generator",normalizedTitle:"generator",charIndex:16585},{level:2,title:"Class",slug:"class",normalizedTitle:"class",charIndex:17071},{level:2,title:"Modlule",slug:"modlule",normalizedTitle:"modlule",charIndex:17420},{level:3,title:"动态导入",slug:"动态导入",normalizedTitle:"动态导入",charIndex:18669},{level:2,title:"异步遍历器",slug:"异步遍历器",normalizedTitle:"异步遍历器",charIndex:18919},{level:2,title:"WeakRefs",slug:"weakrefs",normalizedTitle:"weakrefs",charIndex:19444},{level:2,title:"异常捕获",slug:"异常捕获",normalizedTitle:"异常捕获",charIndex:21026}],headersStr:"变量 作用域 空值运算符 逻辑赋值操作符 字符串拓展 字符串方法 模板字符串 数组拓展 数组复制 正则拓展 正则方法 对象拓展 对象简写 属性名表达式 拓展运算符 可选链操作符 对象方法 私有特征 函数拓展 装配参数 剩余参数 函数Name 箭头函数 Symbol 遍历Symbol Iterator Set Map Proxy Promise Promise方法 Promise.all() Promise.race() Promise手写 Generator Class Modlule 动态导入 异步遍历器 WeakRefs 异常捕获",content:"# ES6\n\nES6 是 JavaScript 语言的标准 , 可以编写些复杂的大型项目 (企业级)\n\n教程网站 : 点击跳转\n\n\n# 变量\n\n\n# 作用域\n\n如果变量定义在 花括号{} 内 , 那么该 变量的作用范围也就仅限于 花括号{}内 (let定义)\n\nif(true){\n    let i = 10;\n}\n// 无法打印\nconsole.log(i);\n\n\n> 如果变量采用 var 导致为全局变量\n\nvar与let区别\n\n              VAR           LET\n重复声明          允许(旧覆盖新)      不允许\n作用范围          全局范围          仅限花括号内\n声明提前(声明前调用)   允许(但不会显示数据)   不允许\n\n\n# 空值运算符\n\n空值合并运算符 ?? (和 || , && 用法一样) , 当左侧变量为 null/undefined 时 , 返回右侧变量 , 否则返回左侧\n\n示例 : (可通过以下代码区分 || 和 ?? 区别)\n\nconsole.log(undefined || \"Sans\") // Sans\nconsole.log(undefined ?? \"Sans\") // Sans\nconsole.log(NaN || \"Sans\") // Sans\nconsole.log(NaN ?? \"Sans\") // NaN\nconsole.log(null || \"Sans\") // Sans\nconsole.log(null ?? \"Sans\") // Sans\nconsole.log(0 || \"Sans\") // Sans\nconsole.log(0 ?? \"Sans\") // 0\n\n\n\n# 逻辑赋值操作符\n\n逻辑赋值操作符 ??= , &&= , ||= , 可在判断的时候进行赋值\n\nlet a = true;\nlet b = false;\na ||= b // a = a || b; (true)\na &&= b // a = a && b; (false)\nlet obj = {name:'Sans'}\nobj.age ??= 22\nconsoel.log(obj.age) // 22\n\n\n\n# 字符串拓展\n\n\n# 字符串方法\n\n对象方法示例 : 点击跳转\n\n方法                                       说明\nstr.padStart(number, string)             在开头填充指定字符直到number的长度\nstr.padEnd(number, string)               在末尾填充指定字符直到number的长度\nstr.trimStart()                          清除开头的所有空格符\nstr.trimEnd()                            清除结尾的所有空白符\nstr.replace(reg , targetStr)             按正则替换为targetStr\nstr.replaceAll(replaceStr , targetStr)   将所有replaceStr替换为targetStr\n\n\n# 模板字符串\n\n教程 : 点击跳转\n\n以往在拼接 H5标签时 , 是通过 \"\"/' 引号的 , 如果添加了换行和变量 , 那么会显得很难阅读 .\n\n模板字符串正式解决了这一痛点\n\nlet name = 'Sans';\n// 引号拼接\nlet node = \"<span>\\\n\t<b>\" + name + \"</b>\\\n\t</span>\";\n\n// 模板字符串 (支持表达式)\nlet node2 = `<span>\n\t\t<b>${name}</b>\n\t</span>`;\n\nlet node3 = `<span>\n\t\t<b>${name===''?'名称不存在':name}</b>\n\t</span>`;\n\n// 原型 <span><b>Sans</b></span>\n\n\n\n# 数组拓展\n\n拓展运算符 用法展示 :\n\nlet arr = [1,2,3];\n\n// 复制\nlet arr2 = [...arr];\n\n// 提取\nlet {a,..b} = arr;\nconsole.log(a,b) // 1 [2,3]\n\n\n\nArray.from()\n\narguments可以在形参中获取没有实参中的内容 , 但获取到的数据并非是数组形式 , 需要借助 ==Array.from()== 能够将 类数组结构 转换为 数组\n\nfunction test(){\n    console.log(Array.from(arguments))\n}\ntest(1,2,3,4)\n\n\nArray.flat()\n\n数组扁平化 . 进行将递归层级的数组进行降维\n\n// 案例1\nlet arr = [\n    ['北京','上海','广州'],\n    ['南京','厦门','南宁']\n]\nconsole.log(arr.flat()); // ['北京','上海','广州','南京','厦门','南宁']\n\n// 案例2\nlet arr2 = [{\n        name: \"A\",\n        list: ['北京','上海','广州']\n    },{\n        name: \"B\",\n        list: ['南京','厦门','南宁']\n    }];\nlet res = arr2.flatMap(item => {\n    return item.list;\n})\nconsole.log(res); // ['北京','上海','广州','南京','厦门','南宁']\n\n\nat()\n\n拿取指定索引数据 , 负数则为倒数元素进行索引 , 字符串也可以行\n\nlet arr = ['no1','no2','no3','no4']\nconsole.log(arr.at(0)) // arr[0] (no1)\nconsole.log(arr.at(-1)) // arr[arr.length-1] (no4)\n\n\n\n# 数组复制\n\n以下数组复制 , 只是复制了指针 , 并非开辟内存空间\n\nconst a1 = [1, 2];\nconst a2 = a1;\n\na2[0] = 2;\na1 // [2, 2]\n\n\n以下代码 , 复制形式 开辟了内存空间\n\nconst a1 = [1, 2];\nconst a2 = a1.concat();\nconst a3 = [...a1]\n\na2[0] = 2;\na1 // [1, 2]\n\n\n\n# 正则拓展\n\n教程 : 点击跳转\n\n\n# 正则方法\n\n方法                  说明\nstr.match()         获取 正则匹配值 的数组 (全局匹配末尾加g)\nstr.matchAll(reg)   获取 正则匹配值 的数组\nstr.replace()       获取 正则匹配值替换预期值 的新字符串\nstr.search()        获取 正则匹配的首个索引 , 不存在 -1\nstr.test()          是否有 正则匹配值\nstr.exec(str)       获取 正则匹配值 的数组 (详细\n\n// ES6 新特性 exec()\nlet str = \"今天是2022-11-11\";\n// exec()\nconsole.log(/[0-9]{4}-[0-9]{2}-[0-9]{2}/.exec(str)) // ['2022-11-11', index: 3, input: '今天是2022-11-11', groups: undefined]\nconsole.log(/([0-9]{4})-([0-9]{2})-([0-9]{2})/.exec(str)) // ['2022-11-11', '2022', '11', '11', index: 3, input: '今天是2022-11-11', groups: undefined]\nconsole.log(/(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/.exec(str)) // ['2022-11-11', '2022', '11', '11', index: 3, input: '今天是2022-11-11', groups: {day: '11',month: '11',year: '2022'}]\n\n\n// ES6 新特性 matchAll()\nlet str = `\n<ul>\n\t<li>111</li>\n\t<li>222</li>\n\t<li>333</li>\n\t<li>444</li>\n</ul>\n`;\n\nlet reg = /<li>(?<content>.*)<\\/li>/g;\nfor(let item of str.matchAll(reg)){\n    console.log(item.groups.content)\n}\n/*\n111\n222\n333\n444\n*/\n\n\n\n# 对象拓展\n\n\n# 对象简写\n\nconst foo = 'bar';\nconst baz = {\n    foo,\n    name: 'Sans',\n    test(){...}\n};\n\n\n\n# 属性名表达式\n\n可以通过变量进行定义变量名\n\nlet name = 'sans'\nlet obj = {\n    [name]: 'zs'\n}\nconsole.log(obj); // {sans: 'zs'}\n\n\n\n# 拓展运算符\n\n可以跟数组一样 使用 ... 进行操作\n\nlet obj1 = {name: 'zs'};\nlet obj2 = {age: 12};\nconsole.log({...obj1, ...obj2});\n\n// 等同于 \n// {}空对象 是将 obj1和obj2分别合并到新的空对象\nconsole.log(Object.assign({}, obj1, obj2));\n\n\n\n# 可选链操作符\n\n可选链操作符 ? , 作用是 判断操作符前面的变量是否为 null/undefined , 如果是 则不会进行往后的链式调用\n\nlet obj1 = {\n    name: 'sans',\n    location: {\n        city:'广东'\n    }\n}\nlet obj2 = {\n    name: 'sans'\n}\n\nconsole.log(obj1.location.city) // 广东\nconsole.log(obj2.location.city) // 报红\nconsole.log(obj2?.location?.city ?? '这人很懒,啥也没写') // undefined\n\n\n> 意图 : 尽可能避免没有意义的报红警告\n\n\n# 对象方法\n\n对象方法示例 : 点击跳转\n\n方法                                       说明\nObject.assign(targetObj, ...sourceObj)   克隆对象 ( 可拷贝多个对象至目标对象)\nObject.is(obj1, obj2)                    比较对象 (比 == , === 更为严谨)\nObject.keys(obj)                         获取 对象所有属性名 的数组\nObject.values(obj)                       获取 对象所有属性值 的数组\nObject.entries(obj)                      获取 对象所有 属性名和属性值 的二维数组\nObject.getOwnPropertyDescriptors()       获取 获取所有属性描述信息\nObject.fromEntries(arr)                  将 键值对的二维数组/Map对象 转为对象 (逆操作)\n\nObject.fromEntries()\n\n// 用法1\nlet arr = [['name','zs'],['age',22]];\nconsole.log(Object.fromEn tries(arr))\n// 用法2\nlet map = Map();\nmap.set(\"name\",\"zs\");\nmap.set(\"age\",22);\nconsole.log(Object.fromEntries(map))\n// 用法3\nlet str = \"name=zs&age=22\"\nlet seatchParams = new URLSearchParams(str);\nconsole.log(Object.fromEntries(seatchParams))\n// 用法4\nlet obj = {\n    \"广东\": [\"广州\",\"佛山\",\"深圳\"],\n    \"广西\": [\"南宁\",\"贵港\"],\n    \"江苏\": [\"南京\"]\n}\nlet myarr = Object.entries(obj)\nlet mynewarr = myarr.map(([key,value])=>{\n    []\n})\nconsole.log(Object.fromEntries(myarr))\n\n\n\n# 私有特征\n\nES13更新中的新功能 , 通过在 变量/方法 前面添加 # 代表私有 , 不过访问是需要调用内部方法进行访问\n\nclass people{\n    #obj = {}\n    \n    get(key){\n        return this.#obj[key]\n    }\n    set(key, value){\n        this.#obj[key] = value\n    }\n}\n\nlet store = new people();\nstore.set(\"name\",\"Sans\");\nstore.set(\"age\",22);\n\n// console.log(store.#obj) 报红\nconsole.log(store)\n\n\n\n# 函数拓展\n\n\n# 装配参数\n\n函数可以定义可选默认值\n\n// url必选 , 其余可选\nfunction ajax(url, method=\"get\", async=true){....}\najax(\"/test\");\najax(\"/test\", 'post');\najax(\"/test\", 'post', false);\n\n\n\n# 剩余参数\n\n多个变量的时候可以采用 ...\n\nfunction test(...arr){\n    console.log(arr); //[1,2,3,4]\n}\ntest(1,2,3,4);\n\n\nlet obj {\n    code: 200,\n    data: \"zs\"\n}\nlet {name, ...others} = obj\n\n\n应用场景 ()\n\nfunction ajax(options){\n    const defaultOptions = {\n        methods: 'get',\n        async: true\n    }\n    options = {...defaultOptions, ...options}\n    ...\n}\najax({\n    url: '...'\n})\n\n\n\n# 函数Name\n\n函数变量可以通过 name属性 进行获取 函数的名称\n\nfunction test(){....}\nconsole.log(test.name)\n\n\n\n# 箭头函数\n\n简写函数的作用\n\nlet test = function(e){...}\nlet test = (e)=>{...}\n\n\n简写情况 :\n\n * 参数只有一个的情况 ; 省略 方法括号 ()\n * 函数体只有一条语句的情况 ; 省略返回 return\n\n注意 :\n\n * 函数体只有一条语句的情况且是返回一个对象 , 必须在对象外的 {}花括号 加上 ()括号\n * 箭头函数没有this , this是访问父作用域 (箭头函数应用严紧)\n\n\n# Symbol\n\nSymbol 是一种新的 原始数据类型 , 表示独一无二的值 !\n\n// 实例 Symbol类型数据\nlet s = Symbol();\nconsole.log(typeof s)\n\nlet s2 = Symbol();\nconsole.log(s === s2) // false\n\n\nSymbol实例中可添加参数 作为标识 (方便理解) ==let s = Symbol('name')==\n\n这一特性解决了 属性名的冲突 问题 , 示例 :\n\nlet obj = { name : 'sans' }\n\nlet name = Symbol('name');\nobj[name] = 'zs';\n\nconsole.log(obj[name]) // zs\nconsole.log(obj.name) // sans\n\n\n> 主要意图是 该对象别人使用相同名称时 , 可防止冲突 , 因此 封装者 一般会采用这种方式\n\n规范用法\n\nlet keys = {\n\tname: Symbol('name'),\n    age: Symbol('age'),\n    test: Symbol('test')\n}\nlet obj = {\n    [keys.name]: 'Sans',\n    [keys.age]: 22,\n    [keys.test]() {\n        console.log('方法测试');\n    }\n}\nconsole.log(obj);\nobj[keys.test]();\n\n\n\n# 遍历Symbol\n\nSymbol属性名 不能被 for...in/for...of 遍历 , 也不会被Object.keys()/Object.getOwnPropertyNames()/JSON.stringify()返回\n\nObject.getOwnPropertySymbols() 获取指定对象的所有Symbol属性名\n\nReflect.ownKeys() 获取指定对象的所有属性\n\nlet obj = {};\nlet a = Symbol('a');\nlet b = Symbol('b');\n\nobj.name = 'sans';\nobj[a] = 'Hello';\nobj[b] = 'World';\n\nconst objectSymbols = Object.getOwnPropertySymbols(obj);\nconst reflectSymbols = Reflect.ownKeys(obj);\n\nconsole.log(objectSymbols) // [Symbol(a), Symbol(b)]\nconsole.log(reflectSymbols) // ['name', Symbol(a), Symbol(b)]\n\n// 遍历\nreflectSymbols.forEach(item =>{\n    console.log(item,'=>',obj[item])\n})\n\n\n注意 :\n\n * 不能进行运算\n * toString()打印显示 实例本身\n * 隐式转换boolean\n * map不能遍历 Symbol类型\n\n\n# Iterator\n\n教程 : 点击跳转\n\nIterator迭代器 是一种机制 , 为不同数据结构提供了统一的访问机制\n\nlet arr = ['zs','ls','ww'];\nlet i = arr[Symbol.iterator]();\nconsole.log(i.next()); // {value: 'zs', done: false}\nconsole.log(i.next()); // {value: 'ls', done: false}\nconsole.log(i.next()); // {value: 'ww', done: false}\nconsole.log(i.next()); // {value: undefined, done: true}\n\n\n原生具备 Iterator接口 的数据结构 :\n\n * Array\n * Set\n * Map\n * String (每个字符的遍历)\n * arguments对象\n * NodeList对象\n\nES6规定 , Iterator接口默认在数据结构的 Symbol.iterator属性 (本身是个迭代器生成函数)\n\n> 数据结构如果具备有 Symbol.iterator属性 那么可认为是 可遍历的\n\n对 Object类型对象 封装 仅限访问\n\nlet list = Symbol('list');\nlet obj = {\n    code: 200,\n    name: 'sans',\n    // 仅限访问list\n    [list]: ['zs','ls','ww'],\n\n    // 迭代器 访问\n    [Symbol.iterator](){\n        let index = 0;\n        return {\n            // 迭代器包含有 next()\n            // 采用箭头函数原因 : this越过函数本身 , 引用对象\n            next: ()=>{\n                return{\n                    value: this[list][index++],\n                    done: index>=(this[list].length+1)?true:false\n                }\n            }\n        }\n    }\n}\n\n// 迭代器测试\nlet i = obj[Symbol.iterator]();\nconsole.log(i.next()) // { value: 'zs', done: false }\nconsole.log(i.next()) // { value: 'ls', done: false }\nconsole.log(i.next()) // { value: 'ww', done: false }\nconsole.log(i.next()) // { value: undefined, done: true }\nconsole.log(i.next()) // { value: undefined, done: true }\n\n// for..of遍历\nfor(item of obj){\n    console.log(item) \n}\n\n\n\n# Set\n\nSet类似数组结构 , 但成员的值都是唯一的 , 没有重复的值\n\nlet set = new Set([1,2,3,2,4,4,5,5]);\nconsole.log(s); // Set(5) { 1, 2, 3, 4, 5 }\n// 转Array\nlet arr = [...set];\nlet arr2 = Array.from(set);\n\n\nSet基本属性和方法\n\n * size : 获取Set总数\n * Set.prototype.add(value) : 添加值\n * Set.prototype.delete(value) : 删除值\n * Set.prototype.has(value) : 判断是否包含有\n * Set.prototype.keys() : 获取键名 遍历器\n * Set.prototype.values() : 获取值 遍历器\n * Set.prototype.entries() : 获取键值对 遍历器\n * Set.prototype.forEach() : 遍历每个成员\n\n数组手写去重\n\nlet set = [11,2,3,'sans',{name:'sans'},{name:'ww'},{name:'sans'},11,123123,undefined,NaN,NaN]\n\n// 方式1\nfunction uni(arr){\n\tlet res = new Set();\n\treturn set.filter(item =>{\n\t\tlet id = JSON.stringify(item);\n\t\tconsole.log('id',id)\n\t\tif(res.has(id)){\n\t\t\treturn false;\n\t\t}else{\n\t\t\tres.add(id);\n\t\t\treturn true;\n\t\t}\n\t})\n}\nconsole.log(uni(set));\n\n//方式2\nfunction uni2(arr){\n    let res = new Set();\n    arr.forEach(item => res.add(item));\n    return res;\n}\nconsole.log(uni2(set));\n\n//方式3\nfunction uni3(arr){\n    return [...new Set(arr)];\n}\nconsole.log(uni3(set));\n\n\n\n# Map\n\nMap类似对象结构 , 键值对的集合 , 但 键 可以是各种类型\n\nlet map = new Map([\n    ['name','sans'],\n    ['age',22]\n])\n// 等同于\nlet map2 = new Map();\nmap2.set('name','sans');\nmap2.set('age',22);\nconsole.log(map); // Map(2) { 'name' => 'sans', 'age' => 22 }\nconsole.log(map2); // Map(2) { 'name' => 'sans', 'age' => 22 }\n\n\nMap基本属性和方法 包含有 Set应用的方法 点击跳转\n\n\n# Proxy\n\nProxy代理 主要作用是 为对象设置个拦截 (监听) , 实时获取对象数据/设置对象数据 等操作\n\nlet obj = {};\nlet proxy = new Proxy(obj,{\n    get(target, key){\n    \tconsole.log('get', target, key);\n        return target[key];\n    },\n\tset(target, key, value){\n\t\tconsole.log('set', target, key, value)\n\t\ttarget[key] = value;\n\t}\n})\n\nproxy.name='sans'\nconsole.log(proxy.name)\n\n\n其他类型的操作\n\nlet s = new Set();\nlet proxy = new Proxy(s,{\n    get(target, key){\n\t\tlet v = target[key];\n\t\t// 如果访问的是方法 , 修正this指向\n\t\tif(v instanceof Function) return v.bind(target);\n        return v;\n    },\n\tset(target, key, value){\n\t\tconsole.log('set', target, key, value)\n\t}\n})\n\nproxy.add('sans')\nconsole.log(proxy) // Set(1) { 'sans' }\n\n\nES5 旧版 , 弊端仅限于对象的属性使用\n\nlet obj = {};\n\n// 监听 obj对象的name属性 \nObject.defineProperty(obj, \"name\", {\n    get(){\n        console.log('get')\n    },\n    set(){\n        console.log('set')\n    }\n})\n\nobj.name = 'sans'\nconsole.log(obj.name)\n\n\n\n# Promise\n\nPromise是回调的升级版 , 在处理花费较长时间的任务时 , 使用 Promise 可以进行异步处理 , 防止堵塞\n\n学习来源 : 点击跳转\n\n基本结构 :\n\n// 参数封装有一个执行器函数\nlet pro = new Promise((resolve, reject)=>{\n\tif(true){\n        resolve('succee');\n    }else{\n        reject('fail')\n    }\n})\n\npro.then( res =>{\n    console.log('succee')\n}).catch( err =>{\n    console.log('fail')\n}).finally(()=>{\n\tsonsole.log(\"一定执行的\")\n})\n\n\n响应结构说明 :\n\n * Prototype : 原型类型\n * PromiseState : pending(等待) / fulfilled(完成) / rejected(拒绝)\n * PromiseResult : 响应数据\n\n案例1 : (检测图片有效)\n\nconst imageUrl = '';\n\nconst imgPromise = (url) => {\n    return new Promise( (resolve, reject) => {\n        const img = new Image();\n        img.src = url;\n        // 加载成功\n        img.onload = () => {\n            resolve(img);\n        }\n        img.onerror = () => {\n            reject(new Error('图片有误'));\n        }\n    } );\n};\n\nimgPromise(imageUrl)\n\t.then( img => {\n    \tconsole.log('success : ',img)\n\t})\n\t.catch(err => {\n    \tconsole.log('error: ',err)\n\t})\n\n\n案例2 : (随机数判断)\n\nnew Promise((resolve, reject) => {\n  setTimeout(() => {\n      let num = Math.floor(Math.random() * 11);//0-10的随机数\n  \t  if (num >= 5) {\n  \t    resolve(num);\n  \t  } else {\n  \t    reject(num);\n  \t  }\n  \t},1000)\n}).then(res => {\n  console.log(\"执行了成功时的回调 , 数值为：\"+ res);\n}).catch(err => {\n  console.log(\"执行了失败时的回调 , 数值为：\"+ err);\n})\n\n\n\n# Promise方法\n\n# Promise.all()\n\nall()方法 用于处理多个异步任务 , 所有执行完后才调用then\n\nlet p1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('结果1');\n  }, 1000);\n})\nlet p2 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('结果2');\n  }, 2000);\n})\n\n//Promise.all([])接收多个异步任务 , 放入数组中\nPromise.all([p1, p2]).then(results => {//results接收多个参数 , 所以是数组\n  console.log(results);//[\"结果1\", \"结果2\"]\n})\n\n\n# Promise.race()\n\nrace()方法 当中的任务谁先完成就执行谁\n\nlet p1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('结果1');\n  }, 1000);\n})\nlet p2 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('结果2');\n  }, 2000);\n})\n//Promise.race([])中接收多个异步任务 , 放入数组中\nPromise.race([p1, p2]).then(result => { //p1和p2 公用同一result , 谁先完成接收谁\n  console.log(result);\n})\n\n\n\n# Promise手写\n\n学习来源 : 点击跳转\n\nclass Commitment {\n    // 状态\n    static PENDING = '待定';\n    static FULFILLED = '成功';\n    static REJECTED = '拒绝';\n    // 构造方法\n    constructor(func) {\n        this.status = Commitment.PENDING;\n        this.result = null;\n        // 保存函数\n        this.resolveCallbacks = [];\n        this.rejectCallbacks = [];\n        // 传入异常对象进行操作\n        try {\n            func(this.resolve.bind(this), this.reject.bind(this));\n        } catch (err) {\n            this.reject(err);\n        }\n\n    }\n    // 失败\n    resolve(res) {\n        // 事件后执行\n        setTimeout(() => {\n            if (this.status === Commitment.PENDING) {\n                this.status = Commitment.FULFILLED;\n                this.result = res;\n                this.resolveCallbacks.forEach(call => {\n                    call(res)\n                });\n            }\n        });\n    }\n    // 成功\n    reject(res) {\n        // 事件后执行\n        setTimeout(() => {\n            if (this.status === Commitment.PENDING) {\n                this.status = Commitment.REJECTED;\n                this.result = res;\n                this.rejectCallbacks.forEach(call => {\n                    call(res)\n                });\n            }\n        });\n    }\n    then(onFULFILLED, onREJECTED) {\n        return new Commitment((resolve, reject) => {\n            // 不是函数则传递空函数\n            onFULFILLED = typeof onFULFILLED === 'function' ? onFULFILLED : () => { };\n            onREJECTED = typeof onREJECTED === 'function' ? onREJECTED : () => { };\n            // 如果外部也使用了异步 , 很有可能还是 待定状态\n            if (this.status === Commitment.PENDING) {\n                this.resolveCallbacks.push(onFULFILLED);\n                this.rejectCallbacks.push(onREJECTED);\n            }\n            if (this.status === Commitment.FULLFILLED) {\n                // 异步处理\n                setTimeout(() => {\n                    onFULFILLED(this.result);\n                })\n            }\n            if (this.status === Commitment.REJECTED) {\n                // 异步处理\n                setTimeout(() => {\n                    onREJECTED(this.result);\n                });\n            }\n        });\n    }\n}\n\n// 测试实例\nconsole.log('No.1');\nlet commitment = new Commitment((resolve, reject) => {\n    console.log('No.2');\n    setTimeout(() => {\n        reject('这次一定');\n        console.log('No.4');\n    });\n});\ncommitment.then(\n    res => { console.log(res) },\n    err => { console.log(err) }\n)\nconsole.log('No.3');\n\n\n测试步骤说明 : (按照No.x步骤说明)\n\n 1. (待定) new实例\n 2. (待定) 异步操作 , 执行 then() , 由于是待定状态进行 数组保存函数(resolve/reject)\n 3. (成功) 执行 reject() 里面还有一个异步处理(外部先执行了)\n 4. (成功) 执行外部异步 , 最后和 reject() 共同跑完\n\n\n# Generator\n\nGenerator函数 是ES6 的一种异步机制 . 可理解为状态机 (封装有多种状态)\n\n示例 :\n\nfunction *gen(){\n\tconsole.log(11)\n\tlet res1 = yield\n    console.log(`11接收到${res1}`)\n\tconsole.log(22)\n\tyield '33'\n\tconsole.log(33)\n}\n\nlet g = gen()\nlet res1 = g.next()\nlet res2 = g.next('11')\nlet res3 = g.next()\nconsole.log(res1,res2,res3) \n/**\n11\n11接收到11\n22\n33\n{ value: undefined, done: false } { value: '33', done: false } { value: undefined, done: true }\n */\n\n\n注意 :\n\n * 第一个传入参数是无意义\n * Generator作为理解 , 目前流行 Promise语法糖\n\n\n# Class\n\nJavaScript类的概念应用 和Java类似\n\n示例 :\n\nclass Person{\n    // 构造函数\n    constructor(name, age){\n        this.name = name\n        this.age = age\n    }\n    \n    say(){\n        console.log(this.name, this.age)\n    }\n}\n\nlet person = new Person('sans',22);\nperson.say();\n\n\n注意 :\n\n * 属性名也支持 属性名表达式用法 示例跳转\n * 属性和方法可以进行 state静态修饰\n * class可以 使用 extends 进行继承\n\n\n# Modlule\n\nJavaScript一直以来没有过模块化体系 , ES6为此增强了 , 提供了 Modlule模块化开发\n\nES6模块化重点解决了以下问题 :\n\n * 异步加载 (节点加载问题)\n * 私密不漏 (外部访问问题)\n * 重名不怕 (函数重名问题)\n * 依赖不乱 (循序调用问题)\n\nModlule模块化 功能由 export , import 关键字组成\n\n * export : 规定模块对外应用的接口 (俗称 暴露/导出)\n * import : 提取其他模块提供的接口 (俗称 引用/导入)\n\n模块引用 (已模块化形式进行加载)\n\n// 异步加载 (节点加载前 , 可直接访问节点)\n<script src=\"..\" type=\"module\"><\/script>\n\n\n> 如果其他模块访问也必须写上该属性 ==type=\"module\"==\n\n模块访问\n\nES6 采用 导入/导出 (引用/暴露) 的形式进行外部引用\n\n// 模块 1 (导出\nfunction A1(){\n    console.log(\"访问A1\");\n}\nexport default A1\n\n// 模块 2 (导入\nimport A1 from './1.js'\nA1();\n\n\n导入/导出 多个 写法\n\n写法1\n\nfunction A1(){...}\nfunction A2(){...}\nexport default { A1, A2 } // 看做一个对象\n\nimport obj\n\n\n写法2\n\nfunction test(){...}\nexport function A1(){...}\nexport function A2(){...}\nexport default test\n\nimport textA,{A1,A2} from './1.js'\n\n\n写法3 (常用)\n\nexport function A1(){}\nexport function A2(){}\nexport function A3(){}\n\n// 模块2 按需导入\nimport {A1} from './1.js'\n// 模块2 所有导入\nimport {* as mod1} from './1.js'\n\n\n> 注意 :\n> \n>  * 模块导入可能有多个 函数/属性/..\n>  * 模块不导出就没法进行通信\n>  * 多模块 导入所引用的名称不能重复发名称\n>  * 多模块 假如出现重名问题 可以进行 进行重新命名 重名写法 : ==import test as testA1==\n>  * 模块导入时 , 导入所有引用 可以直接用 * 替代 但必须重新命名\n>  * 隔离性好 , 那个导入那个用 , 跨出范围不能用 (模块范围)\n>  * 多模块 引用时他们名称必须一致 , 否则不行\n>  * 模块导出时 采用了 default关键字 , 在导入时需要 自定义起名 , 且无需写大括号引用\n\n\n# 动态导入\n\n标准用法是静态的 , 会直接使所有模块进行导入 . ES11 新增了按需导入 模块\n\n定义模块加载 :\n\nasync funtion test(){\n    let res;\n    if(true){\n    \tres = await import(\"./1.js\")\n\t}else{\n    \tres = await import(\"./2.js\")\n\t}\n\tconsole.log(res)\n}\n\n\n获取模块路径\n\n通过 ==import.meta== 进行获取模块的路径\n\n\n# 异步遍历器\n\n==for await==异步遍历器 , 需要异步生成器使用\n\nfunction timer(t){\n\treturn new Promise(resolve=>{\n        setTimeout(()=>{\n            resolve(\"data-\"+t)\n        }, t)\n    })\n}\n\n// 异步生成器\nasync function *gen(){\n    // 请求异步任务\n    yield timer(1000)\n    yield timer(2000)\n    yield timer(3000)\n}\n\nasync function test(){\n    let g = gen();\n    let list = [g.next(), g.next(), g.next()]\n    \n    for await(let i of list){\n        console.log(\"op :>>\",Date.now())\n        console.log(i)\n        console.log(\"ed :>>\",Date.now())\n    }\n}\n\n\n\n# WeakRefs\n\nWeakRef 集合对象允许保留对原对象的弱引用 , 而不会阻止被弱引用对象被 GC 回收\n\n> 一般情况 采用 Set , Map 存数据时 , 传入的原始数据如果赋值 null / undefined / 丢失 等情况 , 集合中的数据是不会丢失的 , 因此采用 WeakRefs集合对象\n\nWeakRef 延伸的集合对象 : (可点击跳转)\n\n * WeakSet\n * WeakMap\n\n示例 : (Map执行和Set差不多)\n\nlet obj = {\n    name : 'Sans'\n}\n \nlet s = new WeakSet();\n\ns.add(obj)\nobj = null\n// 执行后访问 s 为空\n\n\nDOM节点对象\n\n即使丢失了还会存在\n\n<body>\n    <button id=\"like\">按钮</button>\n</body>\n<script type=\"text/JavaScript\"> let like = document.getElementById(\"like\");\n    let map = new WeakMap();\n    // 因为不能穿简单类型\n    map.set(like, {click: 0});\n    \n    like.onclick = function(){\n        let buttom = map.get(like);\n        buttom.click++;\n        console.log(buttom.click);\n    }\n\n    setTimeout(function() {\n        document.body.removeChild(like)\n    }, 3000);\n    \n    // 即使DOM节点被删除了 , 但在后面map访问时 like依旧存在\n<\/script>\n\n\n**解决方案 : ** DOM节点对象使用 WeakRef进行封装 , deref()能够提取 原始DOM节点\n\n<body>\n    <button id=\"like\">按钮</button>\n</body>\n<script type=\"text/JavaScript\"> \n    let like = new WeakRef(document.getElementById(\"like\"));\n    let wmap = new WeakMap();\n    // like.deref() 等同于 document.getElementById(\"like\")\n    wmap.set(like.deref(), {click: 0});\n    \n    like.deref().onclick = function(){\n        let buttom = wmap.get(like.deref());\n        buttom.click++;\n        console.log(buttom.click);\n    }\n\n    setTimeout(function() {\n        document.body.removeChild(like.deref())\n    }, 2000);\n<\/script>\n\n\n> 注意 :\n> \n>  * 只能存储复杂类型 对象 / 函数 / 数组 , 基本类型不能\n>  * 不存在引用计数 +1 (原数据指向丢失集合则丢失)\n>  * 不能使用for循环\n>  * DOM节点对象引用 , 即使body消失了 , 集合是不会消失的 , 除非把该DOM节点对象设为null 除非该对象获取到的是 原始DOM节点!\n\n\n# 异常捕获\n\n和Java差不多 , 捕获回调的数据只能传递 包含cause属性的对象\n\nfunction getData(){\n    try{\n        let i = 1/0; // 异常\n    }catch{\n        throw new Error(\"说明不符合规则\",{cause:'有问题'})\n    }\n}\n\ntry{\n    getData()\n}catch(err){\n    console.log(err, err.cause)\n}\n",normalizedContent:"# es6\n\nes6 是 javascript 语言的标准 , 可以编写些复杂的大型项目 (企业级)\n\n教程网站 : 点击跳转\n\n\n# 变量\n\n\n# 作用域\n\n如果变量定义在 花括号{} 内 , 那么该 变量的作用范围也就仅限于 花括号{}内 (let定义)\n\nif(true){\n    let i = 10;\n}\n// 无法打印\nconsole.log(i);\n\n\n> 如果变量采用 var 导致为全局变量\n\nvar与let区别\n\n              var           let\n重复声明          允许(旧覆盖新)      不允许\n作用范围          全局范围          仅限花括号内\n声明提前(声明前调用)   允许(但不会显示数据)   不允许\n\n\n# 空值运算符\n\n空值合并运算符 ?? (和 || , && 用法一样) , 当左侧变量为 null/undefined 时 , 返回右侧变量 , 否则返回左侧\n\n示例 : (可通过以下代码区分 || 和 ?? 区别)\n\nconsole.log(undefined || \"sans\") // sans\nconsole.log(undefined ?? \"sans\") // sans\nconsole.log(nan || \"sans\") // sans\nconsole.log(nan ?? \"sans\") // nan\nconsole.log(null || \"sans\") // sans\nconsole.log(null ?? \"sans\") // sans\nconsole.log(0 || \"sans\") // sans\nconsole.log(0 ?? \"sans\") // 0\n\n\n\n# 逻辑赋值操作符\n\n逻辑赋值操作符 ??= , &&= , ||= , 可在判断的时候进行赋值\n\nlet a = true;\nlet b = false;\na ||= b // a = a || b; (true)\na &&= b // a = a && b; (false)\nlet obj = {name:'sans'}\nobj.age ??= 22\nconsoel.log(obj.age) // 22\n\n\n\n# 字符串拓展\n\n\n# 字符串方法\n\n对象方法示例 : 点击跳转\n\n方法                                       说明\nstr.padstart(number, string)             在开头填充指定字符直到number的长度\nstr.padend(number, string)               在末尾填充指定字符直到number的长度\nstr.trimstart()                          清除开头的所有空格符\nstr.trimend()                            清除结尾的所有空白符\nstr.replace(reg , targetstr)             按正则替换为targetstr\nstr.replaceall(replacestr , targetstr)   将所有replacestr替换为targetstr\n\n\n# 模板字符串\n\n教程 : 点击跳转\n\n以往在拼接 h5标签时 , 是通过 \"\"/' 引号的 , 如果添加了换行和变量 , 那么会显得很难阅读 .\n\n模板字符串正式解决了这一痛点\n\nlet name = 'sans';\n// 引号拼接\nlet node = \"<span>\\\n\t<b>\" + name + \"</b>\\\n\t</span>\";\n\n// 模板字符串 (支持表达式)\nlet node2 = `<span>\n\t\t<b>${name}</b>\n\t</span>`;\n\nlet node3 = `<span>\n\t\t<b>${name===''?'名称不存在':name}</b>\n\t</span>`;\n\n// 原型 <span><b>sans</b></span>\n\n\n\n# 数组拓展\n\n拓展运算符 用法展示 :\n\nlet arr = [1,2,3];\n\n// 复制\nlet arr2 = [...arr];\n\n// 提取\nlet {a,..b} = arr;\nconsole.log(a,b) // 1 [2,3]\n\n\n\narray.from()\n\narguments可以在形参中获取没有实参中的内容 , 但获取到的数据并非是数组形式 , 需要借助 ==array.from()== 能够将 类数组结构 转换为 数组\n\nfunction test(){\n    console.log(array.from(arguments))\n}\ntest(1,2,3,4)\n\n\narray.flat()\n\n数组扁平化 . 进行将递归层级的数组进行降维\n\n// 案例1\nlet arr = [\n    ['北京','上海','广州'],\n    ['南京','厦门','南宁']\n]\nconsole.log(arr.flat()); // ['北京','上海','广州','南京','厦门','南宁']\n\n// 案例2\nlet arr2 = [{\n        name: \"a\",\n        list: ['北京','上海','广州']\n    },{\n        name: \"b\",\n        list: ['南京','厦门','南宁']\n    }];\nlet res = arr2.flatmap(item => {\n    return item.list;\n})\nconsole.log(res); // ['北京','上海','广州','南京','厦门','南宁']\n\n\nat()\n\n拿取指定索引数据 , 负数则为倒数元素进行索引 , 字符串也可以行\n\nlet arr = ['no1','no2','no3','no4']\nconsole.log(arr.at(0)) // arr[0] (no1)\nconsole.log(arr.at(-1)) // arr[arr.length-1] (no4)\n\n\n\n# 数组复制\n\n以下数组复制 , 只是复制了指针 , 并非开辟内存空间\n\nconst a1 = [1, 2];\nconst a2 = a1;\n\na2[0] = 2;\na1 // [2, 2]\n\n\n以下代码 , 复制形式 开辟了内存空间\n\nconst a1 = [1, 2];\nconst a2 = a1.concat();\nconst a3 = [...a1]\n\na2[0] = 2;\na1 // [1, 2]\n\n\n\n# 正则拓展\n\n教程 : 点击跳转\n\n\n# 正则方法\n\n方法                  说明\nstr.match()         获取 正则匹配值 的数组 (全局匹配末尾加g)\nstr.matchall(reg)   获取 正则匹配值 的数组\nstr.replace()       获取 正则匹配值替换预期值 的新字符串\nstr.search()        获取 正则匹配的首个索引 , 不存在 -1\nstr.test()          是否有 正则匹配值\nstr.exec(str)       获取 正则匹配值 的数组 (详细\n\n// es6 新特性 exec()\nlet str = \"今天是2022-11-11\";\n// exec()\nconsole.log(/[0-9]{4}-[0-9]{2}-[0-9]{2}/.exec(str)) // ['2022-11-11', index: 3, input: '今天是2022-11-11', groups: undefined]\nconsole.log(/([0-9]{4})-([0-9]{2})-([0-9]{2})/.exec(str)) // ['2022-11-11', '2022', '11', '11', index: 3, input: '今天是2022-11-11', groups: undefined]\nconsole.log(/(?<year>[0-9]{4})-(?<month>[0-9]{2})-(?<day>[0-9]{2})/.exec(str)) // ['2022-11-11', '2022', '11', '11', index: 3, input: '今天是2022-11-11', groups: {day: '11',month: '11',year: '2022'}]\n\n\n// es6 新特性 matchall()\nlet str = `\n<ul>\n\t<li>111</li>\n\t<li>222</li>\n\t<li>333</li>\n\t<li>444</li>\n</ul>\n`;\n\nlet reg = /<li>(?<content>.*)<\\/li>/g;\nfor(let item of str.matchall(reg)){\n    console.log(item.groups.content)\n}\n/*\n111\n222\n333\n444\n*/\n\n\n\n# 对象拓展\n\n\n# 对象简写\n\nconst foo = 'bar';\nconst baz = {\n    foo,\n    name: 'sans',\n    test(){...}\n};\n\n\n\n# 属性名表达式\n\n可以通过变量进行定义变量名\n\nlet name = 'sans'\nlet obj = {\n    [name]: 'zs'\n}\nconsole.log(obj); // {sans: 'zs'}\n\n\n\n# 拓展运算符\n\n可以跟数组一样 使用 ... 进行操作\n\nlet obj1 = {name: 'zs'};\nlet obj2 = {age: 12};\nconsole.log({...obj1, ...obj2});\n\n// 等同于 \n// {}空对象 是将 obj1和obj2分别合并到新的空对象\nconsole.log(object.assign({}, obj1, obj2));\n\n\n\n# 可选链操作符\n\n可选链操作符 ? , 作用是 判断操作符前面的变量是否为 null/undefined , 如果是 则不会进行往后的链式调用\n\nlet obj1 = {\n    name: 'sans',\n    location: {\n        city:'广东'\n    }\n}\nlet obj2 = {\n    name: 'sans'\n}\n\nconsole.log(obj1.location.city) // 广东\nconsole.log(obj2.location.city) // 报红\nconsole.log(obj2?.location?.city ?? '这人很懒,啥也没写') // undefined\n\n\n> 意图 : 尽可能避免没有意义的报红警告\n\n\n# 对象方法\n\n对象方法示例 : 点击跳转\n\n方法                                       说明\nobject.assign(targetobj, ...sourceobj)   克隆对象 ( 可拷贝多个对象至目标对象)\nobject.is(obj1, obj2)                    比较对象 (比 == , === 更为严谨)\nobject.keys(obj)                         获取 对象所有属性名 的数组\nobject.values(obj)                       获取 对象所有属性值 的数组\nobject.entries(obj)                      获取 对象所有 属性名和属性值 的二维数组\nobject.getownpropertydescriptors()       获取 获取所有属性描述信息\nobject.fromentries(arr)                  将 键值对的二维数组/map对象 转为对象 (逆操作)\n\nobject.fromentries()\n\n// 用法1\nlet arr = [['name','zs'],['age',22]];\nconsole.log(object.fromen tries(arr))\n// 用法2\nlet map = map();\nmap.set(\"name\",\"zs\");\nmap.set(\"age\",22);\nconsole.log(object.fromentries(map))\n// 用法3\nlet str = \"name=zs&age=22\"\nlet seatchparams = new urlsearchparams(str);\nconsole.log(object.fromentries(seatchparams))\n// 用法4\nlet obj = {\n    \"广东\": [\"广州\",\"佛山\",\"深圳\"],\n    \"广西\": [\"南宁\",\"贵港\"],\n    \"江苏\": [\"南京\"]\n}\nlet myarr = object.entries(obj)\nlet mynewarr = myarr.map(([key,value])=>{\n    []\n})\nconsole.log(object.fromentries(myarr))\n\n\n\n# 私有特征\n\nes13更新中的新功能 , 通过在 变量/方法 前面添加 # 代表私有 , 不过访问是需要调用内部方法进行访问\n\nclass people{\n    #obj = {}\n    \n    get(key){\n        return this.#obj[key]\n    }\n    set(key, value){\n        this.#obj[key] = value\n    }\n}\n\nlet store = new people();\nstore.set(\"name\",\"sans\");\nstore.set(\"age\",22);\n\n// console.log(store.#obj) 报红\nconsole.log(store)\n\n\n\n# 函数拓展\n\n\n# 装配参数\n\n函数可以定义可选默认值\n\n// url必选 , 其余可选\nfunction ajax(url, method=\"get\", async=true){....}\najax(\"/test\");\najax(\"/test\", 'post');\najax(\"/test\", 'post', false);\n\n\n\n# 剩余参数\n\n多个变量的时候可以采用 ...\n\nfunction test(...arr){\n    console.log(arr); //[1,2,3,4]\n}\ntest(1,2,3,4);\n\n\nlet obj {\n    code: 200,\n    data: \"zs\"\n}\nlet {name, ...others} = obj\n\n\n应用场景 ()\n\nfunction ajax(options){\n    const defaultoptions = {\n        methods: 'get',\n        async: true\n    }\n    options = {...defaultoptions, ...options}\n    ...\n}\najax({\n    url: '...'\n})\n\n\n\n# 函数name\n\n函数变量可以通过 name属性 进行获取 函数的名称\n\nfunction test(){....}\nconsole.log(test.name)\n\n\n\n# 箭头函数\n\n简写函数的作用\n\nlet test = function(e){...}\nlet test = (e)=>{...}\n\n\n简写情况 :\n\n * 参数只有一个的情况 ; 省略 方法括号 ()\n * 函数体只有一条语句的情况 ; 省略返回 return\n\n注意 :\n\n * 函数体只有一条语句的情况且是返回一个对象 , 必须在对象外的 {}花括号 加上 ()括号\n * 箭头函数没有this , this是访问父作用域 (箭头函数应用严紧)\n\n\n# symbol\n\nsymbol 是一种新的 原始数据类型 , 表示独一无二的值 !\n\n// 实例 symbol类型数据\nlet s = symbol();\nconsole.log(typeof s)\n\nlet s2 = symbol();\nconsole.log(s === s2) // false\n\n\nsymbol实例中可添加参数 作为标识 (方便理解) ==let s = symbol('name')==\n\n这一特性解决了 属性名的冲突 问题 , 示例 :\n\nlet obj = { name : 'sans' }\n\nlet name = symbol('name');\nobj[name] = 'zs';\n\nconsole.log(obj[name]) // zs\nconsole.log(obj.name) // sans\n\n\n> 主要意图是 该对象别人使用相同名称时 , 可防止冲突 , 因此 封装者 一般会采用这种方式\n\n规范用法\n\nlet keys = {\n\tname: symbol('name'),\n    age: symbol('age'),\n    test: symbol('test')\n}\nlet obj = {\n    [keys.name]: 'sans',\n    [keys.age]: 22,\n    [keys.test]() {\n        console.log('方法测试');\n    }\n}\nconsole.log(obj);\nobj[keys.test]();\n\n\n\n# 遍历symbol\n\nsymbol属性名 不能被 for...in/for...of 遍历 , 也不会被object.keys()/object.getownpropertynames()/json.stringify()返回\n\nobject.getownpropertysymbols() 获取指定对象的所有symbol属性名\n\nreflect.ownkeys() 获取指定对象的所有属性\n\nlet obj = {};\nlet a = symbol('a');\nlet b = symbol('b');\n\nobj.name = 'sans';\nobj[a] = 'hello';\nobj[b] = 'world';\n\nconst objectsymbols = object.getownpropertysymbols(obj);\nconst reflectsymbols = reflect.ownkeys(obj);\n\nconsole.log(objectsymbols) // [symbol(a), symbol(b)]\nconsole.log(reflectsymbols) // ['name', symbol(a), symbol(b)]\n\n// 遍历\nreflectsymbols.foreach(item =>{\n    console.log(item,'=>',obj[item])\n})\n\n\n注意 :\n\n * 不能进行运算\n * tostring()打印显示 实例本身\n * 隐式转换boolean\n * map不能遍历 symbol类型\n\n\n# iterator\n\n教程 : 点击跳转\n\niterator迭代器 是一种机制 , 为不同数据结构提供了统一的访问机制\n\nlet arr = ['zs','ls','ww'];\nlet i = arr[symbol.iterator]();\nconsole.log(i.next()); // {value: 'zs', done: false}\nconsole.log(i.next()); // {value: 'ls', done: false}\nconsole.log(i.next()); // {value: 'ww', done: false}\nconsole.log(i.next()); // {value: undefined, done: true}\n\n\n原生具备 iterator接口 的数据结构 :\n\n * array\n * set\n * map\n * string (每个字符的遍历)\n * arguments对象\n * nodelist对象\n\nes6规定 , iterator接口默认在数据结构的 symbol.iterator属性 (本身是个迭代器生成函数)\n\n> 数据结构如果具备有 symbol.iterator属性 那么可认为是 可遍历的\n\n对 object类型对象 封装 仅限访问\n\nlet list = symbol('list');\nlet obj = {\n    code: 200,\n    name: 'sans',\n    // 仅限访问list\n    [list]: ['zs','ls','ww'],\n\n    // 迭代器 访问\n    [symbol.iterator](){\n        let index = 0;\n        return {\n            // 迭代器包含有 next()\n            // 采用箭头函数原因 : this越过函数本身 , 引用对象\n            next: ()=>{\n                return{\n                    value: this[list][index++],\n                    done: index>=(this[list].length+1)?true:false\n                }\n            }\n        }\n    }\n}\n\n// 迭代器测试\nlet i = obj[symbol.iterator]();\nconsole.log(i.next()) // { value: 'zs', done: false }\nconsole.log(i.next()) // { value: 'ls', done: false }\nconsole.log(i.next()) // { value: 'ww', done: false }\nconsole.log(i.next()) // { value: undefined, done: true }\nconsole.log(i.next()) // { value: undefined, done: true }\n\n// for..of遍历\nfor(item of obj){\n    console.log(item) \n}\n\n\n\n# set\n\nset类似数组结构 , 但成员的值都是唯一的 , 没有重复的值\n\nlet set = new set([1,2,3,2,4,4,5,5]);\nconsole.log(s); // set(5) { 1, 2, 3, 4, 5 }\n// 转array\nlet arr = [...set];\nlet arr2 = array.from(set);\n\n\nset基本属性和方法\n\n * size : 获取set总数\n * set.prototype.add(value) : 添加值\n * set.prototype.delete(value) : 删除值\n * set.prototype.has(value) : 判断是否包含有\n * set.prototype.keys() : 获取键名 遍历器\n * set.prototype.values() : 获取值 遍历器\n * set.prototype.entries() : 获取键值对 遍历器\n * set.prototype.foreach() : 遍历每个成员\n\n数组手写去重\n\nlet set = [11,2,3,'sans',{name:'sans'},{name:'ww'},{name:'sans'},11,123123,undefined,nan,nan]\n\n// 方式1\nfunction uni(arr){\n\tlet res = new set();\n\treturn set.filter(item =>{\n\t\tlet id = json.stringify(item);\n\t\tconsole.log('id',id)\n\t\tif(res.has(id)){\n\t\t\treturn false;\n\t\t}else{\n\t\t\tres.add(id);\n\t\t\treturn true;\n\t\t}\n\t})\n}\nconsole.log(uni(set));\n\n//方式2\nfunction uni2(arr){\n    let res = new set();\n    arr.foreach(item => res.add(item));\n    return res;\n}\nconsole.log(uni2(set));\n\n//方式3\nfunction uni3(arr){\n    return [...new set(arr)];\n}\nconsole.log(uni3(set));\n\n\n\n# map\n\nmap类似对象结构 , 键值对的集合 , 但 键 可以是各种类型\n\nlet map = new map([\n    ['name','sans'],\n    ['age',22]\n])\n// 等同于\nlet map2 = new map();\nmap2.set('name','sans');\nmap2.set('age',22);\nconsole.log(map); // map(2) { 'name' => 'sans', 'age' => 22 }\nconsole.log(map2); // map(2) { 'name' => 'sans', 'age' => 22 }\n\n\nmap基本属性和方法 包含有 set应用的方法 点击跳转\n\n\n# proxy\n\nproxy代理 主要作用是 为对象设置个拦截 (监听) , 实时获取对象数据/设置对象数据 等操作\n\nlet obj = {};\nlet proxy = new proxy(obj,{\n    get(target, key){\n    \tconsole.log('get', target, key);\n        return target[key];\n    },\n\tset(target, key, value){\n\t\tconsole.log('set', target, key, value)\n\t\ttarget[key] = value;\n\t}\n})\n\nproxy.name='sans'\nconsole.log(proxy.name)\n\n\n其他类型的操作\n\nlet s = new set();\nlet proxy = new proxy(s,{\n    get(target, key){\n\t\tlet v = target[key];\n\t\t// 如果访问的是方法 , 修正this指向\n\t\tif(v instanceof function) return v.bind(target);\n        return v;\n    },\n\tset(target, key, value){\n\t\tconsole.log('set', target, key, value)\n\t}\n})\n\nproxy.add('sans')\nconsole.log(proxy) // set(1) { 'sans' }\n\n\nes5 旧版 , 弊端仅限于对象的属性使用\n\nlet obj = {};\n\n// 监听 obj对象的name属性 \nobject.defineproperty(obj, \"name\", {\n    get(){\n        console.log('get')\n    },\n    set(){\n        console.log('set')\n    }\n})\n\nobj.name = 'sans'\nconsole.log(obj.name)\n\n\n\n# promise\n\npromise是回调的升级版 , 在处理花费较长时间的任务时 , 使用 promise 可以进行异步处理 , 防止堵塞\n\n学习来源 : 点击跳转\n\n基本结构 :\n\n// 参数封装有一个执行器函数\nlet pro = new promise((resolve, reject)=>{\n\tif(true){\n        resolve('succee');\n    }else{\n        reject('fail')\n    }\n})\n\npro.then( res =>{\n    console.log('succee')\n}).catch( err =>{\n    console.log('fail')\n}).finally(()=>{\n\tsonsole.log(\"一定执行的\")\n})\n\n\n响应结构说明 :\n\n * prototype : 原型类型\n * promisestate : pending(等待) / fulfilled(完成) / rejected(拒绝)\n * promiseresult : 响应数据\n\n案例1 : (检测图片有效)\n\nconst imageurl = '';\n\nconst imgpromise = (url) => {\n    return new promise( (resolve, reject) => {\n        const img = new image();\n        img.src = url;\n        // 加载成功\n        img.onload = () => {\n            resolve(img);\n        }\n        img.onerror = () => {\n            reject(new error('图片有误'));\n        }\n    } );\n};\n\nimgpromise(imageurl)\n\t.then( img => {\n    \tconsole.log('success : ',img)\n\t})\n\t.catch(err => {\n    \tconsole.log('error: ',err)\n\t})\n\n\n案例2 : (随机数判断)\n\nnew promise((resolve, reject) => {\n  settimeout(() => {\n      let num = math.floor(math.random() * 11);//0-10的随机数\n  \t  if (num >= 5) {\n  \t    resolve(num);\n  \t  } else {\n  \t    reject(num);\n  \t  }\n  \t},1000)\n}).then(res => {\n  console.log(\"执行了成功时的回调 , 数值为：\"+ res);\n}).catch(err => {\n  console.log(\"执行了失败时的回调 , 数值为：\"+ err);\n})\n\n\n\n# promise方法\n\n# promise.all()\n\nall()方法 用于处理多个异步任务 , 所有执行完后才调用then\n\nlet p1 = new promise((resolve, reject) => {\n  settimeout(() => {\n    resolve('结果1');\n  }, 1000);\n})\nlet p2 = new promise((resolve, reject) => {\n  settimeout(() => {\n    resolve('结果2');\n  }, 2000);\n})\n\n//promise.all([])接收多个异步任务 , 放入数组中\npromise.all([p1, p2]).then(results => {//results接收多个参数 , 所以是数组\n  console.log(results);//[\"结果1\", \"结果2\"]\n})\n\n\n# promise.race()\n\nrace()方法 当中的任务谁先完成就执行谁\n\nlet p1 = new promise((resolve, reject) => {\n  settimeout(() => {\n    resolve('结果1');\n  }, 1000);\n})\nlet p2 = new promise((resolve, reject) => {\n  settimeout(() => {\n    resolve('结果2');\n  }, 2000);\n})\n//promise.race([])中接收多个异步任务 , 放入数组中\npromise.race([p1, p2]).then(result => { //p1和p2 公用同一result , 谁先完成接收谁\n  console.log(result);\n})\n\n\n\n# promise手写\n\n学习来源 : 点击跳转\n\nclass commitment {\n    // 状态\n    static pending = '待定';\n    static fulfilled = '成功';\n    static rejected = '拒绝';\n    // 构造方法\n    constructor(func) {\n        this.status = commitment.pending;\n        this.result = null;\n        // 保存函数\n        this.resolvecallbacks = [];\n        this.rejectcallbacks = [];\n        // 传入异常对象进行操作\n        try {\n            func(this.resolve.bind(this), this.reject.bind(this));\n        } catch (err) {\n            this.reject(err);\n        }\n\n    }\n    // 失败\n    resolve(res) {\n        // 事件后执行\n        settimeout(() => {\n            if (this.status === commitment.pending) {\n                this.status = commitment.fulfilled;\n                this.result = res;\n                this.resolvecallbacks.foreach(call => {\n                    call(res)\n                });\n            }\n        });\n    }\n    // 成功\n    reject(res) {\n        // 事件后执行\n        settimeout(() => {\n            if (this.status === commitment.pending) {\n                this.status = commitment.rejected;\n                this.result = res;\n                this.rejectcallbacks.foreach(call => {\n                    call(res)\n                });\n            }\n        });\n    }\n    then(onfulfilled, onrejected) {\n        return new commitment((resolve, reject) => {\n            // 不是函数则传递空函数\n            onfulfilled = typeof onfulfilled === 'function' ? onfulfilled : () => { };\n            onrejected = typeof onrejected === 'function' ? onrejected : () => { };\n            // 如果外部也使用了异步 , 很有可能还是 待定状态\n            if (this.status === commitment.pending) {\n                this.resolvecallbacks.push(onfulfilled);\n                this.rejectcallbacks.push(onrejected);\n            }\n            if (this.status === commitment.fullfilled) {\n                // 异步处理\n                settimeout(() => {\n                    onfulfilled(this.result);\n                })\n            }\n            if (this.status === commitment.rejected) {\n                // 异步处理\n                settimeout(() => {\n                    onrejected(this.result);\n                });\n            }\n        });\n    }\n}\n\n// 测试实例\nconsole.log('no.1');\nlet commitment = new commitment((resolve, reject) => {\n    console.log('no.2');\n    settimeout(() => {\n        reject('这次一定');\n        console.log('no.4');\n    });\n});\ncommitment.then(\n    res => { console.log(res) },\n    err => { console.log(err) }\n)\nconsole.log('no.3');\n\n\n测试步骤说明 : (按照no.x步骤说明)\n\n 1. (待定) new实例\n 2. (待定) 异步操作 , 执行 then() , 由于是待定状态进行 数组保存函数(resolve/reject)\n 3. (成功) 执行 reject() 里面还有一个异步处理(外部先执行了)\n 4. (成功) 执行外部异步 , 最后和 reject() 共同跑完\n\n\n# generator\n\ngenerator函数 是es6 的一种异步机制 . 可理解为状态机 (封装有多种状态)\n\n示例 :\n\nfunction *gen(){\n\tconsole.log(11)\n\tlet res1 = yield\n    console.log(`11接收到${res1}`)\n\tconsole.log(22)\n\tyield '33'\n\tconsole.log(33)\n}\n\nlet g = gen()\nlet res1 = g.next()\nlet res2 = g.next('11')\nlet res3 = g.next()\nconsole.log(res1,res2,res3) \n/**\n11\n11接收到11\n22\n33\n{ value: undefined, done: false } { value: '33', done: false } { value: undefined, done: true }\n */\n\n\n注意 :\n\n * 第一个传入参数是无意义\n * generator作为理解 , 目前流行 promise语法糖\n\n\n# class\n\njavascript类的概念应用 和java类似\n\n示例 :\n\nclass person{\n    // 构造函数\n    constructor(name, age){\n        this.name = name\n        this.age = age\n    }\n    \n    say(){\n        console.log(this.name, this.age)\n    }\n}\n\nlet person = new person('sans',22);\nperson.say();\n\n\n注意 :\n\n * 属性名也支持 属性名表达式用法 示例跳转\n * 属性和方法可以进行 state静态修饰\n * class可以 使用 extends 进行继承\n\n\n# modlule\n\njavascript一直以来没有过模块化体系 , es6为此增强了 , 提供了 modlule模块化开发\n\nes6模块化重点解决了以下问题 :\n\n * 异步加载 (节点加载问题)\n * 私密不漏 (外部访问问题)\n * 重名不怕 (函数重名问题)\n * 依赖不乱 (循序调用问题)\n\nmodlule模块化 功能由 export , import 关键字组成\n\n * export : 规定模块对外应用的接口 (俗称 暴露/导出)\n * import : 提取其他模块提供的接口 (俗称 引用/导入)\n\n模块引用 (已模块化形式进行加载)\n\n// 异步加载 (节点加载前 , 可直接访问节点)\n<script src=\"..\" type=\"module\"><\/script>\n\n\n> 如果其他模块访问也必须写上该属性 ==type=\"module\"==\n\n模块访问\n\nes6 采用 导入/导出 (引用/暴露) 的形式进行外部引用\n\n// 模块 1 (导出\nfunction a1(){\n    console.log(\"访问a1\");\n}\nexport default a1\n\n// 模块 2 (导入\nimport a1 from './1.js'\na1();\n\n\n导入/导出 多个 写法\n\n写法1\n\nfunction a1(){...}\nfunction a2(){...}\nexport default { a1, a2 } // 看做一个对象\n\nimport obj\n\n\n写法2\n\nfunction test(){...}\nexport function a1(){...}\nexport function a2(){...}\nexport default test\n\nimport texta,{a1,a2} from './1.js'\n\n\n写法3 (常用)\n\nexport function a1(){}\nexport function a2(){}\nexport function a3(){}\n\n// 模块2 按需导入\nimport {a1} from './1.js'\n// 模块2 所有导入\nimport {* as mod1} from './1.js'\n\n\n> 注意 :\n> \n>  * 模块导入可能有多个 函数/属性/..\n>  * 模块不导出就没法进行通信\n>  * 多模块 导入所引用的名称不能重复发名称\n>  * 多模块 假如出现重名问题 可以进行 进行重新命名 重名写法 : ==import test as testa1==\n>  * 模块导入时 , 导入所有引用 可以直接用 * 替代 但必须重新命名\n>  * 隔离性好 , 那个导入那个用 , 跨出范围不能用 (模块范围)\n>  * 多模块 引用时他们名称必须一致 , 否则不行\n>  * 模块导出时 采用了 default关键字 , 在导入时需要 自定义起名 , 且无需写大括号引用\n\n\n# 动态导入\n\n标准用法是静态的 , 会直接使所有模块进行导入 . es11 新增了按需导入 模块\n\n定义模块加载 :\n\nasync funtion test(){\n    let res;\n    if(true){\n    \tres = await import(\"./1.js\")\n\t}else{\n    \tres = await import(\"./2.js\")\n\t}\n\tconsole.log(res)\n}\n\n\n获取模块路径\n\n通过 ==import.meta== 进行获取模块的路径\n\n\n# 异步遍历器\n\n==for await==异步遍历器 , 需要异步生成器使用\n\nfunction timer(t){\n\treturn new promise(resolve=>{\n        settimeout(()=>{\n            resolve(\"data-\"+t)\n        }, t)\n    })\n}\n\n// 异步生成器\nasync function *gen(){\n    // 请求异步任务\n    yield timer(1000)\n    yield timer(2000)\n    yield timer(3000)\n}\n\nasync function test(){\n    let g = gen();\n    let list = [g.next(), g.next(), g.next()]\n    \n    for await(let i of list){\n        console.log(\"op :>>\",date.now())\n        console.log(i)\n        console.log(\"ed :>>\",date.now())\n    }\n}\n\n\n\n# weakrefs\n\nweakref 集合对象允许保留对原对象的弱引用 , 而不会阻止被弱引用对象被 gc 回收\n\n> 一般情况 采用 set , map 存数据时 , 传入的原始数据如果赋值 null / undefined / 丢失 等情况 , 集合中的数据是不会丢失的 , 因此采用 weakrefs集合对象\n\nweakref 延伸的集合对象 : (可点击跳转)\n\n * weakset\n * weakmap\n\n示例 : (map执行和set差不多)\n\nlet obj = {\n    name : 'sans'\n}\n \nlet s = new weakset();\n\ns.add(obj)\nobj = null\n// 执行后访问 s 为空\n\n\ndom节点对象\n\n即使丢失了还会存在\n\n<body>\n    <button id=\"like\">按钮</button>\n</body>\n<script type=\"text/javascript\"> let like = document.getelementbyid(\"like\");\n    let map = new weakmap();\n    // 因为不能穿简单类型\n    map.set(like, {click: 0});\n    \n    like.onclick = function(){\n        let buttom = map.get(like);\n        buttom.click++;\n        console.log(buttom.click);\n    }\n\n    settimeout(function() {\n        document.body.removechild(like)\n    }, 3000);\n    \n    // 即使dom节点被删除了 , 但在后面map访问时 like依旧存在\n<\/script>\n\n\n**解决方案 : ** dom节点对象使用 weakref进行封装 , deref()能够提取 原始dom节点\n\n<body>\n    <button id=\"like\">按钮</button>\n</body>\n<script type=\"text/javascript\"> \n    let like = new weakref(document.getelementbyid(\"like\"));\n    let wmap = new weakmap();\n    // like.deref() 等同于 document.getelementbyid(\"like\")\n    wmap.set(like.deref(), {click: 0});\n    \n    like.deref().onclick = function(){\n        let buttom = wmap.get(like.deref());\n        buttom.click++;\n        console.log(buttom.click);\n    }\n\n    settimeout(function() {\n        document.body.removechild(like.deref())\n    }, 2000);\n<\/script>\n\n\n> 注意 :\n> \n>  * 只能存储复杂类型 对象 / 函数 / 数组 , 基本类型不能\n>  * 不存在引用计数 +1 (原数据指向丢失集合则丢失)\n>  * 不能使用for循环\n>  * dom节点对象引用 , 即使body消失了 , 集合是不会消失的 , 除非把该dom节点对象设为null 除非该对象获取到的是 原始dom节点!\n\n\n# 异常捕获\n\n和java差不多 , 捕获回调的数据只能传递 包含cause属性的对象\n\nfunction getdata(){\n    try{\n        let i = 1/0; // 异常\n    }catch{\n        throw new error(\"说明不符合规则\",{cause:'有问题'})\n    }\n}\n\ntry{\n    getdata()\n}catch(err){\n    console.log(err, err.cause)\n}\n",charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"TypeScript",frontmatter:{title:"TypeScript",author:"柏竹",permalink:"/web/1hg7wc",date:"2020-02-18T00:00:00.000Z",categories:["前端"],tags:["TypeScript"]},regularPath:"/02.%E5%89%8D%E7%AB%AF/02.%E6%8A%80%E6%9C%AF%E6%8B%93%E5%B1%95/03.TypeScript.html",relativePath:"02.前端/02.技术拓展/03.TypeScript.md",key:"v-6d0cc81e",path:"/web/1hg7wc/",headers:[{level:2,title:"TS编译JS",slug:"ts编译js",normalizedTitle:"ts编译js",charIndex:185},{level:2,title:"变量声明",slug:"变量声明",normalizedTitle:"变量声明",charIndex:431},{level:2,title:"类对象",slug:"类对象",normalizedTitle:"类对象",charIndex:81},{level:3,title:"inerface接口",slug:"inerface接口",normalizedTitle:"inerface接口",charIndex:1515},{level:2,title:"接收API",slug:"接收api",normalizedTitle:"接收api",charIndex:1734}],headersStr:"TS编译JS 变量声明 类对象 inerface接口 接收API",content:"# TypeScript\n\nJavaScript能做的事 , TypeScript 也能做 ! TypeScript额外增加了类型 , 这一说法可以看做 Java类对象属性等信息 !\n\n语言           文件后缀\nJavaScript   .js\nTypeScript   .ts\n\n> 目前很多浏览器不支持 ts文件 , 可以通过 ts 编译成 js\n\n\n# TS编译JS\n\n 1. 全局安装TypeScirpt (npm安装) ==sudo npm i -g typescript==\n\n 2. 在项目根路径 TypeScirpt初始化 ==tsc --init==\n    \n    > 执行该命令后 , 跟路径会多了 tsconfig.json配置文件 , 入门只需关注 ==\"target\": \"es2016\"==键值对(es2016编译标准)\n\n 3. 编译转化指令 手动编译 : ==tsc== 自动编译 : ==tsc -w==\n\n\n# 变量声明\n\nTS使用的是 ==变量名: + 类型== 标注类型 , 可以避免 JS使用的 弱类型问题\n\n> 类型首字母是小写\n\n// javascript 类型\nlet dan = 'Sans';\n// typescript 类型\nlet dan:string = 'Sans';\n\n\n定义的类型可能为null 那么我们可以这样设置\n\nlet dan:date | null = new Date(); // 以防可能为null的问\n\n\n\n# 类对象\n\n一般用于接口的数据汇集和复用的情况\n\n// 接口\ninterface CatType{\n\t// 标注类型\n    id: string;\n    url: string;\n    height: string;\n    width: string;\n}\n\n// 类对象\nclass Cat implements CatType{\n    \n    // 标注类型\n    id: string;\n    url: string;\n    height: string;\n    width: string;\n    \n\t// 构造函数 \n    // 参数检查类型\n    constructor(id: string, url: string, height: number, width: number){\n        this.id = id;\n        this.url = url;\n        this.height = height;\n        this.width = width;\n    }\n    \n    // 方法\n    // 传递参数 data 类型为 CatType\n    // 返回类型 void\n    public static addData(data: CatType): void{\n    \tconst cat: Cat = new Cat(data.id, data.url, data.height, data.width);\n        console.log(cat.id);\n       \tconsole.log(cat.url);\n        // 类型转换\n        console.log(cat.height.toString());\n        console.log(cat.width.toString());\n    }\n    \n}\n\n\n> 定义/调用 任何东西都需要 标注类型/检查类型\n\n\n# inerface接口\n\n通常用于为对象进行类型定义 , 可以进行提前定义好他们的 属性名/属性类型\n\ninterface dan {\n\tone: number;\n    jian: string;\n    three: number;\n    lian: string;\n    test?: boolean;\n}\n\n\n> 实现接口的前提里面的键值对一定需要一直 , 否者报错 除非该接口的 属性名后面加问号 ? 代表 可选属性\n\n\n# 接收API\n\nfetch进行演示\n\n// 返回泛型对象(不确定类型)\nasync function getJSON<T>(url: string): Promise<T>{\n\tconst resp: Response = await fetch(url);\n    const json: Promise<T> = await resp.json();\n    return json;\n}\n/* 假如JSON数据为 : \n\t\n*/\n\n// 提取数据\nasync function getData(): Promise<T>{\n    try{\n        // 确定返回类型\n     \tconst json: CatType[] = await getJSON<CatType[]>(url);\n        const data: CatType = json[0];\n    }catch(err: Error | unknown){\n        let msg: string;\n        if(err instanceof Error){\n        \tmsg = err.message;\n        }else{\n        \tmsg = String(err);\n        }\n        console.log(msg);\n    }\n}\n",normalizedContent:"# typescript\n\njavascript能做的事 , typescript 也能做 ! typescript额外增加了类型 , 这一说法可以看做 java类对象属性等信息 !\n\n语言           文件后缀\njavascript   .js\ntypescript   .ts\n\n> 目前很多浏览器不支持 ts文件 , 可以通过 ts 编译成 js\n\n\n# ts编译js\n\n 1. 全局安装typescirpt (npm安装) ==sudo npm i -g typescript==\n\n 2. 在项目根路径 typescirpt初始化 ==tsc --init==\n    \n    > 执行该命令后 , 跟路径会多了 tsconfig.json配置文件 , 入门只需关注 ==\"target\": \"es2016\"==键值对(es2016编译标准)\n\n 3. 编译转化指令 手动编译 : ==tsc== 自动编译 : ==tsc -w==\n\n\n# 变量声明\n\nts使用的是 ==变量名: + 类型== 标注类型 , 可以避免 js使用的 弱类型问题\n\n> 类型首字母是小写\n\n// javascript 类型\nlet dan = 'sans';\n// typescript 类型\nlet dan:string = 'sans';\n\n\n定义的类型可能为null 那么我们可以这样设置\n\nlet dan:date | null = new date(); // 以防可能为null的问\n\n\n\n# 类对象\n\n一般用于接口的数据汇集和复用的情况\n\n// 接口\ninterface cattype{\n\t// 标注类型\n    id: string;\n    url: string;\n    height: string;\n    width: string;\n}\n\n// 类对象\nclass cat implements cattype{\n    \n    // 标注类型\n    id: string;\n    url: string;\n    height: string;\n    width: string;\n    \n\t// 构造函数 \n    // 参数检查类型\n    constructor(id: string, url: string, height: number, width: number){\n        this.id = id;\n        this.url = url;\n        this.height = height;\n        this.width = width;\n    }\n    \n    // 方法\n    // 传递参数 data 类型为 cattype\n    // 返回类型 void\n    public static adddata(data: cattype): void{\n    \tconst cat: cat = new cat(data.id, data.url, data.height, data.width);\n        console.log(cat.id);\n       \tconsole.log(cat.url);\n        // 类型转换\n        console.log(cat.height.tostring());\n        console.log(cat.width.tostring());\n    }\n    \n}\n\n\n> 定义/调用 任何东西都需要 标注类型/检查类型\n\n\n# inerface接口\n\n通常用于为对象进行类型定义 , 可以进行提前定义好他们的 属性名/属性类型\n\ninterface dan {\n\tone: number;\n    jian: string;\n    three: number;\n    lian: string;\n    test?: boolean;\n}\n\n\n> 实现接口的前提里面的键值对一定需要一直 , 否者报错 除非该接口的 属性名后面加问号 ? 代表 可选属性\n\n\n# 接收api\n\nfetch进行演示\n\n// 返回泛型对象(不确定类型)\nasync function getjson<t>(url: string): promise<t>{\n\tconst resp: response = await fetch(url);\n    const json: promise<t> = await resp.json();\n    return json;\n}\n/* 假如json数据为 : \n\t\n*/\n\n// 提取数据\nasync function getdata(): promise<t>{\n    try{\n        // 确定返回类型\n     \tconst json: cattype[] = await getjson<cattype[]>(url);\n        const data: cattype = json[0];\n    }catch(err: error | unknown){\n        let msg: string;\n        if(err instanceof error){\n        \tmsg = err.message;\n        }else{\n        \tmsg = string(err);\n        }\n        console.log(msg);\n    }\n}\n",charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Git",frontmatter:{title:"Git",author:"柏竹",permalink:"/web/1hg7sg",date:"2020-02-18T00:00:00.000Z",categories:["代码管理"],tags:["Git"]},regularPath:"/02.%E5%89%8D%E7%AB%AF/01.%E5%89%8D%E7%AB%AF%E5%BF%85%E5%A4%87/05.Git%E5%BA%94%E7%94%A8.html",relativePath:"02.前端/01.前端必备/05.Git应用.md",key:"v-7b6e642c",path:"/web/1hg7sg/",headers:[{level:2,title:"版本控制说明",slug:"版本控制说明",normalizedTitle:"版本控制说明",charIndex:10},{level:2,title:"版本控制系统",slug:"版本控制系统",normalizedTitle:"版本控制系统",charIndex:165},{level:3,title:"Git",slug:"git-2",normalizedTitle:"git",charIndex:2},{level:3,title:"SVN",slug:"svn",normalizedTitle:"svn",charIndex:240},{level:3,title:"Git与SVN区别",slug:"git与svn区别",normalizedTitle:"git与svn区别",charIndex:462},{level:2,title:"Git应用",slug:"git应用",normalizedTitle:"git应用",charIndex:600},{level:3,title:"Git工作流程",slug:"git工作流程",normalizedTitle:"git工作流程",charIndex:610},{level:3,title:"Git工作区域",slug:"git工作区域",normalizedTitle:"git工作区域",charIndex:624},{level:3,title:"Git操作命令",slug:"git操作命令",normalizedTitle:"git操作命令",charIndex:723},{level:3,title:"连接远程仓库",slug:"连接远程仓库",normalizedTitle:"连接远程仓库",charIndex:1850},{level:2,title:"IDEA Git应用",slug:"idea-git应用",normalizedTitle:"idea git应用",charIndex:2392},{level:2,title:"Git简介",slug:"git简介",normalizedTitle:"git简介",charIndex:2498},{level:3,title:"Git与SVN的区别",slug:"git与svn的区别",normalizedTitle:"git与svn的区别",charIndex:2673},{level:3,title:"配置用户名和邮箱",slug:"配置用户名和邮箱",normalizedTitle:"配置用户名和邮箱",charIndex:3266},{level:3,title:"配置https和ssh推送时保存用户名和密码",slug:"配置https和ssh推送时保存用户名和密码",normalizedTitle:"配置https和ssh推送时保存用户名和密码",charIndex:3625},{level:3,title:"推送到远程仓库正确流程",slug:"推送到远程仓库正确流程",normalizedTitle:"推送到远程仓库正确流程",charIndex:3835},{level:3,title:"一、新建本地仓库",slug:"一、新建本地仓库",normalizedTitle:"一、新建本地仓库",charIndex:4124},{level:3,title:"二、配置(全局和项目)",slug:"二、配置-全局和项目",normalizedTitle:"二、配置(全局和项目)",charIndex:4369},{level:3,title:"三、增加/删除文件",slug:"三、增加-删除文件",normalizedTitle:"三、增加/删除文件",charIndex:4630},{level:3,title:"四、代码提交",slug:"四、代码提交",normalizedTitle:"四、代码提交",charIndex:4975},{level:3,title:"五、分支",slug:"五、分支",normalizedTitle:"五、分支",charIndex:5331},{level:3,title:"六、标签",slug:"六、标签",normalizedTitle:"六、标签",charIndex:6006},{level:3,title:"七、查看信息",slug:"七、查看信息",normalizedTitle:"七、查看信息",charIndex:6353},{level:3,title:"八、远程同步",slug:"八、远程同步",normalizedTitle:"八、远程同步",charIndex:7321},{level:3,title:"九、撤销",slug:"九、撤销",normalizedTitle:"九、撤销",charIndex:7682},{level:3,title:"十、其他",slug:"十、其他",normalizedTitle:"十、其他",charIndex:8250}],headersStr:"版本控制说明 版本控制系统 Git SVN Git与SVN区别 Git应用 Git工作流程 Git工作区域 Git操作命令 连接远程仓库 IDEA Git应用 Git简介 Git与SVN的区别 配置用户名和邮箱 配置https和ssh推送时保存用户名和密码 推送到远程仓库正确流程 一、新建本地仓库 二、配置(全局和项目) 三、增加/删除文件 四、代码提交 五、分支 六、标签 七、查看信息 八、远程同步 九、撤销 十、其他",content:'# Git\n\n\n# 版本控制说明\n\n版本控制的目的 是实现在团队并行开发、提高开发效率的基础。其目的在于对软件开发进程中文件或 目录的发展过程提供有效的追踪手段，保证在需要时可回到旧的版本，避免文件的丢失、修改的丢失和 相互覆盖，通过对版本库的访问控制避免未经授权的访问和修改，达到有效保护企业软件资产和知识产 权的目的\n\n\n# 版本控制系统\n\n\n# Git\n\nGit是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理\n\n点击详细说明GIT\n\n\n# SVN\n\nSVN与CVS一样，是一个跨平台的软件，支持大多数常见的操作系统。作为一个开源的版本控制系统,Subversion 管理着随时间改变的数据。 这些数据放置在一个中央资料档案库中。 这个档案库很像一个普通的文件服务器, 不过它会记住每一次文件的变动。 这样你就可以把档案恢复到旧的版本, 或是浏 览文件的变动历史。Subversion 是一个通用的系统, 可用来管理任何类型的文件, 其中包括了程序源码。\n\n点击详细说明SVN\n\n\n# Git与SVN区别\n\n * Git 是分布式，SVN 不是\n * Git 把内容按元数据方式存储，而 SVN 是按文件\n * Git 分支和 SVN 的分支不同\n * Git 没有一个全局的版本号，而 SVN 有全局的版本号\n * Git 的内容完整性要优于 SVN\n\n\n# Git应用\n\n\n# Git工作流程\n\n\n\n\n# Git工作区域\n\n * 工作区： 电脑本地目录\n * 暂存区： 一般在 .git 目录下 index 文件中\n * **版本库：**工作区有个隐藏的目录 .git 是 Git 的版本库\n\n\n\n\n# Git操作命令\n\n常用命令                                           说明\ngit init                                       初始化仓库\ngit add <文件/目录 名>                              添加 文件/目录（*代表全部）\ngit status                                     查看缓存区中的文件状态\ngit clone <HTTPS/SSH 地址>                       克隆远程仓库\ngit commit -m \'<提交描述>\'                         缓存区中的文件进行上传仓库，并描述说明\n$ git commit [file1] [file2] ... -m \'<提交描述>\'   缓存区中的文件进行上传仓库，并描述说明\ngit rm <文件名>                                   删除文件\ngit rm -r <文件夹>                                删除文件夹\ngit rm -r --cached <文件/目录 名>                   删除缓存区中的文件\ngit pull                                       下载远程仓库并合并\ngit pull <远程主机名> <本地分支名>                       下载远程仓库并合并\ngit push                                       上传远程仓库并合并\ngit log                                        查看提交历史记录\ngit push <远程主机名> <本地分支名>                       上传远程仓库并合并\ngit remote -v                                  查看 支点/远程库 信息\n\n更多Git命令\n\n初始化信息\n\n命令                                      说明\ngit config --global user.name \'<用户名>\'   配置用户\ngit config --global user.email \'<邮箱>\'   配置邮箱\ngit config --list                       查看配置\n\n\n# 连接远程仓库\n\n以下步骤用的是 gitee仓库 应用\n\nSSH连接 SSH协议的Git服务，在使用SSH协议访问仓库仓库之前，需要先配置好账户/仓库的SSH公钥。优点：多人共同协作 PS：已有公钥的情况，直接在 步骤3 开始流程\n\n 1. 生成公钥 ，该 Users/<你的电脑用户名>/.ssh/ 目录不存在需要生成公钥，在终端执行以下代码，然后一路按回车，账号密码暂时不需要 $ ssh-keygen -t rsa -C "<填写邮箱>"\n 2. 打开 Users/<你的电脑用户名>/.ssh/id_rsa.pub 复制内容 到 gitee 上\n 3. gitee 进入 ，个人设置 -> 安全设置 -> SSH公钥 。或者 点击添加公钥\n 4. 填写信息，key值(标题) 自定义，将刚刚的内容粘贴到公钥里，添加即可\n 5. SSH连接，$ git remote add <连接对象名> <SSH地址> 进行连接\n 6. 测试连接 $ ssh -t git@gitee.com 连接验证是否连接成功\n 7. 提交方式：git pull <连接对象名> <本地分支名>\n\nHTTPS地址连接\n\ngit clone <HTTPS地址> 克隆即可 提交需要管理员审核！！！\n\n\n# IDEA Git应用\n\n直接上 连接步骤\n\n 1. 下载插件 gitee\n 2. 在设置里搜 Git ，添加Git路径\n 3. 在设置里搜 gitee ，添加用户\n\n首次本地项目上传\n\n首次仓库项目下载\n\n\n# Git简介\n\n * Git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。\n * Git是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。\n * Git与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。\n\n\n# Git与SVN的区别\n\nGit不仅仅是个版本控制系统，它也是个内容管理系统(CMS),工作管理系统等。 如果你是一个具有使用SVN背景的人，你需要做一定的思想转换，来适应Git提供的一些概念和特征。 Git 与 SVN 区别点：\n\n 1. Git是分布式的，SVN不是：这是Git和其它非分布式的版本控制系统，例如SVN，CVS等，最核心的区别。\n 2. Git把内容按元数据方式存储，而SVN是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。\n 3. Git分支和SVN的分支不同：分支在SVN中一点不特别，就是版本库中的另外的一个目录。\n 4. Git没有一个全局的版本号，而SVN有：目前为止这是跟SVN相比GIT缺少的最大的一个特征。\n 5. Git的内容完整性要优于SVN：Git的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。\n\n经常使用 Git ，但是很多命令还是记不住。一般来说，日常使用只要记住下图7个命令就可以了。但要熟练掌握，恐怕要记住40~60个命令，所以整理了一份常用Git命令清单。\n\n * Workspace：工作区\n * Index / Stage：暂存区\n * Repository：仓库区（或本地仓库）\n * Remote：远程仓库\n\n\n# 配置用户名和邮箱\n\n$ git --version  \n## 查看git的版本信息\n$ git config --global user.name  \n## 获取当前登录的用户\n$ git config --global user.email \n## 获取当前登录用户的邮箱\n\n\n登录git\n\n## 如果刚没有获取到用户配置，则只能拉取代码，不能修改  要是使用git，你要告诉git是谁在使用\n$ git config --global user.name \'userName\'   \n## 设置git账户，userName为你的git账号，\n$ git config --global user.email \'email\'\n## 获取Git配置信息，执行以下命令：\n$ git config –list\n\n\n\n# 配置https和ssh推送时保存用户名和密码\n\n## https提交保存用户名和密码\n$ git config --global credential.helper store\n## 生成公钥私钥，将公钥配置到GitHub，ssh提交就可以免输入用户名密码\n## 三次回车即可生成 ssh key\n$ ssh-keygen -t rsa\n## 查看已生成的公钥\n$ cat ~/.ssh/id_rsa.pub\n\n\n\n# 推送到远程仓库正确流程\n\n1. git init\n## 初始化仓库\n2. git add .(文件name)\n## 添加文件到本地仓库\n3. git commit -m "first commit"\n## 添加文件描述信息\n4. git remote add origin 远程仓库地址\n## 链接远程仓库，创建主分支\n5. git pull origin master --allow-unrelated-histories\n## 把本地仓库的变化连接到远程仓库主分支\n6. git push -u origin master\n## 把本地仓库的文件推送到远程仓库\n\n\n\n# 一、新建本地仓库\n\n## 创建一个文件夹\n$ mkdir GitRepositories   \n## 创建文件夹GitRepositories\n$ cd GitRepositories      \n## 切换到GitRepositories目录下\n## 在当前目录新建一个Git代码库\n$ git init\n## 新建一个目录，将其初始化为Git代码库\n$ git init [project-name]\n## 下载一个项目和它的整个代码历史\n$ git clone [url]\n\n\n\n# 二、配置(全局和项目)\n\n## Git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n## 显示当前的Git配置\n$ git config --list\n## 编辑Git配置文件\n$ git config -e [--global]\n## 设置提交代码时的用户信息\n$ git config [--global] user.name "[name]"\n$ git config [--global] user.email "[email address]"\n\n\n\n# 三、增加/删除文件\n\n## 添加指定文件到暂存区\n$ git add [file1][file2] ...\n## 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n## 添加当前目录的所有文件到暂存区\n$ git add .\n## 添加每个变化前，都会要求确认\n## 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n## 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n## 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n## 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n\n\n\n# 四、代码提交\n\n## 提交暂存区到仓库区\n$ git commit -m [message]\n## 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n## 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n## 提交时显示所有diff信息\n$ git commit -v\n## 使用一次新的commit，替代上一次提交\n## 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n## 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n\n\n\n# 五、分支\n\n## 列出所有本地分支\n$ git branch\n## 列出所有远程分支\n$ git branch -r\n## 列出所有本地分支和远程分支\n$ git branch -a\n## 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n## 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n## 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n## 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n## 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n## 切换到上一个分支\n$ git checkout -\n## 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n## 合并指定分支到当前分支\n$ git merge [branch]\n## 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n## 删除分支\n$ git branch -d [branch-name]\n## 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n\n\n\n# 六、标签\n\n## 列出所有tag\n$ git tag\n## 新建一个tag在当前commit\n$ git tag [tag]\n## 新建一个tag在指定commit\n$ git tag [tag] [commit]\n## 删除本地tag\n$ git tag -d [tag]\n## 删除远程tag\n$ git push origin :refs/tags/[tagName]\n## 查看tag信息\n$ git show [tag]\n## 提交指定tag\n$ git push [remote] [tag]\n## 提交所有tag\n$ git push [remote] --tags\n## 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n\n\n\n# 七、查看信息\n\n## 查看目录\n$ ls -al\t或者$ ll\n## 查看仓库状态，显示有变更的文件\n$ git status\n## 显示当前分支的版本历史\n$ git log\n## 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n## 搜索提交历史，根据关键词\n$ git log -S [keyword]\n## 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] HEAD --pretty=format:%s\n## 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件\n$ git log [tag] HEAD --grep feature\n## 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n## 显示指定文件相关的每一次diff\n$ git log -p [file]\n## 显示过去5次提交\n$ git log -5 --pretty --oneline\n## 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n## 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n## 显示暂存区和工作区的差异\n$ git diff\n## 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n## 显示工作区与当前分支最新commit之间的差异\n$ git diff HEAD\n## 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n## 显示今天你写了多少行代码\n$ git diff --shortstat "@{0 day ago}"\n## 显示某次提交的元数据和内容变化\n$ git show [commit]\n## 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n## 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n## 显示当前分支的最近几次提交\n$ git reflog\n\n\n\n# 八、远程同步\n\n## 下载远程仓库的所有变动\n$ git fetch [remote]\n## 显示所有远程仓库\n$ git remote -v\n## 显示某个远程仓库的信息\n$ git remote show [remote]\n## 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n## 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n## 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n## 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n## 推送所有分支到远程仓库\n$ git push [remote] --all\n\n\n\n# 九、撤销\n\n## 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n## 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n## 恢复暂存区的所有文件到工作区\n$ git checkout .\n## 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n## 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n## 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n## 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n## 重置当前HEAD为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n## 新建一个commit，用来撤销指定commit\n## 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n## 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n\n\n\n# 十、其他\n\n## 从当前目录的所有文件中查找文本内容：\n$ git grep "Hello"\n## 在某一版本中搜索文本：\n$ git grep "Hello" v2.5\n## 生成一个可供发布的压缩包\n$ git archive\n',normalizedContent:'# git\n\n\n# 版本控制说明\n\n版本控制的目的 是实现在团队并行开发、提高开发效率的基础。其目的在于对软件开发进程中文件或 目录的发展过程提供有效的追踪手段，保证在需要时可回到旧的版本，避免文件的丢失、修改的丢失和 相互覆盖，通过对版本库的访问控制避免未经授权的访问和修改，达到有效保护企业软件资产和知识产 权的目的\n\n\n# 版本控制系统\n\n\n# git\n\ngit是一个开源的分布式版本控制系统，用以有效、高速的处理从很小到非常大的项目版本管理\n\n点击详细说明git\n\n\n# svn\n\nsvn与cvs一样，是一个跨平台的软件，支持大多数常见的操作系统。作为一个开源的版本控制系统,subversion 管理着随时间改变的数据。 这些数据放置在一个中央资料档案库中。 这个档案库很像一个普通的文件服务器, 不过它会记住每一次文件的变动。 这样你就可以把档案恢复到旧的版本, 或是浏 览文件的变动历史。subversion 是一个通用的系统, 可用来管理任何类型的文件, 其中包括了程序源码。\n\n点击详细说明svn\n\n\n# git与svn区别\n\n * git 是分布式，svn 不是\n * git 把内容按元数据方式存储，而 svn 是按文件\n * git 分支和 svn 的分支不同\n * git 没有一个全局的版本号，而 svn 有全局的版本号\n * git 的内容完整性要优于 svn\n\n\n# git应用\n\n\n# git工作流程\n\n\n\n\n# git工作区域\n\n * 工作区： 电脑本地目录\n * 暂存区： 一般在 .git 目录下 index 文件中\n * **版本库：**工作区有个隐藏的目录 .git 是 git 的版本库\n\n\n\n\n# git操作命令\n\n常用命令                                           说明\ngit init                                       初始化仓库\ngit add <文件/目录 名>                              添加 文件/目录（*代表全部）\ngit status                                     查看缓存区中的文件状态\ngit clone <https/ssh 地址>                       克隆远程仓库\ngit commit -m \'<提交描述>\'                         缓存区中的文件进行上传仓库，并描述说明\n$ git commit [file1] [file2] ... -m \'<提交描述>\'   缓存区中的文件进行上传仓库，并描述说明\ngit rm <文件名>                                   删除文件\ngit rm -r <文件夹>                                删除文件夹\ngit rm -r --cached <文件/目录 名>                   删除缓存区中的文件\ngit pull                                       下载远程仓库并合并\ngit pull <远程主机名> <本地分支名>                       下载远程仓库并合并\ngit push                                       上传远程仓库并合并\ngit log                                        查看提交历史记录\ngit push <远程主机名> <本地分支名>                       上传远程仓库并合并\ngit remote -v                                  查看 支点/远程库 信息\n\n更多git命令\n\n初始化信息\n\n命令                                      说明\ngit config --global user.name \'<用户名>\'   配置用户\ngit config --global user.email \'<邮箱>\'   配置邮箱\ngit config --list                       查看配置\n\n\n# 连接远程仓库\n\n以下步骤用的是 gitee仓库 应用\n\nssh连接 ssh协议的git服务，在使用ssh协议访问仓库仓库之前，需要先配置好账户/仓库的ssh公钥。优点：多人共同协作 ps：已有公钥的情况，直接在 步骤3 开始流程\n\n 1. 生成公钥 ，该 users/<你的电脑用户名>/.ssh/ 目录不存在需要生成公钥，在终端执行以下代码，然后一路按回车，账号密码暂时不需要 $ ssh-keygen -t rsa -c "<填写邮箱>"\n 2. 打开 users/<你的电脑用户名>/.ssh/id_rsa.pub 复制内容 到 gitee 上\n 3. gitee 进入 ，个人设置 -> 安全设置 -> ssh公钥 。或者 点击添加公钥\n 4. 填写信息，key值(标题) 自定义，将刚刚的内容粘贴到公钥里，添加即可\n 5. ssh连接，$ git remote add <连接对象名> <ssh地址> 进行连接\n 6. 测试连接 $ ssh -t git@gitee.com 连接验证是否连接成功\n 7. 提交方式：git pull <连接对象名> <本地分支名>\n\nhttps地址连接\n\ngit clone <https地址> 克隆即可 提交需要管理员审核！！！\n\n\n# idea git应用\n\n直接上 连接步骤\n\n 1. 下载插件 gitee\n 2. 在设置里搜 git ，添加git路径\n 3. 在设置里搜 gitee ，添加用户\n\n首次本地项目上传\n\n首次仓库项目下载\n\n\n# git简介\n\n * git是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。\n * git是 linus torvalds 为了帮助管理 linux 内核开发而开发的一个开放源码的版本控制软件。\n * git与常用的版本控制工具 cvs, subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。\n\n\n# git与svn的区别\n\ngit不仅仅是个版本控制系统，它也是个内容管理系统(cms),工作管理系统等。 如果你是一个具有使用svn背景的人，你需要做一定的思想转换，来适应git提供的一些概念和特征。 git 与 svn 区别点：\n\n 1. git是分布式的，svn不是：这是git和其它非分布式的版本控制系统，例如svn，cvs等，最核心的区别。\n 2. git把内容按元数据方式存储，而svn是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。\n 3. git分支和svn的分支不同：分支在svn中一点不特别，就是版本库中的另外的一个目录。\n 4. git没有一个全局的版本号，而svn有：目前为止这是跟svn相比git缺少的最大的一个特征。\n 5. git的内容完整性要优于svn：git的内容存储使用的是sha-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。\n\n经常使用 git ，但是很多命令还是记不住。一般来说，日常使用只要记住下图7个命令就可以了。但要熟练掌握，恐怕要记住40~60个命令，所以整理了一份常用git命令清单。\n\n * workspace：工作区\n * index / stage：暂存区\n * repository：仓库区（或本地仓库）\n * remote：远程仓库\n\n\n# 配置用户名和邮箱\n\n$ git --version  \n## 查看git的版本信息\n$ git config --global user.name  \n## 获取当前登录的用户\n$ git config --global user.email \n## 获取当前登录用户的邮箱\n\n\n登录git\n\n## 如果刚没有获取到用户配置，则只能拉取代码，不能修改  要是使用git，你要告诉git是谁在使用\n$ git config --global user.name \'username\'   \n## 设置git账户，username为你的git账号，\n$ git config --global user.email \'email\'\n## 获取git配置信息，执行以下命令：\n$ git config –list\n\n\n\n# 配置https和ssh推送时保存用户名和密码\n\n## https提交保存用户名和密码\n$ git config --global credential.helper store\n## 生成公钥私钥，将公钥配置到github，ssh提交就可以免输入用户名密码\n## 三次回车即可生成 ssh key\n$ ssh-keygen -t rsa\n## 查看已生成的公钥\n$ cat ~/.ssh/id_rsa.pub\n\n\n\n# 推送到远程仓库正确流程\n\n1. git init\n## 初始化仓库\n2. git add .(文件name)\n## 添加文件到本地仓库\n3. git commit -m "first commit"\n## 添加文件描述信息\n4. git remote add origin 远程仓库地址\n## 链接远程仓库，创建主分支\n5. git pull origin master --allow-unrelated-histories\n## 把本地仓库的变化连接到远程仓库主分支\n6. git push -u origin master\n## 把本地仓库的文件推送到远程仓库\n\n\n\n# 一、新建本地仓库\n\n## 创建一个文件夹\n$ mkdir gitrepositories   \n## 创建文件夹gitrepositories\n$ cd gitrepositories      \n## 切换到gitrepositories目录下\n## 在当前目录新建一个git代码库\n$ git init\n## 新建一个目录，将其初始化为git代码库\n$ git init [project-name]\n## 下载一个项目和它的整个代码历史\n$ git clone [url]\n\n\n\n# 二、配置(全局和项目)\n\n## git的设置文件为.gitconfig，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。\n## 显示当前的git配置\n$ git config --list\n## 编辑git配置文件\n$ git config -e [--global]\n## 设置提交代码时的用户信息\n$ git config [--global] user.name "[name]"\n$ git config [--global] user.email "[email address]"\n\n\n\n# 三、增加/删除文件\n\n## 添加指定文件到暂存区\n$ git add [file1][file2] ...\n## 添加指定目录到暂存区，包括子目录\n$ git add [dir]\n## 添加当前目录的所有文件到暂存区\n$ git add .\n## 添加每个变化前，都会要求确认\n## 对于同一个文件的多处变化，可以实现分次提交\n$ git add -p\n## 删除工作区文件，并且将这次删除放入暂存区\n$ git rm [file1] [file2] ...\n## 停止追踪指定文件，但该文件会保留在工作区\n$ git rm --cached [file]\n## 改名文件，并且将这个改名放入暂存区\n$ git mv [file-original] [file-renamed]\n\n\n\n# 四、代码提交\n\n## 提交暂存区到仓库区\n$ git commit -m [message]\n## 提交暂存区的指定文件到仓库区\n$ git commit [file1] [file2] ... -m [message]\n## 提交工作区自上次commit之后的变化，直接到仓库区\n$ git commit -a\n## 提交时显示所有diff信息\n$ git commit -v\n## 使用一次新的commit，替代上一次提交\n## 如果代码没有任何新变化，则用来改写上一次commit的提交信息\n$ git commit --amend -m [message]\n## 重做上一次commit，并包括指定文件的新变化\n$ git commit --amend [file1] [file2] ...\n\n\n\n# 五、分支\n\n## 列出所有本地分支\n$ git branch\n## 列出所有远程分支\n$ git branch -r\n## 列出所有本地分支和远程分支\n$ git branch -a\n## 新建一个分支，但依然停留在当前分支\n$ git branch [branch-name]\n## 新建一个分支，并切换到该分支\n$ git checkout -b [branch]\n## 新建一个分支，指向指定commit\n$ git branch [branch] [commit]\n## 新建一个分支，与指定的远程分支建立追踪关系\n$ git branch --track [branch] [remote-branch]\n## 切换到指定分支，并更新工作区\n$ git checkout [branch-name]\n## 切换到上一个分支\n$ git checkout -\n## 建立追踪关系，在现有分支与指定的远程分支之间\n$ git branch --set-upstream [branch] [remote-branch]\n## 合并指定分支到当前分支\n$ git merge [branch]\n## 选择一个commit，合并进当前分支\n$ git cherry-pick [commit]\n## 删除分支\n$ git branch -d [branch-name]\n## 删除远程分支\n$ git push origin --delete [branch-name]\n$ git branch -dr [remote/branch]\n\n\n\n# 六、标签\n\n## 列出所有tag\n$ git tag\n## 新建一个tag在当前commit\n$ git tag [tag]\n## 新建一个tag在指定commit\n$ git tag [tag] [commit]\n## 删除本地tag\n$ git tag -d [tag]\n## 删除远程tag\n$ git push origin :refs/tags/[tagname]\n## 查看tag信息\n$ git show [tag]\n## 提交指定tag\n$ git push [remote] [tag]\n## 提交所有tag\n$ git push [remote] --tags\n## 新建一个分支，指向某个tag\n$ git checkout -b [branch] [tag]\n\n\n\n# 七、查看信息\n\n## 查看目录\n$ ls -al\t或者$ ll\n## 查看仓库状态，显示有变更的文件\n$ git status\n## 显示当前分支的版本历史\n$ git log\n## 显示commit历史，以及每次commit发生变更的文件\n$ git log --stat\n## 搜索提交历史，根据关键词\n$ git log -s [keyword]\n## 显示某个commit之后的所有变动，每个commit占据一行\n$ git log [tag] head --pretty=format:%s\n## 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件\n$ git log [tag] head --grep feature\n## 显示某个文件的版本历史，包括文件改名\n$ git log --follow [file]\n$ git whatchanged [file]\n## 显示指定文件相关的每一次diff\n$ git log -p [file]\n## 显示过去5次提交\n$ git log -5 --pretty --oneline\n## 显示所有提交过的用户，按提交次数排序\n$ git shortlog -sn\n## 显示指定文件是什么人在什么时间修改过\n$ git blame [file]\n## 显示暂存区和工作区的差异\n$ git diff\n## 显示暂存区和上一个commit的差异\n$ git diff --cached [file]\n## 显示工作区与当前分支最新commit之间的差异\n$ git diff head\n## 显示两次提交之间的差异\n$ git diff [first-branch]...[second-branch]\n## 显示今天你写了多少行代码\n$ git diff --shortstat "@{0 day ago}"\n## 显示某次提交的元数据和内容变化\n$ git show [commit]\n## 显示某次提交发生变化的文件\n$ git show --name-only [commit]\n## 显示某次提交时，某个文件的内容\n$ git show [commit]:[filename]\n## 显示当前分支的最近几次提交\n$ git reflog\n\n\n\n# 八、远程同步\n\n## 下载远程仓库的所有变动\n$ git fetch [remote]\n## 显示所有远程仓库\n$ git remote -v\n## 显示某个远程仓库的信息\n$ git remote show [remote]\n## 增加一个新的远程仓库，并命名\n$ git remote add [shortname] [url]\n## 取回远程仓库的变化，并与本地分支合并\n$ git pull [remote] [branch]\n## 上传本地指定分支到远程仓库\n$ git push [remote] [branch]\n## 强行推送当前分支到远程仓库，即使有冲突\n$ git push [remote] --force\n## 推送所有分支到远程仓库\n$ git push [remote] --all\n\n\n\n# 九、撤销\n\n## 恢复暂存区的指定文件到工作区\n$ git checkout [file]\n## 恢复某个commit的指定文件到暂存区和工作区\n$ git checkout [commit] [file]\n## 恢复暂存区的所有文件到工作区\n$ git checkout .\n## 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变\n$ git reset [file]\n## 重置暂存区与工作区，与上一次commit保持一致\n$ git reset --hard\n## 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变\n$ git reset [commit]\n## 重置当前分支的head为指定commit，同时重置暂存区和工作区，与指定commit一致\n$ git reset --hard [commit]\n## 重置当前head为指定commit，但保持暂存区和工作区不变\n$ git reset --keep [commit]\n## 新建一个commit，用来撤销指定commit\n## 后者的所有变化都将被前者抵消，并且应用到当前分支\n$ git revert [commit]\n## 暂时将未提交的变化移除，稍后再移入\n$ git stash\n$ git stash pop\n\n\n\n# 十、其他\n\n## 从当前目录的所有文件中查找文本内容：\n$ git grep "hello"\n## 在某一版本中搜索文本：\n$ git grep "hello" v2.5\n## 生成一个可供发布的压缩包\n$ git archive\n',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"JQuery",frontmatter:{title:"JQuery",author:"柏竹",permalink:"/web/1hg7wv",date:"2020-02-18T00:00:00.000Z",categories:["前端"],tags:["JQuery"]},regularPath:"/02.%E5%89%8D%E7%AB%AF/02.%E6%8A%80%E6%9C%AF%E6%8B%93%E5%B1%95/02.JQuery.html",relativePath:"02.前端/02.技术拓展/02.JQuery.md",key:"v-13f835b1",path:"/web/1hg7wv/",headers:[{level:2,title:"快速入门",slug:"快速入门",normalizedTitle:"快速入门",charIndex:128},{level:3,title:"引用",slug:"引用",normalizedTitle:"引用",charIndex:137},{level:3,title:"语法",slug:"语法",normalizedTitle:"语法",charIndex:212},{level:3,title:"对象转化",slug:"对象转化",normalizedTitle:"对象转化",charIndex:346},{level:2,title:"JQuery选择器",slug:"jquery选择器",normalizedTitle:"jquery选择器",charIndex:422},{level:2,title:"JQuery HTML",slug:"jquery-html",normalizedTitle:"jquery html",charIndex:3807},{level:3,title:"HTML内容",slug:"html内容",normalizedTitle:"html内容",charIndex:3839},{level:3,title:"HMTL属性",slug:"hmtl属性",normalizedTitle:"hmtl属性",charIndex:4509},{level:3,title:"CSS样式",slug:"css样式",normalizedTitle:"css样式",charIndex:6844},{level:2,title:"JQuery事件",slug:"jquery事件",normalizedTitle:"jquery事件",charIndex:11384},{level:2,title:"JQuery效果",slug:"jquery效果",normalizedTitle:"jquery效果",charIndex:15538},{level:2,title:"JQuery文档",slug:"jquery文档",normalizedTitle:"jquery文档",charIndex:17534},{level:2,title:"JQuery 遍历",slug:"jquery-遍历",normalizedTitle:"jquery 遍历",charIndex:22116},{level:3,title:"for循环",slug:"for循环",normalizedTitle:"for循环",charIndex:22144},{level:3,title:"each()1 循环",slug:"each-1-循环",normalizedTitle:"each()1 循环",charIndex:22301},{level:3,title:"each()2 循环",slug:"each-2-循环",normalizedTitle:"each()2 循环",charIndex:22374},{level:3,title:"for of 循环",slug:"for-of-循环",normalizedTitle:"for of 循环",charIndex:22189},{level:3,title:"整体展示",slug:"整体展示",normalizedTitle:"整体展示",charIndex:22514},{level:2,title:"JQuery 插件",slug:"jquery-插件",normalizedTitle:"jquery 插件",charIndex:22889},{level:3,title:"扩展机制",slug:"扩展机制",normalizedTitle:"扩展机制",charIndex:22903},{level:3,title:"Validator表单验证插件",slug:"validator表单验证插件",normalizedTitle:"validator表单验证插件",charIndex:23387},{level:4,title:"自定义验证方法",slug:"自定义验证方法",normalizedTitle:"自定义验证方法",charIndex:24530}],headersStr:"快速入门 引用 语法 对象转化 JQuery选择器 JQuery HTML HTML内容 HMTL属性 CSS样式 JQuery事件 JQuery效果 JQuery文档 JQuery 遍历 for循环 each()1 循环 each()2 循环 for of 循环 整体展示 JQuery 插件 扩展机制 Validator表单验证插件 自定义验证方法",content:'# JQuery\n\njQuery 是个 JavaScript 库, 它简化了JavaScript编程! 封装了JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互。\n\n\n# 快速入门\n\n\n# 引用\n\n外部引用JavaScript脚本文件即可\n\n<head>\n\t<script src="..."><\/script>\n</head>\n\n\n\n# 语法\n\n以下语法的作用是在文档加载完再执行的JQ代码\n\n//No.1\n$(document).ready(function(){\n\t//jQuery 代码 ...\n});\n\n//No.2\n$(function(){\n\t//jQuery 代码 ...\n});\n\n\n\n# 对象转化\n\nDOM对象 转 JQ对象 ==$(<DOM对象>)==\n\n\n\n\nJQ对象 转 DMO对象 ==<JQ对象>.get(0)==\n\n\n\n\n\n# JQuery选择器\n\n$(THIS)                选取\n$("p")                 所有 <p> 元素\n$("p.intro")           所有 class="intro" 的 <p> 元素\n$(".intro")            所有 class="intro" 的元素\n$("#intro")            id="intro" 的\n$("ul li:first")       每个 <ul> 的第一个 <li> 元素\n$("[href$=\'.jpg\']")    所有带有以 ".jpg" 结尾的属性值的 href 属性\n$("div#intro .head")   id="intro" 的 <div> 元素中的所有 class="head" 的元素\n$("div , p")           所有 <div> <p> 元素\n$("form input")        所有 <form> 中的 <input> 元素\n$("form>input")        所有 <form> 中的 <input> 元素\n$("label+input")       所有 <label> 的下一个元素\n\n点击更多JQuery选择器\n\n<head>\n<script src="../js/jquery-1.11.1.js"><\/script>\n    <script>\n        function printList(list) {\n            for (var i = 0; i < list.length; i++) {\n                console.log(list[i]);\n            }\n        }\n        //引用JQ代码\n        $(function () {\n            allSelector();\n        });\n        //标签\n        function LabelSelector() {\n            //遍历结果是 HMTL节点 集合\n            var list = $("div");\n            printList(list);\n        }\n        //id\n        function idSelector() {\n            var list = $("#div4");\n            printList(list);\n        }\n        //class\n        function classSelector() {\n            var list = $(".div2");\n            printList(list);\n        }\n        //全局\n        function allSelector() {\n            var list = $("*");\n            printList(list);\n        }\n    <\/script>\n</head>\n<body>\n    <div>div1</div>\n    <div class="div2">div2</div>\n    <div>div3</div>\n    <div id="div4">div4</div>\n</body>\n\n\n<head>\n<script src="../js/jquery-1.11.1.js"><\/script>\n<script>\n    function printList(list) {\n        for (var i = 0; i < list.length; i++) {\n            console.log(list[i]);\n        }\n    }\n    //引用JQ代码\n    $(function () {\n        visibilitySelector();\n    });\n    //并集\n    function episodeSelector() {\n        var list = $("div,b");\n        printList(list);\n    }\n    //后代\n    function descendantSelector() {\n        var list = $("form label");\n        printList(list);\n    }\n    //子\n    function sonSelector() {\n        var list = $("form>.test");\n        printList(list);\n    }\n    //相邻\n    function adjacentSelector() {\n        var list = $("label+input");\n        printList(list);\n    }\n    //属性\n    function attributesSelector() {\n        // var list = $("input[name]");\n        // var list = $("p[class=\'test\']");\n        // var list = $("input[type=\'text\'][name=\'userss\']");\n        // var list = $("input[name^=\'user\']");\n        var list = $("input[name$=\'ss\']");\n        // var list = $("input[name*=\'ss\']");\n        printList(list);\n    }\n    //可见性\n    function visibilitySelector(){\n        var list = $("div:hidden");\n        // var list = $("div:visible");\n        printList(list);\n    }\n<\/script>\n</head>\n<body>\n    <form action="#">\n        <label for="userid">I D : </label>\n        <input type="text" name="userid">\n        <br>\n        <label for="userss">账号:</label>\n        <input type="text" name="userss">\n        <br>\n        <label for="password">密码:</label>\n        <input type="password" name="password">\n        <br>\n        <b>b1</b>\n        <b class="test">b2</b>\n        <div>\n            div1\n            <p class="test">p1</p>\n            <p>p2</p>\n        </div>\n        <div class="div2" style="display: none;" >div2</div>\n        <div class="test" style="visibility: hidden;" >div3</div>\n        <div id="div4">div4</div>\n    </form>\n</body>\n\n\n\n# JQuery HTML\n\n点击更多jQuery操作方法\n\n\n# HTML内容\n\n常用方法                          说明\n$(selector).text([content])   设置或返回 所选元素的文本内容\n$(selector).html([content])   设置或返回 所选元素的内容,包括 HTML 标签\n$(selector).val([content])    设置或返回 表单字段的值\n\n<head>\n<script src="../js/jquery-1.11.1.js"><\/script>\n<script>\n    $(function(){\n        var str = "Test!!";\n        var div = $("div");\n        console.log(div.html());    //div<button>按钮</button>\n        console.log(div.text());    //div按钮\n        console.log(div.val());     //null ,因非表单value值\n        console.log($("input").val());  //张三\n    });\n<\/script>\n</head>\n<body>\n    <div>\n        div\n        <button>按钮</button>\n    </div>\n    <input type="text" value="张三">\n</body>\n\n\n\n# HMTL属性\n\n常用方法                               说明\n$(selector).attr(<属性名> [,<属性值>])   返回/设置 属性值 (无参则返回值\n$(selector).prop(<选中属性>,<选中>)      判断是否选中\n$(selector).removeAttr()           元素移除指定属性\n\n<head>\n    <script src="../js/jquery-1.11.1.js"><\/script>\n    <script>\n        $(function () {\n            //指定第一个元素的div节点\n            var box = $("div:eq(0)");\n            var user = $("input[id=\'user\']");\n            var password = $("input[id=\'password\']");\n            var button = $(".buttonTest");\n\n            //编辑属性值    attr\n            //attr(属性) => 返回属性值\n            $("button:eq(0)").click(function () {\n                alert(user.attr("value"));\n            });\n            //attr(属性,属性值) => 更改属性值\n            $("button:eq(1)").click(function () {\n                user.attr("value", "Sanscan");\n            });\n            //attr(属性,函数(index,oldValue)) => 编辑属性值\n            $("button:eq(2)").click(function () {\n                //每次运行都会在 属性值追加\'S\'\n                user.attr("value", function (n, o) {\n                    alert("n = " + n + "o = " + o);\n                    return o + "S";\n                });\n            });\n            //获取单选 信息 prop\n            $("button:eq(3)").click(function () {\n                var list = $("input[name=\'sex\']");\n                var str;\n                for (var i = 0; i < list.length; i++) {\n                    alert( $(list[i]).attr("id") +" = " + $(list[i]).prop(\'checked\'));\n                }\n            });\n            //移除属性 removeAttr\n            $("button:eq(4)").click(function () {\n                password.removeAttr("value");\n            });\n\n        });\n    <\/script>\n</head>\n<body>\n    <div>\n        <form action="#">\n            <label for="user">name:</label>\n            <input type="text" id="user" name="user" value="洋葱小鱿"><br>\n            <label for="">password:</label>\n            <input type="password" id="password" name="password" value="*****"><br>\n            <label for="sex">sex:</label>\n            <input type="radio" name="sex" checked="checked" id="man">man\n            <input type="radio" name="sex" id="woman">woman\n        </form>\n    </div>\n    <div>\n        <button>获取名称值</button><br>\n        <button>更改属性值</button><br>\n        <button>追加属性值</button><br>\n        <button>获取单选按钮信息</button><br>\n        <button>移除密码value值</button><br>\n    </div>\n</body>\n\n\n\n# CSS样式\n\n点击更多CSS样式\n\n常用方法                        说明\n$(selector).css()           编辑属性\n$(selector).addClass()      元素添加类\n$(selector).removeClass()   匹配元素中删除全部 或 指定的 类\n$(selector).toggleClass()   元素中添加或删除类\n$(selector).hasClass()      检查元素是否拥有指定的类\n$(selector).width()         设置元素的宽度\n$(selector).height()        设置元素的高度\n\n<head>\n<script src="../js/jquery-1.11.1.js"><\/script>\n    <script>\n        $(function () {\n            //指定第一个元素的div节点\n            var box = $("div:eq(0)");\n            var user = $("input[id=\'user\']");\n            var password = $("input[id=\'password\']");\n            var button = $(".buttonTest");\n\n            //添加类 属性   addClass\n            $("button:eq(0)").click(function () {\n                box.addClass("box");\n            });\n            //删除类 属性   removeClass\n            $("button:eq(1)").click(function () {\n                box.removeClass("box");\n            });\n            //检查 类是否包含"box类"    hasClass\n            $("button:eq(2)").click(function () {\n                alert(box.hasClass("box"));\n            });\n            //按钮颜色  css\n            $("button:eq(3)").click(function () {\n                alert(button.css("background"))\n            });\n            //修改按钮颜色 css\n            $("button:eq(4)").click(function () {\n                button.css("background","darkseagreen");\n            });2\n            //修改盒子高度 height\n            $("button:eq(5)").click(function () {\n                box.height(200);\n            });\n            //修改盒子宽度  width\n            $("button:eq(6)").click(function () {\n                box.width(300);\n            });\n            //设置移除  toggleClass\n            $("button:eq(7)").click(function () {\n                button.toggleClass("buttonTest");\n            });\n        });\n<\/script>\n<style>\n        .box {\n            width: 200px;\n            padding-left: 24px;\n            background: chartreuse;\n        }\n        .buttonTest {\n            background: coral;\n            margin: 4px;\n        }\n    </style>\n</head>\n<body>\n    <div>\n        <form action="#">\n            <label for="user">name:</label>\n            <input type="text" id="user" name="user" value="洋葱小鱿"><br>\n            <label for="">password:</label>\n            <input type="password" id="password" name="password" value="*****"><br>\n            <label for="sex">sex:</label>\n            <input type="radio" name="sex" checked="checked">man\n            <input type="radio" name="sex">woman\n        </form>\n    </div>\n    <div>\n        <button class="buttonTest">添加盒子样式</button><br>\n        <button class="buttonTest">删除盒子样式</button><br>\n        <button class="buttonTest">检查盒子样式</button><br>\n        <button class="buttonTest">获取按钮颜色</button><br>\n        <button class="buttonTest">修改按钮颜色</button><br>\n        <button class="buttonTest">修改盒子高度</button><br>\n        <button class="buttonTest">修改盒子宽度</button><br>\n        <button class="buttonTest">移除/恢复 按钮样式</button><br>\n    </div>\n</body>\n\n\non事件绑定应用\n\n<head>\n    <script src="../js/jquery-1.11.1.js"><\/script>\n    <script>\n        $(function () {\n            //一对一\n            // //on(events , selector , fn)\n            // $("body").on("click" , "button" , function(){\n            //     $(this).css("fontSize", "+=20px");\n            // });\n\n            //多选择 一个事件\n            //on(events , fn)\n            // $("button,p").on("click",function(){\n            //     $(this).css("fontSize","+=20px")\n            // });\n            // //on(events , selector , fn)\n            // $("body").on("click" , "button,p" , function(){\n            //     $(this).css("fontSize", "+=20px");\n            // });\n\n            //多事件 一个方法\n            //on(events , fn)\n            // $("button").on("click mouseover",function(){\n            //     $(this).css("fontSize", "+=20px");\n            // });\n            \n            //多选择 多事件 不同方法\n            $("button , p").on({\n                mouseover: function(){\n                    $("button").css("fontSize", "+=20px");\n                    $("p").css("fontSize", "+=20px");\n                },\n                mouseout: function(){\n                    $("button").css("fontSize", "-=20px");\n                    $("p").css("fontSize", "-=20px");\n                },\n                click: function(){\n                    $("button").css("fontSize", "+=20px");\n                    $("p").css("fontSize", "+=20px");\n                }\n            });\n        });\n    <\/script>\n</head>\n<body>\n    <button>点击触发</button>\n    <br>    \n    <br>    \n    <br>    \n    <p style="background: chartreuse;">Test</p>\n</body>\n\n\n\n# JQuery事件\n\n点击更多JQuery事件\n\n常用方法                      说明\n$(selector).click()       鼠标点击\n$(selector).dblclick()    鼠标双击\n$(selector).mouseover()   获取鼠标焦点\n$(selector).mouseout()    失去鼠标焦点\n$(selector).keydown()     键盘按下\n$(selector).keyup()       键盘松开\n$(selector).submit()      表单提交\n$(selector).change()      元素值改变\n$(selector).focus()       获取表单焦点\n$(selector).blur()        失去表单焦点\n$(selector).load()        图片加载完毕\n$(selector).on()          节点事件绑定\n$(selector).off()         节点解除事件绑定\n\n鼠标事件\n\n<head>\n    <script src="../js/jquery-1.11.1.js"><\/script>\n    <script>\n        $(function(){\n            //鼠标点击触发  click\n            $("a:eq(0)").click(function(){\n                $(this).html("??");\n            });\n            //鼠标双击触发  dblclick\n            $("a:eq(1)").dblclick(function () {\n                $(this).html("??");\n            });\n            //鼠标移上触发 mouseenter\n            $("a:eq(2)").mouseenter(function () {\n                $(this).html("??");\n            });\n            //鼠标移上触发 mouseenter\n            $("a:eq(2)").mouseenter(function () {\n                $(this).html("??");\n            });\n            //鼠标离开触发 mouseleave\n            $("a:eq(2)").mouseleave(function () {\n                $(this).html("鼠标移上触发");\n            });\n        });\n    <\/script>\n</head>\n<body>\n    <div>\n        <a href="#">鼠标点击</a>\n        <a href="#">鼠标双击</a>\n        <a href="#">鼠标移上</a>\n    </div>\n</body>\n\n\n键盘事件\n\n<head>\n    <script src="../js/jquery-1.11.1.js"><\/script>\n    <script>\n        $(function () {\n            //键盘按下  keydown\n            $("input").keydown(function () {\n                $("div").css("background", "red");\n            });\n            //键盘松开  keydown\n            $("input").keyup(function () {\n                $("div").css("background", "dodgerblue");\n            });\n        });\n    <\/script>\n    <style>\n        div{\n            width: 20px;\n            height: 20px;\n            background: dodgerblue;\n        }\n    </style>\n</head>\n<body>\n    <input type="text">\n    <p>按下变红/松开变蓝:</p>\n    <div></div>\n</body>\n\n\n表单事件\n\n<head>\n    <script src="../js/jquery-1.11.1.js"><\/script>\n    <script>\n        $(function () {\n            //提交表单触发  submit\n            $("form").submit(function () {\n                alert("提交成功");\n            });\n            //提交2 \n            $("button:eq(0)").click(function () {\n                $("form").submit();\n            });\n            //元素值改变触发 change\n            $("#user").change(function () {\n                $("#user+label").html("值更变!!!");\n            });\n            //更改2\n            $("button:eq(1)").click(function () {\n                $("#user").change();\n            });\n            //获取焦点触发 focus\n            $("input").focus(function (e) {\n                $("input").css("background", "chartreuse");\n            });\n            //获取焦点2\n            $("button:eq(2)").click(function () {\n                $("input").focus();\n            });\n            //失去焦点 blur\n            $("input").blur(function () {\n                $("input").css("background","white");\n            });\n            //也可强制失去焦点\n        });\n    <\/script>\n</head>\n<body>\n    <div>\n        <form action="#">\n            <label for="user">name:</label>\n            <input type="text" id="user" name="user" value="洋葱小鱿">\n            <label></label><br>\n            <label for="">password:</label>\n            <input type="password" id="password" name="password" value="*****">\n            <label></label><br>\n            <label for="sex">sex:</label>\n            <input type="radio" name="sex" checked="checked" id="man">man\n            <input type="radio" name="sex" id="woman">woman\n            <br>\n            <input type="submit">\n            <input type="reset">\n        </form>\n        <button>提交2</button>\n        <button>强制更变</button>\n        <button>强制获取焦点</button>\n    </div>\n</body>\n\n\n图片加载\n\n<head>\n    <script src="../js/jquery-1.11.1.js"><\/script>\n    <script>\n        $(function(){\n            $("img").load(function(){\n                $("img+p").html("图片加载完毕");\n            });\n        });\n    <\/script>\n</head>\n<body>\n    <img src="https://sanscan.top/medias/banner/0.jpg" alt="">\n    <p>图片加载中......</p>\n</body>\n\n\n\n# JQuery效果\n\n点击更多JQuery效果\n\n常用方法                       说明\n$(selector).hide()         隐藏所有匹配的节点\n$(selector).show()         显示所有匹配的节点\n$(selector).toggle()       隐藏/显示 所有匹配的节点\n$(selector).fadeOut()      淡化 隐藏所有匹配的节点\n$(selector).fadeIn()       淡化 显示所有匹配的节点\n$(selector).fadeToggle()   淡化 隐藏/显示 所有匹配的节点\n$(selector).animate()      自定义动画\n\n隐藏和显示\n\n<head>\n    <script src="../js/jquery-1.11.1.js"><\/script>\n    <script>\n        //淡化使用方式是一样的该方法即可\n        $(function(){\n            //隐藏div hide  淡化方法 fadeOut\n            $("button:eq(0)").click(function(){\n                //可能值:"slow"/"normal"/"fast"/数值\n                $("div").hide("slow");\n            });\n            //显示div show  淡化方法 fadeIn\n            $("button:eq(1)").click(function(){\n                //可能值:"slow"/"normal"/"fast"/数值\n                $("div").show(2000);\n            });\n            // 隐藏/显示 show   淡化方法 fadeToggle\n            $("button:eq(2)").click(function(){\n                //可能值:"slow"/"normal"/"fast"/数值\n                $("div").toggle(1400);\n            });\n        });\n    <\/script>\n</head>\n<body>\n    <button>隐藏</button>\n    <button>显示</button>\n    <button>隐藏/显示</button>\n    <br><br> \n    <div style="background: hotpink; width: 200px; height: 200px;"></div>\n    <div>Test</div>\n</body>\n\n\n自定义动画\n\n<head>\n    <script src="../js/jquery-1.11.1.js"><\/script>\n    <script>\n    $(function(){\n        // 语法 $(selector).animate(styles[,speed][,easing][,callback])\n        var box = $(".box");\n        //变大\n        $("button:eq(0)").click(function(){\n            box.animate({height:"+=50px",width:"+=50px"});\n        });\n        //变小\n        $("button:eq(1)").click(function () {\n            box.animate({ height: "-=50px", width: "-=50px" });\n        });\n    });\n    <\/script>\n    <style>\n        .box{\n            background: hotpink;\n            width: 200px;\n            height: 200px;\n        }\n    </style>\n</head>\n<body>\n    <button>宽高+++</button>\n    <button>宽高--</button>\n    <br><br>\n    <div class="box"></div>\n</body>\n\n\n\n# JQuery文档\n\n点击更多JQuery文档操作\n\n常用方法                        说明\n$(selector).append()        匹配的节点插入内容结尾\n$(selector).prepend()       匹配的节点插入内容开头\n$(selector).after()         匹配的节点之后插入\n$(selector).before()        匹配的节点之前插入\n$(selector).clone()         克隆节点副本\n$(selector).replaceWith()   所有匹配节点 替换 新节点\n$(selector).remove()        删除所有匹配的节点\n$(selector).empty()         删除所有匹配的节点, 不包括本身\n$(selector).parent()        获取父节点\n$(selector).children()      获取子节点\n\n添加节点\n\n<head>\n    <script src="../js/jquery-1.11.1.js"><\/script>\n    <script>\n        $(function(){\n            //指定节点插入内容结尾 append\n            $("button:eq(0)").click(function(){\n                $(".box").append("<p>插入P尾</p>");\n            });\n            //指定节点插入内容开头 prepend\n            $("button:eq(1)").click(function () {\n                $(".box").prepend("<p>插入P尾</p>");\n            });\n            //指定节点后 after\n            $("button:eq(2)").click(function () {\n                $(".box").after("<p>写入P后</p>");\n            });\n            //指定节点前 before\n            $("button:eq(3)").click(function () {\n                $(".box").before("<p>写入P前</p>");\n            });\n        });\n    <\/script>\n    <style>\n        .box{\n            background: violet;\n            padding:10px;\n        }\n        p{\n            background: wheat;\n            padding: 10px;\n        }\n    </style>\n</head>\n<body>\n    <button>插入div尾</button>\n    <button>插入div头</button>\n    <button>写入div尾</button>\n    <button>写入div头</button>\n    <br><br>\n    <div class="box">\n        p标签\n        <p>div</p>\n    </div>\n</body>\n\n\n克隆节点\n\n<head>\n    <script src="../js/jquery-1.11.1.js"><\/script>\n    <script>\n        $(function(){\n            //克隆div参数true   clone\n            $("button:eq(0)").click(function(){\n                $("body").append($(".box").clone(true));\n            }); \n            //克隆div参数false  clone\n            $("button:eq(1)").click(function () {\n                $("body").append($(".box").clone(false));\n            });\n            $("button:last").click(function(){\n                alert("嘿嘿嘿!!");\n            });\n        });\n    <\/script>\n    <style>\n        .box{\n            background: violet;\n            padding:10px;\n            border: red 2px solid;\n        }\n        p{\n            background: wheat;\n            padding: 10px;\n        }\n    </style>\n</head>\n<body>\n    <button>克隆div参数true</button>\n    <button>克隆div参数false</button>\n    <br><br>\n    <div class="box">\n        p标签\n        <button>点击看看</button>\n        <p></p>\n    </div>\n    <p>p</p>\n</body>\n\n\n替换节点\n\n<head>\n    <script src="../js/jquery-1.11.1.js"><\/script>\n    <script>    \n        $(function(){\n\n            //替换div  replaceWith  \n            $("button:eq(0)").click(function(){\n                $("div").replaceWith("<p>替换标签</p>");\n            });\n            //替换div  replaceWith  \n            $("button:eq(1)").click(function(){\n                $("p").replaceWith("<p>替换标签</p>");\n            });\n\n            //替换div     replaceAll\n            $("button:eq(2)").click(function(){\n                $("<p>替换标签</p>").replaceAll("div");\n            });\n            //替换p     replaceAll\n            $("button:eq(3)").click(function(){\n                $("<p>替换标签</p>").replaceAll("p");\n            });\n        });\n    <\/script>\n    <style>\n        div {\n            background: violet;\n            padding: 10px;\n            border: red 2px solid;\n        }\n        p {\n            background: wheat;\n            padding: 10px;\n        }\n    </style>\n</head>\n<body>\n    <button>替换全部div replaceWith</button>\n    <button>替换全部p replaceWith</button>\n    <button>替换全部div replaceAll</button>\n    <button>替换全部p replaceAll</button>\n    <br><br>\n    <div class="box">\n        div\n        <p>p</p>\n    </div>\n    <p>p</p>\n    <div>div</div>\n</body>\n\n\n删除节点\n\n<head>\n    <script src="../js/jquery-1.11.1.js"><\/script>\n    <script>    \n        $(function(){\n            //删除所有div  remove  \n            $("button:eq(0)").click(function(){\n                $("div").remove();\n            });\n            //删除所有div  empty  \n            $("button:eq(1)").click(function(){\n                $("div").empty();\n            });\n            \n        });\n    <\/script>\n    <style>\n        div {\n            background: violet;\n            padding: 10px;\n            border: red 2px solid;\n        }\n        p {\n            background: wheat;\n            padding: 10px;\n        }\n    </style>\n</head>\n<body>\n    <button>删除所有div remove</button>\n    <button>删除所有div empty</button>\n    <br><br>\n    <div class="box">\n        div\n        <p>p</p>\n    </div>\n    <p>p</p>\n    <div>div</div>\n</body>\n\n\n\n# JQuery 遍历\n\n变量方式一共有四种：\n\n * 传统for循环\n * jq集合 each() 循环\n * jq方法 each() 循环\n * for of 循环\n\n> 后面三种注意 jq对象集合 遍历使用\n\n\n# for循环\n\nlet arr = [1,2,3,4];\nfor(let i = 0 ; i < arr.length ; i++){...}\n\n\n\n# each()1 循环\n\nlet arr = [1,2,3,4];\n$(arr).each(function(i , e){...});\n\n\n\n# each()2 循环\n\nlet arr = [1,2,3,4];\n$.each($(arr) , function(i , e){...});\n\n\n\n# for of 循环\n\nlet arr = [1,2,3,4];\nfor(let e of $(arr)){...}\n\n\n\n# 整体展示\n\nlet arr = [1,2,3,4,5,6];\n\n// no1\nconsole.log("no1:")\nfor (let i = 0; i < arr.length ; i++) {\n    console.log(arr[i]);\n}\n\n// no2\nconsole.log("no2:")\n$(arr).each(function (i , e) {\n    console.log(i,e)\n});\n\n// no3\nconsole.log("no3:")\n$.each($(arr), function (i, e) {\n    console.log(i,e);\n});\n\n// no4\nconsole.log("no4")\nfor (let e of $(arr)) {\n    console.log(e);\n}\n\n\n\n# JQuery 插件\n\n\n# 扩展机制\n\njQuery提供的 ==jQuery.fn.extend()==/==jQuery.extend()== (全局扩展/对象扩展），扩展jQuery的功能\n\n实现实例：\n\n// 对象扩展方法\njQuery.fn.extend({\n\tgetText:function () {\n\t    return $(this).text();\n\t},\n\tgetHtml:function () {\n\t    return $(this).html();\n\t}\n})\n// 应用:  $(..).getHtml(); / $(..).getText();\n\n// 全局扩展方法\n// 扩展min方法：求2个值的最小值；扩展max方法：求2个值最大值\n$.extend({\n    min:function (a,b) {\n        return a<b?a:b;\n    },\n    max:function (a,b) {\n        return a>b?a:b;\n    }\n})\n// 应用 $.min(1,2) / $.max(23,2)\n\n\n\n# Validator表单验证插件\n\n插件网站： https://www.jq22.com/jquery-info743\n\n插件应用\n\n$(“<form表单的选择器>”).validate({\n  // 设置约束规则\n  rules:{\n   <表单选项name值>:<验证规则> [, <表单项name值>:<验证规则>]\n },\n  // 验证失败提示\n  messages:{\n   <表单项name值>:<错误提示信息> [, <表单项name值>:<错误提示信息>]\n }\n});\n\n\n当验证失败显示效果未达到预期时，可按照以下方式自定义错误显示标签\n\n<lable for="<表单项name值>" class="error" style="display:none">错误信息</lable>\n\n\n验证规则\n\n属性名           值                     描述\nrequired      boolean               是否必填\nemail         boolean               验证邮箱\nurl           boolean               验证地址\ndate          boolean               验证日期\ndateISO       boolean               验证日期(ISO)\nnumber        boolean               合法数值(包含 负数/小数)\ndigits        boolean               输入整数\nequalTo       JQ对象                  比较两值是否相同\naccept        String                验证符合后缀的字符串\nmaxlength     Number                最多输入长度为 <参数> 的字符串\nminlength     Number                至少输入长度为 <参数> 的字符串\nrangelength   [Number1 , Number2]   指定输入长度为 [Number1 , Number2] 个的字符串\nrange         [Number1 , Number2]   指定输入值 为 Number1至Number2 的范围值\nmax           Number                输入值不能 大于 Number\nmin           Number                输入值不能 小于 Number\n\n# 自定义验证方法\n\n步骤：\n\n * 使用$.validator.addMethod(<校验规则名称>,function(value,element,params) {...}) value：组件value值 ；element：组件节点对象 ；params：验证规则的参数\n * 在 rules 中通过 校验规则名称 使用校验规则\n * 在 messages 中定义该规则对应的错误提示信息',normalizedContent:'# jquery\n\njquery 是个 javascript 库, 它简化了javascript编程! 封装了javascript常用的功能代码，提供一种简便的javascript设计模式，优化html文档操作、事件处理、动画设计和ajax交互。\n\n\n# 快速入门\n\n\n# 引用\n\n外部引用javascript脚本文件即可\n\n<head>\n\t<script src="..."><\/script>\n</head>\n\n\n\n# 语法\n\n以下语法的作用是在文档加载完再执行的jq代码\n\n//no.1\n$(document).ready(function(){\n\t//jquery 代码 ...\n});\n\n//no.2\n$(function(){\n\t//jquery 代码 ...\n});\n\n\n\n# 对象转化\n\ndom对象 转 jq对象 ==$(<dom对象>)==\n\n\n\n\njq对象 转 dmo对象 ==<jq对象>.get(0)==\n\n\n\n\n\n# jquery选择器\n\n$(this)                选取\n$("p")                 所有 <p> 元素\n$("p.intro")           所有 class="intro" 的 <p> 元素\n$(".intro")            所有 class="intro" 的元素\n$("#intro")            id="intro" 的\n$("ul li:first")       每个 <ul> 的第一个 <li> 元素\n$("[href$=\'.jpg\']")    所有带有以 ".jpg" 结尾的属性值的 href 属性\n$("div#intro .head")   id="intro" 的 <div> 元素中的所有 class="head" 的元素\n$("div , p")           所有 <div> <p> 元素\n$("form input")        所有 <form> 中的 <input> 元素\n$("form>input")        所有 <form> 中的 <input> 元素\n$("label+input")       所有 <label> 的下一个元素\n\n点击更多jquery选择器\n\n<head>\n<script src="../js/jquery-1.11.1.js"><\/script>\n    <script>\n        function printlist(list) {\n            for (var i = 0; i < list.length; i++) {\n                console.log(list[i]);\n            }\n        }\n        //引用jq代码\n        $(function () {\n            allselector();\n        });\n        //标签\n        function labelselector() {\n            //遍历结果是 hmtl节点 集合\n            var list = $("div");\n            printlist(list);\n        }\n        //id\n        function idselector() {\n            var list = $("#div4");\n            printlist(list);\n        }\n        //class\n        function classselector() {\n            var list = $(".div2");\n            printlist(list);\n        }\n        //全局\n        function allselector() {\n            var list = $("*");\n            printlist(list);\n        }\n    <\/script>\n</head>\n<body>\n    <div>div1</div>\n    <div class="div2">div2</div>\n    <div>div3</div>\n    <div id="div4">div4</div>\n</body>\n\n\n<head>\n<script src="../js/jquery-1.11.1.js"><\/script>\n<script>\n    function printlist(list) {\n        for (var i = 0; i < list.length; i++) {\n            console.log(list[i]);\n        }\n    }\n    //引用jq代码\n    $(function () {\n        visibilityselector();\n    });\n    //并集\n    function episodeselector() {\n        var list = $("div,b");\n        printlist(list);\n    }\n    //后代\n    function descendantselector() {\n        var list = $("form label");\n        printlist(list);\n    }\n    //子\n    function sonselector() {\n        var list = $("form>.test");\n        printlist(list);\n    }\n    //相邻\n    function adjacentselector() {\n        var list = $("label+input");\n        printlist(list);\n    }\n    //属性\n    function attributesselector() {\n        // var list = $("input[name]");\n        // var list = $("p[class=\'test\']");\n        // var list = $("input[type=\'text\'][name=\'userss\']");\n        // var list = $("input[name^=\'user\']");\n        var list = $("input[name$=\'ss\']");\n        // var list = $("input[name*=\'ss\']");\n        printlist(list);\n    }\n    //可见性\n    function visibilityselector(){\n        var list = $("div:hidden");\n        // var list = $("div:visible");\n        printlist(list);\n    }\n<\/script>\n</head>\n<body>\n    <form action="#">\n        <label for="userid">i d : </label>\n        <input type="text" name="userid">\n        <br>\n        <label for="userss">账号:</label>\n        <input type="text" name="userss">\n        <br>\n        <label for="password">密码:</label>\n        <input type="password" name="password">\n        <br>\n        <b>b1</b>\n        <b class="test">b2</b>\n        <div>\n            div1\n            <p class="test">p1</p>\n            <p>p2</p>\n        </div>\n        <div class="div2" style="display: none;" >div2</div>\n        <div class="test" style="visibility: hidden;" >div3</div>\n        <div id="div4">div4</div>\n    </form>\n</body>\n\n\n\n# jquery html\n\n点击更多jquery操作方法\n\n\n# html内容\n\n常用方法                          说明\n$(selector).text([content])   设置或返回 所选元素的文本内容\n$(selector).html([content])   设置或返回 所选元素的内容,包括 html 标签\n$(selector).val([content])    设置或返回 表单字段的值\n\n<head>\n<script src="../js/jquery-1.11.1.js"><\/script>\n<script>\n    $(function(){\n        var str = "test!!";\n        var div = $("div");\n        console.log(div.html());    //div<button>按钮</button>\n        console.log(div.text());    //div按钮\n        console.log(div.val());     //null ,因非表单value值\n        console.log($("input").val());  //张三\n    });\n<\/script>\n</head>\n<body>\n    <div>\n        div\n        <button>按钮</button>\n    </div>\n    <input type="text" value="张三">\n</body>\n\n\n\n# hmtl属性\n\n常用方法                               说明\n$(selector).attr(<属性名> [,<属性值>])   返回/设置 属性值 (无参则返回值\n$(selector).prop(<选中属性>,<选中>)      判断是否选中\n$(selector).removeattr()           元素移除指定属性\n\n<head>\n    <script src="../js/jquery-1.11.1.js"><\/script>\n    <script>\n        $(function () {\n            //指定第一个元素的div节点\n            var box = $("div:eq(0)");\n            var user = $("input[id=\'user\']");\n            var password = $("input[id=\'password\']");\n            var button = $(".buttontest");\n\n            //编辑属性值    attr\n            //attr(属性) => 返回属性值\n            $("button:eq(0)").click(function () {\n                alert(user.attr("value"));\n            });\n            //attr(属性,属性值) => 更改属性值\n            $("button:eq(1)").click(function () {\n                user.attr("value", "sanscan");\n            });\n            //attr(属性,函数(index,oldvalue)) => 编辑属性值\n            $("button:eq(2)").click(function () {\n                //每次运行都会在 属性值追加\'s\'\n                user.attr("value", function (n, o) {\n                    alert("n = " + n + "o = " + o);\n                    return o + "s";\n                });\n            });\n            //获取单选 信息 prop\n            $("button:eq(3)").click(function () {\n                var list = $("input[name=\'sex\']");\n                var str;\n                for (var i = 0; i < list.length; i++) {\n                    alert( $(list[i]).attr("id") +" = " + $(list[i]).prop(\'checked\'));\n                }\n            });\n            //移除属性 removeattr\n            $("button:eq(4)").click(function () {\n                password.removeattr("value");\n            });\n\n        });\n    <\/script>\n</head>\n<body>\n    <div>\n        <form action="#">\n            <label for="user">name:</label>\n            <input type="text" id="user" name="user" value="洋葱小鱿"><br>\n            <label for="">password:</label>\n            <input type="password" id="password" name="password" value="*****"><br>\n            <label for="sex">sex:</label>\n            <input type="radio" name="sex" checked="checked" id="man">man\n            <input type="radio" name="sex" id="woman">woman\n        </form>\n    </div>\n    <div>\n        <button>获取名称值</button><br>\n        <button>更改属性值</button><br>\n        <button>追加属性值</button><br>\n        <button>获取单选按钮信息</button><br>\n        <button>移除密码value值</button><br>\n    </div>\n</body>\n\n\n\n# css样式\n\n点击更多css样式\n\n常用方法                        说明\n$(selector).css()           编辑属性\n$(selector).addclass()      元素添加类\n$(selector).removeclass()   匹配元素中删除全部 或 指定的 类\n$(selector).toggleclass()   元素中添加或删除类\n$(selector).hasclass()      检查元素是否拥有指定的类\n$(selector).width()         设置元素的宽度\n$(selector).height()        设置元素的高度\n\n<head>\n<script src="../js/jquery-1.11.1.js"><\/script>\n    <script>\n        $(function () {\n            //指定第一个元素的div节点\n            var box = $("div:eq(0)");\n            var user = $("input[id=\'user\']");\n            var password = $("input[id=\'password\']");\n            var button = $(".buttontest");\n\n            //添加类 属性   addclass\n            $("button:eq(0)").click(function () {\n                box.addclass("box");\n            });\n            //删除类 属性   removeclass\n            $("button:eq(1)").click(function () {\n                box.removeclass("box");\n            });\n            //检查 类是否包含"box类"    hasclass\n            $("button:eq(2)").click(function () {\n                alert(box.hasclass("box"));\n            });\n            //按钮颜色  css\n            $("button:eq(3)").click(function () {\n                alert(button.css("background"))\n            });\n            //修改按钮颜色 css\n            $("button:eq(4)").click(function () {\n                button.css("background","darkseagreen");\n            });2\n            //修改盒子高度 height\n            $("button:eq(5)").click(function () {\n                box.height(200);\n            });\n            //修改盒子宽度  width\n            $("button:eq(6)").click(function () {\n                box.width(300);\n            });\n            //设置移除  toggleclass\n            $("button:eq(7)").click(function () {\n                button.toggleclass("buttontest");\n            });\n        });\n<\/script>\n<style>\n        .box {\n            width: 200px;\n            padding-left: 24px;\n            background: chartreuse;\n        }\n        .buttontest {\n            background: coral;\n            margin: 4px;\n        }\n    </style>\n</head>\n<body>\n    <div>\n        <form action="#">\n            <label for="user">name:</label>\n            <input type="text" id="user" name="user" value="洋葱小鱿"><br>\n            <label for="">password:</label>\n            <input type="password" id="password" name="password" value="*****"><br>\n            <label for="sex">sex:</label>\n            <input type="radio" name="sex" checked="checked">man\n            <input type="radio" name="sex">woman\n        </form>\n    </div>\n    <div>\n        <button class="buttontest">添加盒子样式</button><br>\n        <button class="buttontest">删除盒子样式</button><br>\n        <button class="buttontest">检查盒子样式</button><br>\n        <button class="buttontest">获取按钮颜色</button><br>\n        <button class="buttontest">修改按钮颜色</button><br>\n        <button class="buttontest">修改盒子高度</button><br>\n        <button class="buttontest">修改盒子宽度</button><br>\n        <button class="buttontest">移除/恢复 按钮样式</button><br>\n    </div>\n</body>\n\n\non事件绑定应用\n\n<head>\n    <script src="../js/jquery-1.11.1.js"><\/script>\n    <script>\n        $(function () {\n            //一对一\n            // //on(events , selector , fn)\n            // $("body").on("click" , "button" , function(){\n            //     $(this).css("fontsize", "+=20px");\n            // });\n\n            //多选择 一个事件\n            //on(events , fn)\n            // $("button,p").on("click",function(){\n            //     $(this).css("fontsize","+=20px")\n            // });\n            // //on(events , selector , fn)\n            // $("body").on("click" , "button,p" , function(){\n            //     $(this).css("fontsize", "+=20px");\n            // });\n\n            //多事件 一个方法\n            //on(events , fn)\n            // $("button").on("click mouseover",function(){\n            //     $(this).css("fontsize", "+=20px");\n            // });\n            \n            //多选择 多事件 不同方法\n            $("button , p").on({\n                mouseover: function(){\n                    $("button").css("fontsize", "+=20px");\n                    $("p").css("fontsize", "+=20px");\n                },\n                mouseout: function(){\n                    $("button").css("fontsize", "-=20px");\n                    $("p").css("fontsize", "-=20px");\n                },\n                click: function(){\n                    $("button").css("fontsize", "+=20px");\n                    $("p").css("fontsize", "+=20px");\n                }\n            });\n        });\n    <\/script>\n</head>\n<body>\n    <button>点击触发</button>\n    <br>    \n    <br>    \n    <br>    \n    <p style="background: chartreuse;">test</p>\n</body>\n\n\n\n# jquery事件\n\n点击更多jquery事件\n\n常用方法                      说明\n$(selector).click()       鼠标点击\n$(selector).dblclick()    鼠标双击\n$(selector).mouseover()   获取鼠标焦点\n$(selector).mouseout()    失去鼠标焦点\n$(selector).keydown()     键盘按下\n$(selector).keyup()       键盘松开\n$(selector).submit()      表单提交\n$(selector).change()      元素值改变\n$(selector).focus()       获取表单焦点\n$(selector).blur()        失去表单焦点\n$(selector).load()        图片加载完毕\n$(selector).on()          节点事件绑定\n$(selector).off()         节点解除事件绑定\n\n鼠标事件\n\n<head>\n    <script src="../js/jquery-1.11.1.js"><\/script>\n    <script>\n        $(function(){\n            //鼠标点击触发  click\n            $("a:eq(0)").click(function(){\n                $(this).html("??");\n            });\n            //鼠标双击触发  dblclick\n            $("a:eq(1)").dblclick(function () {\n                $(this).html("??");\n            });\n            //鼠标移上触发 mouseenter\n            $("a:eq(2)").mouseenter(function () {\n                $(this).html("??");\n            });\n            //鼠标移上触发 mouseenter\n            $("a:eq(2)").mouseenter(function () {\n                $(this).html("??");\n            });\n            //鼠标离开触发 mouseleave\n            $("a:eq(2)").mouseleave(function () {\n                $(this).html("鼠标移上触发");\n            });\n        });\n    <\/script>\n</head>\n<body>\n    <div>\n        <a href="#">鼠标点击</a>\n        <a href="#">鼠标双击</a>\n        <a href="#">鼠标移上</a>\n    </div>\n</body>\n\n\n键盘事件\n\n<head>\n    <script src="../js/jquery-1.11.1.js"><\/script>\n    <script>\n        $(function () {\n            //键盘按下  keydown\n            $("input").keydown(function () {\n                $("div").css("background", "red");\n            });\n            //键盘松开  keydown\n            $("input").keyup(function () {\n                $("div").css("background", "dodgerblue");\n            });\n        });\n    <\/script>\n    <style>\n        div{\n            width: 20px;\n            height: 20px;\n            background: dodgerblue;\n        }\n    </style>\n</head>\n<body>\n    <input type="text">\n    <p>按下变红/松开变蓝:</p>\n    <div></div>\n</body>\n\n\n表单事件\n\n<head>\n    <script src="../js/jquery-1.11.1.js"><\/script>\n    <script>\n        $(function () {\n            //提交表单触发  submit\n            $("form").submit(function () {\n                alert("提交成功");\n            });\n            //提交2 \n            $("button:eq(0)").click(function () {\n                $("form").submit();\n            });\n            //元素值改变触发 change\n            $("#user").change(function () {\n                $("#user+label").html("值更变!!!");\n            });\n            //更改2\n            $("button:eq(1)").click(function () {\n                $("#user").change();\n            });\n            //获取焦点触发 focus\n            $("input").focus(function (e) {\n                $("input").css("background", "chartreuse");\n            });\n            //获取焦点2\n            $("button:eq(2)").click(function () {\n                $("input").focus();\n            });\n            //失去焦点 blur\n            $("input").blur(function () {\n                $("input").css("background","white");\n            });\n            //也可强制失去焦点\n        });\n    <\/script>\n</head>\n<body>\n    <div>\n        <form action="#">\n            <label for="user">name:</label>\n            <input type="text" id="user" name="user" value="洋葱小鱿">\n            <label></label><br>\n            <label for="">password:</label>\n            <input type="password" id="password" name="password" value="*****">\n            <label></label><br>\n            <label for="sex">sex:</label>\n            <input type="radio" name="sex" checked="checked" id="man">man\n            <input type="radio" name="sex" id="woman">woman\n            <br>\n            <input type="submit">\n            <input type="reset">\n        </form>\n        <button>提交2</button>\n        <button>强制更变</button>\n        <button>强制获取焦点</button>\n    </div>\n</body>\n\n\n图片加载\n\n<head>\n    <script src="../js/jquery-1.11.1.js"><\/script>\n    <script>\n        $(function(){\n            $("img").load(function(){\n                $("img+p").html("图片加载完毕");\n            });\n        });\n    <\/script>\n</head>\n<body>\n    <img src="https://sanscan.top/medias/banner/0.jpg" alt="">\n    <p>图片加载中......</p>\n</body>\n\n\n\n# jquery效果\n\n点击更多jquery效果\n\n常用方法                       说明\n$(selector).hide()         隐藏所有匹配的节点\n$(selector).show()         显示所有匹配的节点\n$(selector).toggle()       隐藏/显示 所有匹配的节点\n$(selector).fadeout()      淡化 隐藏所有匹配的节点\n$(selector).fadein()       淡化 显示所有匹配的节点\n$(selector).fadetoggle()   淡化 隐藏/显示 所有匹配的节点\n$(selector).animate()      自定义动画\n\n隐藏和显示\n\n<head>\n    <script src="../js/jquery-1.11.1.js"><\/script>\n    <script>\n        //淡化使用方式是一样的该方法即可\n        $(function(){\n            //隐藏div hide  淡化方法 fadeout\n            $("button:eq(0)").click(function(){\n                //可能值:"slow"/"normal"/"fast"/数值\n                $("div").hide("slow");\n            });\n            //显示div show  淡化方法 fadein\n            $("button:eq(1)").click(function(){\n                //可能值:"slow"/"normal"/"fast"/数值\n                $("div").show(2000);\n            });\n            // 隐藏/显示 show   淡化方法 fadetoggle\n            $("button:eq(2)").click(function(){\n                //可能值:"slow"/"normal"/"fast"/数值\n                $("div").toggle(1400);\n            });\n        });\n    <\/script>\n</head>\n<body>\n    <button>隐藏</button>\n    <button>显示</button>\n    <button>隐藏/显示</button>\n    <br><br> \n    <div style="background: hotpink; width: 200px; height: 200px;"></div>\n    <div>test</div>\n</body>\n\n\n自定义动画\n\n<head>\n    <script src="../js/jquery-1.11.1.js"><\/script>\n    <script>\n    $(function(){\n        // 语法 $(selector).animate(styles[,speed][,easing][,callback])\n        var box = $(".box");\n        //变大\n        $("button:eq(0)").click(function(){\n            box.animate({height:"+=50px",width:"+=50px"});\n        });\n        //变小\n        $("button:eq(1)").click(function () {\n            box.animate({ height: "-=50px", width: "-=50px" });\n        });\n    });\n    <\/script>\n    <style>\n        .box{\n            background: hotpink;\n            width: 200px;\n            height: 200px;\n        }\n    </style>\n</head>\n<body>\n    <button>宽高+++</button>\n    <button>宽高--</button>\n    <br><br>\n    <div class="box"></div>\n</body>\n\n\n\n# jquery文档\n\n点击更多jquery文档操作\n\n常用方法                        说明\n$(selector).append()        匹配的节点插入内容结尾\n$(selector).prepend()       匹配的节点插入内容开头\n$(selector).after()         匹配的节点之后插入\n$(selector).before()        匹配的节点之前插入\n$(selector).clone()         克隆节点副本\n$(selector).replacewith()   所有匹配节点 替换 新节点\n$(selector).remove()        删除所有匹配的节点\n$(selector).empty()         删除所有匹配的节点, 不包括本身\n$(selector).parent()        获取父节点\n$(selector).children()      获取子节点\n\n添加节点\n\n<head>\n    <script src="../js/jquery-1.11.1.js"><\/script>\n    <script>\n        $(function(){\n            //指定节点插入内容结尾 append\n            $("button:eq(0)").click(function(){\n                $(".box").append("<p>插入p尾</p>");\n            });\n            //指定节点插入内容开头 prepend\n            $("button:eq(1)").click(function () {\n                $(".box").prepend("<p>插入p尾</p>");\n            });\n            //指定节点后 after\n            $("button:eq(2)").click(function () {\n                $(".box").after("<p>写入p后</p>");\n            });\n            //指定节点前 before\n            $("button:eq(3)").click(function () {\n                $(".box").before("<p>写入p前</p>");\n            });\n        });\n    <\/script>\n    <style>\n        .box{\n            background: violet;\n            padding:10px;\n        }\n        p{\n            background: wheat;\n            padding: 10px;\n        }\n    </style>\n</head>\n<body>\n    <button>插入div尾</button>\n    <button>插入div头</button>\n    <button>写入div尾</button>\n    <button>写入div头</button>\n    <br><br>\n    <div class="box">\n        p标签\n        <p>div</p>\n    </div>\n</body>\n\n\n克隆节点\n\n<head>\n    <script src="../js/jquery-1.11.1.js"><\/script>\n    <script>\n        $(function(){\n            //克隆div参数true   clone\n            $("button:eq(0)").click(function(){\n                $("body").append($(".box").clone(true));\n            }); \n            //克隆div参数false  clone\n            $("button:eq(1)").click(function () {\n                $("body").append($(".box").clone(false));\n            });\n            $("button:last").click(function(){\n                alert("嘿嘿嘿!!");\n            });\n        });\n    <\/script>\n    <style>\n        .box{\n            background: violet;\n            padding:10px;\n            border: red 2px solid;\n        }\n        p{\n            background: wheat;\n            padding: 10px;\n        }\n    </style>\n</head>\n<body>\n    <button>克隆div参数true</button>\n    <button>克隆div参数false</button>\n    <br><br>\n    <div class="box">\n        p标签\n        <button>点击看看</button>\n        <p></p>\n    </div>\n    <p>p</p>\n</body>\n\n\n替换节点\n\n<head>\n    <script src="../js/jquery-1.11.1.js"><\/script>\n    <script>    \n        $(function(){\n\n            //替换div  replacewith  \n            $("button:eq(0)").click(function(){\n                $("div").replacewith("<p>替换标签</p>");\n            });\n            //替换div  replacewith  \n            $("button:eq(1)").click(function(){\n                $("p").replacewith("<p>替换标签</p>");\n            });\n\n            //替换div     replaceall\n            $("button:eq(2)").click(function(){\n                $("<p>替换标签</p>").replaceall("div");\n            });\n            //替换p     replaceall\n            $("button:eq(3)").click(function(){\n                $("<p>替换标签</p>").replaceall("p");\n            });\n        });\n    <\/script>\n    <style>\n        div {\n            background: violet;\n            padding: 10px;\n            border: red 2px solid;\n        }\n        p {\n            background: wheat;\n            padding: 10px;\n        }\n    </style>\n</head>\n<body>\n    <button>替换全部div replacewith</button>\n    <button>替换全部p replacewith</button>\n    <button>替换全部div replaceall</button>\n    <button>替换全部p replaceall</button>\n    <br><br>\n    <div class="box">\n        div\n        <p>p</p>\n    </div>\n    <p>p</p>\n    <div>div</div>\n</body>\n\n\n删除节点\n\n<head>\n    <script src="../js/jquery-1.11.1.js"><\/script>\n    <script>    \n        $(function(){\n            //删除所有div  remove  \n            $("button:eq(0)").click(function(){\n                $("div").remove();\n            });\n            //删除所有div  empty  \n            $("button:eq(1)").click(function(){\n                $("div").empty();\n            });\n            \n        });\n    <\/script>\n    <style>\n        div {\n            background: violet;\n            padding: 10px;\n            border: red 2px solid;\n        }\n        p {\n            background: wheat;\n            padding: 10px;\n        }\n    </style>\n</head>\n<body>\n    <button>删除所有div remove</button>\n    <button>删除所有div empty</button>\n    <br><br>\n    <div class="box">\n        div\n        <p>p</p>\n    </div>\n    <p>p</p>\n    <div>div</div>\n</body>\n\n\n\n# jquery 遍历\n\n变量方式一共有四种：\n\n * 传统for循环\n * jq集合 each() 循环\n * jq方法 each() 循环\n * for of 循环\n\n> 后面三种注意 jq对象集合 遍历使用\n\n\n# for循环\n\nlet arr = [1,2,3,4];\nfor(let i = 0 ; i < arr.length ; i++){...}\n\n\n\n# each()1 循环\n\nlet arr = [1,2,3,4];\n$(arr).each(function(i , e){...});\n\n\n\n# each()2 循环\n\nlet arr = [1,2,3,4];\n$.each($(arr) , function(i , e){...});\n\n\n\n# for of 循环\n\nlet arr = [1,2,3,4];\nfor(let e of $(arr)){...}\n\n\n\n# 整体展示\n\nlet arr = [1,2,3,4,5,6];\n\n// no1\nconsole.log("no1:")\nfor (let i = 0; i < arr.length ; i++) {\n    console.log(arr[i]);\n}\n\n// no2\nconsole.log("no2:")\n$(arr).each(function (i , e) {\n    console.log(i,e)\n});\n\n// no3\nconsole.log("no3:")\n$.each($(arr), function (i, e) {\n    console.log(i,e);\n});\n\n// no4\nconsole.log("no4")\nfor (let e of $(arr)) {\n    console.log(e);\n}\n\n\n\n# jquery 插件\n\n\n# 扩展机制\n\njquery提供的 ==jquery.fn.extend()==/==jquery.extend()== (全局扩展/对象扩展），扩展jquery的功能\n\n实现实例：\n\n// 对象扩展方法\njquery.fn.extend({\n\tgettext:function () {\n\t    return $(this).text();\n\t},\n\tgethtml:function () {\n\t    return $(this).html();\n\t}\n})\n// 应用:  $(..).gethtml(); / $(..).gettext();\n\n// 全局扩展方法\n// 扩展min方法：求2个值的最小值；扩展max方法：求2个值最大值\n$.extend({\n    min:function (a,b) {\n        return a<b?a:b;\n    },\n    max:function (a,b) {\n        return a>b?a:b;\n    }\n})\n// 应用 $.min(1,2) / $.max(23,2)\n\n\n\n# validator表单验证插件\n\n插件网站： https://www.jq22.com/jquery-info743\n\n插件应用\n\n$(“<form表单的选择器>”).validate({\n  // 设置约束规则\n  rules:{\n   <表单选项name值>:<验证规则> [, <表单项name值>:<验证规则>]\n },\n  // 验证失败提示\n  messages:{\n   <表单项name值>:<错误提示信息> [, <表单项name值>:<错误提示信息>]\n }\n});\n\n\n当验证失败显示效果未达到预期时，可按照以下方式自定义错误显示标签\n\n<lable for="<表单项name值>" class="error" style="display:none">错误信息</lable>\n\n\n验证规则\n\n属性名           值                     描述\nrequired      boolean               是否必填\nemail         boolean               验证邮箱\nurl           boolean               验证地址\ndate          boolean               验证日期\ndateiso       boolean               验证日期(iso)\nnumber        boolean               合法数值(包含 负数/小数)\ndigits        boolean               输入整数\nequalto       jq对象                  比较两值是否相同\naccept        string                验证符合后缀的字符串\nmaxlength     number                最多输入长度为 <参数> 的字符串\nminlength     number                至少输入长度为 <参数> 的字符串\nrangelength   [number1 , number2]   指定输入长度为 [number1 , number2] 个的字符串\nrange         [number1 , number2]   指定输入值 为 number1至number2 的范围值\nmax           number                输入值不能 大于 number\nmin           number                输入值不能 小于 number\n\n# 自定义验证方法\n\n步骤：\n\n * 使用$.validator.addmethod(<校验规则名称>,function(value,element,params) {...}) value：组件value值 ；element：组件节点对象 ；params：验证规则的参数\n * 在 rules 中通过 校验规则名称 使用校验规则\n * 在 messages 中定义该规则对应的错误提示信息',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Nginx",frontmatter:{title:"Nginx",author:"柏竹",permalink:"/web/1hg7wd",date:"2020-02-18T00:00:00.000Z",categories:["前端"],tags:["Nginx"]},regularPath:"/02.%E5%89%8D%E7%AB%AF/02.%E6%8A%80%E6%9C%AF%E6%8B%93%E5%B1%95/04.Nginx.html",relativePath:"02.前端/02.技术拓展/04.Nginx.md",key:"v-2a180b97",path:"/web/1hg7wd/",headers:[{level:2,title:"快速上手",slug:"快速上手",normalizedTitle:"快速上手",charIndex:12},{level:3,title:"下载&安装",slug:"下载-安装",normalizedTitle:"下载&amp;安装",charIndex:null},{level:4,title:"Window",slug:"window",normalizedTitle:"window",charIndex:252},{level:4,title:"Linux",slug:"linux",normalizedTitle:"linux",charIndex:553},{level:3,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:478},{level:4,title:"主要配置",slug:"主要配置",normalizedTitle:"主要配置",charIndex:1166},{level:4,title:"负载均衡配置",slug:"负载均衡配置",normalizedTitle:"负载均衡配置",charIndex:993},{level:3,title:"Docker",slug:"docker",normalizedTitle:"docker",charIndex:1595},{level:2,title:"Nginx Proxy Manger",slug:"nginx-proxy-manger",normalizedTitle:"nginx proxy manger",charIndex:2655}],headersStr:"快速上手 下载&安装 Window Linux 配置 主要配置 负载均衡配置 Docker Nginx Proxy Manger",content:"# Nginx\n\n\n# 快速上手\n\nNginx是一个高性能的HTTP和反向代理web服务器 , 同时也提供了 IMAP/POP3/SMTP 服务\n\n官网 : https://nginx.org\n\n> 正向代理&反向代理 正向代理要知道访问服务器的地址，反向代理不需要知道访问服务器的真实地址\n\n优点 :\n\n 1. 反向代理能够将请求进行 负载均衡\n 2. 有多种 均衡策略\n\n\n# 下载&安装\n\n下载 : https://nginx.org/en/download.html\n\n一般下载稳定版即可\n\n# Window\n\n解压后 , cmd根路径 ==start nginx==/==nginx.exe== 指令即可食用\n\n验证 : http://localhost:80\n\nwindow常用指令\n\n# 启动&退出&关闭&重启 服务\nstart nginx\nnginx -s quit\nnginx -s stop\nnginx -s reopen\n# 帮助\nnginx -h\n\n\n> 注意 :\n> \n>  * 解压路径中不能包含有中文路径\n>  * Nginx配置是80端口 , 如果加载无效需要更改端口 配置文件 ==/conf/nginx.conf== 看见 ==listen 80;== 更改即可\n\n# Linux\n\n安装\n\n# 安装\nyum install epel-release\nyum update\nyum -y install nginx\n\n# nginx服务 开启/停止/重启\nsystemctl start nginx\nsystemctl stop nginx\nsystemctl restart nginx\n\n\n配置\n\n * ==/etc/nginx/nginx.conf==文件\n * ==/etc/nginx/conf.d/自定义文件.conf==文件 (一般在这里新建应用)\n\n验证 : http://localhost:80\n\n\n# 配置\n\nNginx配置中有三个核心功能 :\n\n * 静态服务器\n * 反向代理\n * 负载均衡\n\n# 全局配置\nmain\n\n# 工作模式配置\nevents { }\n\n# http 配置\nhttp {\n   \n\t# 服务器主机配置\n    server { }\n   \n\t# 路由配置\n    location { }\n\n\t# 负载均衡配置\n    upstream name {  }\n}\n\n\n配置文档 :\n\n * http://www.gwznkj.cn\n * http://shouce.jb51.net/nginx/left.html\n * https://blog.csdn.net/qq_33454884/article/details/89212702\n\n# 主要配置\n\nserver {\n   \n\t# 端口\n    listen 80;\n   \n\t# 域名\n    server_name localhost  192.168.1.100;\n   \n\t# 代表这是项目根目录\n    location / {\n       \n\t\t# 虚拟目录\n        root /usr/share/nginx/www;\n    }\n}\n\n\n# 负载均衡配置\n\nhttp{\n\tupstream myweb {\n\n\t\t# 两个服务器\n    \tserver localhost:8080; 　　\n    \tserver localhost:8081;\n\t}\n\tserver {\n\t    listen 80;\n       \n\t\t# 路由对应\n\t    location / {\n\t        proxy_pass http://myweb;\n\t    }\n\t}\n}\n\n\n> 需要对应路由才能进行访问后端指定路由\n\n\n# Docker\n\n利用docker安装nginx实现反向代理\n\n 1. 安装镜像 nginx\n\n 2. 创建配置文件 (运行docker挂载的配置)\n    \n    # 创建挂载目录\n     mkdir -p /home/nginx/conf\n    mkdir -p /home/nginx/log\n    mkdir -p /home/nginx/html\n    \n\n 3. 拷贝主要配置到宿主机\n    \n     # 生成容器\n     docker run --name nginx -p 9001:80 -d nginx\n    \n     # 将容器nginx.conf文件复制到宿主机\n     docker cp nginx:/etc/nginx/nginx.conf /home/nginx/conf/nginx.conf\n     \n     # 将容器conf.d文件夹下内容复制到宿主机\n    docker cp nginx:/etc/nginx/conf.d /home/nginx/conf/conf.d\n    \n     # 将容器中的html文件夹复制到宿主机\n    docker cp nginx:/usr/share/nginx/html /home/nginx/\n    \n\n 4. 运行 Nginx容器\n    \n    docker run \\\n    -p 9002:80 \\\n    --name nginx \\\n    -v /home/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \\\n    -v /home/nginx/conf/conf.d:/etc/nginx/conf.d \\\n    -v /home/nginx/log:/var/log/nginx \\\n    -v /home/nginx/html:/usr/share/nginx/html \\\n    -d nginx:latest\n    \n\n 5. 访问 [IP]:9002 即可\n\n命令                 说明\n-name [名称]         命名\n-d                 后台运行\n-p [宿主端口]:[容器端口]   端口映射\n-v [宿主路径]:[容器路径]   配置文件挂载\nnginx:latest       本地运行的版本\n\\                  shell 命令换行\n\n\n# Nginx Proxy Manger\n\n官方 : https://nginxproxymanager.com/\n\nNginx 的进化 , 简化了Nginx操作 , 图形化UI操作",normalizedContent:"# nginx\n\n\n# 快速上手\n\nnginx是一个高性能的http和反向代理web服务器 , 同时也提供了 imap/pop3/smtp 服务\n\n官网 : https://nginx.org\n\n> 正向代理&反向代理 正向代理要知道访问服务器的地址，反向代理不需要知道访问服务器的真实地址\n\n优点 :\n\n 1. 反向代理能够将请求进行 负载均衡\n 2. 有多种 均衡策略\n\n\n# 下载&安装\n\n下载 : https://nginx.org/en/download.html\n\n一般下载稳定版即可\n\n# window\n\n解压后 , cmd根路径 ==start nginx==/==nginx.exe== 指令即可食用\n\n验证 : http://localhost:80\n\nwindow常用指令\n\n# 启动&退出&关闭&重启 服务\nstart nginx\nnginx -s quit\nnginx -s stop\nnginx -s reopen\n# 帮助\nnginx -h\n\n\n> 注意 :\n> \n>  * 解压路径中不能包含有中文路径\n>  * nginx配置是80端口 , 如果加载无效需要更改端口 配置文件 ==/conf/nginx.conf== 看见 ==listen 80;== 更改即可\n\n# linux\n\n安装\n\n# 安装\nyum install epel-release\nyum update\nyum -y install nginx\n\n# nginx服务 开启/停止/重启\nsystemctl start nginx\nsystemctl stop nginx\nsystemctl restart nginx\n\n\n配置\n\n * ==/etc/nginx/nginx.conf==文件\n * ==/etc/nginx/conf.d/自定义文件.conf==文件 (一般在这里新建应用)\n\n验证 : http://localhost:80\n\n\n# 配置\n\nnginx配置中有三个核心功能 :\n\n * 静态服务器\n * 反向代理\n * 负载均衡\n\n# 全局配置\nmain\n\n# 工作模式配置\nevents { }\n\n# http 配置\nhttp {\n   \n\t# 服务器主机配置\n    server { }\n   \n\t# 路由配置\n    location { }\n\n\t# 负载均衡配置\n    upstream name {  }\n}\n\n\n配置文档 :\n\n * http://www.gwznkj.cn\n * http://shouce.jb51.net/nginx/left.html\n * https://blog.csdn.net/qq_33454884/article/details/89212702\n\n# 主要配置\n\nserver {\n   \n\t# 端口\n    listen 80;\n   \n\t# 域名\n    server_name localhost  192.168.1.100;\n   \n\t# 代表这是项目根目录\n    location / {\n       \n\t\t# 虚拟目录\n        root /usr/share/nginx/www;\n    }\n}\n\n\n# 负载均衡配置\n\nhttp{\n\tupstream myweb {\n\n\t\t# 两个服务器\n    \tserver localhost:8080; 　　\n    \tserver localhost:8081;\n\t}\n\tserver {\n\t    listen 80;\n       \n\t\t# 路由对应\n\t    location / {\n\t        proxy_pass http://myweb;\n\t    }\n\t}\n}\n\n\n> 需要对应路由才能进行访问后端指定路由\n\n\n# docker\n\n利用docker安装nginx实现反向代理\n\n 1. 安装镜像 nginx\n\n 2. 创建配置文件 (运行docker挂载的配置)\n    \n    # 创建挂载目录\n     mkdir -p /home/nginx/conf\n    mkdir -p /home/nginx/log\n    mkdir -p /home/nginx/html\n    \n\n 3. 拷贝主要配置到宿主机\n    \n     # 生成容器\n     docker run --name nginx -p 9001:80 -d nginx\n    \n     # 将容器nginx.conf文件复制到宿主机\n     docker cp nginx:/etc/nginx/nginx.conf /home/nginx/conf/nginx.conf\n     \n     # 将容器conf.d文件夹下内容复制到宿主机\n    docker cp nginx:/etc/nginx/conf.d /home/nginx/conf/conf.d\n    \n     # 将容器中的html文件夹复制到宿主机\n    docker cp nginx:/usr/share/nginx/html /home/nginx/\n    \n\n 4. 运行 nginx容器\n    \n    docker run \\\n    -p 9002:80 \\\n    --name nginx \\\n    -v /home/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \\\n    -v /home/nginx/conf/conf.d:/etc/nginx/conf.d \\\n    -v /home/nginx/log:/var/log/nginx \\\n    -v /home/nginx/html:/usr/share/nginx/html \\\n    -d nginx:latest\n    \n\n 5. 访问 [ip]:9002 即可\n\n命令                 说明\n-name [名称]         命名\n-d                 后台运行\n-p [宿主端口]:[容器端口]   端口映射\n-v [宿主路径]:[容器路径]   配置文件挂载\nnginx:latest       本地运行的版本\n\\                  shell 命令换行\n\n\n# nginx proxy manger\n\n官方 : https://nginxproxymanager.com/\n\nnginx 的进化 , 简化了nginx操作 , 图形化ui操作",charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Bootstrap",frontmatter:{title:"Bootstrap",author:"柏竹",permalink:"/web/1hg7wa",date:"2020-02-18T00:00:00.000Z",categories:["前端","UI"],tags:["UI框架","Bootstrap"]},regularPath:"/02.%E5%89%8D%E7%AB%AF/02.%E6%8A%80%E6%9C%AF%E6%8B%93%E5%B1%95/01.Bootstrap.html",relativePath:"02.前端/02.技术拓展/01.Bootstrap.md",key:"v-6af45ef5",path:"/web/1hg7wa/",headers:[{level:2,title:"引入",slug:"引入",normalizedTitle:"引入",charIndex:83},{level:2,title:"按钮",slug:"按钮",normalizedTitle:"按钮",charIndex:229},{level:2,title:"表格",slug:"表格",normalizedTitle:"表格",charIndex:2615},{level:2,title:"网格系统",slug:"网格系统",normalizedTitle:"网格系统",charIndex:5342},{level:2,title:"图片",slug:"图片",normalizedTitle:"图片",charIndex:7677},{level:2,title:"表单",slug:"表单",normalizedTitle:"表单",charIndex:9007},{level:2,title:"标题",slug:"标题",normalizedTitle:"标题",charIndex:16585},{level:2,title:"其他",slug:"其他",normalizedTitle:"其他",charIndex:16889},{level:3,title:"文本",slug:"文本",normalizedTitle:"文本",charIndex:9605},{level:3,title:"背景",slug:"背景",normalizedTitle:"背景",charIndex:17200},{level:3,title:"提示",slug:"提示",normalizedTitle:"提示",charIndex:589},{level:3,title:"进度条",slug:"进度条",normalizedTitle:"进度条",charIndex:17907},{level:3,title:"更多",slug:"更多",normalizedTitle:"更多",charIndex:18568},{level:2,title:"导航栏",slug:"导航栏",normalizedTitle:"导航栏",charIndex:22918},{level:2,title:"轮播图",slug:"轮播图",normalizedTitle:"轮播图",charIndex:24690}],headersStr:"引入 按钮 表格 网格系统 图片 表单 标题 其他 文本 背景 提示 进度条 更多 导航栏 轮播图",content:'# Bootstrap\n\nBootstrap用于快速开发Web应用程序和网站的框架. 支持多平台设备. 它基于 HTML、CSS、JavaScript 应用\n\n\n# 引入\n\n 1. 文件 引入bootstrap的支持, js、css、font文件\n 2. JS 先引入JQ库，再引入bootstrap的js文件\n 3. CSS 先引入bootstrap的css，在引入自己的css\n 4. FONT 文件无需引入，但必须存在目录\n\n点击在线教学文档\n\n\n# 按钮\n\n主要 作用在 <a>/<button>/<input> 标签中\n\n默认样式\n\n<a class="btn btn-default" href="#" role="button">a</a>\n<button class="btn btn-default" type="submit">Button</button>\n<input class="btn btn-default" type="button" value="Input">\n<input class="btn btn-default" type="submit" value="Submit">\n\n\n类             说明\nbtn           按钮基本样式\nbtn-default   标准按钮\nbtn-primary   原始按钮\n提示按钮          提示按钮说明\nbtn-success   成功提示按钮\nbtn-info      弹 信息按钮\nbtn-warning   谨慎 操作按钮\nbtn-danger    危险 操作按钮\nbtn-link      链接按钮\n按钮大小          按钮大小说明\nbtn-lg        大按钮\nbtn-sm        小按钮\nbtn-xs        超小按钮\n状态按钮          状态按钮说明\nbtn-block     块级按钮\nactive        按钮 被点击\ndisabled      禁用按钮\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script type="text/javascript" src="../js/jquery-1.11.1.js"><\/script>\n    <script type="text/javascript" src="../js/bootstrap.js"><\/script>\n    <link rel="stylesheet" href="../css/bootstrap.css">\n    <link rel="stylesheet" href="../css/bootstrap-theme.css">\n</head>\n<body>\n    <h1>按钮样式展示</h1>\n    <h2>样式展示</h2>\n    <button class="btn ">按钮</button>\n    <button class="btn btn-default">标准按钮</button>\n    <button class="btn btn-primary">原始按钮</button>\n    <button class="btn btn-success">成功操作按钮</button>\n    <button class="btn btn-info">弹出消息按钮</button>\n    <button class="btn btn-warming">谨慎操作按钮</button>\n    <button class="btn btn-danger">危险操作按钮</button>\n    <button class="btn btn-link">链接按钮</button>\n    <br>\n    <h2>大小展示</h2>\n    <button class="btn btn-lg">大按钮</button>\n    <button class="btn btn-sm">小按钮</button>\n    <button class="btn btn-xs">超小按钮</button>\n    <button class="btn btn-block">块级按钮</button>\n    <br>\n    <h2>状态展示</h2>\n    <p>\n        <button class="btn btn-default">标准按钮</button>\n        <button class="btn btn-default active">选中标准按钮</button>\n        <button class="btn btn-default disabled">禁用标准按钮</button>\n    </p>\n    <p>\n        <button class="btn btn-primary">原始按钮</button>\n        <button class="btn btn-primary active">选中原始按钮</button>\n        <button class="btn btn-primary disabled">禁用原始按钮</button>\n    </p>\n    <br>\n    <h2>标签展示</h2>\n    <p>\n        <a class="btn btn-default" href="#">链接</a>\n        <button class="btn btn-default" type="submit">按钮</button>\n        <input class="btn btn-default" type="button" value="输入">\n        <input class="btn btn-default" type="submit" value="提交">\n    </p>\n</body>\n</html>\n\n\n\n# 表格\n\nTABLE标签                    说明\ntable                      基本样式\ntable-striped              隔行添加斑马线\ntable-bordered             添加边框\ntable-hover                鼠标悬停状态\ntable-condensed            表格更紧凑\n<tr>/<th> / <td> 标签 (状态)   说明\nactive                     悬停鼠标\nsuccess                    成功操作\ninfo                       变化操作\nwarning                    警告操作\ndanger                     危险操作\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script type="text/javascript" src="../js/jquery-1.11.1.js"><\/script>\n    <script type="text/javascript" src="../js/bootstrap.js"><\/script>\n    <link rel="stylesheet" href="../css/bootstrap.css">\n    <link rel="stylesheet" href="../css/bootstrap-theme.css">\n</head>\n<body>\n    <h1>表格样式展示</h1>\n    <h2>table类样式联合使用</h2>\n    <div>\n        <table class="table table-striped table-bordered table-hover table-condensed">\n            <tr>\n                <th>作用范围</th>\n                <th>样式类</th>\n                <th>说明</th>\n            </tr>\n            <tr>\n                <td>table</td>\n                <td>table</td>\n                <td>添加基础样式</td>\n            </tr>\n            <tr>\n                <td>table</td>\n                <td>table-striped</td>\n                <td>添加斑马线</td>\n            </tr>\n            <tr>\n                <td>table</td>\n                <td>table-bordered</td>\n                <td>添加单元格边框</td>\n            </tr>\n            <tr>\n                <td>table</td>\n                <td>table-hover</td>\n                <td>添加悬停变暗</td>\n            </tr>\n            <tr>\n                <td>table</td>\n                <td>table-condensed</td>\n                <td>设置紧凑</td>\n            </tr>\n        </table>\n    </div>\n    <h2>tr、th、td类 样式联合使用</h2>\n    <div>\n        <table class="table table-striped table-bordered">\n            <tr>\n                <th>作用范围</th>\n                <th>样式类</th>\n                <th>说明</th>\n            </tr>\n            <tr class="active">\n                <td>tr标签</td>\n                <td>active</td>\n                <td>悬停 样式应用</td>\n            </tr>\n            <tr class="success">\n                <td>tr标签</td>\n                <td>success</td>\n                <td>成功 样式应用</td>\n            </tr>\n            <tr class="info">\n                <td>tr标签</td>\n                <td>info</td>\n                <td>变化 样式应用</td>\n            </tr>\n            <tr class="warning">\n                <td>tr标签</td>\n                <td>warning</td>\n                <td>警告 样式应用</td>\n            </tr>\n            <tr class="danger">\n                <td>tr标签</td>\n                <td>danger</td>\n                <td>危险 样式应用</td>\n            </tr>\n        </table>\n    </div>\n</body>\n</html>\n\n\n\n# 网格系统\n\n跟表格差不多，但网格系统可设置多设备，兼容性更好！\n\n生成前系统会自动分配12列的个数\n\n设备使用样式说明\n\n           手机         平板电脑       台式电脑       大型台式电脑\n设备应用范围     <768px     ≥768px     ≥992px     ≥1200px\nClass 前缀   col-xs-*   col-sm-*   col-md-*   col-lg-*\n\n网格类                          说明\ncontainer                    表示网格整体\nrow                          网格行\ncol-{设备}-{列数}                网格列\ncol-{设备}-{列数}-offset-{偏移数}   偏移列（指定开始位置）\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script type="text/javascript" src="../js/jquery-1.11.1.js"><\/script>\n    <script type="text/javascript" src="../js/bootstrap.js"><\/script>\n    <link rel="stylesheet" href="../css/bootstrap.css">\n    <link rel="stylesheet" href="../css/bootstrap-theme.css">\n    <style>\n        div {\n            background: rgb(52, 223, 157);\n            border: rgb(0, 0, 0) solid 1px;\n        }\n    </style>\n</head>\n<body>\n    <h1>网格系统</h1>\n    <h2>标准网格</h2>\n    <p>支持手机 电脑端</p>\n    <div class="container">\n        <div class="row">\n            <div class="col-lg-12 col-xs-12">嵌套列测试</div>\n        </div>\n        <div class="row">\n            <div class="col-lg-1 col-xs-1">列</div>\n            <div class="col-lg-1 col-xs-1">列</div>\n            <div class="col-lg-1 col-xs-1">列</div>\n            <div class="col-lg-1 col-xs-1">列</div>\n            <div class="col-lg-1 col-xs-1">列</div>\n            <div class="col-lg-1 col-xs-1">列</div>\n            <div class="col-lg-1 col-xs-1">列</div>\n            <div class="col-lg-1 col-xs-1">列</div>\n            <div class="col-lg-1 col-xs-1">列</div>\n            <div class="col-lg-1 col-xs-1">列</div>\n            <div class="col-lg-1 col-xs-1">列</div>\n            <div class="col-lg-1 col-xs-1">列</div>\n        </div>\n        <div class="row">\n            <div class="col-lg-6 col-xs-6">六列</div>\n            <div class="col-lg-6 col-xs-6">六列</div>\n        </div>\n        <div class="row">\n            <div class="col-lg-3 col-xs-3">三列</div>\n            <div class="col-lg-9 col-xs-9">九列</div>\n        </div>\n        <div class="row">\n            <div class="col-lg-12 col-xs-12">偏移列测试</div>\n        </div>\n        <div class="row">\n            <div class="col-lg-1 col-xs-1">列</div>\n            <div class="col-lg-offset-4 col-xs-offset-4">偏移量四（偏移后该列后面独占一行，不能添加）</div>\n        </div>\n    </div>\n</body>\n</html>\n\n\n\n# 图片\n\nIMG类             说明\nimg-rounded      圆角\nimg-circle       圆形\nimg-thumbnail    缩略图功能\nimg-responsive   图片响应式 (图片扩展父类100%)\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script type="text/javascript" src="../js/jquery-1.11.1.js"><\/script>\n    <script type="text/javascript" src="../js/bootstrap.js"><\/script>\n    <link rel="stylesheet" href="../css/bootstrap.css">\n    <link rel="stylesheet" href="../css/bootstrap-theme.css">\n    <script>\n        $(function(){\n            $("img").attr("src","http://sanscan12.gitee.io/blogimg/Cover/article%2002.jpg");\n        });\n    <\/script>\n    <style>\n        img {\n            width: 400px;\n            height: 300px;\n        }\n        div{\n            display: inline-block;\n        }\n    </style>\n</head>\n<body>\n    <h1>图片样式展示</h1>\n    <div>\n        <span>无样式</span><br>\n        <img>\n    </div>\n    <div>\n        <span>圆角 (img-rounded 类样式)</span><br>\n        <img class="img-rounded">\n    </div>\n    <div>\n        <span>圆形 (img-circle 类样式)</span><br>\n        <img class="img-circle">\n    </div>\n    <div>\n        <span>内边距框 (img-thumbnail 类样式)</span><br>\n        <img class="img-thumbnail">\n    </div>\n    <div>\n        <span>响应式 (img-responsive 类样式)</span><br>\n        <img class="img-responsive">\n    </div>\n</body>\n</html>\n\n\n\n# 表单\n\n将 label 元素和前面提到的控件包裹在 .form-group 中可以获得最好的排列\n\n表单类               作用标签                           说明\n属性 role="form"    <form>                         标准表单\nform-inline       <form>                         内联表单\nform-horizontal   <form>                         水平表单\ncontrol-label     标签、控件                          网格布局模式\ncol-{设备}-{列数}     标签、控件                          网格设置\nform-group        标签、控件                          标准：适当行高间距\n                                                 内联：内行元素\n                                                 水平：适当行高间距\nform-control      <input> 、<textarea>、<select>   文本元素（设置输入框）\nradio             标签                             单选按钮\ncheckbox          标签                             多选按钮\nradio-inline      标签                             内行单选按钮\ncheckbox-inline   标签                             内行多选按钮\ninput-{设备}        控件                             控件高度\nhelp-block        <span>                         帮助文档 提示作用\n属性 disabled       控件                             禁止输入\nhas-success       标签                             成功 提示\nhas-warning       标签                             警告 提示\nhas-error         标签                             错误 提示\n\n应用实例\n\n<!DOCTYPE html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script type="text/javascript" src="../js/jquery-1.11.1.js"><\/script>\n    <script type="text/javascript" src="../js/bootstrap.js"><\/script>\n    <link rel="stylesheet" href="../css/bootstrap.css">\n    <link rel="stylesheet" href="../css/bootstrap-theme.css">\n</head>\n\n<body>\n    <h1>表单</h1>\n    <h2>基本表单</h2>\n    <form action="#" role="form">\n        <div class="form-group">\n            <label for="name">名称：</label>\n            <input type="text" class="form-control" name="name" placeholder="请输入用户名称">\n        </div>\n        <div class="form-group">\n            <label for="password">密码：</label>\n            <input type="password" class="form-control" name="password">\n        </div>\n    </form>\n\n\n    <h2>内联表单</h2>\n    <form action="#" role="form" class="form-inline">\n        <div class="form-group">\n            <label for="name">名称：</label>\n            <input type="text" class="form-control" name="name" placeholder="请输入用户名称">\n        </div>\n        <div class="form-group">\n            <label for="password">密码：</label>\n            <input type="password" class="form-control " name="password">\n        </div>\n    </form>\n\n\n    <h2>水平表单</h2>\n    <form action="#" role="form" class="form-horizontal">\n        <div class="form-group">\n            <label for="name" class="col-xs-2 col-lg-2 control-label">名称：</label>\n            <div class="col-xs-6 col-lg-6">\n                <input type="text" class="form-control control-label" name="name" placeholder="请输入用户名称">\n            </div>\n        </div>\n        <div class="form-group">\n            <label for="password" class="col-xs-2 col-lg-2 control-label">密码：</label>\n            <div class="col-xs-6 col-lg-6">\n                <input type="password" class="form-control control-label" name="password" placeholder="密码不少六位">\n            </div>\n        </div>\n        <div class="form-group">\n            <label for="protocol" class="col-xs-2 col-lg-2 control-label">协议:</label>\n            <div class="col-xs-6 col-lg-6">\n                <textarea name="protocol" id="protocol" rows="3" class="form-control control-label"></textarea>\n            </div>\n        </div>\n    </form>\n\n\n    <h2>控件应用</h2>\n    <form action="#" role="form">\n\n        <div class="form-group">\n            <label for="name">名称：（输入）</label>\n            <input type="text" class="form-control" name="name" placeholder="请输入用户名称">\n        </div>\n\n        <div class="form-group">\n            <label>性别：（单选）</label>\n            <div class="radio">\n                <label>\n                    <input type="radio" value="男" name="sex">\n                    男\n                </label>\n            </div>\n            <div class="radio">\n                <label>\n                    <input type="radio" value="女" name="sex">\n                    女\n                </label>\n            </div>\n        </div>\n\n        <div class="form-group">\n            <label>爱好：（多选）</label>\n            <div class="checkbox-inline">\n                <input type="checkbox" value="篮球" name="hobby">篮球\n            </div>\n            <div class="checkbox-inline">\n                <input type="checkbox" value="足球" name="hobby">足球\n            </div>\n            <div class="checkbox-inline">\n                <input type="checkbox" value="网球" name="hobby">网球\n            </div>\n        </div>\n\n\n        <div class="form-group">\n            <label for="age">年龄：（单选列表）</label>\n            <select class="form-control">\n                <option value="16">16</option>\n                <option value="17">17</option>\n                <option value="18">18</option>\n                <option value="19">19</option>\n                <option value="20">20</option>\n                <option value="21">21</option>\n                <option value="22">22</option>\n            </select>\n        </div>\n\n\n        <div class="form-group">\n            <label for="age">部门：（多项列表）</label>\n            <select multiple class="form-control">\n\n                <option value="1">编辑部</option>\n                <option value="2">外联部</option>\n                <option value="3">财务部</option>\n                <option value="4">传媒部</option>\n            </select>\n        </div>\n\n        <div class="form-group">\n            <label for="protocol">协议：（文本）</label>\n            <textarea name="protocol" id="protocol" cols="40" rows="3"></textarea>\n        </div>\n    </form>\n\n    <h2>状态展示</h2>\n    <form action="#" role="form">\n        <div class="form-group">\n            <label>禁用 输入框</label>\n            <input type="text" class="form-control" disabled>\n        </div>\n\n        <div class="form-group">\n            <label for="age">年龄：</label>\n            <select class="form-control" disabled>\n                <option value="-1">禁止选择</option>\n                <option value="16">16</option>\n                <option value="17">17</option>\n                <option value="18">18</option>\n            </select>\n        </div>\n\n        <div class="form-group">\n            <label>大型台式测试 输入框</label>\n            <input type="text" class="form-control input-lg" placeholder="大小字体测试">\n        </div>\n        <div class="form-group">\n            <label>台式测试 输入框</label>\n            <input type="text" class="form-control input-md" placeholder="大小字体测试">\n        </div>\n        <div class="form-group">\n            <label>平板测试 输入框</label>\n            <input type="text" class="form-control input-sm" placeholder="大小字体测试">\n        </div>\n        <div class="form-group">\n            <label>手机测试 输入框</label>\n            <input type="text" class="form-control input-xs" placeholder="大小字体测试">\n        </div>\n\n\n        <div class="form-group has-success">\n            <label>完成 输入框</label>\n            <input type="text" class="form-control">\n        </div>\n        <div class="form-group has-warning">\n            <label>警告 输入框</label>\n            <input type="text" class="form-control">\n        </div>\n        <div class="form-group has-error">\n            <label>错误 输入框</label>\n            <input type="text" class="form-control">\n        </div>\n        \n        <div class="form-group">\n            <label>输入框（帮助文档）</label>\n            <input type="text" class="form-control">\n            <span class="help-block">\n                一个较长的帮助文本块，超过一行，\n            15. 需要扩展到下一行。本实例中的帮助文本总共有两行\n            </span>\n        </div>\n    </form>\n    \n</body>\n</html>\n\n\n\n# 标题\n\n<body>\n    <h1>排版</h1>\n    <h2>内联标题测试 <span class="small">内联子标题 测试</span></h2>\n    <h3>内联标题测试 <span class="small">内联子标题 测试</span></h3>\n    <h2>标题摘要</h2>\n    <p class="lead">\n        测试测试测试测试测试测试测试测试测\n        试测试测试测试测试测试测试测试测试\n        测试测试测试测试测试测试测试测试测\n        试测试测试测试测试测试测试测试测试\n    </p>\n</body>\n\n\n\n# 其他\n\n\n# 文本\n\n类                              说明\ntext-muted                     白灰色\ntext-primary                   深蓝色\ntext-success                   成功色（白绿色\ntext-info                      信息色（浅蓝色\ntext-warning                   警告色（白黄色\ntext-danger                    错误色（桃红色\ntext-[left | rigth | center]   对齐方式\n\n\n# 背景\n\n类            说明\nbg-primary   深蓝色 背景样式\nbg-success   白绿色 背景样式\nbg-info      浅蓝色 背景样式\nbg-warning   白黄色 背景样式\nbg-danger    桃红色 背景样式\n\n\n# 提示\n\n类               说明\nalert-success   成功 提示\nalert-info      注意 提示\nalert-warning   警告 提示\nalert-danger    错误 提示\n\n提示框添加 关闭按钮：\n\n>  1. 添加带有 .alert、.alert-dismissable 两个类的 <div>\n>  2. <div> 内有 属性：class ="close" data-dismiss ="alert" 的<button>\n>  3. 显示点击控件 <button> 内容：&times;\n\n提示框添加 链接：\n\n> 提示标签 内添加 <a> 添加类：.alert-link (链接匹配标签颜色)\n\n<div class="alert alert-danger alert-dismissable">\n    <button class="close" data-dismiss="alert" >&times;</button>\n    错误(添加右侧删除按钮)\n</div>\n\n<div class="alert alert-warning">\n    <a href="#" class="alert-link">警告！请不要提交（链接点击查看填写详细）</a>\n</div>\n\n\n\n# 进度条\n\n类                                                     说明\nprogress                                              进度条框架\nprogress-bar                                          进度显示\n属性 style="width: {百分比};"                              进度进程\nprogress-bar-{success \\| info \\| warning \\| danger}   进度样式\nprogress-striped                                      条纹进度条\nactive                                                动画进度条（配合条纹使用）\n\n进度条 添加：\n\n>  1. 添加带有 .progress 的 <div> （框架类）\n>  2. <div> 内有 属性 .progress-bar （进度显示） style="width: 40%;" （目前进度）\n\n<div class="container progress" style="padding: 0;">\n    <div class="progress-bar" style="width: 40%;"></div>\n</div>\n\n\n\n# 更多\n\n类              说明\npull-left      元素浮动到左边\npull-right     元素浮动到右边\ncenter-block   设置元素 并居中显示\nclearfix       清除浮动\nshow           强制元素显示\nhidden         强制元素隐藏\nclose          显示关闭按钮\ncaret          显示下拉式功能\n\n<!DOCTYPE html>\n<html lang="en">\n\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script type="text/javascript" src="../js/jquery-1.11.1.js"><\/script>\n    <script type="text/javascript" src="../js/bootstrap.js"><\/script>\n    <link rel="stylesheet" href="../css/bootstrap.css">\n    <link rel="stylesheet" href="../css/bootstrap-theme.css">\n</head>\n\n<body>\n    <h1>辅助类测试</h1>\n\n    <h2>文本</h2>\n    <p class="text-muted">text-muted 文本测试</p>\n    <p class="text-primary">text-primary 文本测试</p>\n    <p class="text-success">text-success 文本测试</p>\n    <p class="text-info">text-info 文本测试</p>\n    <p class="text-warning">text-warning 文本测试</p>\n    <p class="text-danger">text-danger 文本测试</p>\n\n    <h2>背景</h2>\n    <p class="bg-primary">bg-primary 背景测试</p>\n    <p class="bg-success">bg-success 背景测试</p>\n    <p class="bg-info">bg-info 背景测试</p>\n    <p class="bg-warning">bg-warning 背景测试</p>\n    <p class="bg-danger">bg-danger 背景测试</p>\n\n    <h2>提示</h2>\n    <div class="container">\n        <div class="alert alert-success">alert-success 成功提示</div>\n        <div class="alert alert-info">alert-info 信息提示</div>\n        <div class="alert alert-warning">alert-warning 警告提示</div>\n        <div class="alert alert-danger">alert-danger 错误提示</div>\n    </div>\n    <h3>其他提示操作</h3>\n    <div class="container">\n\n        <div class="alert alert-danger alert-dismissable">\n            <button class="close" data-dismiss="alert" >&times;</button>\n            错误(添加右侧删除按钮)\n        </div>\n\n        <div class="alert alert-warning">\n            <a href="#" class="alert-link">警告！请不要提交（链接点击查看填写详细）</a>\n        </div>\n\n    </div>\n\n    <h2>进度条</h2>\n    <h3>默认进度条</h3>\n    <div class="container progress" style="padding: 0;">\n        <div class="progress-bar" role="progressbar" aria-valuenow="60" aria-valuemin="0" aria-valuemax="100" style="width: 40%;">\n            <span class="sr-only">40%</span>\n        </div>\n    </div>\n    <div class="container progress" style="padding: 0;">\n        <div class="progress-bar"style="width: 40%;"></div>\n    </div>\n    <h3>不同样式进度条 （progress-bar-*）</h3>\n    <div class="container progress" style="padding: 0;">\n        <div class="progress-bar progress-bar-success" style="width: 90%;"></div>\n    </div>\n    <div class="container progress" style="padding: 0;">\n        <div class="progress-bar progress-bar-info" style="width: 70%;"></div>\n    </div>\n    <div class="container progress" style="padding: 0;">\n        <div class="progress-bar progress-bar-warning"style="width: 50%;"></div>\n    </div>\n    <div class="container progress" style="padding: 0;">\n        <div class="progress-bar progress-bar-danger" style="width: 30%;"></div>\n    </div>\n    <h3>条纹进度条 (progress-striped) </h3>\n    <div class="container progress progress-striped" style="padding: 0;">\n        <div class="progress-bar" style="width: 80%;"></div>\n    </div>\n    <h3>动画进度条 （progress-striped、active）</h3>\n    <div class="container progress progress-striped active" style="padding: 0;">\n        <div class="progress-bar"style="width: 60%;"></div>\n    </div>\n    <h3>堆叠进度条</h3>\n    <div class="container progress" style="padding: 0;">\n        <div class="progress-bar progress-bar-danger"  style="width: 30%;"></div>\n        <div class="progress-bar progress-bar-warning" style="width: 30%;"></div>\n        <div class="progress-bar progress-bar-success" style="width: 30%;"></div>\n    </div>\n\n\n    <h2>其他</h2>\n    <h3>浮动 测试</h3>\n    <div class="container bg-warning">\n        <button class="pull-left">左浮动</span>\n            <button class="pull-right">右浮动</button>\n    </div>\n    <h3>消除浮动 测试</h3>\n    <div class="container bg-warning clearfix">\n        <button class="pull-left">左浮动</span>\n            <button class="pull-right">右浮动</button>\n    </div>\n    <h3>盒子居中 测试</h3>\n    <div class="container bg-success center-block" style="width:80%; height: 100px;"></div>\n    <h3>显示与隐藏 测试</h3>\n    <div>\n        <p class="hidden">隐藏测试</p>\n        <p class="show">显示测试</p>\n    </div>\n    <h3>关闭按钮 测试</h3>\n    <div class="container bg-info alert alert-dismissable">\n        <button class="close" data-dismiss="alert">&times;</button>\n    </div>\n</body>\n</html>\n\n\n\n# 导航栏\n\n作用范围    类                      说明\n<nav>   navbar                 设置导航栏\n<nav>   navbar-default         设置导航栏\n<nav>   属性 role="navigation"   可访问\n标签      navbar-header          第一个导航栏\n<a>     navbar-brand           文本大一号\n<ul>    nav                    设置导航栏中的链接项\n<ul>    navbar-nav             设置导航栏中的链接项\nli      active                 禁用链接选项\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script type="text/javascript" src="../js/jquery-1.11.1.js"><\/script>\n    <script type="text/javascript" src="../js/bootstrap.js"><\/script>\n    <link rel="stylesheet" href="../css/bootstrap.css">\n    <link rel="stylesheet" href="../css/bootstrap-theme.css">\n</head>\n<body>\n    <nav class="navbar navbar-default" role="navigation">\n        <div class="navbar-header">\n            <a href="#" class="navbar-brand">首页测试</a>\n        </div>\n        <ul class="nav navbar-nav">\n            <li class="active"><a href="#">ios</a></li>\n            <li><a href="#">Python</a></li>\n            <li><a href="#">Java</a></li>\n            <li><a href="#">JavaScript</a></li>\n            <li class="dropdown">\n                <a href="#" class="dropdown-toggle" data-toggle="dropdown">\n                    Java<b class="caret"></b>\n                </a>\n                <ul class="dropdown-menu">\n                    <li><a href="#">Test1</a></li>\n                    <li><a href="#">Test2</a></li>\n                    <li><a href="#">Test3</a></li>\n                    <li class="divider"></li>\n                    <li><a href="#">Test4(分割测试)</a></li>\n                    <li class="divider"></li>\n                    <li><a href="#">Test5(分割测试)</a></li>\n                </ul>\n            </li>\n        </ul>\n    </nav>\n</body>\n</html>\n\n\n\n# 轮播图\n\n轮播图应用：\n\n 1. 添加带有 .carousel 、.slide 的 <div> ，并且给定一个id属性（轮播图框架）\n 2. <div> 内有 .carousel-indicators 的 <ol> （轮播指标）\n 3. <ol> 中的 data-slide-to={索引}、data-target="#{id值}" <li> （控制轮播属性）\n 4. <div> 内的 .carousel-inner 用来（定义图片）\n 5. 包含 .carousel-inner 的<div> 中的每个 .item 用于定义图片\n 6. 添加有 .active 代表当前显示的图片\n 7. 最后 <a> （用户手动轮播） <a href="#{id值}" class="carousel-control left" data-slide="prev">&lt;</a> <a href="#{id值}" class="carousel-control right" data-slide="next">&gt;</a>\n\n其他功能\n\n.item 内的 .carousel-caption 元素向添加标题\n\n轮播图属性选项\n\n// 一定是指定是轮播jq对象\n$(\'.carousel\').carousel({<选项>})\n\n\n属性名        值               描述\ninterval   number          自动轮播 指定 时间秒\npause      string / null   停止轮播的时间 参数有 "hover","mouseenter","mouseleave","null"\nwrap       boolean         是否连续循环轮播\nkeyboard   boolean         是否对应响应事件\n\n<!DOCTYPE html>\n<html lang="en">\n<head>\n    <meta charset="UTF-8">\n    <title>Document</title>\n    <script type="text/javascript" src="../js/jquery-1.11.1.js"><\/script>\n    <script type="text/javascript" src="../js/bootstrap.js"><\/script>\n    <link rel="stylesheet" href="../css/bootstrap.css">\n    <link rel="stylesheet" href="../css/bootstrap-theme.css">\n    <style>\n        .box {\n            width: 500px;\n            height: 300px;\n            margin-top: 50px;\n            padding: 0;\n        }\n\n        .carousel-control {\n            width: 50px;\n            line-height: 300px;\n        }\n    </style>\n    <script>\n        $(function () {\n            var csel = $("#myCarousel");\n\n            $("button:eq(0)").click(function(){\n                csel.carousel({\n                    interval:2000\n                });\n            });\n\n            $("button:eq(1)").click(function(){\n                //hover、 pause \n                csel.carousel(\'pause\');\n            });\n\n            $("button:eq(2)").click(function () {\n                csel.carousel(\'next\');\n            });\n            $("button:eq(3)").click(function () {\n                csel.carousel(\'prev\');\n            });\n        });\n    <\/script>\n</head>\n\n<body>\n    <button>一秒轮播</button>\n    <button>停止轮播</button>\n    <button>往下轮播</button>\n    <button>往上轮播</button>\n\n    <div id="myCarousel" class="container carousel slide box">\n        \x3c!-- 轮播指标 --\x3e\n        <ol class="carousel-indicators">\n            <li data-target="#myCarousel" data-slide-to="0" class="active"></li>\n            <li data-target="#myCarousel" data-slide-to="1"></li>\n            <li data-target="#myCarousel" data-slide-to="2"></li>\n            <li data-target="#myCarousel" data-slide-to="3"></li>\n            <li data-target="#myCarousel" data-slide-to="4"></li>\n            <li data-target="#myCarousel" data-slide-to="5"></li>\n        </ol>\n        \x3c!-- 轮播图片 --\x3e\n        <div class="carousel-inner">\n            <div class="item active">\n                <img src="http://sanscan12.gitee.io/blogimg/Cover/article 03.jpg" alt="1">\n                <div class="carousel-caption">\n                    添加标签\n                </div>\n            </div>\n            <div class="item">\n                <img src="http://sanscan12.gitee.io/blogimg/Cover/article 02.jpg" alt="2">\n                \n            </div>\n            <div class="item">\n                <img src="http://sanscan12.gitee.io/blogimg/Cover/article 18.jpg" alt="3">\n            </div>\n            <div class="item">\n                <img src="http://sanscan12.gitee.io/blogimg/Cover/article 14.jpg" alt="4">\n            </div>\n            <div class="item">\n                <img src="http://sanscan12.gitee.io/blogimg/Cover/article 16.jpg" alt="5">\n            </div>\n        </div>\n        \x3c!-- 轮播滑动按钮 --\x3e\n        <a href="#myCarousel" class="carousel-control left" data-slide="prev">&lt;</a>\n        <a href="#myCarousel" class="carousel-control right" data-slide="next">&gt;</a>\n    </div>\n\n</body>\n\n</html>\n',normalizedContent:'# bootstrap\n\nbootstrap用于快速开发web应用程序和网站的框架. 支持多平台设备. 它基于 html、css、javascript 应用\n\n\n# 引入\n\n 1. 文件 引入bootstrap的支持, js、css、font文件\n 2. js 先引入jq库，再引入bootstrap的js文件\n 3. css 先引入bootstrap的css，在引入自己的css\n 4. font 文件无需引入，但必须存在目录\n\n点击在线教学文档\n\n\n# 按钮\n\n主要 作用在 <a>/<button>/<input> 标签中\n\n默认样式\n\n<a class="btn btn-default" href="#" role="button">a</a>\n<button class="btn btn-default" type="submit">button</button>\n<input class="btn btn-default" type="button" value="input">\n<input class="btn btn-default" type="submit" value="submit">\n\n\n类             说明\nbtn           按钮基本样式\nbtn-default   标准按钮\nbtn-primary   原始按钮\n提示按钮          提示按钮说明\nbtn-success   成功提示按钮\nbtn-info      弹 信息按钮\nbtn-warning   谨慎 操作按钮\nbtn-danger    危险 操作按钮\nbtn-link      链接按钮\n按钮大小          按钮大小说明\nbtn-lg        大按钮\nbtn-sm        小按钮\nbtn-xs        超小按钮\n状态按钮          状态按钮说明\nbtn-block     块级按钮\nactive        按钮 被点击\ndisabled      禁用按钮\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script type="text/javascript" src="../js/jquery-1.11.1.js"><\/script>\n    <script type="text/javascript" src="../js/bootstrap.js"><\/script>\n    <link rel="stylesheet" href="../css/bootstrap.css">\n    <link rel="stylesheet" href="../css/bootstrap-theme.css">\n</head>\n<body>\n    <h1>按钮样式展示</h1>\n    <h2>样式展示</h2>\n    <button class="btn ">按钮</button>\n    <button class="btn btn-default">标准按钮</button>\n    <button class="btn btn-primary">原始按钮</button>\n    <button class="btn btn-success">成功操作按钮</button>\n    <button class="btn btn-info">弹出消息按钮</button>\n    <button class="btn btn-warming">谨慎操作按钮</button>\n    <button class="btn btn-danger">危险操作按钮</button>\n    <button class="btn btn-link">链接按钮</button>\n    <br>\n    <h2>大小展示</h2>\n    <button class="btn btn-lg">大按钮</button>\n    <button class="btn btn-sm">小按钮</button>\n    <button class="btn btn-xs">超小按钮</button>\n    <button class="btn btn-block">块级按钮</button>\n    <br>\n    <h2>状态展示</h2>\n    <p>\n        <button class="btn btn-default">标准按钮</button>\n        <button class="btn btn-default active">选中标准按钮</button>\n        <button class="btn btn-default disabled">禁用标准按钮</button>\n    </p>\n    <p>\n        <button class="btn btn-primary">原始按钮</button>\n        <button class="btn btn-primary active">选中原始按钮</button>\n        <button class="btn btn-primary disabled">禁用原始按钮</button>\n    </p>\n    <br>\n    <h2>标签展示</h2>\n    <p>\n        <a class="btn btn-default" href="#">链接</a>\n        <button class="btn btn-default" type="submit">按钮</button>\n        <input class="btn btn-default" type="button" value="输入">\n        <input class="btn btn-default" type="submit" value="提交">\n    </p>\n</body>\n</html>\n\n\n\n# 表格\n\ntable标签                    说明\ntable                      基本样式\ntable-striped              隔行添加斑马线\ntable-bordered             添加边框\ntable-hover                鼠标悬停状态\ntable-condensed            表格更紧凑\n<tr>/<th> / <td> 标签 (状态)   说明\nactive                     悬停鼠标\nsuccess                    成功操作\ninfo                       变化操作\nwarning                    警告操作\ndanger                     危险操作\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script type="text/javascript" src="../js/jquery-1.11.1.js"><\/script>\n    <script type="text/javascript" src="../js/bootstrap.js"><\/script>\n    <link rel="stylesheet" href="../css/bootstrap.css">\n    <link rel="stylesheet" href="../css/bootstrap-theme.css">\n</head>\n<body>\n    <h1>表格样式展示</h1>\n    <h2>table类样式联合使用</h2>\n    <div>\n        <table class="table table-striped table-bordered table-hover table-condensed">\n            <tr>\n                <th>作用范围</th>\n                <th>样式类</th>\n                <th>说明</th>\n            </tr>\n            <tr>\n                <td>table</td>\n                <td>table</td>\n                <td>添加基础样式</td>\n            </tr>\n            <tr>\n                <td>table</td>\n                <td>table-striped</td>\n                <td>添加斑马线</td>\n            </tr>\n            <tr>\n                <td>table</td>\n                <td>table-bordered</td>\n                <td>添加单元格边框</td>\n            </tr>\n            <tr>\n                <td>table</td>\n                <td>table-hover</td>\n                <td>添加悬停变暗</td>\n            </tr>\n            <tr>\n                <td>table</td>\n                <td>table-condensed</td>\n                <td>设置紧凑</td>\n            </tr>\n        </table>\n    </div>\n    <h2>tr、th、td类 样式联合使用</h2>\n    <div>\n        <table class="table table-striped table-bordered">\n            <tr>\n                <th>作用范围</th>\n                <th>样式类</th>\n                <th>说明</th>\n            </tr>\n            <tr class="active">\n                <td>tr标签</td>\n                <td>active</td>\n                <td>悬停 样式应用</td>\n            </tr>\n            <tr class="success">\n                <td>tr标签</td>\n                <td>success</td>\n                <td>成功 样式应用</td>\n            </tr>\n            <tr class="info">\n                <td>tr标签</td>\n                <td>info</td>\n                <td>变化 样式应用</td>\n            </tr>\n            <tr class="warning">\n                <td>tr标签</td>\n                <td>warning</td>\n                <td>警告 样式应用</td>\n            </tr>\n            <tr class="danger">\n                <td>tr标签</td>\n                <td>danger</td>\n                <td>危险 样式应用</td>\n            </tr>\n        </table>\n    </div>\n</body>\n</html>\n\n\n\n# 网格系统\n\n跟表格差不多，但网格系统可设置多设备，兼容性更好！\n\n生成前系统会自动分配12列的个数\n\n设备使用样式说明\n\n           手机         平板电脑       台式电脑       大型台式电脑\n设备应用范围     <768px     ≥768px     ≥992px     ≥1200px\nclass 前缀   col-xs-*   col-sm-*   col-md-*   col-lg-*\n\n网格类                          说明\ncontainer                    表示网格整体\nrow                          网格行\ncol-{设备}-{列数}                网格列\ncol-{设备}-{列数}-offset-{偏移数}   偏移列（指定开始位置）\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script type="text/javascript" src="../js/jquery-1.11.1.js"><\/script>\n    <script type="text/javascript" src="../js/bootstrap.js"><\/script>\n    <link rel="stylesheet" href="../css/bootstrap.css">\n    <link rel="stylesheet" href="../css/bootstrap-theme.css">\n    <style>\n        div {\n            background: rgb(52, 223, 157);\n            border: rgb(0, 0, 0) solid 1px;\n        }\n    </style>\n</head>\n<body>\n    <h1>网格系统</h1>\n    <h2>标准网格</h2>\n    <p>支持手机 电脑端</p>\n    <div class="container">\n        <div class="row">\n            <div class="col-lg-12 col-xs-12">嵌套列测试</div>\n        </div>\n        <div class="row">\n            <div class="col-lg-1 col-xs-1">列</div>\n            <div class="col-lg-1 col-xs-1">列</div>\n            <div class="col-lg-1 col-xs-1">列</div>\n            <div class="col-lg-1 col-xs-1">列</div>\n            <div class="col-lg-1 col-xs-1">列</div>\n            <div class="col-lg-1 col-xs-1">列</div>\n            <div class="col-lg-1 col-xs-1">列</div>\n            <div class="col-lg-1 col-xs-1">列</div>\n            <div class="col-lg-1 col-xs-1">列</div>\n            <div class="col-lg-1 col-xs-1">列</div>\n            <div class="col-lg-1 col-xs-1">列</div>\n            <div class="col-lg-1 col-xs-1">列</div>\n        </div>\n        <div class="row">\n            <div class="col-lg-6 col-xs-6">六列</div>\n            <div class="col-lg-6 col-xs-6">六列</div>\n        </div>\n        <div class="row">\n            <div class="col-lg-3 col-xs-3">三列</div>\n            <div class="col-lg-9 col-xs-9">九列</div>\n        </div>\n        <div class="row">\n            <div class="col-lg-12 col-xs-12">偏移列测试</div>\n        </div>\n        <div class="row">\n            <div class="col-lg-1 col-xs-1">列</div>\n            <div class="col-lg-offset-4 col-xs-offset-4">偏移量四（偏移后该列后面独占一行，不能添加）</div>\n        </div>\n    </div>\n</body>\n</html>\n\n\n\n# 图片\n\nimg类             说明\nimg-rounded      圆角\nimg-circle       圆形\nimg-thumbnail    缩略图功能\nimg-responsive   图片响应式 (图片扩展父类100%)\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script type="text/javascript" src="../js/jquery-1.11.1.js"><\/script>\n    <script type="text/javascript" src="../js/bootstrap.js"><\/script>\n    <link rel="stylesheet" href="../css/bootstrap.css">\n    <link rel="stylesheet" href="../css/bootstrap-theme.css">\n    <script>\n        $(function(){\n            $("img").attr("src","http://sanscan12.gitee.io/blogimg/cover/article%2002.jpg");\n        });\n    <\/script>\n    <style>\n        img {\n            width: 400px;\n            height: 300px;\n        }\n        div{\n            display: inline-block;\n        }\n    </style>\n</head>\n<body>\n    <h1>图片样式展示</h1>\n    <div>\n        <span>无样式</span><br>\n        <img>\n    </div>\n    <div>\n        <span>圆角 (img-rounded 类样式)</span><br>\n        <img class="img-rounded">\n    </div>\n    <div>\n        <span>圆形 (img-circle 类样式)</span><br>\n        <img class="img-circle">\n    </div>\n    <div>\n        <span>内边距框 (img-thumbnail 类样式)</span><br>\n        <img class="img-thumbnail">\n    </div>\n    <div>\n        <span>响应式 (img-responsive 类样式)</span><br>\n        <img class="img-responsive">\n    </div>\n</body>\n</html>\n\n\n\n# 表单\n\n将 label 元素和前面提到的控件包裹在 .form-group 中可以获得最好的排列\n\n表单类               作用标签                           说明\n属性 role="form"    <form>                         标准表单\nform-inline       <form>                         内联表单\nform-horizontal   <form>                         水平表单\ncontrol-label     标签、控件                          网格布局模式\ncol-{设备}-{列数}     标签、控件                          网格设置\nform-group        标签、控件                          标准：适当行高间距\n                                                 内联：内行元素\n                                                 水平：适当行高间距\nform-control      <input> 、<textarea>、<select>   文本元素（设置输入框）\nradio             标签                             单选按钮\ncheckbox          标签                             多选按钮\nradio-inline      标签                             内行单选按钮\ncheckbox-inline   标签                             内行多选按钮\ninput-{设备}        控件                             控件高度\nhelp-block        <span>                         帮助文档 提示作用\n属性 disabled       控件                             禁止输入\nhas-success       标签                             成功 提示\nhas-warning       标签                             警告 提示\nhas-error         标签                             错误 提示\n\n应用实例\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script type="text/javascript" src="../js/jquery-1.11.1.js"><\/script>\n    <script type="text/javascript" src="../js/bootstrap.js"><\/script>\n    <link rel="stylesheet" href="../css/bootstrap.css">\n    <link rel="stylesheet" href="../css/bootstrap-theme.css">\n</head>\n\n<body>\n    <h1>表单</h1>\n    <h2>基本表单</h2>\n    <form action="#" role="form">\n        <div class="form-group">\n            <label for="name">名称：</label>\n            <input type="text" class="form-control" name="name" placeholder="请输入用户名称">\n        </div>\n        <div class="form-group">\n            <label for="password">密码：</label>\n            <input type="password" class="form-control" name="password">\n        </div>\n    </form>\n\n\n    <h2>内联表单</h2>\n    <form action="#" role="form" class="form-inline">\n        <div class="form-group">\n            <label for="name">名称：</label>\n            <input type="text" class="form-control" name="name" placeholder="请输入用户名称">\n        </div>\n        <div class="form-group">\n            <label for="password">密码：</label>\n            <input type="password" class="form-control " name="password">\n        </div>\n    </form>\n\n\n    <h2>水平表单</h2>\n    <form action="#" role="form" class="form-horizontal">\n        <div class="form-group">\n            <label for="name" class="col-xs-2 col-lg-2 control-label">名称：</label>\n            <div class="col-xs-6 col-lg-6">\n                <input type="text" class="form-control control-label" name="name" placeholder="请输入用户名称">\n            </div>\n        </div>\n        <div class="form-group">\n            <label for="password" class="col-xs-2 col-lg-2 control-label">密码：</label>\n            <div class="col-xs-6 col-lg-6">\n                <input type="password" class="form-control control-label" name="password" placeholder="密码不少六位">\n            </div>\n        </div>\n        <div class="form-group">\n            <label for="protocol" class="col-xs-2 col-lg-2 control-label">协议:</label>\n            <div class="col-xs-6 col-lg-6">\n                <textarea name="protocol" id="protocol" rows="3" class="form-control control-label"></textarea>\n            </div>\n        </div>\n    </form>\n\n\n    <h2>控件应用</h2>\n    <form action="#" role="form">\n\n        <div class="form-group">\n            <label for="name">名称：（输入）</label>\n            <input type="text" class="form-control" name="name" placeholder="请输入用户名称">\n        </div>\n\n        <div class="form-group">\n            <label>性别：（单选）</label>\n            <div class="radio">\n                <label>\n                    <input type="radio" value="男" name="sex">\n                    男\n                </label>\n            </div>\n            <div class="radio">\n                <label>\n                    <input type="radio" value="女" name="sex">\n                    女\n                </label>\n            </div>\n        </div>\n\n        <div class="form-group">\n            <label>爱好：（多选）</label>\n            <div class="checkbox-inline">\n                <input type="checkbox" value="篮球" name="hobby">篮球\n            </div>\n            <div class="checkbox-inline">\n                <input type="checkbox" value="足球" name="hobby">足球\n            </div>\n            <div class="checkbox-inline">\n                <input type="checkbox" value="网球" name="hobby">网球\n            </div>\n        </div>\n\n\n        <div class="form-group">\n            <label for="age">年龄：（单选列表）</label>\n            <select class="form-control">\n                <option value="16">16</option>\n                <option value="17">17</option>\n                <option value="18">18</option>\n                <option value="19">19</option>\n                <option value="20">20</option>\n                <option value="21">21</option>\n                <option value="22">22</option>\n            </select>\n        </div>\n\n\n        <div class="form-group">\n            <label for="age">部门：（多项列表）</label>\n            <select multiple class="form-control">\n\n                <option value="1">编辑部</option>\n                <option value="2">外联部</option>\n                <option value="3">财务部</option>\n                <option value="4">传媒部</option>\n            </select>\n        </div>\n\n        <div class="form-group">\n            <label for="protocol">协议：（文本）</label>\n            <textarea name="protocol" id="protocol" cols="40" rows="3"></textarea>\n        </div>\n    </form>\n\n    <h2>状态展示</h2>\n    <form action="#" role="form">\n        <div class="form-group">\n            <label>禁用 输入框</label>\n            <input type="text" class="form-control" disabled>\n        </div>\n\n        <div class="form-group">\n            <label for="age">年龄：</label>\n            <select class="form-control" disabled>\n                <option value="-1">禁止选择</option>\n                <option value="16">16</option>\n                <option value="17">17</option>\n                <option value="18">18</option>\n            </select>\n        </div>\n\n        <div class="form-group">\n            <label>大型台式测试 输入框</label>\n            <input type="text" class="form-control input-lg" placeholder="大小字体测试">\n        </div>\n        <div class="form-group">\n            <label>台式测试 输入框</label>\n            <input type="text" class="form-control input-md" placeholder="大小字体测试">\n        </div>\n        <div class="form-group">\n            <label>平板测试 输入框</label>\n            <input type="text" class="form-control input-sm" placeholder="大小字体测试">\n        </div>\n        <div class="form-group">\n            <label>手机测试 输入框</label>\n            <input type="text" class="form-control input-xs" placeholder="大小字体测试">\n        </div>\n\n\n        <div class="form-group has-success">\n            <label>完成 输入框</label>\n            <input type="text" class="form-control">\n        </div>\n        <div class="form-group has-warning">\n            <label>警告 输入框</label>\n            <input type="text" class="form-control">\n        </div>\n        <div class="form-group has-error">\n            <label>错误 输入框</label>\n            <input type="text" class="form-control">\n        </div>\n        \n        <div class="form-group">\n            <label>输入框（帮助文档）</label>\n            <input type="text" class="form-control">\n            <span class="help-block">\n                一个较长的帮助文本块，超过一行，\n            15. 需要扩展到下一行。本实例中的帮助文本总共有两行\n            </span>\n        </div>\n    </form>\n    \n</body>\n</html>\n\n\n\n# 标题\n\n<body>\n    <h1>排版</h1>\n    <h2>内联标题测试 <span class="small">内联子标题 测试</span></h2>\n    <h3>内联标题测试 <span class="small">内联子标题 测试</span></h3>\n    <h2>标题摘要</h2>\n    <p class="lead">\n        测试测试测试测试测试测试测试测试测\n        试测试测试测试测试测试测试测试测试\n        测试测试测试测试测试测试测试测试测\n        试测试测试测试测试测试测试测试测试\n    </p>\n</body>\n\n\n\n# 其他\n\n\n# 文本\n\n类                              说明\ntext-muted                     白灰色\ntext-primary                   深蓝色\ntext-success                   成功色（白绿色\ntext-info                      信息色（浅蓝色\ntext-warning                   警告色（白黄色\ntext-danger                    错误色（桃红色\ntext-[left | rigth | center]   对齐方式\n\n\n# 背景\n\n类            说明\nbg-primary   深蓝色 背景样式\nbg-success   白绿色 背景样式\nbg-info      浅蓝色 背景样式\nbg-warning   白黄色 背景样式\nbg-danger    桃红色 背景样式\n\n\n# 提示\n\n类               说明\nalert-success   成功 提示\nalert-info      注意 提示\nalert-warning   警告 提示\nalert-danger    错误 提示\n\n提示框添加 关闭按钮：\n\n>  1. 添加带有 .alert、.alert-dismissable 两个类的 <div>\n>  2. <div> 内有 属性：class ="close" data-dismiss ="alert" 的<button>\n>  3. 显示点击控件 <button> 内容：&times;\n\n提示框添加 链接：\n\n> 提示标签 内添加 <a> 添加类：.alert-link (链接匹配标签颜色)\n\n<div class="alert alert-danger alert-dismissable">\n    <button class="close" data-dismiss="alert" >&times;</button>\n    错误(添加右侧删除按钮)\n</div>\n\n<div class="alert alert-warning">\n    <a href="#" class="alert-link">警告！请不要提交（链接点击查看填写详细）</a>\n</div>\n\n\n\n# 进度条\n\n类                                                     说明\nprogress                                              进度条框架\nprogress-bar                                          进度显示\n属性 style="width: {百分比};"                              进度进程\nprogress-bar-{success \\| info \\| warning \\| danger}   进度样式\nprogress-striped                                      条纹进度条\nactive                                                动画进度条（配合条纹使用）\n\n进度条 添加：\n\n>  1. 添加带有 .progress 的 <div> （框架类）\n>  2. <div> 内有 属性 .progress-bar （进度显示） style="width: 40%;" （目前进度）\n\n<div class="container progress" style="padding: 0;">\n    <div class="progress-bar" style="width: 40%;"></div>\n</div>\n\n\n\n# 更多\n\n类              说明\npull-left      元素浮动到左边\npull-right     元素浮动到右边\ncenter-block   设置元素 并居中显示\nclearfix       清除浮动\nshow           强制元素显示\nhidden         强制元素隐藏\nclose          显示关闭按钮\ncaret          显示下拉式功能\n\n<!doctype html>\n<html lang="en">\n\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script type="text/javascript" src="../js/jquery-1.11.1.js"><\/script>\n    <script type="text/javascript" src="../js/bootstrap.js"><\/script>\n    <link rel="stylesheet" href="../css/bootstrap.css">\n    <link rel="stylesheet" href="../css/bootstrap-theme.css">\n</head>\n\n<body>\n    <h1>辅助类测试</h1>\n\n    <h2>文本</h2>\n    <p class="text-muted">text-muted 文本测试</p>\n    <p class="text-primary">text-primary 文本测试</p>\n    <p class="text-success">text-success 文本测试</p>\n    <p class="text-info">text-info 文本测试</p>\n    <p class="text-warning">text-warning 文本测试</p>\n    <p class="text-danger">text-danger 文本测试</p>\n\n    <h2>背景</h2>\n    <p class="bg-primary">bg-primary 背景测试</p>\n    <p class="bg-success">bg-success 背景测试</p>\n    <p class="bg-info">bg-info 背景测试</p>\n    <p class="bg-warning">bg-warning 背景测试</p>\n    <p class="bg-danger">bg-danger 背景测试</p>\n\n    <h2>提示</h2>\n    <div class="container">\n        <div class="alert alert-success">alert-success 成功提示</div>\n        <div class="alert alert-info">alert-info 信息提示</div>\n        <div class="alert alert-warning">alert-warning 警告提示</div>\n        <div class="alert alert-danger">alert-danger 错误提示</div>\n    </div>\n    <h3>其他提示操作</h3>\n    <div class="container">\n\n        <div class="alert alert-danger alert-dismissable">\n            <button class="close" data-dismiss="alert" >&times;</button>\n            错误(添加右侧删除按钮)\n        </div>\n\n        <div class="alert alert-warning">\n            <a href="#" class="alert-link">警告！请不要提交（链接点击查看填写详细）</a>\n        </div>\n\n    </div>\n\n    <h2>进度条</h2>\n    <h3>默认进度条</h3>\n    <div class="container progress" style="padding: 0;">\n        <div class="progress-bar" role="progressbar" aria-valuenow="60" aria-valuemin="0" aria-valuemax="100" style="width: 40%;">\n            <span class="sr-only">40%</span>\n        </div>\n    </div>\n    <div class="container progress" style="padding: 0;">\n        <div class="progress-bar"style="width: 40%;"></div>\n    </div>\n    <h3>不同样式进度条 （progress-bar-*）</h3>\n    <div class="container progress" style="padding: 0;">\n        <div class="progress-bar progress-bar-success" style="width: 90%;"></div>\n    </div>\n    <div class="container progress" style="padding: 0;">\n        <div class="progress-bar progress-bar-info" style="width: 70%;"></div>\n    </div>\n    <div class="container progress" style="padding: 0;">\n        <div class="progress-bar progress-bar-warning"style="width: 50%;"></div>\n    </div>\n    <div class="container progress" style="padding: 0;">\n        <div class="progress-bar progress-bar-danger" style="width: 30%;"></div>\n    </div>\n    <h3>条纹进度条 (progress-striped) </h3>\n    <div class="container progress progress-striped" style="padding: 0;">\n        <div class="progress-bar" style="width: 80%;"></div>\n    </div>\n    <h3>动画进度条 （progress-striped、active）</h3>\n    <div class="container progress progress-striped active" style="padding: 0;">\n        <div class="progress-bar"style="width: 60%;"></div>\n    </div>\n    <h3>堆叠进度条</h3>\n    <div class="container progress" style="padding: 0;">\n        <div class="progress-bar progress-bar-danger"  style="width: 30%;"></div>\n        <div class="progress-bar progress-bar-warning" style="width: 30%;"></div>\n        <div class="progress-bar progress-bar-success" style="width: 30%;"></div>\n    </div>\n\n\n    <h2>其他</h2>\n    <h3>浮动 测试</h3>\n    <div class="container bg-warning">\n        <button class="pull-left">左浮动</span>\n            <button class="pull-right">右浮动</button>\n    </div>\n    <h3>消除浮动 测试</h3>\n    <div class="container bg-warning clearfix">\n        <button class="pull-left">左浮动</span>\n            <button class="pull-right">右浮动</button>\n    </div>\n    <h3>盒子居中 测试</h3>\n    <div class="container bg-success center-block" style="width:80%; height: 100px;"></div>\n    <h3>显示与隐藏 测试</h3>\n    <div>\n        <p class="hidden">隐藏测试</p>\n        <p class="show">显示测试</p>\n    </div>\n    <h3>关闭按钮 测试</h3>\n    <div class="container bg-info alert alert-dismissable">\n        <button class="close" data-dismiss="alert">&times;</button>\n    </div>\n</body>\n</html>\n\n\n\n# 导航栏\n\n作用范围    类                      说明\n<nav>   navbar                 设置导航栏\n<nav>   navbar-default         设置导航栏\n<nav>   属性 role="navigation"   可访问\n标签      navbar-header          第一个导航栏\n<a>     navbar-brand           文本大一号\n<ul>    nav                    设置导航栏中的链接项\n<ul>    navbar-nav             设置导航栏中的链接项\nli      active                 禁用链接选项\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script type="text/javascript" src="../js/jquery-1.11.1.js"><\/script>\n    <script type="text/javascript" src="../js/bootstrap.js"><\/script>\n    <link rel="stylesheet" href="../css/bootstrap.css">\n    <link rel="stylesheet" href="../css/bootstrap-theme.css">\n</head>\n<body>\n    <nav class="navbar navbar-default" role="navigation">\n        <div class="navbar-header">\n            <a href="#" class="navbar-brand">首页测试</a>\n        </div>\n        <ul class="nav navbar-nav">\n            <li class="active"><a href="#">ios</a></li>\n            <li><a href="#">python</a></li>\n            <li><a href="#">java</a></li>\n            <li><a href="#">javascript</a></li>\n            <li class="dropdown">\n                <a href="#" class="dropdown-toggle" data-toggle="dropdown">\n                    java<b class="caret"></b>\n                </a>\n                <ul class="dropdown-menu">\n                    <li><a href="#">test1</a></li>\n                    <li><a href="#">test2</a></li>\n                    <li><a href="#">test3</a></li>\n                    <li class="divider"></li>\n                    <li><a href="#">test4(分割测试)</a></li>\n                    <li class="divider"></li>\n                    <li><a href="#">test5(分割测试)</a></li>\n                </ul>\n            </li>\n        </ul>\n    </nav>\n</body>\n</html>\n\n\n\n# 轮播图\n\n轮播图应用：\n\n 1. 添加带有 .carousel 、.slide 的 <div> ，并且给定一个id属性（轮播图框架）\n 2. <div> 内有 .carousel-indicators 的 <ol> （轮播指标）\n 3. <ol> 中的 data-slide-to={索引}、data-target="#{id值}" <li> （控制轮播属性）\n 4. <div> 内的 .carousel-inner 用来（定义图片）\n 5. 包含 .carousel-inner 的<div> 中的每个 .item 用于定义图片\n 6. 添加有 .active 代表当前显示的图片\n 7. 最后 <a> （用户手动轮播） <a href="#{id值}" class="carousel-control left" data-slide="prev">&lt;</a> <a href="#{id值}" class="carousel-control right" data-slide="next">&gt;</a>\n\n其他功能\n\n.item 内的 .carousel-caption 元素向添加标题\n\n轮播图属性选项\n\n// 一定是指定是轮播jq对象\n$(\'.carousel\').carousel({<选项>})\n\n\n属性名        值               描述\ninterval   number          自动轮播 指定 时间秒\npause      string / null   停止轮播的时间 参数有 "hover","mouseenter","mouseleave","null"\nwrap       boolean         是否连续循环轮播\nkeyboard   boolean         是否对应响应事件\n\n<!doctype html>\n<html lang="en">\n<head>\n    <meta charset="utf-8">\n    <title>document</title>\n    <script type="text/javascript" src="../js/jquery-1.11.1.js"><\/script>\n    <script type="text/javascript" src="../js/bootstrap.js"><\/script>\n    <link rel="stylesheet" href="../css/bootstrap.css">\n    <link rel="stylesheet" href="../css/bootstrap-theme.css">\n    <style>\n        .box {\n            width: 500px;\n            height: 300px;\n            margin-top: 50px;\n            padding: 0;\n        }\n\n        .carousel-control {\n            width: 50px;\n            line-height: 300px;\n        }\n    </style>\n    <script>\n        $(function () {\n            var csel = $("#mycarousel");\n\n            $("button:eq(0)").click(function(){\n                csel.carousel({\n                    interval:2000\n                });\n            });\n\n            $("button:eq(1)").click(function(){\n                //hover、 pause \n                csel.carousel(\'pause\');\n            });\n\n            $("button:eq(2)").click(function () {\n                csel.carousel(\'next\');\n            });\n            $("button:eq(3)").click(function () {\n                csel.carousel(\'prev\');\n            });\n        });\n    <\/script>\n</head>\n\n<body>\n    <button>一秒轮播</button>\n    <button>停止轮播</button>\n    <button>往下轮播</button>\n    <button>往上轮播</button>\n\n    <div id="mycarousel" class="container carousel slide box">\n        \x3c!-- 轮播指标 --\x3e\n        <ol class="carousel-indicators">\n            <li data-target="#mycarousel" data-slide-to="0" class="active"></li>\n            <li data-target="#mycarousel" data-slide-to="1"></li>\n            <li data-target="#mycarousel" data-slide-to="2"></li>\n            <li data-target="#mycarousel" data-slide-to="3"></li>\n            <li data-target="#mycarousel" data-slide-to="4"></li>\n            <li data-target="#mycarousel" data-slide-to="5"></li>\n        </ol>\n        \x3c!-- 轮播图片 --\x3e\n        <div class="carousel-inner">\n            <div class="item active">\n                <img src="http://sanscan12.gitee.io/blogimg/cover/article 03.jpg" alt="1">\n                <div class="carousel-caption">\n                    添加标签\n                </div>\n            </div>\n            <div class="item">\n                <img src="http://sanscan12.gitee.io/blogimg/cover/article 02.jpg" alt="2">\n                \n            </div>\n            <div class="item">\n                <img src="http://sanscan12.gitee.io/blogimg/cover/article 18.jpg" alt="3">\n            </div>\n            <div class="item">\n                <img src="http://sanscan12.gitee.io/blogimg/cover/article 14.jpg" alt="4">\n            </div>\n            <div class="item">\n                <img src="http://sanscan12.gitee.io/blogimg/cover/article 16.jpg" alt="5">\n            </div>\n        </div>\n        \x3c!-- 轮播滑动按钮 --\x3e\n        <a href="#mycarousel" class="carousel-control left" data-slide="prev">&lt;</a>\n        <a href="#mycarousel" class="carousel-control right" data-slide="next">&gt;</a>\n    </div>\n\n</body>\n\n</html>\n',charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Vdoing主题 评论功能",frontmatter:{title:'Vdoing主题 评论功能 <Badge text="转载" type="error" vertical="middle"/>',author:"柏竹",permalink:"/blog/2scac",date:"2020-03-13T00:00:00.000Z",categories:["博客相关"],tags:["评论功能"]},regularPath:"/03.%E6%9B%B4%E5%A4%9A/01.%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/02.Vdoing%E4%B8%BB%E9%A2%98.html",relativePath:"03.更多/01.博客相关/02.Vdoing主题.md",key:"v-a68a0746",path:"/blog/2scac/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:2},{level:2,title:"后端",slug:"后端",normalizedTitle:"后端",charIndex:190},{level:3,title:"拉取镜像",slug:"拉取镜像",normalizedTitle:"拉取镜像",charIndex:297},{level:3,title:"镜像容器运行",slug:"镜像容器运行",normalizedTitle:"镜像容器运行",charIndex:306},{level:3,title:"Nginx反向代理",slug:"nginx反向代理",normalizedTitle:"nginx反向代理",charIndex:328},{level:3,title:"配置登录账号",slug:"配置登录账号",normalizedTitle:"配置登录账号",charIndex:317},{level:3,title:"Web管理页配置",slug:"web管理页配置",normalizedTitle:"web管理页配置",charIndex:344},{level:3,title:"重启docker",slug:"重启docker",normalizedTitle:"重启docker",charIndex:357},{level:2,title:"前端",slug:"前端",normalizedTitle:"前端",charIndex:2622}],headersStr:"前言 后端 拉取镜像 镜像容器运行 Nginx反向代理 配置登录账号 Web管理页配置 重启docker 前端",content:"# 前言\n\n该主题配置实战经历 , 也是给了自己在当中学习的经历作为记录 , 虽说是转载 , 但自己也在当中踩了不少坑\n\n以下是采用 Artalk自托管评论系统 来配置 vuepress-theme-vdoing 主题\n\n官方文档 : https://artalk.js.org/\n\n转载文章 : https://wiki.eryajf.net/pages/b74c2b\n\n\n# 后端\n\n后端基于 docker , 开箱即用的容器 , 需要到服务器 !!\n\n准备 :\n\n * Docker 服务器/搭载docker云空间\n * Nginx 反向代理\n\n大致步骤 : (点击快速跳转)\n\n 1. 拉取镜像\n 2. 镜像容器运行\n 3. 配置登录账号\n 4. Nginx反向代理配置\n 5. Web管理页配置\n 6. 重启docker\n\n\n# 拉取镜像\n\ndocker pull artalk/artalk-go\n\n\n\n# 镜像容器运行\n\ndocker run -d \\\n    --name artalk \\\n    -p 8088:23366 \\\n    -v $(pwd)/data:/data \\\n    --restart=always \\\n    artalk/artalk-go\n\n\n选项说明 :\n\n选项       说明\n-d       后台运行\n--name   指定容器名称\n-p       指定端口 [外部端口]:[容器端口]\n-v       映射 目录/文件\n\n提示\n\n端口可以自定义\n\n\n# Nginx反向代理\n\n检测上一步的容器是否正在运行\n\n# 查看正在运行的容器相关信息\ndocker ps -a\n# 查看容器端口是否开放 填下 容器名/容器id\ndocker port {name/id}\n\n\n检查无误后进行配置反向代理\n\n 1. 配置Nginx (注意自己的nginx根路径 , 可能和我的不同)\n    \n    vim /etc/nginx/conf.d/comment.bozhu12.cc\n    \n\n 2. 粘贴以下配置 含SSL证书\n    \n    server {\n        listen 80;\n        listen 443 ssl;\n        listen [::]:80;\n        listen [::]:443 ssl;\n    \t\n        # 外部访问的域名\n        server_name comment.bozhu12.cc;\n    \n        ssl_certificate /etc/nginx/ssl/comment.bozhu12.cc.pem;\n        ssl_certificate_key /etc/nginx/ssl/comment.bozhu12.cc.key;\n        ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;\n        ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n        ssl_prefer_server_ciphers on;\n    \n        location / {\n            proxy_set_header Host $host;\n            proxy_set_header   X-Forwarded-Proto $scheme;\n            proxy_set_header   X-Real-IP         $remote_addr;\n            proxy_pass http://localhost:8088;\n        }\n    }\n    \n    \n    无SSL证书\n    \n    server {\n        listen 80;\n        listen 443 ssl;\n        listen [::]:80;\n        listen [::]:443 ssl;\n    \t\n        # 外部访问的域名\n        server_name comment.bozhu12.cc;\n    \n        location / {\n            proxy_set_header Host $host;\n            proxy_set_header   X-Forwarded-Proto $scheme;\n            proxy_set_header   X-Real-IP         $remote_addr;\n            proxy_pass http://localhost:8088;\n        }\n    }\n    \n\n注意\n\n * 80是 http访问 / 443是 https访问\n * 防火墙需要开放 80/443 端口 , 外部访问需要\n * 有些平台 并非采用防火墙 , 则是需要开放 安全组\n * 如果是个人的服务器 , 供应商必然会屏蔽 80/443 端口 , 因此配置需要添加端口\n\n\n# 配置登录账号\n\n通过管理员创建账户\n\ndocker exec -it artalk artalk admin\n\n\n根据提示填写 账号/密码\n\n\n# Web管理页配置\n\n有些人会倾向于在 docker 映射的 /data中更改配置 , 为了更直观的更改配置 , 我选择了Web进行配置\n\n如果上面的配置没有问题 , 那么我们可以通过 comment.bozhu12.cc 访问到后台进行配置\n\n提示\n\n根据Nginx配置的不同 , 会有所差异!!!\n\n关键配置 : (个人建议)\n\n配置项                     值\n语言 (最新版默认英文)            zh-CN\n可信域名(一个测试 , 一个发布)       http://localhost:8080\n                        https://www.bozhu12.cc\n前端配置->头像 (国内最好头像镜像平台)   https://cravatar.cn/avatar/\n\n> 其他配置自行细品\n\n\n# 重启docker\n\n必不可少的一个重要步骤 , 前面所有在Web配置中 , 不会立马生效 , 需要重启docker容器才能生效\n\ndocker restart artalk\n\n\n\n# 前端\n\n大致步骤 :\n\n 1. 安装评论插件\n    \n    npm install --save vuepress-plugin-vdoing-comment --registry=https://registry.npmmirror.com\n    \n\n 2. 配置评论插件 , 在自己的 vdoing 工程项目中，插件配置可能在 :\n    \n    * docs/.vuepress/config.ts\n    * docs/.vuepress/config/plugins.js\n    \n    但下面的配置一定相同 :\n    \n    plugins: <UserPlugins>[\n        // 评论\n        [\n            'vuepress-plugin-vdoing-comment',\n            {\n                choosen: 'artalk',\n                options: {\n                    server: 'https://comment.bozhu12.cc', // （必填）\n                    site: '柏竹', // （必填）\n                    // disableEmotion: false, // 是否禁用表情（可选）\n                    // disablePicture: true, // 是否禁用图片（可选）\n                    // disablePreview: false // 是否禁用预览（可选）\n                }\n            }\n        ],\n    \n    ],\n    \n\n 3. 样式配置 , 兼容主题 docs/.vuepress/styles/palette.styl 最后添加如下内容进行优化：\n    \n    // artalk 评论框 适配暗黑模式\n    .theme-mode-dark #vuepress-plugin-vdoing-comment {\n      --at-color-bg: --bodyBg;\n      color: #ffffff;\n      --at-color-font: #ffffff;\n      --at-color-bg-transl: --bodyBg;\n      --at-color-bg-grey: #373a40\n    }\n    .theme-mode-dark #vuepress-plugin-vdoing-comment .atk-editor-plug-emoticons > .atk-grp-switcher > span:hover, .atk-editor-plug-emoticons > .atk-grp-switcher > span.active {\n      background: var(--at-color-bg-grey);\n    }\n    .theme-mode-dark #vuepress-plugin-vdoing-comment .atk-editor-plug-emoticons > .atk-grp-switcher {\n      background: var(--at-color-bg-grey)\n    }\n    \n\n----------------------------------------\n\n以上内容仅限做引导说明 , 如有问题评论区讨论吧",normalizedContent:"# 前言\n\n该主题配置实战经历 , 也是给了自己在当中学习的经历作为记录 , 虽说是转载 , 但自己也在当中踩了不少坑\n\n以下是采用 artalk自托管评论系统 来配置 vuepress-theme-vdoing 主题\n\n官方文档 : https://artalk.js.org/\n\n转载文章 : https://wiki.eryajf.net/pages/b74c2b\n\n\n# 后端\n\n后端基于 docker , 开箱即用的容器 , 需要到服务器 !!\n\n准备 :\n\n * docker 服务器/搭载docker云空间\n * nginx 反向代理\n\n大致步骤 : (点击快速跳转)\n\n 1. 拉取镜像\n 2. 镜像容器运行\n 3. 配置登录账号\n 4. nginx反向代理配置\n 5. web管理页配置\n 6. 重启docker\n\n\n# 拉取镜像\n\ndocker pull artalk/artalk-go\n\n\n\n# 镜像容器运行\n\ndocker run -d \\\n    --name artalk \\\n    -p 8088:23366 \\\n    -v $(pwd)/data:/data \\\n    --restart=always \\\n    artalk/artalk-go\n\n\n选项说明 :\n\n选项       说明\n-d       后台运行\n--name   指定容器名称\n-p       指定端口 [外部端口]:[容器端口]\n-v       映射 目录/文件\n\n提示\n\n端口可以自定义\n\n\n# nginx反向代理\n\n检测上一步的容器是否正在运行\n\n# 查看正在运行的容器相关信息\ndocker ps -a\n# 查看容器端口是否开放 填下 容器名/容器id\ndocker port {name/id}\n\n\n检查无误后进行配置反向代理\n\n 1. 配置nginx (注意自己的nginx根路径 , 可能和我的不同)\n    \n    vim /etc/nginx/conf.d/comment.bozhu12.cc\n    \n\n 2. 粘贴以下配置 含ssl证书\n    \n    server {\n        listen 80;\n        listen 443 ssl;\n        listen [::]:80;\n        listen [::]:443 ssl;\n    \t\n        # 外部访问的域名\n        server_name comment.bozhu12.cc;\n    \n        ssl_certificate /etc/nginx/ssl/comment.bozhu12.cc.pem;\n        ssl_certificate_key /etc/nginx/ssl/comment.bozhu12.cc.key;\n        ssl_ciphers ecdhe-rsa-aes128-gcm-sha256:ecdhe:ecdh:aes:high:!null:!anull:!md5:!adh:!rc4;\n        ssl_protocols tlsv1 tlsv1.1 tlsv1.2;\n        ssl_prefer_server_ciphers on;\n    \n        location / {\n            proxy_set_header host $host;\n            proxy_set_header   x-forwarded-proto $scheme;\n            proxy_set_header   x-real-ip         $remote_addr;\n            proxy_pass http://localhost:8088;\n        }\n    }\n    \n    \n    无ssl证书\n    \n    server {\n        listen 80;\n        listen 443 ssl;\n        listen [::]:80;\n        listen [::]:443 ssl;\n    \t\n        # 外部访问的域名\n        server_name comment.bozhu12.cc;\n    \n        location / {\n            proxy_set_header host $host;\n            proxy_set_header   x-forwarded-proto $scheme;\n            proxy_set_header   x-real-ip         $remote_addr;\n            proxy_pass http://localhost:8088;\n        }\n    }\n    \n\n注意\n\n * 80是 http访问 / 443是 https访问\n * 防火墙需要开放 80/443 端口 , 外部访问需要\n * 有些平台 并非采用防火墙 , 则是需要开放 安全组\n * 如果是个人的服务器 , 供应商必然会屏蔽 80/443 端口 , 因此配置需要添加端口\n\n\n# 配置登录账号\n\n通过管理员创建账户\n\ndocker exec -it artalk artalk admin\n\n\n根据提示填写 账号/密码\n\n\n# web管理页配置\n\n有些人会倾向于在 docker 映射的 /data中更改配置 , 为了更直观的更改配置 , 我选择了web进行配置\n\n如果上面的配置没有问题 , 那么我们可以通过 comment.bozhu12.cc 访问到后台进行配置\n\n提示\n\n根据nginx配置的不同 , 会有所差异!!!\n\n关键配置 : (个人建议)\n\n配置项                     值\n语言 (最新版默认英文)            zh-cn\n可信域名(一个测试 , 一个发布)       http://localhost:8080\n                        https://www.bozhu12.cc\n前端配置->头像 (国内最好头像镜像平台)   https://cravatar.cn/avatar/\n\n> 其他配置自行细品\n\n\n# 重启docker\n\n必不可少的一个重要步骤 , 前面所有在web配置中 , 不会立马生效 , 需要重启docker容器才能生效\n\ndocker restart artalk\n\n\n\n# 前端\n\n大致步骤 :\n\n 1. 安装评论插件\n    \n    npm install --save vuepress-plugin-vdoing-comment --registry=https://registry.npmmirror.com\n    \n\n 2. 配置评论插件 , 在自己的 vdoing 工程项目中，插件配置可能在 :\n    \n    * docs/.vuepress/config.ts\n    * docs/.vuepress/config/plugins.js\n    \n    但下面的配置一定相同 :\n    \n    plugins: <userplugins>[\n        // 评论\n        [\n            'vuepress-plugin-vdoing-comment',\n            {\n                choosen: 'artalk',\n                options: {\n                    server: 'https://comment.bozhu12.cc', // （必填）\n                    site: '柏竹', // （必填）\n                    // disableemotion: false, // 是否禁用表情（可选）\n                    // disablepicture: true, // 是否禁用图片（可选）\n                    // disablepreview: false // 是否禁用预览（可选）\n                }\n            }\n        ],\n    \n    ],\n    \n\n 3. 样式配置 , 兼容主题 docs/.vuepress/styles/palette.styl 最后添加如下内容进行优化：\n    \n    // artalk 评论框 适配暗黑模式\n    .theme-mode-dark #vuepress-plugin-vdoing-comment {\n      --at-color-bg: --bodybg;\n      color: #ffffff;\n      --at-color-font: #ffffff;\n      --at-color-bg-transl: --bodybg;\n      --at-color-bg-grey: #373a40\n    }\n    .theme-mode-dark #vuepress-plugin-vdoing-comment .atk-editor-plug-emoticons > .atk-grp-switcher > span:hover, .atk-editor-plug-emoticons > .atk-grp-switcher > span.active {\n      background: var(--at-color-bg-grey);\n    }\n    .theme-mode-dark #vuepress-plugin-vdoing-comment .atk-editor-plug-emoticons > .atk-grp-switcher {\n      background: var(--at-color-bg-grey)\n    }\n    \n\n----------------------------------------\n\n以上内容仅限做引导说明 , 如有问题评论区讨论吧",charsets:{cjk:!0}},{title:"Vue技巧功能",frontmatter:{title:"Vue技巧功能",author:"柏竹",permalink:"/web/1hg7wq",date:"2020-02-18T00:00:00.000Z",categories:["前端"],tags:["技巧"]},regularPath:"/02.%E5%89%8D%E7%AB%AF/03.%E5%89%8D%E7%AB%AF%E6%8A%80%E5%B7%A7/02.vue%E6%8A%80%E5%B7%A7%E5%8A%9F%E8%83%BD.html",relativePath:"02.前端/03.前端技巧/02.vue技巧功能.md",key:"v-d177183e",path:"/web/1hg7wq/",headers:[{level:3,title:"节流",slug:"节流",normalizedTitle:"节流",charIndex:14},{level:3,title:"限流",slug:"限流",normalizedTitle:"限流",charIndex:411},{level:3,title:"跳转外部URL",slug:"跳转外部url",normalizedTitle:"跳转外部url",charIndex:662},{level:2,title:"uniApp",slug:"uniapp",normalizedTitle:"uniapp",charIndex:1274},{level:3,title:"返回传参",slug:"返回传参",normalizedTitle:"返回传参",charIndex:1285},{level:2,title:"踩坑",slug:"踩坑",normalizedTitle:"踩坑",charIndex:1486},{level:3,title:"Vuex",slug:"vuex",normalizedTitle:"vuex",charIndex:1493},{level:3,title:"克隆",slug:"克隆",normalizedTitle:"克隆",charIndex:1646}],headersStr:"节流 限流 跳转外部URL uniApp 返回传参 踩坑 Vuex 克隆",content:"# Vue技巧功能\n\n\n# 节流\n\n请求时间内禁止再次请求 , 除非上次请求结束(指的是单个请求)\n\n// 设置节流阀\ndata() {\n  return {\n    // 是否正在请求数据\n    isloading: false\n  }\n}\n\n// 请求操作 方法\nasync query() {\n  // ** 打开节流阀\n  this.isloading = true\n  // 发起请求\n  const res = await uni.request({url:'xxx'});\n  // ** 关闭节流阀\n  this.isloading = false\n\n  // 省略其它代码...\n}\n\n// 触发 请求 方法\nrequest() {\n  // 判断是否正在请求其它数据，如果是，则不发起额外的请求\n  if (this.isloading) return\n\n  this.query()\n}\n\n\n\n# 限流\n\n限流 能够将一段时间内频繁操作设置成一次操作\n\ndata() {\n  return {\n    // 延迟器\n    timer: null\n  }\n}\n\n//  触发 操作 方法\noperate(){\n    // 清除 timer 对应的延时器\n    clearTimeout(this.timer);\n    // 1s 未触发则更新数值\n    this.timer = setTimeout(() => {\n        // 执行内容\n    }, 1000);\n}\n\n\n\n# 跳转外部URL\n\n操作步骤 :\n\n创建 webview.vue 页面 (page.json也需要添加)\n\n<template>\n  <web-view :src=\"url\"></web-view>\n</template>\n \n<script>\nexport default {\n  data() {\n    return {\n      url: ''\n    }\n  },\n  onLoad(item) {\n    this.url = decodeURIComponent(item.url)\n    console.log(this.url)\n    // 传入需要跳转的链接 使用web-view标签进行跳转\n  }\n}\n<\/script>\n \n<style lang=\"scss\">\n</style>\n\n\n触发跳转\n\n<view @click=\"hrefrouterApp()\"> 平台跳转 </view>\n// 触发跳转\nhrefrouterApp() {\n  let url = 'http://xxxxxx/routerApp'  // URL是要跳转的外部地址 作为参数\n  uni.navigateTo({\n    url: '/pages/common/webview?url=' + url\n    // page.json定义的路径 传url 到webview界面去接收 实现跳转\n})\n\n\n\n# uniApp\n\n\n# 返回传参\n\n可以传递 对象/数组/...\n\n// 返回后接收的页面\nuni.$once('number' ,(number)=>{\n    this.templateNum = number - 1; \n});\n\n\n// 页面返回操作\nbackTest(index) {\n    uni.$emit('number' , index);\n    uni.navigateBack();\n},\n\n\n\n# 踩坑\n\n\n# Vuex\n\n问题 : setData 内存过大 (不能操作1M)\n\n原因1 : Vuex 的 state数据在 mutations方法中调用时使用了 arr = [...arr, ...] 链式添加\n\n原因2 : 组件通信传递无用参数\n\n解决 : 改用 Array.push() 方法进行添加数组\n\n\n# 克隆\n\n问题 : 批量克隆对象到数组 , 那么修改里面的数据 , 那么数组的所有元素也收到影响\n\n原因 : 浅克隆 会连同引用原型对象进行克隆过去 (地址)\n\n解决 : 进行深克隆 (蠢方法)\n\nJSON.parse(JSON.stringify(obj));\n",normalizedContent:"# vue技巧功能\n\n\n# 节流\n\n请求时间内禁止再次请求 , 除非上次请求结束(指的是单个请求)\n\n// 设置节流阀\ndata() {\n  return {\n    // 是否正在请求数据\n    isloading: false\n  }\n}\n\n// 请求操作 方法\nasync query() {\n  // ** 打开节流阀\n  this.isloading = true\n  // 发起请求\n  const res = await uni.request({url:'xxx'});\n  // ** 关闭节流阀\n  this.isloading = false\n\n  // 省略其它代码...\n}\n\n// 触发 请求 方法\nrequest() {\n  // 判断是否正在请求其它数据，如果是，则不发起额外的请求\n  if (this.isloading) return\n\n  this.query()\n}\n\n\n\n# 限流\n\n限流 能够将一段时间内频繁操作设置成一次操作\n\ndata() {\n  return {\n    // 延迟器\n    timer: null\n  }\n}\n\n//  触发 操作 方法\noperate(){\n    // 清除 timer 对应的延时器\n    cleartimeout(this.timer);\n    // 1s 未触发则更新数值\n    this.timer = settimeout(() => {\n        // 执行内容\n    }, 1000);\n}\n\n\n\n# 跳转外部url\n\n操作步骤 :\n\n创建 webview.vue 页面 (page.json也需要添加)\n\n<template>\n  <web-view :src=\"url\"></web-view>\n</template>\n \n<script>\nexport default {\n  data() {\n    return {\n      url: ''\n    }\n  },\n  onload(item) {\n    this.url = decodeuricomponent(item.url)\n    console.log(this.url)\n    // 传入需要跳转的链接 使用web-view标签进行跳转\n  }\n}\n<\/script>\n \n<style lang=\"scss\">\n</style>\n\n\n触发跳转\n\n<view @click=\"hrefrouterapp()\"> 平台跳转 </view>\n// 触发跳转\nhrefrouterapp() {\n  let url = 'http://xxxxxx/routerapp'  // url是要跳转的外部地址 作为参数\n  uni.navigateto({\n    url: '/pages/common/webview?url=' + url\n    // page.json定义的路径 传url 到webview界面去接收 实现跳转\n})\n\n\n\n# uniapp\n\n\n# 返回传参\n\n可以传递 对象/数组/...\n\n// 返回后接收的页面\nuni.$once('number' ,(number)=>{\n    this.templatenum = number - 1; \n});\n\n\n// 页面返回操作\nbacktest(index) {\n    uni.$emit('number' , index);\n    uni.navigateback();\n},\n\n\n\n# 踩坑\n\n\n# vuex\n\n问题 : setdata 内存过大 (不能操作1m)\n\n原因1 : vuex 的 state数据在 mutations方法中调用时使用了 arr = [...arr, ...] 链式添加\n\n原因2 : 组件通信传递无用参数\n\n解决 : 改用 array.push() 方法进行添加数组\n\n\n# 克隆\n\n问题 : 批量克隆对象到数组 , 那么修改里面的数据 , 那么数组的所有元素也收到影响\n\n原因 : 浅克隆 会连同引用原型对象进行克隆过去 (地址)\n\n解决 : 进行深克隆 (蠢方法)\n\njson.parse(json.stringify(obj));\n",charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Vdoing 主题建站",frontmatter:{title:"Vdoing 主题建站",author:"柏竹",permalink:"/blog/1hg722",date:"2022-03-13T00:00:00.000Z",categories:["博客相关"],tags:["博客搭建"]},regularPath:"/03.%E6%9B%B4%E5%A4%9A/01.%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/01.Vdoing%E4%B8%BB%E9%A2%98%E6%90%AD%E5%BB%BA.html",relativePath:"03.更多/01.博客相关/01.Vdoing主题搭建.md",key:"v-462a5c98",path:"/blog/1hg722/",headers:[{level:2,title:"前言",slug:"前言",normalizedTitle:"前言",charIndex:2},{level:2,title:"应用",slug:"应用",normalizedTitle:"应用",charIndex:441},{level:2,title:"域名 (收费)",slug:"域名-收费",normalizedTitle:"域名 (收费)",charIndex:1071},{level:2,title:"SSL (免费)",slug:"ssl-免费",normalizedTitle:"ssl (免费)",charIndex:1410},{level:2,title:"DNS(免费)",slug:"dns-免费",normalizedTitle:"dns(免费)",charIndex:1789}],headersStr:"前言 应用 域名 (收费) SSL (免费) DNS(免费)",content:"# 前言\n\n🌈首次建站 : 19年开始使用 hexo建站 , 发现当中有很多缺陷不适合系统性阅读文章 , 太过于个性化 , 也没有找到相关较好的主题 , 于是搁置流放了....\n\n🦜建站搁置 : 在学习Vue的时候 , 查阅官方文档时 , 嘿 , 发现也挺适合知识库存储(跟语雀差不多) ! 是采用 VuePress 开发的 , 也有了打算做的念头 . 在那期间也忙于实习 , 然后又鸽了一阵子 ...\n\n🚩回归初衷 : 直到今年(23年) , 无意间发现有 某个博客采用 vuepress-theme-vdoing , 进去看了阵子 .... 简直是 VuePress 的优化版啊 , 大多配置什么的都不需要配 , 只要按照约定编写文档即可 , 开箱即用什么的 . 于是走起了开坑之旅..\n\n> 如果对 主题配置有要求 , 不建议使用 . 进开源看演示指不定喜欢上呢💓\n\n主题基于 : VuePress\n\n采用主题 : vuepress-theme-vdoing\n\n\n# 应用\n\n大致步骤 :\n\n 1. 跑一遍官方指南 , 所有!\n 2. 按照 约定更改 文章\n 3. 运行 ==npm run deploy== (查看以下配置)\n 4. 在GitHub配置仓库 , Settings -> Pages -> 构建部署 (指定分支..)\n 5. 首次访问(里面会有个访问连接访问即可)\n\n新GitHub默认分支更改为 main , 操作可按照以下配置\n\n# 确保脚本抛出遇到的错误\nset -e\n\n# 生成静态文件 / 生成覆盖\nnpm run build\n\n# 缓存目录\nmkdir -p docs/.vuepress/gitTemp\ncd docs/.vuepress/gitTemp\ngit init\n# 远程连接\ngit remote add origin git@github.com:xxxx/Blog.git\n# 获取远程分支\ngit fetch origin\n# 切换分支\ngit checkout main\n# 拷贝(覆盖)\ncp -rf ../dist/* ./\n# 自定义域名 (没有则注释)\necho 'blog.bozhu12.cc' > CNAME\n# git add --all 有等于 git add . (兼容更多版本)\ngit add .\ngit commit -m \"deploy\"\ngit push -f origin main\n# 删除\ncd ..\nrm -rf gitTemp\n\n\n\n# 域名 (收费)\n\n博主 采用 阿里云 配置 , 其他平台配置差异不大\n\n假设 :\n\n * GitHub账号 : Sancan12\n * 域名 : blog.bozhu12.cc\n\n大致步骤 :\n\n 1. 购买域名\n\n 2. 域名解析 (自选二级域名)\n    \n    记录类型    主机记录(二级域名)   记录值 (注意名称)\n    CNAME   blog         Sancan12.github.io\n\n 3. 在GitHub配置仓库 , Settings -> Pages -> Custom domain (填写配置的域名)\n\n 4. 域名访问测试 https://blog.bozhu12.cc\n\n> 加载可能没有那么块需要等待10min左右\n\n\n# SSL (免费)\n\n博主 采用 阿里云 配置 , 其他平台配置差异不大\n\n假设 :\n\n * GitHub账号 : Sancan12\n * 域名 : blog.bozhu12.cc\n\n大致步骤 :\n\n 1. 进入 SSL证书 控制台 , 并实名认证\n\n 2. 创建证书 , SSL证书 -> 免费证书 -> 创建证书 -> 申请证书\n\n 3. 申请配置 , (选项形式呈现)\n    \n    证书绑定域名: blog.bozhu12.cc\n    密钥算法:RSA\n    SCR生成方式:系统生成\n    \n\n 4. 申请后会得到 主机记录,记录类型,记录值 , 需要域名逐一配置\n\n 5. 下载证书 (证书到手 , 其他平台只需配置即可)\n\n使用方式 :\n\n * 运行服务器 配置 Nginx\n * 在GitHub仓库静态访问 , 在CDN配置\n\n\n# DNS(免费)\n\n博主 采用 七牛云 配置 , 其他平台配置差异不大\n\n免费 , 但提速有限 , 国内响应平均 4秒内\n\n假设 :\n\n * GitHub账号 : Sancan12\n * 域名 : blog.bozhu12.cc\n\n大致步骤 :\n\n 1. SSL控制台 -> 上传证书 -> 下载证书 , CV内容 即可 (分别有 证书内容/私钥)\n 2. CDN控制台 -> 域名管理 -> 添加域名\n 3. 填写配置 (下图\n 4. 配置域名 CNAME记录即可\n 5. 在网上找些网站平测试\n\n----------------------------------------\n\n以上内容仅限做引导说明 , 如有问题评论区讨论吧",normalizedContent:"# 前言\n\n🌈首次建站 : 19年开始使用 hexo建站 , 发现当中有很多缺陷不适合系统性阅读文章 , 太过于个性化 , 也没有找到相关较好的主题 , 于是搁置流放了....\n\n🦜建站搁置 : 在学习vue的时候 , 查阅官方文档时 , 嘿 , 发现也挺适合知识库存储(跟语雀差不多) ! 是采用 vuepress 开发的 , 也有了打算做的念头 . 在那期间也忙于实习 , 然后又鸽了一阵子 ...\n\n🚩回归初衷 : 直到今年(23年) , 无意间发现有 某个博客采用 vuepress-theme-vdoing , 进去看了阵子 .... 简直是 vuepress 的优化版啊 , 大多配置什么的都不需要配 , 只要按照约定编写文档即可 , 开箱即用什么的 . 于是走起了开坑之旅..\n\n> 如果对 主题配置有要求 , 不建议使用 . 进开源看演示指不定喜欢上呢💓\n\n主题基于 : vuepress\n\n采用主题 : vuepress-theme-vdoing\n\n\n# 应用\n\n大致步骤 :\n\n 1. 跑一遍官方指南 , 所有!\n 2. 按照 约定更改 文章\n 3. 运行 ==npm run deploy== (查看以下配置)\n 4. 在github配置仓库 , settings -> pages -> 构建部署 (指定分支..)\n 5. 首次访问(里面会有个访问连接访问即可)\n\n新github默认分支更改为 main , 操作可按照以下配置\n\n# 确保脚本抛出遇到的错误\nset -e\n\n# 生成静态文件 / 生成覆盖\nnpm run build\n\n# 缓存目录\nmkdir -p docs/.vuepress/gittemp\ncd docs/.vuepress/gittemp\ngit init\n# 远程连接\ngit remote add origin git@github.com:xxxx/blog.git\n# 获取远程分支\ngit fetch origin\n# 切换分支\ngit checkout main\n# 拷贝(覆盖)\ncp -rf ../dist/* ./\n# 自定义域名 (没有则注释)\necho 'blog.bozhu12.cc' > cname\n# git add --all 有等于 git add . (兼容更多版本)\ngit add .\ngit commit -m \"deploy\"\ngit push -f origin main\n# 删除\ncd ..\nrm -rf gittemp\n\n\n\n# 域名 (收费)\n\n博主 采用 阿里云 配置 , 其他平台配置差异不大\n\n假设 :\n\n * github账号 : sancan12\n * 域名 : blog.bozhu12.cc\n\n大致步骤 :\n\n 1. 购买域名\n\n 2. 域名解析 (自选二级域名)\n    \n    记录类型    主机记录(二级域名)   记录值 (注意名称)\n    cname   blog         sancan12.github.io\n\n 3. 在github配置仓库 , settings -> pages -> custom domain (填写配置的域名)\n\n 4. 域名访问测试 https://blog.bozhu12.cc\n\n> 加载可能没有那么块需要等待10min左右\n\n\n# ssl (免费)\n\n博主 采用 阿里云 配置 , 其他平台配置差异不大\n\n假设 :\n\n * github账号 : sancan12\n * 域名 : blog.bozhu12.cc\n\n大致步骤 :\n\n 1. 进入 ssl证书 控制台 , 并实名认证\n\n 2. 创建证书 , ssl证书 -> 免费证书 -> 创建证书 -> 申请证书\n\n 3. 申请配置 , (选项形式呈现)\n    \n    证书绑定域名: blog.bozhu12.cc\n    密钥算法:rsa\n    scr生成方式:系统生成\n    \n\n 4. 申请后会得到 主机记录,记录类型,记录值 , 需要域名逐一配置\n\n 5. 下载证书 (证书到手 , 其他平台只需配置即可)\n\n使用方式 :\n\n * 运行服务器 配置 nginx\n * 在github仓库静态访问 , 在cdn配置\n\n\n# dns(免费)\n\n博主 采用 七牛云 配置 , 其他平台配置差异不大\n\n免费 , 但提速有限 , 国内响应平均 4秒内\n\n假设 :\n\n * github账号 : sancan12\n * 域名 : blog.bozhu12.cc\n\n大致步骤 :\n\n 1. ssl控制台 -> 上传证书 -> 下载证书 , cv内容 即可 (分别有 证书内容/私钥)\n 2. cdn控制台 -> 域名管理 -> 添加域名\n 3. 填写配置 (下图\n 4. 配置域名 cname记录即可\n 5. 在网上找些网站平测试\n\n----------------------------------------\n\n以上内容仅限做引导说明 , 如有问题评论区讨论吧",charsets:{cjk:!0}},{title:"Linux基本操作篇",frontmatter:{title:"Linux基本操作篇",author:"柏竹",permalink:"/other/183ssax",date:"2020-02-18T00:00:00.000Z",categories:["后端"],tags:["Linux"]},regularPath:"/03.%E6%9B%B4%E5%A4%9A/02.Linux/01.Linux%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C.html",relativePath:"03.更多/02.Linux/01.Linux常用手册.md",key:"v-5b6cb686",path:"/other/183ssax/",headers:[{level:2,title:"用户命令",slug:"用户命令",normalizedTitle:"用户命令",charIndex:17},{level:2,title:"目录命令",slug:"目录命令",normalizedTitle:"目录命令",charIndex:322},{level:2,title:"文件命令",slug:"文件命令",normalizedTitle:"文件命令",charIndex:724},{level:2,title:"查找命令",slug:"查找命令",normalizedTitle:"查找命令",charIndex:1442},{level:2,title:"其他命令",slug:"其他命令",normalizedTitle:"其他命令",charIndex:1812}],headersStr:"用户命令 目录命令 文件命令 查找命令 其他命令",content:"# Linux基本操作篇\n\n\n# 用户命令\n\n用户查看\n\ncat /etc/passwd\n# 查询信息\nroot:x:0:0:root:/root:/bin/bash\n\t- root 用户名\n\t- x 密码\n\t- 0 账号ID\n\t- 0 组ID\n\n\n用户切换\n\nsu {用户名}\n\n\n用户创建\n\nuseradd {账号}\n#示例 useradd sans\n\n\n用户删除\n\n# -r 选项 将用户连同主目录一起删除\nuserdel -r {账号}\n\n\n用户口令管理\n\npasswd [Options] {账号}\nOptions：\n\t-l 锁定口令，即禁用账号\n\t-u 口令解锁\n\t-d 使账号无口令\n\t-f 强迫用户下次登录时修改口令\n\n\n\n# 目录命令\n\n目录查看\n\n# 查看当前目录文件名 \nls \n# 列出所有文件 (包括隐藏文件)\nll\n# 查看当前目录路径\npwd\n\n\n目录切换\n\n# 切换指定目录\ncd {目录}\n# 返回上级目录\ncd ..\n# 返回根目录\ncd /\n\n\n目录创建\n\nmkdir {目录名}\n\n\n> 如果root用户创建，注意其他用户是不可用的需要！！\n\n目录移动\n\n# 将目录搬运指定路径\nmv {目录} {目标路径}\n\n\n目录 打包&拆包\n\n# 打包\ntar -cvf {目录/文件}.tar\n# 压缩包\ntar -zcvf {目录/文件}.tar.gz\n# 拆包\ntar -xvf {文件}.tar\n# 解压 (需要指定路径)\ntar -zxvf {File}.tar.gz -C {目录}\n\n\n目录删除\n\nrmdir {目录}\n\n\n> 删除目录不建议命令删除（容易翻车 还是乖乖手动在Linux上删除吧\n\n\n# 文件命令\n\n文件查看\n\n# 标准形式全部展现\ncat {文件}\n# 当行形式展现\nmore {文件}\n\t- Enter键(回车) 下行\n\t- :f 显示当前行\n\t- q 离开\n# 翻页形式展现\nless {文件}\n\t- 空格键/pagedown键 下页\n\t- pageup键 上页\n\t- q 退出\n\n\n修改权限\n\n# 设置所有权\n# chmod [参数] [文件]\nchmod 777 {文件名}\n\n\nr读 -- w写 -- x执行\n\n操作符    R   W   X   R   W   X   R   W   X\n权限值    4   2   1   4   2   1   4   2   1\n权限分配           |           |           |\n\n权限分配分类顺序：所有者 -> 文件分组 -> 其他用户\n\n> 权限类型会根据权限值相加判断权限是否赋予！\n\n文件创建\n\ntouch {文件名}\n\n\n文件编辑\n\n# 编辑器编辑\nvim {文件}\n\t- Esc键 切换模式\n\t- i 编辑模式\n\t- :q 退出\n\t- :wq 保存并退出\n\t- :wq!保存并退出(强制)\n# 重定向文件\n# 覆盖模式\necho '{内容}'>{文件}\n# 追加模式\necho '{内容}'>>{文件}\n\n\n**文件 复制&拷贝 **\n\ncp {旧文件} {新文件名} \n\n\n文件移动\n\nmv {文件} {目录}\n\n\n删除文件\n\nrm {文件}\nrm -rf {文件}\n# 删除大小为0的文件\nfind ./ -size 0 | xargs rm -f &\n\n\n> 删除文件不建议代码形式进行递归删除\n\n文件查找\n\n\n# 查找命令\n\n进程查找\n\n# 查指定进程\nps -ef | grep {进程名}\n# 查端口\nnetstat -antpl | grep {端口名}\n\n\n文件查找\n\n# 在当前路径 按 文件名/目录名 查 \nfind -name {关键字} -ls\n# 递归查找所有后缀 .xml文件\nfind . -name \"*.xml\"\n# 递归查找所有后缀 .xml文件，且内容包含有 hello world\nfind . -name \"*.xml\" | xargs grep \"hello world\"\n# 查找当前所有目录下的jar包文件\nls -l | grep '.jar'\n# 在当前路径 按 模糊文件名/目录名 查\nlocate {关键字}\n\n\n环境变量属性值 查找\n\nwhich {属性名}\n# 查所有环境\nwhich * \n\n\n\n# 其他命令\n\n系统命令 防火墙相关\n\n# 查看防火墙状态\nsystemctl status firewalld\n# 启动防火墙\nsystemctl start firewalld\n# 关闭防火墙\nsystemctl stop firewalld\n\n# 查询防火墙服务是否开机启动\nsystemctl is-enabled firewalld\n# 开机时启用防火墙服务\nsystemctl enable firewalld\n# 开机时禁用防火墙服务\nsystemctl disable firewalld\n\n# 查询已经启动的服务列表\nsystemctl list-unit-files|grep enabled\n# 查询启动失败的服务列表\nsystemctl --failed\n\n\n系统命令 服务相关\n\n# 查看IP\nifconfig\n# 查看网络服务状态\nsystemctl status network\n# 启动网络服务\nsystemctl start network\n#停止网络服务\nsystemctl stop network\n# 重启网络服务\nsystemctl restart network\n\n# 设置开机启动\nsystemctl enable network\n\n\n进程相关\n\n# 查看tomcat程序进程\nps -ef | grep tomcat \n# 高亮关键字\nps -ef | grep --coloer java\n# 终止进程 终止19979进程\nkill -9 19979\n",normalizedContent:"# linux基本操作篇\n\n\n# 用户命令\n\n用户查看\n\ncat /etc/passwd\n# 查询信息\nroot:x:0:0:root:/root:/bin/bash\n\t- root 用户名\n\t- x 密码\n\t- 0 账号id\n\t- 0 组id\n\n\n用户切换\n\nsu {用户名}\n\n\n用户创建\n\nuseradd {账号}\n#示例 useradd sans\n\n\n用户删除\n\n# -r 选项 将用户连同主目录一起删除\nuserdel -r {账号}\n\n\n用户口令管理\n\npasswd [options] {账号}\noptions：\n\t-l 锁定口令，即禁用账号\n\t-u 口令解锁\n\t-d 使账号无口令\n\t-f 强迫用户下次登录时修改口令\n\n\n\n# 目录命令\n\n目录查看\n\n# 查看当前目录文件名 \nls \n# 列出所有文件 (包括隐藏文件)\nll\n# 查看当前目录路径\npwd\n\n\n目录切换\n\n# 切换指定目录\ncd {目录}\n# 返回上级目录\ncd ..\n# 返回根目录\ncd /\n\n\n目录创建\n\nmkdir {目录名}\n\n\n> 如果root用户创建，注意其他用户是不可用的需要！！\n\n目录移动\n\n# 将目录搬运指定路径\nmv {目录} {目标路径}\n\n\n目录 打包&拆包\n\n# 打包\ntar -cvf {目录/文件}.tar\n# 压缩包\ntar -zcvf {目录/文件}.tar.gz\n# 拆包\ntar -xvf {文件}.tar\n# 解压 (需要指定路径)\ntar -zxvf {file}.tar.gz -c {目录}\n\n\n目录删除\n\nrmdir {目录}\n\n\n> 删除目录不建议命令删除（容易翻车 还是乖乖手动在linux上删除吧\n\n\n# 文件命令\n\n文件查看\n\n# 标准形式全部展现\ncat {文件}\n# 当行形式展现\nmore {文件}\n\t- enter键(回车) 下行\n\t- :f 显示当前行\n\t- q 离开\n# 翻页形式展现\nless {文件}\n\t- 空格键/pagedown键 下页\n\t- pageup键 上页\n\t- q 退出\n\n\n修改权限\n\n# 设置所有权\n# chmod [参数] [文件]\nchmod 777 {文件名}\n\n\nr读 -- w写 -- x执行\n\n操作符    r   w   x   r   w   x   r   w   x\n权限值    4   2   1   4   2   1   4   2   1\n权限分配           |           |           |\n\n权限分配分类顺序：所有者 -> 文件分组 -> 其他用户\n\n> 权限类型会根据权限值相加判断权限是否赋予！\n\n文件创建\n\ntouch {文件名}\n\n\n文件编辑\n\n# 编辑器编辑\nvim {文件}\n\t- esc键 切换模式\n\t- i 编辑模式\n\t- :q 退出\n\t- :wq 保存并退出\n\t- :wq!保存并退出(强制)\n# 重定向文件\n# 覆盖模式\necho '{内容}'>{文件}\n# 追加模式\necho '{内容}'>>{文件}\n\n\n**文件 复制&拷贝 **\n\ncp {旧文件} {新文件名} \n\n\n文件移动\n\nmv {文件} {目录}\n\n\n删除文件\n\nrm {文件}\nrm -rf {文件}\n# 删除大小为0的文件\nfind ./ -size 0 | xargs rm -f &\n\n\n> 删除文件不建议代码形式进行递归删除\n\n文件查找\n\n\n# 查找命令\n\n进程查找\n\n# 查指定进程\nps -ef | grep {进程名}\n# 查端口\nnetstat -antpl | grep {端口名}\n\n\n文件查找\n\n# 在当前路径 按 文件名/目录名 查 \nfind -name {关键字} -ls\n# 递归查找所有后缀 .xml文件\nfind . -name \"*.xml\"\n# 递归查找所有后缀 .xml文件，且内容包含有 hello world\nfind . -name \"*.xml\" | xargs grep \"hello world\"\n# 查找当前所有目录下的jar包文件\nls -l | grep '.jar'\n# 在当前路径 按 模糊文件名/目录名 查\nlocate {关键字}\n\n\n环境变量属性值 查找\n\nwhich {属性名}\n# 查所有环境\nwhich * \n\n\n\n# 其他命令\n\n系统命令 防火墙相关\n\n# 查看防火墙状态\nsystemctl status firewalld\n# 启动防火墙\nsystemctl start firewalld\n# 关闭防火墙\nsystemctl stop firewalld\n\n# 查询防火墙服务是否开机启动\nsystemctl is-enabled firewalld\n# 开机时启用防火墙服务\nsystemctl enable firewalld\n# 开机时禁用防火墙服务\nsystemctl disable firewalld\n\n# 查询已经启动的服务列表\nsystemctl list-unit-files|grep enabled\n# 查询启动失败的服务列表\nsystemctl --failed\n\n\n系统命令 服务相关\n\n# 查看ip\nifconfig\n# 查看网络服务状态\nsystemctl status network\n# 启动网络服务\nsystemctl start network\n#停止网络服务\nsystemctl stop network\n# 重启网络服务\nsystemctl restart network\n\n# 设置开机启动\nsystemctl enable network\n\n\n进程相关\n\n# 查看tomcat程序进程\nps -ef | grep tomcat \n# 高亮关键字\nps -ef | grep --coloer java\n# 终止进程 终止19979进程\nkill -9 19979\n",charsets:{cjk:!0}},{title:"JavaScript进阶技巧",frontmatter:{title:"JavaScript进阶技巧",author:"柏竹",permalink:"/web/1hg7ww",date:"2020-02-18T00:00:00.000Z",categories:["前端"],tags:["技巧"]},regularPath:"/02.%E5%89%8D%E7%AB%AF/03.%E5%89%8D%E7%AB%AF%E6%8A%80%E5%B7%A7/01.JavaScript%E8%BF%9B%E9%98%B6%E6%8A%80%E5%B7%A7.html",relativePath:"02.前端/03.前端技巧/01.JavaScript进阶技巧.md",key:"v-0ecba8f6",path:"/web/1hg7ww/",headers:[{level:2,title:"Promise",slug:"promise",normalizedTitle:"promise",charIndex:21},{level:3,title:"Promise方法",slug:"promise方法",normalizedTitle:"promise方法",charIndex:1042},{level:4,title:"Promise.all()",slug:"promise-all",normalizedTitle:"promise.all()",charIndex:1055},{level:4,title:"Promise.race()",slug:"promise-race",normalizedTitle:"promise.race()",charIndex:1435},{level:3,title:"Promise手写",slug:"promise手写",normalizedTitle:"promise手写",charIndex:1811},{level:3,title:"Promise问题",slug:"promise问题",normalizedTitle:"promise问题",charIndex:4414},{level:2,title:"Fetch",slug:"fetch",normalizedTitle:"fetch",charIndex:4428},{level:3,title:"Get",slug:"get",normalizedTitle:"get",charIndex:5508},{level:3,title:"Post",slug:"post",normalizedTitle:"post",charIndex:5601},{level:2,title:"Async Await",slug:"async-await",normalizedTitle:"async await",charIndex:5815},{level:2,title:"Web存储",slug:"web存储",normalizedTitle:"web存储",charIndex:7082},{level:3,title:"Cookie",slug:"cookie",normalizedTitle:"cookie",charIndex:7092},{level:3,title:"localStorage",slug:"localstorage",normalizedTitle:"localstorage",charIndex:7787},{level:3,title:"sessionStorage",slug:"sessionstorage",normalizedTitle:"sessionstorage",charIndex:8036},{level:3,title:"Web存储总结",slug:"web存储总结",normalizedTitle:"web存储总结",charIndex:8243},{level:2,title:"call & apply & bind",slug:"call-apply-bind",normalizedTitle:"call &amp; apply &amp; bind",charIndex:null},{level:3,title:"call",slug:"call",normalizedTitle:"call",charIndex:2575},{level:4,title:"call()手写",slug:"call-手写",normalizedTitle:"call()手写",charIndex:8944},{level:3,title:"apply",slug:"apply",normalizedTitle:"apply",charIndex:8584},{level:3,title:"bind",slug:"bind",normalizedTitle:"bind",charIndex:2207}],headersStr:"Promise Promise方法 Promise.all() Promise.race() Promise手写 Promise问题 Fetch Get Post Async Await Web存储 Cookie localStorage sessionStorage Web存储总结 call & apply & bind call call()手写 apply bind",content:"# JavaScript进阶技巧\n\n\n# Promise\n\nPromise是回调的升级版 , 在处理花费较长时间的任务时 , 使用 Promise 可以进行异步处理 , 防止堵塞\n\n学习来源 : 点击跳转\n\n响应结构说明 :\n\n * Prototype : 原型类型\n * PromiseState : pending(等待) / fulfilled(完成) / rejected(拒绝)\n * PromiseResult : 响应数据\n\n案例 1: (检测图片有效)\n\nconst imageUrl = '';\n\nconst imgPromise = (url) => {\n    return new Promise( (resolve, reject) => {\n        const img = new Image();\n        img.src = url;\n        // 加载成功\n        img.onload = () => {\n            resolve(img);\n        }\n        img.onerror = () => {\n            reject(new Error('图片有误'));\n        }\n    } );\n};\n\nimgPromise(imageUrl)\n\t.then( img => {\n    \tconsole.log('success : ',img)\n\t})\n\t.catch(err => {\n    \tconsole.log('error: ',err)\n\t})\n\n\n案例2 : (随机数判断)\n\nnew Promise((resolve, reject) => {\n  setTimeout(() => {\n      let num = Math.floor(Math.random() * 11);//0-10的随机数\n  \t  if (num >= 5) {\n  \t    resolve(num);\n  \t  } else {\n  \t    reject(num);\n  \t  }\n  \t},1000)\n}).then(res => {\n  console.log(\"执行了成功时的回调 , 数值为：\"+ res);\n}).catch(err => {\n  console.log(\"执行了失败时的回调 , 数值为：\"+ err);\n})\n\n\n\n# Promise方法\n\n# Promise.all()\n\nall()方法 用于处理多个异步任务\n\nlet p1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('结果1');\n  }, 1000);\n})\nlet p2 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('结果2');\n  }, 2000);\n})\n\n//Promise.all([])接收多个异步任务 , 放入数组中\nPromise.all([p1, p2]).then(results => {//results接收多个参数 , 所以是数组\n  console.log(results);//[\"结果1\", \"结果2\"]\n})\n\n\n# Promise.race()\n\nrace()方法 当中的任务谁先完成就执行谁\n\nlet p1 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('结果1');\n  }, 1000);\n})\nlet p2 = new Promise((resolve, reject) => {\n  setTimeout(() => {\n    resolve('结果2');\n  }, 2000);\n})\n//Promise.race([])中接收多个异步任务 , 放入数组中\nPromise.race([p1, p2]).then(result => { //p1和p2 公用同一result , 谁先完成接收谁\n  console.log(result);\n})\n\n\n\n# Promise手写\n\n学习来源 : 点击跳转\n\nclass Commitment {\n    // 状态\n    static PENDING = '待定';\n    static FULFILLED = '成功';\n    static REJECTED = '拒绝';\n    // 构造方法\n    constructor(func) {\n        this.status = Commitment.PENDING;\n        this.result = null;\n        // 保存函数\n        this.resolveCallbacks = [];\n        this.rejectCallbacks = [];\n        // 传入异常对象进行操作\n        try {\n            func(this.resolve.bind(this), this.reject.bind(this));\n        } catch (err) {\n            this.reject(err);\n        }\n\n    }\n    // 失败\n    resolve(res) {\n        // 事件后执行\n        setTimeout(() => {\n            if (this.status === Commitment.PENDING) {\n                this.status = Commitment.FULFILLED;\n                this.result = res;\n                this.resolveCallbacks.forEach(call => {\n                    call(res)\n                });\n            }\n        });\n    }\n    // 成功\n    reject(res) {\n        // 事件后执行\n        setTimeout(() => {\n            if (this.status === Commitment.PENDING) {\n                this.status = Commitment.REJECTED;\n                this.result = res;\n                this.rejectCallbacks.forEach(call => {\n                    call(res)\n                });\n            }\n        });\n    }\n    then(onFULFILLED, onREJECTED) {\n        return new Commitment((resolve, reject) => {\n            // 不是函数则传递空函数\n            onFULFILLED = typeof onFULFILLED === 'function' ? onFULFILLED : () => { };\n            onREJECTED = typeof onREJECTED === 'function' ? onREJECTED : () => { };\n            // 如果外部也使用了异步 , 很有可能还是 待定状态\n            if (this.status === Commitment.PENDING) {\n                this.resolveCallbacks.push(onFULFILLED);\n                this.rejectCallbacks.push(onREJECTED);\n            }\n            if (this.status === Commitment.FULLFILLED) {\n                // 异步处理\n                setTimeout(() => {\n                    onFULFILLED(this.result);\n                })\n            }\n            if (this.status === Commitment.REJECTED) {\n                // 异步处理\n                setTimeout(() => {\n                    onREJECTED(this.result);\n                });\n            }\n        });\n    }\n}\n\n// 测试实例\nconsole.log('No.1');\nlet commitment = new Commitment((resolve, reject) => {\n    console.log('No.2');\n    setTimeout(() => {\n        reject('这次一定');\n        console.log('No.4');\n    });\n});\ncommitment.then(\n    res => { console.log(res) },\n    err => { console.log(err) }\n)\nconsole.log('No.3');\n\n\n测试步骤说明 : (按照No.x步骤说明)\n\n 1. (待定) new实例\n 2. (待定) 异步操作 , 执行 then() , 由于是待定状态进行 数组保存函数(resolve/reject)\n 3. (成功) 执行 reject() 里面还有一个异步处理(外部先执行了)\n 4. (成功) 执行外部异步 , 最后和 reject() 共同跑完\n\n\n# Promise问题\n\n\n# Fetch\n\nFetch 和 ajax 一样能实现异步请求 , Fetch 请求是基于 Promise对象(响应为Promise)\n\nFetch 和 ajax 区别 :\n\n * 当接收到错误HTTP状态码(404/500)时 , 并不会进行 reject()处理(关闭网络才会进行该处理) , 但会在 fetch()处理中返回 Promise对象ok属性为 false 的异常\n * fetch() 可以接收跨域 cookies , 也可 建立跨域会话\n * fetch() 不会发送 cookies . 需要自行修改请求头(下面有)\n\nMDN文档 : 点击跳转\n\n学习来源 : 点击跳转\n\n基本语法 :\n\nfetch(url, options).then( res =>{\n\t//处理http响应\n})\n.catch( err =>{\n\t//处理错误\n})\n\n\nResponse对象响应结构 : (主要关注 PromiseResult的Response对象 响应数据)\n\n属性           类型                        说明\nbody         Object (ReadableStream)   响应体\nbodyUsed     Boolean                   \nheaders      Object (Headers)          响应头\nok           Boolean                   是否成功\nredirected   Boolean                   是否发生跳转\nstatus       Number                    http状态码\nstatusText   String                    返回状态文字描述\ntype         String                    返回请求类型\nurl          String                    来源url\n\n> 注意 :\n> \n>  * fetch默认不带cookie 传递cookie时 , 必须在header参数内加上 ==credentials: 'include'== , 才会像 xhr 将当前cookie 带有请求中\n>  * 请求成功返回 Response对象 / 失败则是 TypeError对象\n>  * 请求异常捕获操作一般 使用await 搭配 try-catch异常捕获\n\n\n# Get\n\nfetch(`url`)\t\n.then(response => response.json())\n.then(data => console.log(data));\n\n\n\n# Post\n\nfetch('url',{\n\tmethod: 'POST',\n    body: JSON.stringify({name:'Sans',age:20}),\n    headers: { 'Content-Type': 'application/json' }\n})\n.then(response => response.json())\n.then(data => console.log(data));\n\n\n\n# Async Await\n\nAsync 是用于声明异步 function函数 ; Await 是用于等待 异步方法执行完成\n\nAsync Await函数 一般会返回Promise对象 (也是基于Promise延伸)\n\n// 返回的是 Promise对象\nasync function shwo() {\n    // 这两条返回是同理的\n    // return Promise.resolve('Sans');\n    return 'Sans';\n}\nshwo().then(value =>{\n    console.log(value); // Sans\n}) \n\n\n实例 :\n\n异步最大的痛点就是在多个共同运行时 , 顺序不能同步执行 , 例如以下代码 , 每次执行结果的顺序不一样\n\nconst url = \"https://gorest.co.in/public/v1/users\"\nfunction show(){\n    fetch(`${url}/1/`)\n\t\t.then(res => res.json())\n\t\t.then(json => json.data)\n\t\t.then(data => console.log(`${data.name}`))\n\n\tfetch(`${url}/2/`)\n\t\t.then(res => res.json())\n\t\t.then(json => json.data)\n\t\t.then(data => console.log(`${data.name}`))\n\t\n\tfetch(`${url}/3/`)\n\t\t.then(res => res.json())\n\t\t.then(json => json.data)\n\t\t.then(data => console.log(`${data.name}`))\n}\nshow()\n\n\nAsync Await 解决痛点\n\nconst url = \"https://gorest.co.in/public/v1/users\"\nasync function show(){\n    let res1 = await fetch(`${url}/1/`)\n    let json = await res1.json();\n    console.log(json.data.name)\n    \n\tlet res2 = await fetch(`${url}/2/`)\n    let json2 = await res2.json();\n    console.log(json2.data.name)\n    \n\tlet res3 = await fetch(`${url}/3/`)\n    let json3 = await res3.json();\n    console.log(json3.data.name)\n}\nshow()\n\n\n> await 会等待请求 , 等待的是当前 async修饰的函数 , 并不会影响主线程\n\n\n# Web存储\n\n\n# Cookie\n\nCookie 是服务器发送到浏览器中的本地小块数据(4Kb大小) , 由于浏览器访问的HTTP是无状态的 , 可以通过Cookie 记录状态信息\n\nMDN文档 : 点击跳转\n\nCookie应用方面 :\n\n * 会话状态管理 (登录状态/记住密码/...)\n * 个性化设置 (自定义设置/主题/...)\n * 浏览器行为跟踪\n\n> Cookie 是早期开发的 , 存储小 , 每次请求都携带(额外开销) , Cookie 也逐渐被淘汰\n\n存储形式 : 名值对字符串形式存储\n\n操作示例 :\n\n// 存储\nlet key = \"Sans\";\nlet value = encodeURIComponent(\"\");\ndocument.cookie = `${key}=${value}`;\n\n// 提取\n// 分割结果 [['user',\"xxx\"],['Jone','xxx']]\nlet array = document.cookie\n\t.split(';') // 分割结果 ['Sans=xxx','Jone=xxx']\n\t.map( cookie => cookie.split('=') ); \n\n\n> value 进行 URL编码 是为了防止输入 非法字符(空格/分号/...) 问题\n\n有效期设置 :\n\n只需在后面添加参数 max-age=时间量 (单位s)\n\n// 两天\nlet twoDays = 2 * 24 * 60 * 60;\ndocument.cookie = `${key}=${value}; max-age=${twoDays}`;\n\n\n\n# localStorage\n\n永远存储至浏览器(可手动删) , 有同步机制(影响渲染)\n\nMDN文档 : 点击跳转\n\n存储形式 : 键值对字符串形式存储\n\n操作示例 :\n\n// 存储\nlocalStorage.setItem('myCat', 'Tom');\n// 提取\nlet cat = localStorage.getItem('myCat');\n// 移出\nlocalStorage.removeItem('myCat');\n// 清空\nlocalStorage.clear();\n\n\n\n# sessionStorage\n\n存储于 当前浏览器会话 , 一旦关闭则失效(安全性高)\n\nMDN文档 : 点击跳转\n\n存储形式 : 键值对字符串形式存储\n\n操作示例 : 和localStorage操作方式一致\n\n注意 :\n\n * 页面一旦刷新 sessionStorage 就失效\n * 浏览器另开一个新窗口(每个页面都有各自的sessionStorage) , sessionStorage 也不会共享\n\n\n# Web存储总结\n\n          COOKIE    LOCALSTORAGE   SESSIONSTORAGE\n大小        4Kb       10Mb           5Mb\n兼容        H4/H5     H5             H5\n访问        任何窗口      任何窗口           同一窗口\n有效期       手动设置      无              窗口关闭\n存储位置      浏览器&服务器   浏览器            浏览器\n与请求一同发送   Y         N              N\n语法        复杂        简易             简易\n\n\n# call & apply & bind\n\nJavaScript函数都是 Funcation对象 是构造函数 , 构造函数有 Funcation.prototype原型对象 , 原型对象 里面包含有很多属性(call)\n\n\n# call\n\ncall()方法 指定的 this 值和单独给出的 一个/多个 参数来调用一个函数\n\n意图 : call() 实现在不同对象 分配/调用 一个对象的 函数/方法\n\nMDN文档 : 点击跳转\n\n**语法 : ** ==function.call(thisArg, arg1, arg2, ...)==\n\n参数        选择   说明\nthisArg   可选   在 function函数 运行时使用的 this 值\narg...    可选   传递的数据\n\n实例可以看以上链接文档\n\n# call()手写\n\nfunction person( a , b , c , d){\n    return {\n        name: this.name,\n        a: a, b: b, c: c, d:d\n    }\n\n}\n\nvar people = { name:'Sans' };\n\nFunction.prototype.newCall = function (obj) {\n    // 对象obj不存在指向window\n    var obj = obj || window;\n    // this指定的并非为 person , 因此需要绑定\n    obj.p = this;\n    let newArray = [];\n    for(let i = 1 ; i < arguments.length ; i++){\n        // 最终结构 [ 'arguments[1]', 'arguments[2]', 'arguments[3]', 'arguments[4]' ]\n        newArray.push('arguments[' + i + ']')\n    }\n    // 执行方法\n    var res = eval('obj.p('+newArray+')');\n    delete obj.p;\n    return res;\n};\n\n// 测试代码\nlet p = person.newCall( people , 'No.1' , 'No.2' , 'No.3' , 'No.4');\nconsole.log(p);\n\n\n\n# apply\n\napply() 方法语法作用和 call()相同 , 唯独区别在 接收的是参数列表\n\nMDN文档 : 点击跳转\n\n语法 : ==apply(thisArg, argsArray)==\n\n参数          选择   说明\nthisArg     可选   在 function函数 运行时使用的 this 值\nargsArray   可选   数组/类数组对象\n\n\n# bind",normalizedContent:"# javascript进阶技巧\n\n\n# promise\n\npromise是回调的升级版 , 在处理花费较长时间的任务时 , 使用 promise 可以进行异步处理 , 防止堵塞\n\n学习来源 : 点击跳转\n\n响应结构说明 :\n\n * prototype : 原型类型\n * promisestate : pending(等待) / fulfilled(完成) / rejected(拒绝)\n * promiseresult : 响应数据\n\n案例 1: (检测图片有效)\n\nconst imageurl = '';\n\nconst imgpromise = (url) => {\n    return new promise( (resolve, reject) => {\n        const img = new image();\n        img.src = url;\n        // 加载成功\n        img.onload = () => {\n            resolve(img);\n        }\n        img.onerror = () => {\n            reject(new error('图片有误'));\n        }\n    } );\n};\n\nimgpromise(imageurl)\n\t.then( img => {\n    \tconsole.log('success : ',img)\n\t})\n\t.catch(err => {\n    \tconsole.log('error: ',err)\n\t})\n\n\n案例2 : (随机数判断)\n\nnew promise((resolve, reject) => {\n  settimeout(() => {\n      let num = math.floor(math.random() * 11);//0-10的随机数\n  \t  if (num >= 5) {\n  \t    resolve(num);\n  \t  } else {\n  \t    reject(num);\n  \t  }\n  \t},1000)\n}).then(res => {\n  console.log(\"执行了成功时的回调 , 数值为：\"+ res);\n}).catch(err => {\n  console.log(\"执行了失败时的回调 , 数值为：\"+ err);\n})\n\n\n\n# promise方法\n\n# promise.all()\n\nall()方法 用于处理多个异步任务\n\nlet p1 = new promise((resolve, reject) => {\n  settimeout(() => {\n    resolve('结果1');\n  }, 1000);\n})\nlet p2 = new promise((resolve, reject) => {\n  settimeout(() => {\n    resolve('结果2');\n  }, 2000);\n})\n\n//promise.all([])接收多个异步任务 , 放入数组中\npromise.all([p1, p2]).then(results => {//results接收多个参数 , 所以是数组\n  console.log(results);//[\"结果1\", \"结果2\"]\n})\n\n\n# promise.race()\n\nrace()方法 当中的任务谁先完成就执行谁\n\nlet p1 = new promise((resolve, reject) => {\n  settimeout(() => {\n    resolve('结果1');\n  }, 1000);\n})\nlet p2 = new promise((resolve, reject) => {\n  settimeout(() => {\n    resolve('结果2');\n  }, 2000);\n})\n//promise.race([])中接收多个异步任务 , 放入数组中\npromise.race([p1, p2]).then(result => { //p1和p2 公用同一result , 谁先完成接收谁\n  console.log(result);\n})\n\n\n\n# promise手写\n\n学习来源 : 点击跳转\n\nclass commitment {\n    // 状态\n    static pending = '待定';\n    static fulfilled = '成功';\n    static rejected = '拒绝';\n    // 构造方法\n    constructor(func) {\n        this.status = commitment.pending;\n        this.result = null;\n        // 保存函数\n        this.resolvecallbacks = [];\n        this.rejectcallbacks = [];\n        // 传入异常对象进行操作\n        try {\n            func(this.resolve.bind(this), this.reject.bind(this));\n        } catch (err) {\n            this.reject(err);\n        }\n\n    }\n    // 失败\n    resolve(res) {\n        // 事件后执行\n        settimeout(() => {\n            if (this.status === commitment.pending) {\n                this.status = commitment.fulfilled;\n                this.result = res;\n                this.resolvecallbacks.foreach(call => {\n                    call(res)\n                });\n            }\n        });\n    }\n    // 成功\n    reject(res) {\n        // 事件后执行\n        settimeout(() => {\n            if (this.status === commitment.pending) {\n                this.status = commitment.rejected;\n                this.result = res;\n                this.rejectcallbacks.foreach(call => {\n                    call(res)\n                });\n            }\n        });\n    }\n    then(onfulfilled, onrejected) {\n        return new commitment((resolve, reject) => {\n            // 不是函数则传递空函数\n            onfulfilled = typeof onfulfilled === 'function' ? onfulfilled : () => { };\n            onrejected = typeof onrejected === 'function' ? onrejected : () => { };\n            // 如果外部也使用了异步 , 很有可能还是 待定状态\n            if (this.status === commitment.pending) {\n                this.resolvecallbacks.push(onfulfilled);\n                this.rejectcallbacks.push(onrejected);\n            }\n            if (this.status === commitment.fullfilled) {\n                // 异步处理\n                settimeout(() => {\n                    onfulfilled(this.result);\n                })\n            }\n            if (this.status === commitment.rejected) {\n                // 异步处理\n                settimeout(() => {\n                    onrejected(this.result);\n                });\n            }\n        });\n    }\n}\n\n// 测试实例\nconsole.log('no.1');\nlet commitment = new commitment((resolve, reject) => {\n    console.log('no.2');\n    settimeout(() => {\n        reject('这次一定');\n        console.log('no.4');\n    });\n});\ncommitment.then(\n    res => { console.log(res) },\n    err => { console.log(err) }\n)\nconsole.log('no.3');\n\n\n测试步骤说明 : (按照no.x步骤说明)\n\n 1. (待定) new实例\n 2. (待定) 异步操作 , 执行 then() , 由于是待定状态进行 数组保存函数(resolve/reject)\n 3. (成功) 执行 reject() 里面还有一个异步处理(外部先执行了)\n 4. (成功) 执行外部异步 , 最后和 reject() 共同跑完\n\n\n# promise问题\n\n\n# fetch\n\nfetch 和 ajax 一样能实现异步请求 , fetch 请求是基于 promise对象(响应为promise)\n\nfetch 和 ajax 区别 :\n\n * 当接收到错误http状态码(404/500)时 , 并不会进行 reject()处理(关闭网络才会进行该处理) , 但会在 fetch()处理中返回 promise对象ok属性为 false 的异常\n * fetch() 可以接收跨域 cookies , 也可 建立跨域会话\n * fetch() 不会发送 cookies . 需要自行修改请求头(下面有)\n\nmdn文档 : 点击跳转\n\n学习来源 : 点击跳转\n\n基本语法 :\n\nfetch(url, options).then( res =>{\n\t//处理http响应\n})\n.catch( err =>{\n\t//处理错误\n})\n\n\nresponse对象响应结构 : (主要关注 promiseresult的response对象 响应数据)\n\n属性           类型                        说明\nbody         object (readablestream)   响应体\nbodyused     boolean                   \nheaders      object (headers)          响应头\nok           boolean                   是否成功\nredirected   boolean                   是否发生跳转\nstatus       number                    http状态码\nstatustext   string                    返回状态文字描述\ntype         string                    返回请求类型\nurl          string                    来源url\n\n> 注意 :\n> \n>  * fetch默认不带cookie 传递cookie时 , 必须在header参数内加上 ==credentials: 'include'== , 才会像 xhr 将当前cookie 带有请求中\n>  * 请求成功返回 response对象 / 失败则是 typeerror对象\n>  * 请求异常捕获操作一般 使用await 搭配 try-catch异常捕获\n\n\n# get\n\nfetch(`url`)\t\n.then(response => response.json())\n.then(data => console.log(data));\n\n\n\n# post\n\nfetch('url',{\n\tmethod: 'post',\n    body: json.stringify({name:'sans',age:20}),\n    headers: { 'content-type': 'application/json' }\n})\n.then(response => response.json())\n.then(data => console.log(data));\n\n\n\n# async await\n\nasync 是用于声明异步 function函数 ; await 是用于等待 异步方法执行完成\n\nasync await函数 一般会返回promise对象 (也是基于promise延伸)\n\n// 返回的是 promise对象\nasync function shwo() {\n    // 这两条返回是同理的\n    // return promise.resolve('sans');\n    return 'sans';\n}\nshwo().then(value =>{\n    console.log(value); // sans\n}) \n\n\n实例 :\n\n异步最大的痛点就是在多个共同运行时 , 顺序不能同步执行 , 例如以下代码 , 每次执行结果的顺序不一样\n\nconst url = \"https://gorest.co.in/public/v1/users\"\nfunction show(){\n    fetch(`${url}/1/`)\n\t\t.then(res => res.json())\n\t\t.then(json => json.data)\n\t\t.then(data => console.log(`${data.name}`))\n\n\tfetch(`${url}/2/`)\n\t\t.then(res => res.json())\n\t\t.then(json => json.data)\n\t\t.then(data => console.log(`${data.name}`))\n\t\n\tfetch(`${url}/3/`)\n\t\t.then(res => res.json())\n\t\t.then(json => json.data)\n\t\t.then(data => console.log(`${data.name}`))\n}\nshow()\n\n\nasync await 解决痛点\n\nconst url = \"https://gorest.co.in/public/v1/users\"\nasync function show(){\n    let res1 = await fetch(`${url}/1/`)\n    let json = await res1.json();\n    console.log(json.data.name)\n    \n\tlet res2 = await fetch(`${url}/2/`)\n    let json2 = await res2.json();\n    console.log(json2.data.name)\n    \n\tlet res3 = await fetch(`${url}/3/`)\n    let json3 = await res3.json();\n    console.log(json3.data.name)\n}\nshow()\n\n\n> await 会等待请求 , 等待的是当前 async修饰的函数 , 并不会影响主线程\n\n\n# web存储\n\n\n# cookie\n\ncookie 是服务器发送到浏览器中的本地小块数据(4kb大小) , 由于浏览器访问的http是无状态的 , 可以通过cookie 记录状态信息\n\nmdn文档 : 点击跳转\n\ncookie应用方面 :\n\n * 会话状态管理 (登录状态/记住密码/...)\n * 个性化设置 (自定义设置/主题/...)\n * 浏览器行为跟踪\n\n> cookie 是早期开发的 , 存储小 , 每次请求都携带(额外开销) , cookie 也逐渐被淘汰\n\n存储形式 : 名值对字符串形式存储\n\n操作示例 :\n\n// 存储\nlet key = \"sans\";\nlet value = encodeuricomponent(\"\");\ndocument.cookie = `${key}=${value}`;\n\n// 提取\n// 分割结果 [['user',\"xxx\"],['jone','xxx']]\nlet array = document.cookie\n\t.split(';') // 分割结果 ['sans=xxx','jone=xxx']\n\t.map( cookie => cookie.split('=') ); \n\n\n> value 进行 url编码 是为了防止输入 非法字符(空格/分号/...) 问题\n\n有效期设置 :\n\n只需在后面添加参数 max-age=时间量 (单位s)\n\n// 两天\nlet twodays = 2 * 24 * 60 * 60;\ndocument.cookie = `${key}=${value}; max-age=${twodays}`;\n\n\n\n# localstorage\n\n永远存储至浏览器(可手动删) , 有同步机制(影响渲染)\n\nmdn文档 : 点击跳转\n\n存储形式 : 键值对字符串形式存储\n\n操作示例 :\n\n// 存储\nlocalstorage.setitem('mycat', 'tom');\n// 提取\nlet cat = localstorage.getitem('mycat');\n// 移出\nlocalstorage.removeitem('mycat');\n// 清空\nlocalstorage.clear();\n\n\n\n# sessionstorage\n\n存储于 当前浏览器会话 , 一旦关闭则失效(安全性高)\n\nmdn文档 : 点击跳转\n\n存储形式 : 键值对字符串形式存储\n\n操作示例 : 和localstorage操作方式一致\n\n注意 :\n\n * 页面一旦刷新 sessionstorage 就失效\n * 浏览器另开一个新窗口(每个页面都有各自的sessionstorage) , sessionstorage 也不会共享\n\n\n# web存储总结\n\n          cookie    localstorage   sessionstorage\n大小        4kb       10mb           5mb\n兼容        h4/h5     h5             h5\n访问        任何窗口      任何窗口           同一窗口\n有效期       手动设置      无              窗口关闭\n存储位置      浏览器&服务器   浏览器            浏览器\n与请求一同发送   y         n              n\n语法        复杂        简易             简易\n\n\n# call & apply & bind\n\njavascript函数都是 funcation对象 是构造函数 , 构造函数有 funcation.prototype原型对象 , 原型对象 里面包含有很多属性(call)\n\n\n# call\n\ncall()方法 指定的 this 值和单独给出的 一个/多个 参数来调用一个函数\n\n意图 : call() 实现在不同对象 分配/调用 一个对象的 函数/方法\n\nmdn文档 : 点击跳转\n\n**语法 : ** ==function.call(thisarg, arg1, arg2, ...)==\n\n参数        选择   说明\nthisarg   可选   在 function函数 运行时使用的 this 值\narg...    可选   传递的数据\n\n实例可以看以上链接文档\n\n# call()手写\n\nfunction person( a , b , c , d){\n    return {\n        name: this.name,\n        a: a, b: b, c: c, d:d\n    }\n\n}\n\nvar people = { name:'sans' };\n\nfunction.prototype.newcall = function (obj) {\n    // 对象obj不存在指向window\n    var obj = obj || window;\n    // this指定的并非为 person , 因此需要绑定\n    obj.p = this;\n    let newarray = [];\n    for(let i = 1 ; i < arguments.length ; i++){\n        // 最终结构 [ 'arguments[1]', 'arguments[2]', 'arguments[3]', 'arguments[4]' ]\n        newarray.push('arguments[' + i + ']')\n    }\n    // 执行方法\n    var res = eval('obj.p('+newarray+')');\n    delete obj.p;\n    return res;\n};\n\n// 测试代码\nlet p = person.newcall( people , 'no.1' , 'no.2' , 'no.3' , 'no.4');\nconsole.log(p);\n\n\n\n# apply\n\napply() 方法语法作用和 call()相同 , 唯独区别在 接收的是参数列表\n\nmdn文档 : 点击跳转\n\n语法 : ==apply(thisarg, argsarray)==\n\n参数          选择   说明\nthisarg     可选   在 function函数 运行时使用的 this 值\nargsarray   可选   数组/类数组对象\n\n\n# bind",charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Markdown语法拓展",frontmatter:{title:"Markdown语法拓展",author:"柏竹",permalink:"/blog/2ccess",date:"2020-03-14T00:00:00.000Z",categories:["博客相关"],tags:["Markdown"]},regularPath:"/03.%E6%9B%B4%E5%A4%9A/01.%E5%8D%9A%E5%AE%A2%E7%9B%B8%E5%85%B3/03.Markdown%E8%AF%AD%E6%B3%95%E6%8B%93%E5%B1%95.html",relativePath:"03.更多/01.博客相关/03.Markdown语法拓展.md",key:"v-4b0d10ec",path:"/blog/2ccess/",headers:[{level:2,title:"自定义容器",slug:"自定义容器",normalizedTitle:"自定义容器",charIndex:2},{level:2,title:"代码块行高亮",slug:"代码块行高亮",normalizedTitle:"代码块行高亮",charIndex:183},{level:2,title:"标签",slug:"标签",normalizedTitle:"标签",charIndex:361}],headersStr:"自定义容器 代码块行高亮 标签",content:'# 自定义容器\n\n输入\n\n::: tip\n提示ing...\n:::\n\n::: warning\n警告ing...\n:::\n\n::: danger\n危险ing...\n:::\n\n::: details 点击展开\n折叠ing...\n:::\n\n\n输出\n\n提示\n\n提示ing...\n\n注意\n\n警告ing...\n\n警告\n\n危险ing...\n\n点击展开\n\n折叠ing...\n\n\n# 代码块行高亮\n\n输入\n\n```java {4}\n1\n2\n3\n4\n```\n\n\n输出\n\n\n\n\n\n \n\n\n1\n2\n3\n4\n\n\n其他语法\n\n形式     值              说明\n多行区间   {3-8}/{2-4}    由小到大覆盖\n多个单行   {1,3,5,7}      数组形式\n混合使用   {1,3,4-9,11}   混合食用\n\n\n# 标签\n\n输入\n\n#### 《沁园春·雪》 <Badge text="摘"/>\n北国风光<Badge text="注释" type="warning"/>，千里冰封，万里雪飘。\n\n> <Badge text="译文" type="error" vertical="middle"/>: 北方的风光。\n\n\n输入\n\n参数\n\n      \n      \n      \n      ',normalizedContent:'# 自定义容器\n\n输入\n\n::: tip\n提示ing...\n:::\n\n::: warning\n警告ing...\n:::\n\n::: danger\n危险ing...\n:::\n\n::: details 点击展开\n折叠ing...\n:::\n\n\n输出\n\n提示\n\n提示ing...\n\n注意\n\n警告ing...\n\n警告\n\n危险ing...\n\n点击展开\n\n折叠ing...\n\n\n# 代码块行高亮\n\n输入\n\n```java {4}\n1\n2\n3\n4\n```\n\n\n输出\n\n\n\n\n\n \n\n\n1\n2\n3\n4\n\n\n其他语法\n\n形式     值              说明\n多行区间   {3-8}/{2-4}    由小到大覆盖\n多个单行   {1,3,5,7}      数组形式\n混合使用   {1,3,4-9,11}   混合食用\n\n\n# 标签\n\n输入\n\n#### 《沁园春·雪》 <badge text="摘"/>\n北国风光<badge text="注释" type="warning"/>，千里冰封，万里雪飘。\n\n> <badge text="译文" type="error" vertical="middle"/>: 北方的风光。\n\n\n输入\n\n参数\n\n      \n      \n      \n      ',charsets:{cjk:!0}},{title:"Linux文件管理",frontmatter:{title:"Linux文件管理",author:"柏竹",permalink:"/other/122ssa",date:"2020-02-18T00:00:00.000Z",categories:["后端"],tags:["Linux"]},regularPath:"/03.%E6%9B%B4%E5%A4%9A/02.Linux/02.Linux%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86.html",relativePath:"03.更多/02.Linux/02.Linux文件管理.md",key:"v-7e82dfbf",path:"/other/122ssa/",headers:[{level:2,title:"文件",slug:"文件",normalizedTitle:"文件",charIndex:7},{level:2,title:"权限",slug:"权限",normalizedTitle:"权限",charIndex:59},{level:2,title:"目录",slug:"目录",normalizedTitle:"目录",charIndex:37},{level:3,title:"配置",slug:"配置",normalizedTitle:"配置",charIndex:1836},{level:3,title:"根目录",slug:"根目录",normalizedTitle:"根目录",charIndex:2417},{level:3,title:"目录路径",slug:"目录路径",normalizedTitle:"目录路径",charIndex:3491},{level:4,title:"命令操作",slug:"命令操作",normalizedTitle:"命令操作",charIndex:3664}],headersStr:"文件 权限 目录 配置 根目录 目录路径 命令操作",content:"# Linux文件管理\n\n\n# 文件\n\n通过命令 ls&ll 可以得知当前目录的文件&文件夹 , ll 命令可以看到 权限相关信息\n\n[root@bozhu01 ~]# ll\ntotal 8\n-rw-------. 1 root root 1719 11月  9 2021 anaconda-ks.cfg\ndrwxr-xr-x. 2 root root    6 5月  29 19:09 Desktop\ndrwxr-xr-x. 2 root root    6 5月  29 19:09 Documents\ndrwxr-xr-x. 2 root root    6 5月  29 19:09 Downloads\n-rw-------. 1 root root 1767 11月  8 2021 initial-setup-ks.cfg\ndrwxr-xr-x. 2 root root    6 5月  29 19:09 Music\ndrwxr-xr-x. 5 root root   39 5月  30 00:20 mysql\ndrwxr-xr-x. 2 root root    6 5月  29 19:09 Pictures\ndrwxr-xr-x. 2 root root    6 5月  29 19:09 Public\ndrwxr-xr-x. 3 root root   17 5月  31 04:28 tc_tomcat\ndrwxr-xr-x. 2 root root    6 5月  29 19:09 Templates\ndrwxr-xr-x. 3 root root   17 5月  30 01:55 tomcat\ndrwxr-xr-x. 2 root root    6 5月  29 19:09 Videos\n\n\n==(权限) (链接数) (拥有者) (用户组) (文件容量) (最后修改日期) (文件名)==\n\n\n# 权限\n\ndrwxr-xr-x. 包含有很多权限相关的信息\n\n列数   值     说明\n1    d/-   d目录(文件夹) / -文件\n2    r/-   r可读 / -无权\n3    w/-   w可写 / -无权\n4    x/-   x可执行 / -无权\n5    r/-   用户组权限 r可读 / -无权\n6    w/-   用户组权限 w可写 / -无权\n7    x/-   非用户组权限 x可执行 / -无权\n8    r/-   非用户组权限 r可读 / -无权\n9    w/-   非用户组权限 w可写 / -无权\n10   x/-   非用户组权限 x可执行 / -无权\n\n文件&目录权限区别\n\n权限   文件       目录\n内容   文件数据     目录名\nr    读取文件数据   读取目录名\nw    修改文件内容   修改目录名\nx    执行文件内容   进入目录\n\n命令修改权限\n\n * chgrp : 修改文件所属组 (修改前提改组必须存在)\n   \n   ==chgrp [OPTION]... GROUP FILE...== : ==chgrp -R users a== (-R : 目录下全修改)\n\n * chown : 修改文件拥有者\n   \n   ==chown [OPTION]... [OWNER/GROUP] FILE...== : ==chown -R bozhu a==\n   \n   ==chown [OPTION]... [OWNER ] [:[GROUP]] FILE...== : ==chown -R root:root a==\n\n * chmod : 修改文件权限\n   \n   ==chmod [OPTION]... MODE[,MODE]... FILE...==\n\n> 选项较多在系统中帮助查阅\n\nr读 -- w写 -- x执行\n\n操作符    R   W   X   R   W   X   R   W   X\n权限值    4   2   1   4   2   1   4   2   1\n权限分配           |           |           |\n\n分配文件权限 drwxr-xr-x. => ==chomd 755 a== (数字结构 : [4+2+1] [4+1] [4+1])\n\n\n# 目录\n\n\n# 配置\n\nLinux首次目录配置时 , 人们都会先按照自己的想法进行分配 , 没有一个标准规则 , 因此诞生出了 FHS\n\n在漫长的改版中 , 得出 4种目录的交互形态 : 不变 , 可变 , 可分享 , 不分享\n\n                可分享 (SHAREABLE)         不可分享 (UNSHAREABLE)\n不变 (static)     /usr (软件存放出)            /etc (配置文件)\n                /opt (第三方辅助软件)          /boot (启动/内核文件)\n可变 (variable)   /var/mail (用户邮箱)        /var/run (程序相关)\n                /var/spool/news (新闻组)   /var/lock (程序相关)\n\n * 可分享 (shareable) : 可给其他系统挂载使用的目录 , 分享其他主机挂载用的目录\n * 不可分享 (unshareable) : 主机运行的设备&配置 , 和自身有关的\n * 不变 (static) : 不变的数据 . 函数库/文件说明等... (一般随着发行版本变动)\n * 可变 (variable) : 经常修改 , 日志/新闻组等...\n\n> FHS建议 : 根目录/ 分区越小越好\n\n\n# 根目录\n\n结构\n\n目录            说明\n/bin          系统命令执行相关\n/boot         启动项&启动配置相关\n/dev          读取外部设备\n/etc          系统配置\n/lib          函数库\n/media        媒体\n/mnt          挂载额外设备\n/opt          第三方辅助软件\n/run          系统启动运行生成的信息\n/sbin         设置系统环境\n/srv          网络服务启动数据\n/tmp          用户执行程序暂放\n/home         默认用户的家\n              ~ : 默认用户家\n              ~bozhu : 柏竹用户家\n/lib <qual>   二进制函数库\n/root         系统管理员家\n/lost+found   系统文件目录 , ext1&ext2系统目录\n/sys          系统硬件相关信息\n\n这里还差两个目录 /usr&/var 没讲 , 因为是改版后的统合 (为了简洁), 因此分开说明\n\n/usr\n\n放置 可分享&不可变 的数据 , 一般存放 操作系统软件资源\n\n目录              说明\n/usr/bin/       一般用户能够使用的命令\n/usr/lib/       函数库\n/usr/local/     本机安装的软件\n/usr/sbin/      非系统命令 , 网络服务相关\n/usr/share/     只读文件 . 文档&软件说明相关\n/usr/games/     游戏相关\n/usr/include/   c/c++头文件 (c/c++函数库)\n/usr/libexec/   不被一般用户执行的脚本\n/usr/src/       一般源代码\n\n/var\n\n放置 不可分享&可变 的数据 , 存放 缓存&日志&软件产生的数据等...\n\n目录            说明\n/var/cache/   应用程序的缓存\n/var/lib/     程序执行 , 需要用到的数据\n/var/lock/    文件资源 , 一次一个应用程序使用\n/var/log/     日志信息\n/var/mail/    邮箱目录\n/var/run/     程序服务启动 PID\n/var/spool/   队列数据 , 等待其他程序使用的数据\n\n\n# 目录路径\n\n绝对路径 : ==./var/lib== (在当前文件夹进入)\n\n相对路径 : ==/var/lib== (在根路径开始进入)\n\n特殊路径\n\n路径符号     说明\n.        当前目录\n..       上一层目录\n-        前一个工作目录\n~        当前身份家目录\n~bozhu   bozhu家目录\n\n# 命令操作\n\n目录操作\n\n * cd : 切换目录\n * pwd : 显示当前目录\n * mkdir : 创建新目录\n * rmdir : 删除空目录\n * cp : 复制\n * rm : 删除\n * mv : 移动\n\n文件内容查看\n\n * car : 查看\n * more : 翻页查看\n   * 空格 : 下页\n   * /字符串 : 向下查找关键字\n   * :f: : 显示行数\n   * q: : 离开\n   * b : 往回翻页\n * less : 弹性翻页查看\n   * 继承以上 翻页查看 功能\n   * [pagedown]/[pageup] : 翻动 下一页/上一页\n   * /字符串/?字符串 : 向下查找/向上 关键字\n   * n/N : 重复/反复 前一个查找\n   * g/G : 移至 开头/结尾\n\n数据截取\n\n * head : 截取前几行\n * tail : 截取后几行",normalizedContent:"# linux文件管理\n\n\n# 文件\n\n通过命令 ls&ll 可以得知当前目录的文件&文件夹 , ll 命令可以看到 权限相关信息\n\n[root@bozhu01 ~]# ll\ntotal 8\n-rw-------. 1 root root 1719 11月  9 2021 anaconda-ks.cfg\ndrwxr-xr-x. 2 root root    6 5月  29 19:09 desktop\ndrwxr-xr-x. 2 root root    6 5月  29 19:09 documents\ndrwxr-xr-x. 2 root root    6 5月  29 19:09 downloads\n-rw-------. 1 root root 1767 11月  8 2021 initial-setup-ks.cfg\ndrwxr-xr-x. 2 root root    6 5月  29 19:09 music\ndrwxr-xr-x. 5 root root   39 5月  30 00:20 mysql\ndrwxr-xr-x. 2 root root    6 5月  29 19:09 pictures\ndrwxr-xr-x. 2 root root    6 5月  29 19:09 public\ndrwxr-xr-x. 3 root root   17 5月  31 04:28 tc_tomcat\ndrwxr-xr-x. 2 root root    6 5月  29 19:09 templates\ndrwxr-xr-x. 3 root root   17 5月  30 01:55 tomcat\ndrwxr-xr-x. 2 root root    6 5月  29 19:09 videos\n\n\n==(权限) (链接数) (拥有者) (用户组) (文件容量) (最后修改日期) (文件名)==\n\n\n# 权限\n\ndrwxr-xr-x. 包含有很多权限相关的信息\n\n列数   值     说明\n1    d/-   d目录(文件夹) / -文件\n2    r/-   r可读 / -无权\n3    w/-   w可写 / -无权\n4    x/-   x可执行 / -无权\n5    r/-   用户组权限 r可读 / -无权\n6    w/-   用户组权限 w可写 / -无权\n7    x/-   非用户组权限 x可执行 / -无权\n8    r/-   非用户组权限 r可读 / -无权\n9    w/-   非用户组权限 w可写 / -无权\n10   x/-   非用户组权限 x可执行 / -无权\n\n文件&目录权限区别\n\n权限   文件       目录\n内容   文件数据     目录名\nr    读取文件数据   读取目录名\nw    修改文件内容   修改目录名\nx    执行文件内容   进入目录\n\n命令修改权限\n\n * chgrp : 修改文件所属组 (修改前提改组必须存在)\n   \n   ==chgrp [option]... group file...== : ==chgrp -r users a== (-r : 目录下全修改)\n\n * chown : 修改文件拥有者\n   \n   ==chown [option]... [owner/group] file...== : ==chown -r bozhu a==\n   \n   ==chown [option]... [owner ] [:[group]] file...== : ==chown -r root:root a==\n\n * chmod : 修改文件权限\n   \n   ==chmod [option]... mode[,mode]... file...==\n\n> 选项较多在系统中帮助查阅\n\nr读 -- w写 -- x执行\n\n操作符    r   w   x   r   w   x   r   w   x\n权限值    4   2   1   4   2   1   4   2   1\n权限分配           |           |           |\n\n分配文件权限 drwxr-xr-x. => ==chomd 755 a== (数字结构 : [4+2+1] [4+1] [4+1])\n\n\n# 目录\n\n\n# 配置\n\nlinux首次目录配置时 , 人们都会先按照自己的想法进行分配 , 没有一个标准规则 , 因此诞生出了 fhs\n\n在漫长的改版中 , 得出 4种目录的交互形态 : 不变 , 可变 , 可分享 , 不分享\n\n                可分享 (shareable)         不可分享 (unshareable)\n不变 (static)     /usr (软件存放出)            /etc (配置文件)\n                /opt (第三方辅助软件)          /boot (启动/内核文件)\n可变 (variable)   /var/mail (用户邮箱)        /var/run (程序相关)\n                /var/spool/news (新闻组)   /var/lock (程序相关)\n\n * 可分享 (shareable) : 可给其他系统挂载使用的目录 , 分享其他主机挂载用的目录\n * 不可分享 (unshareable) : 主机运行的设备&配置 , 和自身有关的\n * 不变 (static) : 不变的数据 . 函数库/文件说明等... (一般随着发行版本变动)\n * 可变 (variable) : 经常修改 , 日志/新闻组等...\n\n> fhs建议 : 根目录/ 分区越小越好\n\n\n# 根目录\n\n结构\n\n目录            说明\n/bin          系统命令执行相关\n/boot         启动项&启动配置相关\n/dev          读取外部设备\n/etc          系统配置\n/lib          函数库\n/media        媒体\n/mnt          挂载额外设备\n/opt          第三方辅助软件\n/run          系统启动运行生成的信息\n/sbin         设置系统环境\n/srv          网络服务启动数据\n/tmp          用户执行程序暂放\n/home         默认用户的家\n              ~ : 默认用户家\n              ~bozhu : 柏竹用户家\n/lib <qual>   二进制函数库\n/root         系统管理员家\n/lost+found   系统文件目录 , ext1&ext2系统目录\n/sys          系统硬件相关信息\n\n这里还差两个目录 /usr&/var 没讲 , 因为是改版后的统合 (为了简洁), 因此分开说明\n\n/usr\n\n放置 可分享&不可变 的数据 , 一般存放 操作系统软件资源\n\n目录              说明\n/usr/bin/       一般用户能够使用的命令\n/usr/lib/       函数库\n/usr/local/     本机安装的软件\n/usr/sbin/      非系统命令 , 网络服务相关\n/usr/share/     只读文件 . 文档&软件说明相关\n/usr/games/     游戏相关\n/usr/include/   c/c++头文件 (c/c++函数库)\n/usr/libexec/   不被一般用户执行的脚本\n/usr/src/       一般源代码\n\n/var\n\n放置 不可分享&可变 的数据 , 存放 缓存&日志&软件产生的数据等...\n\n目录            说明\n/var/cache/   应用程序的缓存\n/var/lib/     程序执行 , 需要用到的数据\n/var/lock/    文件资源 , 一次一个应用程序使用\n/var/log/     日志信息\n/var/mail/    邮箱目录\n/var/run/     程序服务启动 pid\n/var/spool/   队列数据 , 等待其他程序使用的数据\n\n\n# 目录路径\n\n绝对路径 : ==./var/lib== (在当前文件夹进入)\n\n相对路径 : ==/var/lib== (在根路径开始进入)\n\n特殊路径\n\n路径符号     说明\n.        当前目录\n..       上一层目录\n-        前一个工作目录\n~        当前身份家目录\n~bozhu   bozhu家目录\n\n# 命令操作\n\n目录操作\n\n * cd : 切换目录\n * pwd : 显示当前目录\n * mkdir : 创建新目录\n * rmdir : 删除空目录\n * cp : 复制\n * rm : 删除\n * mv : 移动\n\n文件内容查看\n\n * car : 查看\n * more : 翻页查看\n   * 空格 : 下页\n   * /字符串 : 向下查找关键字\n   * :f: : 显示行数\n   * q: : 离开\n   * b : 往回翻页\n * less : 弹性翻页查看\n   * 继承以上 翻页查看 功能\n   * [pagedown]/[pageup] : 翻动 下一页/上一页\n   * /字符串/?字符串 : 向下查找/向上 关键字\n   * n/n : 重复/反复 前一个查找\n   * g/g : 移至 开头/结尾\n\n数据截取\n\n * head : 截取前几行\n * tail : 截取后几行",charsets:{cjk:!0}},{title:"Linux搭建",frontmatter:{title:"Linux搭建",author:"柏竹",permalink:"/other/cbba2",date:"2020-02-18T00:00:00.000Z",categories:["后端"],tags:["Linux"]},regularPath:"/03.%E6%9B%B4%E5%A4%9A/02.Linux/03.Linux%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA.html",relativePath:"03.更多/02.Linux/03.Linux框架搭建.md",key:"v-9a683472",path:"/other/cbba2/",headers:[{level:2,title:"安装 JDK",slug:"安装-jdk",normalizedTitle:"安装 jdk",charIndex:14},{level:2,title:"安装 MySQL",slug:"安装-mysql",normalizedTitle:"安装 mysql",charIndex:560},{level:2,title:"安装 Tomcat",slug:"安装-tomcat",normalizedTitle:"安装 tomcat",charIndex:2052},{level:2,title:"安装 Zookeeper",slug:"安装-zookeeper",normalizedTitle:"安装 zookeeper",charIndex:2429},{level:2,title:"安装Yum",slug:"安装yum",normalizedTitle:"安装yum",charIndex:3022}],headersStr:"安装 JDK 安装 MySQL 安装 Tomcat 安装 Zookeeper 安装Yum",content:"# Linux搭建\n\n\n# 安装 JDK\n\n 1. 上传JDK压缩文件，放置 根目录创建的 mysoft 文件夹\n\n 2. 解压 (解压至当前目录)\n    \n    tar -xzvf {file}\n    \n\n 3. 测试jdk安装。进入jdk的bin目录进行验证 (返回版本号表示成功)\n    \n    ./java -version \n    \n    \n    > 注意：在jdk的bin目录下执行java命令，前面要有 . 符号\n\n 4. 配置环境变量 ，添加变量 JAVA_HOME、PATH\n    \n    vim /etc/profile\n    ### 在最下面添加 两个变量 注意jdk的路径\n    export JAVA_HOME=/mysoft/jdk1.8.0_11\n    export PATH=$PATH:$JAVA_HOME/bin\n    \n\n 5. 使环境变量生效\n    \n    source /etc/profile\n    \n    \n\n 6. 测试环境配置 (返回预期的bin目录即可)\n    \n    echo $PATH\n    \n\n 7. 在任意路径测试java命令 (返回版本号代表成功)\n    \n    java -version\n    \n\n\n# 安装 MySQL\n\n 1.  检测是否自带安装MySQL\n     \n     yum list installed | grep mysql\n     \n\n 2.  删除系统自带的sql及其依赖 (以防后面冲突)\n     \n     yum -y remove mysql-libs.x86_64\n     \n\n 3.  添加rpm源\n     \n     wget --no-check-certificate dev.mysql.com/get/mysql-community-release-el6-5.noarch.rpm\n     \n\n 4.  安装第一步下载的rpm文件 (出现许可输入y 即可\n     \n     yum install mysql-community-release-el6-5.noarch.rpm\n     \n\n 5.  查看MySQL是否下载 ，列出所有yum repo文件\n     \n     yum repolist enabled | grep mysql\n     \n\n 6.  使用yum安装MySQL （输入3次 y\n     \n     yum install mysql-community-server\n     \n\n 7.  启动MySQL服务\n     \n     service mysqld start\n     \n\n 8.  查看是否自动启动并启动\n     \n     # 查看\n     chkconfig --list | grep mysqld\n     # 自动启动\n     chkconfig mysqld on\n     \n     \n     > 看到3、4、5状态为开或者为 on 则表示成功\n\n 9.  修改字符集为UTF-8\n     \n     vim /etc/my.cnf\n     ### 1. 在 [mysqld] 下面添加：\n     character-set-server=utf8\n     ### 2. 在末尾 [client] 添加：(client没有自行添加)\n     default-character-set=utf8\n     \n\n 10. 重启服务\n     \n     service mysqld restart\n     \n\n 11. 修改默认配置\n     \n     mysql_secure_installation\n     \n     \n     > 此步骤可设置密码，root用户密码可自行设置。此处输入内容依次为：y、y、n、y、y\n\n 12. 授权远程登录，通过改表实现\n     \n     # 上号\n     mysql -uroot -p\n     # 选中库\n     >use mysql;\n     # 修改表数据\n     >update user set host = '%' where user = 'root' and host='localhost';\n     # 允许外网访问\n     >grant all privileges on *.* to 'root'@'%' identified by 'PANZER' with grant option;\n     # 刷新MySQL的系统权限相关表\n     >flush privileges;\n     \n\n> 如果连接还出现异常，请检查 ：\n> \n>  * 授权问题\n>  * 是否刷新权限表\n>  * 是否关闭防火墙 或 允许访问\n\n\n# 安装 Tomcat\n\n 1. 安装JDK\n\n 2. 上传Tomcat压缩包到 根目录的 mysoft 文件夹\n\n 3. 解压\n    \n    tar -xzvf {file}\n    \n\n 4. 进入bin目录启动Tomcat\n    \n    sh startup.sh\n    \n\n 5. 关闭防火墙\n    \n    # 查看防火墙状态\n    systemctl status firewalld\n    # 启动防火墙\n    systemctl start firewalld\n    # 关闭防火墙\n    systemctl stop firewalld\n    \n\n 6. 测试访问，\n    \n    # 查看IP\n    ifconfig\n    # 浏览器访问（看见熟系的页面）\n    {IP}:8080 \n    \n\n\n# 安装 Zookeeper\n\n 1. 安装JDK\n\n 2. 上传Zookeeper压缩包到根目录的 mysoft 文件夹\n\n 3. 解压 解压至根路径usr\n    \n    tar -zxvf {file} -C /usr/\n    \n\n 4. 进入 Zookeeper目录 创建 data 目录\n    \n    mkdir data\n    \n\n 5. 编辑配置 ，进入confg目录 拷贝 zoo_sample.cfg 为 zoo.cfg (将默认配置更改并应用)\n    \n    # 拷贝应用的配置\n    cp zoo_sample.cfg zoo.cfg\n    # 编辑配置\n    vim zoo.cfg\n    ### 更改 dataDir属性 路径 file为解压的文件目录\n    dataDir=/usr/{file}/data\n    \n\n 6. Zookeeper 启动&停止&查看\n    \n    # Zookeeper 启动\n    ./zkServer.sh start\n    # Zookeeper 停止\n    ./zkServer.sh stop\n    # Zookeeper 查看\n    ./zkServer.sh status\n    \n    \n    > 需要进入Zookeeper的bin目录且是root权限进行操作\n\n\n# 安装Yum",normalizedContent:"# linux搭建\n\n\n# 安装 jdk\n\n 1. 上传jdk压缩文件，放置 根目录创建的 mysoft 文件夹\n\n 2. 解压 (解压至当前目录)\n    \n    tar -xzvf {file}\n    \n\n 3. 测试jdk安装。进入jdk的bin目录进行验证 (返回版本号表示成功)\n    \n    ./java -version \n    \n    \n    > 注意：在jdk的bin目录下执行java命令，前面要有 . 符号\n\n 4. 配置环境变量 ，添加变量 java_home、path\n    \n    vim /etc/profile\n    ### 在最下面添加 两个变量 注意jdk的路径\n    export java_home=/mysoft/jdk1.8.0_11\n    export path=$path:$java_home/bin\n    \n\n 5. 使环境变量生效\n    \n    source /etc/profile\n    \n    \n\n 6. 测试环境配置 (返回预期的bin目录即可)\n    \n    echo $path\n    \n\n 7. 在任意路径测试java命令 (返回版本号代表成功)\n    \n    java -version\n    \n\n\n# 安装 mysql\n\n 1.  检测是否自带安装mysql\n     \n     yum list installed | grep mysql\n     \n\n 2.  删除系统自带的sql及其依赖 (以防后面冲突)\n     \n     yum -y remove mysql-libs.x86_64\n     \n\n 3.  添加rpm源\n     \n     wget --no-check-certificate dev.mysql.com/get/mysql-community-release-el6-5.noarch.rpm\n     \n\n 4.  安装第一步下载的rpm文件 (出现许可输入y 即可\n     \n     yum install mysql-community-release-el6-5.noarch.rpm\n     \n\n 5.  查看mysql是否下载 ，列出所有yum repo文件\n     \n     yum repolist enabled | grep mysql\n     \n\n 6.  使用yum安装mysql （输入3次 y\n     \n     yum install mysql-community-server\n     \n\n 7.  启动mysql服务\n     \n     service mysqld start\n     \n\n 8.  查看是否自动启动并启动\n     \n     # 查看\n     chkconfig --list | grep mysqld\n     # 自动启动\n     chkconfig mysqld on\n     \n     \n     > 看到3、4、5状态为开或者为 on 则表示成功\n\n 9.  修改字符集为utf-8\n     \n     vim /etc/my.cnf\n     ### 1. 在 [mysqld] 下面添加：\n     character-set-server=utf8\n     ### 2. 在末尾 [client] 添加：(client没有自行添加)\n     default-character-set=utf8\n     \n\n 10. 重启服务\n     \n     service mysqld restart\n     \n\n 11. 修改默认配置\n     \n     mysql_secure_installation\n     \n     \n     > 此步骤可设置密码，root用户密码可自行设置。此处输入内容依次为：y、y、n、y、y\n\n 12. 授权远程登录，通过改表实现\n     \n     # 上号\n     mysql -uroot -p\n     # 选中库\n     >use mysql;\n     # 修改表数据\n     >update user set host = '%' where user = 'root' and host='localhost';\n     # 允许外网访问\n     >grant all privileges on *.* to 'root'@'%' identified by 'panzer' with grant option;\n     # 刷新mysql的系统权限相关表\n     >flush privileges;\n     \n\n> 如果连接还出现异常，请检查 ：\n> \n>  * 授权问题\n>  * 是否刷新权限表\n>  * 是否关闭防火墙 或 允许访问\n\n\n# 安装 tomcat\n\n 1. 安装jdk\n\n 2. 上传tomcat压缩包到 根目录的 mysoft 文件夹\n\n 3. 解压\n    \n    tar -xzvf {file}\n    \n\n 4. 进入bin目录启动tomcat\n    \n    sh startup.sh\n    \n\n 5. 关闭防火墙\n    \n    # 查看防火墙状态\n    systemctl status firewalld\n    # 启动防火墙\n    systemctl start firewalld\n    # 关闭防火墙\n    systemctl stop firewalld\n    \n\n 6. 测试访问，\n    \n    # 查看ip\n    ifconfig\n    # 浏览器访问（看见熟系的页面）\n    {ip}:8080 \n    \n\n\n# 安装 zookeeper\n\n 1. 安装jdk\n\n 2. 上传zookeeper压缩包到根目录的 mysoft 文件夹\n\n 3. 解压 解压至根路径usr\n    \n    tar -zxvf {file} -c /usr/\n    \n\n 4. 进入 zookeeper目录 创建 data 目录\n    \n    mkdir data\n    \n\n 5. 编辑配置 ，进入confg目录 拷贝 zoo_sample.cfg 为 zoo.cfg (将默认配置更改并应用)\n    \n    # 拷贝应用的配置\n    cp zoo_sample.cfg zoo.cfg\n    # 编辑配置\n    vim zoo.cfg\n    ### 更改 datadir属性 路径 file为解压的文件目录\n    datadir=/usr/{file}/data\n    \n\n 6. zookeeper 启动&停止&查看\n    \n    # zookeeper 启动\n    ./zkserver.sh start\n    # zookeeper 停止\n    ./zkserver.sh stop\n    # zookeeper 查看\n    ./zkserver.sh status\n    \n    \n    > 需要进入zookeeper的bin目录且是root权限进行操作\n\n\n# 安装yum",charsets:{cjk:!0}},{title:"Docker",frontmatter:{title:"Docker",author:"柏竹",permalink:"/backend/1hg7cc",date:"2020-02-18T00:00:00.000Z",categories:["容器"],tags:["Docker"]},regularPath:"/03.%E6%9B%B4%E5%A4%9A/99.%E9%9B%B6%E7%A2%8E/01.Docker.html",relativePath:"03.更多/99.零碎/01.Docker.md",key:"v-93907e36",path:"/backend/1hg7cc/",headers:[{level:2,title:"简介",slug:"简介",normalizedTitle:"简介",charIndex:13},{level:2,title:"安装",slug:"安装",normalizedTitle:"安装",charIndex:153},{level:3,title:"Linux",slug:"linux",normalizedTitle:"linux",charIndex:160},{level:3,title:"镜像加速",slug:"镜像加速",normalizedTitle:"镜像加速",charIndex:208},{level:2,title:"命令",slug:"命令",normalizedTitle:"命令",charIndex:1034},{level:3,title:"进程相关",slug:"进程相关",normalizedTitle:"进程相关",charIndex:1133},{level:3,title:"镜像相关",slug:"镜像相关",normalizedTitle:"镜像相关",charIndex:1353},{level:3,title:"容器相关",slug:"容器相关",normalizedTitle:"容器相关",charIndex:1690},{level:2,title:"数据卷",slug:"数据卷",normalizedTitle:"数据卷",charIndex:2493},{level:3,title:"数据卷配置",slug:"数据卷配置",normalizedTitle:"数据卷配置",charIndex:2689},{level:3,title:"数据卷容器配置",slug:"数据卷容器配置",normalizedTitle:"数据卷容器配置",charIndex:3321},{level:2,title:"应用部署",slug:"应用部署",normalizedTitle:"应用部署",charIndex:3844},{level:3,title:"MySQL",slug:"mysql",normalizedTitle:"mysql",charIndex:4054},{level:3,title:"Tomcat",slug:"tomcat",normalizedTitle:"tomcat",charIndex:4794},{level:3,title:"Nginx",slug:"nginx",normalizedTitle:"nginx",charIndex:5308},{level:3,title:"RabbitMQ",slug:"rabbitmq",normalizedTitle:"rabbitmq",charIndex:6340},{level:3,title:"Redis",slug:"redis",normalizedTitle:"redis",charIndex:1509},{level:2,title:"Dockerfile",slug:"dockerfile",normalizedTitle:"dockerfile",charIndex:7392},{level:3,title:"镜像原理",slug:"镜像原理",normalizedTitle:"镜像原理",charIndex:7485},{level:3,title:"镜像制作",slug:"镜像制作",normalizedTitle:"镜像制作",charIndex:7978},{level:4,title:"容器转镜像",slug:"容器转镜像",normalizedTitle:"容器转镜像",charIndex:7986}],headersStr:"简介 安装 Linux 镜像加速 命令 进程相关 镜像相关 容器相关 数据卷 数据卷配置 数据卷容器配置 应用部署 MySQL Tomcat Nginx RabbitMQ Redis Dockerfile 镜像原理 镜像制作 容器转镜像",content:'# Docker\n\n\n# 简介\n\n官网：https://www.docker.com/\n\ndocker是种容器技术，能够解决环境迁移问题\n\n * 开源应用容器\n * 基于Go语言实现\n * 轻量级、可移植\n * 沙箱机制隔离\n\n功能\n\n * 解决代码执行的环境兼容问题\n * 软件打包环境直接应用\n\n\n# 安装\n\n\n# Linux\n\n安装步骤：\n\n 1. 安装Docker\n 2. 安装组件软件包\n 3. 配置阿里云镜像加速（自己的\n\n示例：\n\n# 1、yum 包更新到最新\nyum update\n# 2、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的\nyum install -y yum-utils device-mapper-persistent-data lvm2\n# 3、 设置yum源\nyum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n# 4、 安装docker，出现输入的界面都按 y\nyum install -y docker-ce\n# 5、 查看docker版本，验证是否验证成功\ndocker -v\n\n\n\n# 镜像加速\n\n镜像加速JSON文件需要手动配置 镜像配置：https://developer.aliyun.com/article/110806\n\n阿里云镜像配置\n\n 1. 登录阿里云 镜像服务模块 -> 镜像加速 -> 复制操作文档的镜像配置，如：(个人专属镜像加速\n    \n    {\n      "registry-mirrors": ["https://xd43lwzc.mirror.aliyuncs.com"]\n    }\n    \n\n 2. 进入路径 ==/etc/docker/daemon.json== (没有则创建\n\n 3. 编辑 daemon.json 复制添加以上配置\n\n 4. 重启 Docker ==systemctl restart docker==\n\n 5. 检查配置镜像 。查看参数 ==docker info== (存在以下配置说明配置成功\n    \n    Registry Mirrors:\n    https://xd43lwzc.mirror.aliyuncs.com/\n    \n\n\n# 命令\n\n官方文档：https://docs.docker.com/reference/\n\n一键查看命令：==docker== 命令查看详细：==docker {命令前缀} --help==\n\n\n# 进程相关\n\n * 启动docker服务 ==systemctl start docker==\n * 关闭docker服务 ==systemctl stop docker==\n * 重启docker服务 ==systemctl restart docker==\n * 查看docker状态 ==systemctl status docker==\n * 开机自启docker服务 ==systemctl enable docker==\n\n\n# 镜像相关\n\n * 查看镜像（查看本地镜像 ==docker images== 查看所有镜像 ==docker images -q== 查看所有镜像id\n\n * 搜索镜像 ==docker search redis== 查找redis镜像\n\n * 下载镜像 ==docker pull redis== 下载最新版本Redis ==docker pull redis:5.0== 下载5.0版本Redis\n   \n   > 如果需要了解指定下载的版本：(搜索版本 https://hub.docker.com/\n\n * 删除镜像 ==docker rmi {镜像id}== 删除指定本地镜像 ==docker rmi docker images -q== 删除所有镜像\n\n\n# 容器相关\n\n * 容器查看 ==docker ps== 查看所有正在运行容器 ==docker ps -a== 查看所有容器 ==docker ps -aq== 查看所有容器id ==docker port {name/id}== 查看容器端口\n\n * 查看容器详细 ==docker inspect {name/id}==\n\n * 容器创建 ==docker run {参数}==\n   \n   * -i：保持容器运行\n   * -t：为容器分配一个为输入终端\n   * -d：以守护线程模式运行\n   * --name：为容器命名\n   \n   创建交互式容器 创建自动进入容器，退出自动关闭容器 ==docker run -it --name=c1 redis:5.0 /bin/bash== 创建 redis:5.0 镜像且名称为c1的容器，并初始化指令至 /bin/bash\n   \n   > 进入容器终端需要手动退出 exit\n   \n   创建守护容器 容器后台启动需要手动进入 ==docker run -id --name=c2 mysql /bin/bash==\n\n * 容器进入 ==docker exec -it {容器 name/id} /bin/bash==\n\n * 容器退出 ==exit== / 快捷键==Ctrl+Q+P==\n\n * 容器启动 ==docker start [容器 name/id]==\n   \n   > 如果是交互式容器，启动后会转变为守护线程\n\n * 容器停止 ==docker stop {容器 name/id}==\n\n * 容器删除 ==docker rm {容器 name/id}== 删除指定容器 ==docker rm docker ps -aq== 删除所有容器\n   \n   > 如果容器处于运行状态，则需要停止容器才能进行删除\n\n\n# 数据卷\n\n数据源是容器挂载运行的媒介\n\n数据卷概念：\n\n * 数据卷是宿主机中的一个 目录/文件\n * 但容器 目录和数据卷 绑定后，会立马同步\n * 一个数据卷可同时挂载多个容器\n * 一个容器可被多个数据卷挂载\n\n数据卷作用：\n\n * 容器数据 持久化\n * 外部机器和容器通信的媒介\n * 容器之间的数据交互\n\n> PS：容器不能直接与外部机器直接通信，需要依赖宿主机通信交互\n\n\n# 数据卷配置\n\n创建启动容器时 ，可通过 -v参数 设置数据卷\n\n==docker run ... -v {主机目录}:{容器目录} ...==\n\n注意：\n\n * 容器目录必须为绝对路径\n * 如果目录不存在，会自动创建\n * 可以挂载多个数据卷\n\n示例： 创建容器 c1 挂载到 宿主机/root/data目录 挂载到 容器/root/data_container目录，并初始化指令 /bin/bash ==docker run -it --name=c1 -v /root/data:/root/data_container mysql /bin/bash==\n\n> 在容器创建的数据会持久化，即便是 停止/删除 容器 文件仍然会存在\n\n一个容器挂载多个数据卷\n\ndocker run -it --name=c2 \\\n-v ~/data2:/root/data2 \\\n-v ~/dtaa3:/root/data3 \\\nmysql /bin/bash\n\n\n> \\换行作用\n\n多个容器挂载同一个数据卷\n\ndocker run -it --name=c3 -v /root/data:/root/data6 mysql /bin/bash\ndocker run -it --name=c4 -v /root/data:/root/data6 mysql /bin/bash\n\n\n> 两个容器共享一个数据卷数据访问和修改也会跟随更改（仅限于该数据卷内的数据同步\n\n\n# 数据卷容器配置\n\n多容器进行数据交互，多个容器挂载在同一数据卷容器，完成数据交互（将容器挂载到同一管理的容器进行同步数据卷\n\n> container c3 作为容器同步卷 进行同步 c1 、c2 数据卷\n\n示例：\n\n 1. 创建启动c3数据卷容器 ==docker run -it --name=c3 -v /volume mysql /bin/bash==\n    \n    > 这里没有指定宿主目录，默认生成目录。查询容器详细：（可得知容器宿主目录 ==docker inspect c3== （关注：Mounts键集合对象中的 Source键\n\n 2. 启动创建c1、c2容器，使用 --volumes-from参数 设置数据卷\n    \n    docker run -it --name=c1 --volumes-from c3 mysql /bin/bash\n    docker run -it --name=c2 --volumes-from c3 mysql /bin/bash\n    \n\n 3. 进入 /volume目录 测试同步\n\n> 使用c3数据卷容器创建 c1、c2，如果c3关闭也不影响c1和c2的数据交互\n\n\n# 应用部署\n\nDocker应用部署容器需要了解一下几点：\n\n * 应用前提都是提前下载镜像再部署应用\n * 容器不能直接与外部机器进行通信\n * 外部机可以和宿主机进行通信；且宿主机也可和容器通信\n * 容器访问外部机需要宿主机调配映射端口与外部机通信\n\n> 容器(3306) --- 外部机器(3307) 宿主机调配端口映射可以间接的通信\n\n通过官网查找镜像 : https://hub.docker.com/\n\n\n# MySQL\n\n部署步骤：\n\n 1. 创建容器目录\n    \n    # 在/root目录下创建mysql目录用于存储mysql数据信息\n     mkdir ~/mysql\n    cd ~/mysql\n    \n\n 2. 创建容器，并设置 端口/目录 映射\n    \n    docker run -id \\\n    -p 3307:3306 \\\n    --name=c_mysql \\\n    -v $PWD/conf:/etc/mysql/conf.d \\\n    -v $PWD/logs:/logs \\\n    -v $PWD/data:/var/lib/mysql \\\n    -e MYSQL_ROOT_PASSWORD=123456 \\\n    mysql:5.6\n    \n    \n    参数说明：\n    \n    * -p 3307:3306：将 容器3306端口 对应宿主的 3307端口\n    * -v $PWD/conf:/etc/mysql/conf.d：主机当前/conf目录下创建数据卷 （pwd当前目录路径\n    * confg配置目录 / logs日志目录 / data数据目录\n    * -e MYSQL_ROOT_PASSWORD=123456：配置参数，初始化root用户密码\n\n 3. 进入容器操作\n    \n    # 运行启动容器\n     docker exec -it c_mysql /bin/bash\n    \n    # 进入mysql\n     mysql -uroot -p123456\n    \n\n 4. 外部连接测试\n    \n    虚拟机IP + 端口3307 即可访问 mysql容器\n\n\n# Tomcat\n\n部署步骤：\n\n 1. 创建容器目录\n    \n    # 在/root目录下创建tomcat目录用于存储tomcat数据信息\n     mkdir ~/tomcat\n    cd ~/tomcat\n    \n\n 2. 创建容器，并设置 端口/目录 映射\n    \n    docker run -id --name=c_tomcat \\\n    -p 8080:8080 \\\n    -v $PWD:/usr/local/tomcat/webapps \\\n    tomcat\n    \n    \n    > 参数的详细说明可以参考mysql配置\n\n 3. 为容器数据卷 添加页面内容\n    \n    mkdir /test\n    cd test\n    vim index.html\n    \n     # 添加H5页面内容保存即可\n    \n\n 4. 外部机访问 IP+端口8080 ==IP:8080/test/index.html== / ==IP:8080/test/== (Tomcat默认应用index.html\n\n> 应用Web内容时，只需为容器数据卷添加Web内容信息启动容器即可\n\n\n# Nginx\n\n 1. 安装镜像 nginx\n\n 2. 创建配置文件 (运行docker挂载的配置)\n    \n    # 创建挂载目录\n    mkdir -p /home/nginx/conf\n    mkdir -p /home/nginx/log\n    mkdir -p /home/nginx/html\n    \n\n 3. 拷贝主要配置到宿主机\n    \n    # 生成容器\n     docker run --name nginx -p 9001:80 -d nginx\n    \n    # 将容器nginx.conf文件复制到宿主机\n     docker cp nginx:/etc/nginx/nginx.conf /home/nginx/conf/nginx.conf\n    \n    # 将容器conf.d文件夹下内容复制到宿主机\n     docker cp nginx:/etc/nginx/conf.d /home/nginx/conf/conf.d\n    \n    # 将容器中的html文件夹复制到宿主机\n     docker cp nginx:/usr/share/nginx/html /home/nginx/\n    \n\n 4. 运行 Nginx容器\n    \n    docker run \\\n    -p 9002:80 \\\n    --name nginx \\\n    -v /home/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \\\n    -v /home/nginx/conf/conf.d:/etc/nginx/conf.d \\\n    -v /home/nginx/log:/var/log/nginx \\\n    -v /home/nginx/html:/usr/share/nginx/html \\\n    -d nginx:latest\n    \n\n 5. 访问 [IP]:9002 即可\n\n命令                 说明\n-name [名称]         命名\n-d                 后台运行\n-p [宿主端口]:[容器端口]   端口映射\n-v [宿主路径]:[容器路径]   配置文件挂载\nnginx:latest       本地运行的版本\n\\                  shell 命令换行\n\n\n# RabbitMQ\n\ndocker官方 : https://hub.docker.com/_/rabbitmq\n\n部署步骤：\n\n 1. 官网查找RabbitMQ\n\n 2. 建议下载含有Web管理页 , 镜像中带有 mangement版本的 , 并拉取下载\n\n 3. 启动docker容器\n    \n    docker run -d --name [容器名称]  \\\n    -p 5672:5672  \\\n    -p 15672:15672  \\\n    -v `pwd`/data:/home/rabbitmq  \\\n    --hostname [节点名称]  \\\n    -e RABBITMQ_DEFAULT_USER=admin  \\\n    -e RABBITMQ_DEFAULT_PASS=admin rabbitmq:[tag标签] \\\n    \n    \n    我个人的应用方式 (端口小修一下)\n    \n    docker run -d --name rabbitmq03  \\\n    -p 5674:5672  \\\n    -p 15674:15672  \\\n    -v `pwd`/data:/home/rabbitmq  \\\n    --hostname node03  \\\n    -e RABBITMQ_DEFAULT_USER=admin  \\\n    -e RABBITMQ_DEFAULT_PASS=admin  \\\n    rabbitmq:3.11.10-management\n    \n\n 4. 查看界面 ip+15672端口 http://ip:15672/\n\n选项说明 :\n\n选项           说明\n-d           后台运行\n--name       指定容器名称\n-p           指定端口 [外部端口]:[容器端口] (5672:连接访问; 15672: Web管理页)\n-v           映射 目录/文件\n--hostname   主机名 (较为重要 集群作为 节点名称 使用)\n-e           指定环境变量 (默认账号密码)\n\n\n# Redis\n\n部署步骤：\n\n 1. 创建容器，设置端口映射\n    \n    ==docker run -id --name=c_redis -p 6379:6379 redis:5.0==\n\n 2. 使用外部机器连接redis （对应IP+端口即可\n\n\n# Dockerfile\n\nDockerfild 是一个用于组合映像的命令的文本文档。可以使用在命令行中调用任何命令。 Docker通过读取Dockerfile中的指令自动生成映像\n\n\n# 镜像原理\n\n镜像原理先从文件管理进行讲述\n\nLiunx文件管理系统\n\nLinux文件系统由 bootfs 和 rootfs 组成 PS：不同发行版本，rootfs也不同，而rootfs基本不变\n\n * bootfs：包含Bootloader(引导加载程序) 和 kernel(内核)\n * rootfs：root文件系统，包含有 /dev，/proc，/bin，/etc等\n\ndocker镜像文件管理\n\nDocker镜像原理\n\n * Docker镜像有特殊的文件系统叠加而成\n * 最低端是 bootfs，并使用宿主机的bootfs，往上则是镜像文件\n * 文件系统的统一，将不同的文件层整合一个文件系统，提供统一的视角，隐藏多层的存在，在用户角度来看只有一个文件系统\n * 另一往下的镜像称为 父镜像，最底层则为 基础镜像\n * 当启动容器时，Docker会在最顶层加载读取文件作为容器\n\n> 总结：Docker镜像的本质是一个分层的文件系统\n\n注意：\n\n * Docker镜像会在不同层级可能会对父产生依赖\n * 镜像文件不能以本身决定大小，会复用 父镜像/系统 已有数据\n\n\n# 镜像制作\n\n# 容器转镜像\n\n镜像创建可写容器进行生成镜像——>压缩镜像——>应用\n\n步骤命令解释：\n\n# 生成镜像\ndocker commit {容器id} {容器名称}:{版本号} \n# 压缩文件\ndocker save -o {压缩文件名称} {镜像名称}:{版本号}\n# 加载应用镜像\ndocker load -i {压缩文件}\n\n\n> 容器转镜像 不包括数据卷数据，只封装容器数据\n\n步骤示例：\n\n# 数据卷\nmkdir ~/c_tomcat\ncd ~/c_tomcat\n# 创建tomcat镜像\ndocker run -id --name=c_tomcat \\\n-p 8080:8080 \\\n-v $PWD:/usr/local/tomcat/webapps \\\ntomcat\n# 进入tomcat镜像\ndocker exec -it c_tomcat /bin/bash\n# 创建a.txt b.txt （该文件用于封装镜像给测试人看的\ncd ~\ntouch a.txt b.txt\n# 容器转镜像\ndocker commit 28b8d4dc9744 lxs_tomcat:1.0\n# 压缩镜像\ndocker save -o lxs_tomcat.tar lxs_tomcat:1.0\n#删除 容器/镜像\ndocker rm c_tomcat\ndocker rmi lxs_tomcat:1.0\n# 从压缩文件加载镜像\ndocker load -i lxs_tomcat.tar\n# 产生镜像\ndocker run -it --name=new_tomcat lxs_tomcat:1.0 /bin/bash\n#进入查看内容\ndocker exec -it c_tomcat /bin/bash\n#可以看到a.txt b.txt存在，而webapps/test不存在\n',normalizedContent:'# docker\n\n\n# 简介\n\n官网：https://www.docker.com/\n\ndocker是种容器技术，能够解决环境迁移问题\n\n * 开源应用容器\n * 基于go语言实现\n * 轻量级、可移植\n * 沙箱机制隔离\n\n功能\n\n * 解决代码执行的环境兼容问题\n * 软件打包环境直接应用\n\n\n# 安装\n\n\n# linux\n\n安装步骤：\n\n 1. 安装docker\n 2. 安装组件软件包\n 3. 配置阿里云镜像加速（自己的\n\n示例：\n\n# 1、yum 包更新到最新\nyum update\n# 2、安装需要的软件包， yum-util 提供yum-config-manager功能，另外两个是devicemapper驱动依赖的\nyum install -y yum-utils device-mapper-persistent-data lvm2\n# 3、 设置yum源\nyum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo\n# 4、 安装docker，出现输入的界面都按 y\nyum install -y docker-ce\n# 5、 查看docker版本，验证是否验证成功\ndocker -v\n\n\n\n# 镜像加速\n\n镜像加速json文件需要手动配置 镜像配置：https://developer.aliyun.com/article/110806\n\n阿里云镜像配置\n\n 1. 登录阿里云 镜像服务模块 -> 镜像加速 -> 复制操作文档的镜像配置，如：(个人专属镜像加速\n    \n    {\n      "registry-mirrors": ["https://xd43lwzc.mirror.aliyuncs.com"]\n    }\n    \n\n 2. 进入路径 ==/etc/docker/daemon.json== (没有则创建\n\n 3. 编辑 daemon.json 复制添加以上配置\n\n 4. 重启 docker ==systemctl restart docker==\n\n 5. 检查配置镜像 。查看参数 ==docker info== (存在以下配置说明配置成功\n    \n    registry mirrors:\n    https://xd43lwzc.mirror.aliyuncs.com/\n    \n\n\n# 命令\n\n官方文档：https://docs.docker.com/reference/\n\n一键查看命令：==docker== 命令查看详细：==docker {命令前缀} --help==\n\n\n# 进程相关\n\n * 启动docker服务 ==systemctl start docker==\n * 关闭docker服务 ==systemctl stop docker==\n * 重启docker服务 ==systemctl restart docker==\n * 查看docker状态 ==systemctl status docker==\n * 开机自启docker服务 ==systemctl enable docker==\n\n\n# 镜像相关\n\n * 查看镜像（查看本地镜像 ==docker images== 查看所有镜像 ==docker images -q== 查看所有镜像id\n\n * 搜索镜像 ==docker search redis== 查找redis镜像\n\n * 下载镜像 ==docker pull redis== 下载最新版本redis ==docker pull redis:5.0== 下载5.0版本redis\n   \n   > 如果需要了解指定下载的版本：(搜索版本 https://hub.docker.com/\n\n * 删除镜像 ==docker rmi {镜像id}== 删除指定本地镜像 ==docker rmi docker images -q== 删除所有镜像\n\n\n# 容器相关\n\n * 容器查看 ==docker ps== 查看所有正在运行容器 ==docker ps -a== 查看所有容器 ==docker ps -aq== 查看所有容器id ==docker port {name/id}== 查看容器端口\n\n * 查看容器详细 ==docker inspect {name/id}==\n\n * 容器创建 ==docker run {参数}==\n   \n   * -i：保持容器运行\n   * -t：为容器分配一个为输入终端\n   * -d：以守护线程模式运行\n   * --name：为容器命名\n   \n   创建交互式容器 创建自动进入容器，退出自动关闭容器 ==docker run -it --name=c1 redis:5.0 /bin/bash== 创建 redis:5.0 镜像且名称为c1的容器，并初始化指令至 /bin/bash\n   \n   > 进入容器终端需要手动退出 exit\n   \n   创建守护容器 容器后台启动需要手动进入 ==docker run -id --name=c2 mysql /bin/bash==\n\n * 容器进入 ==docker exec -it {容器 name/id} /bin/bash==\n\n * 容器退出 ==exit== / 快捷键==ctrl+q+p==\n\n * 容器启动 ==docker start [容器 name/id]==\n   \n   > 如果是交互式容器，启动后会转变为守护线程\n\n * 容器停止 ==docker stop {容器 name/id}==\n\n * 容器删除 ==docker rm {容器 name/id}== 删除指定容器 ==docker rm docker ps -aq== 删除所有容器\n   \n   > 如果容器处于运行状态，则需要停止容器才能进行删除\n\n\n# 数据卷\n\n数据源是容器挂载运行的媒介\n\n数据卷概念：\n\n * 数据卷是宿主机中的一个 目录/文件\n * 但容器 目录和数据卷 绑定后，会立马同步\n * 一个数据卷可同时挂载多个容器\n * 一个容器可被多个数据卷挂载\n\n数据卷作用：\n\n * 容器数据 持久化\n * 外部机器和容器通信的媒介\n * 容器之间的数据交互\n\n> ps：容器不能直接与外部机器直接通信，需要依赖宿主机通信交互\n\n\n# 数据卷配置\n\n创建启动容器时 ，可通过 -v参数 设置数据卷\n\n==docker run ... -v {主机目录}:{容器目录} ...==\n\n注意：\n\n * 容器目录必须为绝对路径\n * 如果目录不存在，会自动创建\n * 可以挂载多个数据卷\n\n示例： 创建容器 c1 挂载到 宿主机/root/data目录 挂载到 容器/root/data_container目录，并初始化指令 /bin/bash ==docker run -it --name=c1 -v /root/data:/root/data_container mysql /bin/bash==\n\n> 在容器创建的数据会持久化，即便是 停止/删除 容器 文件仍然会存在\n\n一个容器挂载多个数据卷\n\ndocker run -it --name=c2 \\\n-v ~/data2:/root/data2 \\\n-v ~/dtaa3:/root/data3 \\\nmysql /bin/bash\n\n\n> \\换行作用\n\n多个容器挂载同一个数据卷\n\ndocker run -it --name=c3 -v /root/data:/root/data6 mysql /bin/bash\ndocker run -it --name=c4 -v /root/data:/root/data6 mysql /bin/bash\n\n\n> 两个容器共享一个数据卷数据访问和修改也会跟随更改（仅限于该数据卷内的数据同步\n\n\n# 数据卷容器配置\n\n多容器进行数据交互，多个容器挂载在同一数据卷容器，完成数据交互（将容器挂载到同一管理的容器进行同步数据卷\n\n> container c3 作为容器同步卷 进行同步 c1 、c2 数据卷\n\n示例：\n\n 1. 创建启动c3数据卷容器 ==docker run -it --name=c3 -v /volume mysql /bin/bash==\n    \n    > 这里没有指定宿主目录，默认生成目录。查询容器详细：（可得知容器宿主目录 ==docker inspect c3== （关注：mounts键集合对象中的 source键\n\n 2. 启动创建c1、c2容器，使用 --volumes-from参数 设置数据卷\n    \n    docker run -it --name=c1 --volumes-from c3 mysql /bin/bash\n    docker run -it --name=c2 --volumes-from c3 mysql /bin/bash\n    \n\n 3. 进入 /volume目录 测试同步\n\n> 使用c3数据卷容器创建 c1、c2，如果c3关闭也不影响c1和c2的数据交互\n\n\n# 应用部署\n\ndocker应用部署容器需要了解一下几点：\n\n * 应用前提都是提前下载镜像再部署应用\n * 容器不能直接与外部机器进行通信\n * 外部机可以和宿主机进行通信；且宿主机也可和容器通信\n * 容器访问外部机需要宿主机调配映射端口与外部机通信\n\n> 容器(3306) --- 外部机器(3307) 宿主机调配端口映射可以间接的通信\n\n通过官网查找镜像 : https://hub.docker.com/\n\n\n# mysql\n\n部署步骤：\n\n 1. 创建容器目录\n    \n    # 在/root目录下创建mysql目录用于存储mysql数据信息\n     mkdir ~/mysql\n    cd ~/mysql\n    \n\n 2. 创建容器，并设置 端口/目录 映射\n    \n    docker run -id \\\n    -p 3307:3306 \\\n    --name=c_mysql \\\n    -v $pwd/conf:/etc/mysql/conf.d \\\n    -v $pwd/logs:/logs \\\n    -v $pwd/data:/var/lib/mysql \\\n    -e mysql_root_password=123456 \\\n    mysql:5.6\n    \n    \n    参数说明：\n    \n    * -p 3307:3306：将 容器3306端口 对应宿主的 3307端口\n    * -v $pwd/conf:/etc/mysql/conf.d：主机当前/conf目录下创建数据卷 （pwd当前目录路径\n    * confg配置目录 / logs日志目录 / data数据目录\n    * -e mysql_root_password=123456：配置参数，初始化root用户密码\n\n 3. 进入容器操作\n    \n    # 运行启动容器\n     docker exec -it c_mysql /bin/bash\n    \n    # 进入mysql\n     mysql -uroot -p123456\n    \n\n 4. 外部连接测试\n    \n    虚拟机ip + 端口3307 即可访问 mysql容器\n\n\n# tomcat\n\n部署步骤：\n\n 1. 创建容器目录\n    \n    # 在/root目录下创建tomcat目录用于存储tomcat数据信息\n     mkdir ~/tomcat\n    cd ~/tomcat\n    \n\n 2. 创建容器，并设置 端口/目录 映射\n    \n    docker run -id --name=c_tomcat \\\n    -p 8080:8080 \\\n    -v $pwd:/usr/local/tomcat/webapps \\\n    tomcat\n    \n    \n    > 参数的详细说明可以参考mysql配置\n\n 3. 为容器数据卷 添加页面内容\n    \n    mkdir /test\n    cd test\n    vim index.html\n    \n     # 添加h5页面内容保存即可\n    \n\n 4. 外部机访问 ip+端口8080 ==ip:8080/test/index.html== / ==ip:8080/test/== (tomcat默认应用index.html\n\n> 应用web内容时，只需为容器数据卷添加web内容信息启动容器即可\n\n\n# nginx\n\n 1. 安装镜像 nginx\n\n 2. 创建配置文件 (运行docker挂载的配置)\n    \n    # 创建挂载目录\n    mkdir -p /home/nginx/conf\n    mkdir -p /home/nginx/log\n    mkdir -p /home/nginx/html\n    \n\n 3. 拷贝主要配置到宿主机\n    \n    # 生成容器\n     docker run --name nginx -p 9001:80 -d nginx\n    \n    # 将容器nginx.conf文件复制到宿主机\n     docker cp nginx:/etc/nginx/nginx.conf /home/nginx/conf/nginx.conf\n    \n    # 将容器conf.d文件夹下内容复制到宿主机\n     docker cp nginx:/etc/nginx/conf.d /home/nginx/conf/conf.d\n    \n    # 将容器中的html文件夹复制到宿主机\n     docker cp nginx:/usr/share/nginx/html /home/nginx/\n    \n\n 4. 运行 nginx容器\n    \n    docker run \\\n    -p 9002:80 \\\n    --name nginx \\\n    -v /home/nginx/conf/nginx.conf:/etc/nginx/nginx.conf \\\n    -v /home/nginx/conf/conf.d:/etc/nginx/conf.d \\\n    -v /home/nginx/log:/var/log/nginx \\\n    -v /home/nginx/html:/usr/share/nginx/html \\\n    -d nginx:latest\n    \n\n 5. 访问 [ip]:9002 即可\n\n命令                 说明\n-name [名称]         命名\n-d                 后台运行\n-p [宿主端口]:[容器端口]   端口映射\n-v [宿主路径]:[容器路径]   配置文件挂载\nnginx:latest       本地运行的版本\n\\                  shell 命令换行\n\n\n# rabbitmq\n\ndocker官方 : https://hub.docker.com/_/rabbitmq\n\n部署步骤：\n\n 1. 官网查找rabbitmq\n\n 2. 建议下载含有web管理页 , 镜像中带有 mangement版本的 , 并拉取下载\n\n 3. 启动docker容器\n    \n    docker run -d --name [容器名称]  \\\n    -p 5672:5672  \\\n    -p 15672:15672  \\\n    -v `pwd`/data:/home/rabbitmq  \\\n    --hostname [节点名称]  \\\n    -e rabbitmq_default_user=admin  \\\n    -e rabbitmq_default_pass=admin rabbitmq:[tag标签] \\\n    \n    \n    我个人的应用方式 (端口小修一下)\n    \n    docker run -d --name rabbitmq03  \\\n    -p 5674:5672  \\\n    -p 15674:15672  \\\n    -v `pwd`/data:/home/rabbitmq  \\\n    --hostname node03  \\\n    -e rabbitmq_default_user=admin  \\\n    -e rabbitmq_default_pass=admin  \\\n    rabbitmq:3.11.10-management\n    \n\n 4. 查看界面 ip+15672端口 http://ip:15672/\n\n选项说明 :\n\n选项           说明\n-d           后台运行\n--name       指定容器名称\n-p           指定端口 [外部端口]:[容器端口] (5672:连接访问; 15672: web管理页)\n-v           映射 目录/文件\n--hostname   主机名 (较为重要 集群作为 节点名称 使用)\n-e           指定环境变量 (默认账号密码)\n\n\n# redis\n\n部署步骤：\n\n 1. 创建容器，设置端口映射\n    \n    ==docker run -id --name=c_redis -p 6379:6379 redis:5.0==\n\n 2. 使用外部机器连接redis （对应ip+端口即可\n\n\n# dockerfile\n\ndockerfild 是一个用于组合映像的命令的文本文档。可以使用在命令行中调用任何命令。 docker通过读取dockerfile中的指令自动生成映像\n\n\n# 镜像原理\n\n镜像原理先从文件管理进行讲述\n\nliunx文件管理系统\n\nlinux文件系统由 bootfs 和 rootfs 组成 ps：不同发行版本，rootfs也不同，而rootfs基本不变\n\n * bootfs：包含bootloader(引导加载程序) 和 kernel(内核)\n * rootfs：root文件系统，包含有 /dev，/proc，/bin，/etc等\n\ndocker镜像文件管理\n\ndocker镜像原理\n\n * docker镜像有特殊的文件系统叠加而成\n * 最低端是 bootfs，并使用宿主机的bootfs，往上则是镜像文件\n * 文件系统的统一，将不同的文件层整合一个文件系统，提供统一的视角，隐藏多层的存在，在用户角度来看只有一个文件系统\n * 另一往下的镜像称为 父镜像，最底层则为 基础镜像\n * 当启动容器时，docker会在最顶层加载读取文件作为容器\n\n> 总结：docker镜像的本质是一个分层的文件系统\n\n注意：\n\n * docker镜像会在不同层级可能会对父产生依赖\n * 镜像文件不能以本身决定大小，会复用 父镜像/系统 已有数据\n\n\n# 镜像制作\n\n# 容器转镜像\n\n镜像创建可写容器进行生成镜像——>压缩镜像——>应用\n\n步骤命令解释：\n\n# 生成镜像\ndocker commit {容器id} {容器名称}:{版本号} \n# 压缩文件\ndocker save -o {压缩文件名称} {镜像名称}:{版本号}\n# 加载应用镜像\ndocker load -i {压缩文件}\n\n\n> 容器转镜像 不包括数据卷数据，只封装容器数据\n\n步骤示例：\n\n# 数据卷\nmkdir ~/c_tomcat\ncd ~/c_tomcat\n# 创建tomcat镜像\ndocker run -id --name=c_tomcat \\\n-p 8080:8080 \\\n-v $pwd:/usr/local/tomcat/webapps \\\ntomcat\n# 进入tomcat镜像\ndocker exec -it c_tomcat /bin/bash\n# 创建a.txt b.txt （该文件用于封装镜像给测试人看的\ncd ~\ntouch a.txt b.txt\n# 容器转镜像\ndocker commit 28b8d4dc9744 lxs_tomcat:1.0\n# 压缩镜像\ndocker save -o lxs_tomcat.tar lxs_tomcat:1.0\n#删除 容器/镜像\ndocker rm c_tomcat\ndocker rmi lxs_tomcat:1.0\n# 从压缩文件加载镜像\ndocker load -i lxs_tomcat.tar\n# 产生镜像\ndocker run -it --name=new_tomcat lxs_tomcat:1.0 /bin/bash\n#进入查看内容\ndocker exec -it c_tomcat /bin/bash\n#可以看到a.txt b.txt存在，而webapps/test不存在\n',charsets:{cjk:!0}},{title:"关于",frontmatter:{title:"关于",date:"2019-12-25T14:27:01.000Z",permalink:"/about/",sidebar:!1,article:!1,author:{name:"Sanscan12",link:"https://github.com/Sanscan12"}},regularPath:"/04.%E5%85%B3%E4%BA%8E/01.%E5%85%B3%E4%BA%8E.html",relativePath:"04.关于/01.关于.md",key:"v-e909945c",path:"/about/",headers:[{level:2,title:"🐼关于博主",slug:"🐼关于博主",normalizedTitle:"🐼关于博主",charIndex:2},{level:2,title:"📔关于本站",slug:"📔关于本站",normalizedTitle:"📔关于本站",charIndex:683},{level:2,title:"✉️ 联系",slug:"联系",normalizedTitle:"✉️ 联系",charIndex:1765}],headersStr:"🐼关于博主 📔关于本站 ✉️ 联系",content:"# 🐼关于博主\n\n🙋‍♂️本人基本设定 :\n\n * 物种 : 人类\n * 类型 : 男\n * 生产地 : 华南\n * 初始化于 : 2000年\n * 型号 : INTJ\n * 属性 : 2.5次元 , 文笔渣 , 独立体 , ...\n\n🙌关于名字? 关于域名?\n\n柏竹(Bozhu) =? 博主(BoZhu) , 奇思妙想\n\n柏(Bo) : 关于这个字 , 不难联想到是植物相关 , 含有 可塑造性 含义(!$%@*&)\n\n竹(Zhu) : 柏竹在当中也有很多地方相关 竹 , 共同属性 : 高洁 , 比直 , 不屈不挠 等...\n\n其实关于起名也想了挺久 , 排除了共性(大众化) , 提纯了个性 , 从中统合的名称 , 也玩了些谐音\n\n🌲技能树\n\n * 前端 H5 , CSS3 , JavaScript , TypeScript , Vue , Nginx ,\n * 后端 Java , Python ,\n * 后端框架 SprinBoot , SprinCloud , Shiro , MybatisPlus , Hibernate , Activiti ,\n * 容器 Docker ,\n * 数据库 MySQL , Redis , RabbitMQ ,\n\n🎨主题色?\n\n绿色 在写代码时 , 每次执行看见的绿色 , 如同心中压力的一同释放 , 非常nice (舒畅ing)\n\n紫色 使写代码时 , 保持沉着冷静 , 能使我快速同步到 心流状态 , 长时保持一个频段\n\n不难发现 绿色和紫色是相对色 , 也可以说明这是个 run 的过程\n\n\n# 📔关于本站\n\n🌱本站来源\n\n18年(高三) , 在初次学习C语言遇到问题时候 , 搜度娘 无意间在百度发现很多相关博客 , IDY主题博客什么的 , 从中发现了很多有意思的东西 , 从此埋下了种子\n\n🌈首次建站\n\n19年(大一) . 接触是从B站视频说起 , 那时候看见哪个好看就干哪个 , 也没有多想 , 于是发现 hexo框架 IDY主题 , 还能秒开发 , 就开始走向开坑博客的道路上 , 路途中坎坎坷坷 , 也加了框架的主题群唠嗑博客问题 , 还学了 Git 基本操作 , 当中整了比较花哨的主题 , 整了很多 css DIY加工 , 像极了 当年中二的我 , 可惜现在没有把图片保留给阅读的各位....\n\n一段时间后 , 随着笔记日积月累的增长 , 发现博客中的笔记越来越难以管理 , 不适合查阅 , 也没有相关搜索功能 . 如果需求信息在15秒内不能获取到 , 可能会放弃此方案查找 , 因此不太适合于使用该框架维护文章 , 于是 博客搁置流放起来了\n\n🦜建站搁置\n\n博客搁置期间 , 文章都是放到 CSDN 平台(可点击查阅博客) . CSDN 曾被大伙一堵认为 是垃圾堆 , 但也是很多新手 , 起始淘垃圾的开始(笑哭) . 我为什么选择 CSDN , 因为度娘搜 , 见得多用 , 人用多 , 刷得也多 , 自然而然 从众嘛 也加入了(DDDD) . 其实期间也忙于学习 , 也没折腾博客框架 , 就食用了第三方平台的发布 , 简单 , 方便 , 直接 , 还能自动百度收录什么的 . 期间学习发现一些官方文档 , 快速阅读 , 快速定位 , 一个字 nice , 非常适合 知识库的管理 VuePress , 时间好久不久 很快哈 , 就到了我首次实习的开始 , 忙碌接触的新事物 , 也将 博客开发放置到代办事项当中...\n\n🚩回归初衷\n\n直到23年(大四) , 返校的一段时间后 , 开始投入编写博客当中 , 起初是打算用 VuePress 进行开发 , 发现里面很多功能需要自己集成开发 , 也在中途发现了 vuepress-theme-vdoing主题 , 进去看了一阵子 , 牛 , 简直是 VuePress 的优化版啊 , 大多配置什么的都不需要配 , 只要按照约定编写文档即可 , 开箱即用什么的 . 于是走起了开坑之旅..\n\n注意\n\n博客中的文章是通过个人在学习的过程中记录 , 当中可能会出现 , 描述不到位 , 理解片面等问题也有所难免 , 如在当中出现不对的地方 , 也希望大伙在文章下方评论指正说明!\n\n\n# ✉️ 联系\n\n * WeChat or QQ: {{ QQ }}\n * Email: 1173930245@qq.com\n * GitHub: https://github.com/Sanscan12",normalizedContent:"# 🐼关于博主\n\n🙋‍♂️本人基本设定 :\n\n * 物种 : 人类\n * 类型 : 男\n * 生产地 : 华南\n * 初始化于 : 2000年\n * 型号 : intj\n * 属性 : 2.5次元 , 文笔渣 , 独立体 , ...\n\n🙌关于名字? 关于域名?\n\n柏竹(bozhu) =? 博主(bozhu) , 奇思妙想\n\n柏(bo) : 关于这个字 , 不难联想到是植物相关 , 含有 可塑造性 含义(!$%@*&)\n\n竹(zhu) : 柏竹在当中也有很多地方相关 竹 , 共同属性 : 高洁 , 比直 , 不屈不挠 等...\n\n其实关于起名也想了挺久 , 排除了共性(大众化) , 提纯了个性 , 从中统合的名称 , 也玩了些谐音\n\n🌲技能树\n\n * 前端 h5 , css3 , javascript , typescript , vue , nginx ,\n * 后端 java , python ,\n * 后端框架 sprinboot , sprincloud , shiro , mybatisplus , hibernate , activiti ,\n * 容器 docker ,\n * 数据库 mysql , redis , rabbitmq ,\n\n🎨主题色?\n\n绿色 在写代码时 , 每次执行看见的绿色 , 如同心中压力的一同释放 , 非常nice (舒畅ing)\n\n紫色 使写代码时 , 保持沉着冷静 , 能使我快速同步到 心流状态 , 长时保持一个频段\n\n不难发现 绿色和紫色是相对色 , 也可以说明这是个 run 的过程\n\n\n# 📔关于本站\n\n🌱本站来源\n\n18年(高三) , 在初次学习c语言遇到问题时候 , 搜度娘 无意间在百度发现很多相关博客 , idy主题博客什么的 , 从中发现了很多有意思的东西 , 从此埋下了种子\n\n🌈首次建站\n\n19年(大一) . 接触是从b站视频说起 , 那时候看见哪个好看就干哪个 , 也没有多想 , 于是发现 hexo框架 idy主题 , 还能秒开发 , 就开始走向开坑博客的道路上 , 路途中坎坎坷坷 , 也加了框架的主题群唠嗑博客问题 , 还学了 git 基本操作 , 当中整了比较花哨的主题 , 整了很多 css diy加工 , 像极了 当年中二的我 , 可惜现在没有把图片保留给阅读的各位....\n\n一段时间后 , 随着笔记日积月累的增长 , 发现博客中的笔记越来越难以管理 , 不适合查阅 , 也没有相关搜索功能 . 如果需求信息在15秒内不能获取到 , 可能会放弃此方案查找 , 因此不太适合于使用该框架维护文章 , 于是 博客搁置流放起来了\n\n🦜建站搁置\n\n博客搁置期间 , 文章都是放到 csdn 平台(可点击查阅博客) . csdn 曾被大伙一堵认为 是垃圾堆 , 但也是很多新手 , 起始淘垃圾的开始(笑哭) . 我为什么选择 csdn , 因为度娘搜 , 见得多用 , 人用多 , 刷得也多 , 自然而然 从众嘛 也加入了(dddd) . 其实期间也忙于学习 , 也没折腾博客框架 , 就食用了第三方平台的发布 , 简单 , 方便 , 直接 , 还能自动百度收录什么的 . 期间学习发现一些官方文档 , 快速阅读 , 快速定位 , 一个字 nice , 非常适合 知识库的管理 vuepress , 时间好久不久 很快哈 , 就到了我首次实习的开始 , 忙碌接触的新事物 , 也将 博客开发放置到代办事项当中...\n\n🚩回归初衷\n\n直到23年(大四) , 返校的一段时间后 , 开始投入编写博客当中 , 起初是打算用 vuepress 进行开发 , 发现里面很多功能需要自己集成开发 , 也在中途发现了 vuepress-theme-vdoing主题 , 进去看了一阵子 , 牛 , 简直是 vuepress 的优化版啊 , 大多配置什么的都不需要配 , 只要按照约定编写文档即可 , 开箱即用什么的 . 于是走起了开坑之旅..\n\n注意\n\n博客中的文章是通过个人在学习的过程中记录 , 当中可能会出现 , 描述不到位 , 理解片面等问题也有所难免 , 如在当中出现不对的地方 , 也希望大伙在文章下方评论指正说明!\n\n\n# ✉️ 联系\n\n * wechat or qq: {{ qq }}\n * email: 1173930245@qq.com\n * github: https://github.com/sanscan12",charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"标签",frontmatter:{tagsPage:!0,title:"标签",permalink:"/tags/",article:!1},regularPath:"/@pages/tagsPage.html",relativePath:"@pages/tagsPage.md",key:"v-44ee75b0",path:"/tags/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"分类",frontmatter:{categoriesPage:!0,title:"分类",permalink:"/categories/",article:!1},regularPath:"/@pages/categoriesPage.html",relativePath:"@pages/categoriesPage.md",key:"v-12033e88",path:"/categories/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"归档",frontmatter:{archivesPage:!0,title:"归档",permalink:"/archives/",article:!1},regularPath:"/@pages/archivesPage.html",relativePath:"@pages/archivesPage.md",key:"v-2c6a8ca8",path:"/archives/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"友情链接",frontmatter:{title:"友情链接",date:"2019-12-25T14:27:01.000Z",permalink:"/friendLink",article:!1,sidebar:!1,author:"柏竹"},regularPath:"/99.%E5%8F%8B%E9%93%BE.html",relativePath:"99.友链.md",key:"v-41736a06",path:"/friendLink/",headers:[{level:3,title:"友链申请",slug:"友链申请",normalizedTitle:"友链申请",charIndex:386}],headersStr:"友链申请",content:"柏竹\n\n💻学习📝记录🔗分享\n\n二丫讲梵\n\n💻学习📝记录🔗分享\n\n- name: 柏竹\n  desc: 💻学习📝记录🔗分享 # 介绍\n  avatar: /img/favicon.ico # 可选\n  link: https://www.bozhu12.cc # 可选\n  bgColor: '#bd93f9' # 可选，默认var(--bodyBg)。颜色值有#号时请添加单引号\n  textColor: '#6854A1' # 可选，默认var(--textColor)\n- name: 二丫讲梵 # 昵称\n  desc: 💻学习📝记录🔗分享 # 介绍\n  avatar: https://wiki.eryajf.net/img/logo.png # 头像\n  link: https://wiki.eryajf.net/  # 链接\n\n\n\n# 友链申请\n\n与我 联系 或者 在本页面评论区留言您的友链信息，格式：(点击代码块右上角一键复制)\n\n- name: 柏竹\n  desc: 💻学习📝记录🔗分享 # 描述\n  avatar: /img/favicon.ico # 头像\n  link: https://www.bozhu12.cc # 链接\n\n\n申请前记得先添加本站哦~",normalizedContent:"柏竹\n\n💻学习📝记录🔗分享\n\n二丫讲梵\n\n💻学习📝记录🔗分享\n\n- name: 柏竹\n  desc: 💻学习📝记录🔗分享 # 介绍\n  avatar: /img/favicon.ico # 可选\n  link: https://www.bozhu12.cc # 可选\n  bgcolor: '#bd93f9' # 可选，默认var(--bodybg)。颜色值有#号时请添加单引号\n  textcolor: '#6854a1' # 可选，默认var(--textcolor)\n- name: 二丫讲梵 # 昵称\n  desc: 💻学习📝记录🔗分享 # 介绍\n  avatar: https://wiki.eryajf.net/img/logo.png # 头像\n  link: https://wiki.eryajf.net/  # 链接\n\n\n\n# 友链申请\n\n与我 联系 或者 在本页面评论区留言您的友链信息，格式：(点击代码块右上角一键复制)\n\n- name: 柏竹\n  desc: 💻学习📝记录🔗分享 # 描述\n  avatar: /img/favicon.ico # 头像\n  link: https://www.bozhu12.cc # 链接\n\n\n申请前记得先添加本站哦~",charsets:{cjk:!0},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3},{title:"Home",frontmatter:{home:!0,heroText:"柏竹",tagline:"与风为名，屿之齐鸣。",bannerBg:"auto"},regularPath:"/",relativePath:"index.md",key:"v-4768fc14",path:"/",headersStr:null,content:"",normalizedContent:"",charsets:{},lastUpdated:"2023/03/12, 00:43:49",lastUpdatedTimestamp:1678553029e3}],themeConfig:{nav:[{text:"首页",link:"/"},{text:"后端",link:"/backend/"},{text:"前端",link:"/web/"},{text:"更多",items:[{text:"拓展知识",link:"/other/"},{text:"零碎知识",link:"/other/"},{text:"工具介绍",link:"/pages/4c778760be26d8b3/"}]},{text:"关于",link:"/about/"},{text:"友链",link:"/friendLink/"},{text:"索引",link:"/archives/",items:[{text:"分类",link:"/categories/"},{text:"标签",link:"/tags/"},{text:"归档",link:"/archives/"}]}],searchPlaceholder:"按下 𝑺 搜索",sidebarDepth:2,logo:"https://image.bozhu12.cc/myblog/Essay/hendImage02.jpg",searchMaxSuggestions:10,lastUpdated:"上次更新",docsDir:"docs",editLinks:!0,editLinkText:"编辑",bodyBgImg:["https://image.bozhu12.cc/myblog/Essay/home.jpg"],contentBgStyle:1,pageButton:!1,sidebar:{"/00.目录页/":[["01.后端.md","后端","/backend/"],["02.前端.md","前端","/web/"],["03.更多.md","拓展","/other/"]],catalogue:{"后端":"/backend/","前端":"/web/","更多":"/other/"},"/01.后端/":[{title:"Java基础",collapsable:!0,children:[["01.Java基础/01.认知.md","Java认识","/backend/ac1298"],["01.Java基础/02.类和对象.md","面向对象概述","/backend/pe1123"],["01.Java基础/03.API.md","Java API","/backend/m0die6"],["01.Java基础/04.三大特性.md","Java三大特性","/backend/39ibdm"],["01.Java基础/05.类的高级特性.md","Java类的高级特性","/backend/9sun1b"],["01.Java基础/06.异常.md","Java异常","/backend/b5ikzm"],["01.Java基础/07.Swing 程序设计.md","Java异常","/backend/g25p48"],["01.Java基础/08.集合类.md","Java集合类","/backend/x25lyh"],["01.Java基础/09.IO流.md","Java I/O","/backend/dampib"],["01.Java基础/10.反射.md","Java反射","/backend/y0rkxc"],["01.Java基础/11.枚举.md","枚举","/backend/r3608t"],["01.Java基础/12.泛型.md","泛型","/backend/v3dlns"],["01.Java基础/13.线程.md","Java线程","/backend/zvajuy"],["01.Java基础/14.网络通信.md","Java网络通信","/backend/pwb68r"],["01.Java基础/15.监听事件.md","Java事件","/backend/tfnnik"],["01.Java基础/16.AWT绘图.md","AWT绘图","/backend/34q8xb"],["01.Java基础/17.URL说明.md","Java网页访问","/backend/1s9khm"],["01.Java基础/19.MXL&JSON.md","XML&JSON","/backend/lipl8p"],["01.Java基础/20.注解.md","Java注解","/backend/zyaf2n"]]},{title:"JavaWeb",collapsable:!0,children:[["02.JavaWeb/01.Tomcat应用.md","Tomcat","/backend/0y9sdx"],["02.JavaWeb/02.servlet应用.md","JavaWeb Servlet","/backend/qls54u"],["02.JavaWeb/03.JSP.md","JSP","/backend/nkcjdp"],["02.JavaWeb/04.Filter过滤监听器.md","过滤监听器","/backend/0nybdh"],["02.JavaWeb/05.Session&Cookie会话跟踪.md","会话跟踪","/backend/tlfhkk"],["02.JavaWeb/06.MVC.md","MVC设计模式","/backend/aud35w"],["02.JavaWeb/07.AJAX应用.md","Ajax","/backend/s9wrzy"],["02.JavaWeb/08.JSON操作.md","JSON","/backend/d4tcq2"],["02.JavaWeb/09.文件上传下载.md","JspSmartUpload应用","/backend/r5xd4s"]]},{title:"Java拓展",collapsable:!0,children:[["03.Java拓展/01.Java 设计模式.md","Java设计模式","/backend/ea9655"],["03.Java拓展/02. Properties 序列化与反序列化.md","Java序列化","/backend/d69655"],["03.Java拓展/03.Stream流操作.md","Stream流","/backend/c69655"],["03.Java拓展/04.Lombok简化开发.md","Lombok简化开发应用","/backend/b69655"],["03.Java拓展/05.zip解压缩.md","JavaZip解压缩","/backend/a69655"]]},{title:"框架技术",collapsable:!0,children:[["04.框架技术/01.Maven.md","Maven","/backend/60chrc"],["04.框架技术/02.Activiti工作流.md","Activiti","/backend/60chrp"],["04.框架技术/03.Shiro安全框架.md","Shiro","/backend/40kn38"],["04.框架技术/04.SpringBoot .md","SpringBoot","/backend/40kn39"],["04.框架技术/05.Apache Dubbo.md","Dubbo","/backend/afbo81"],["04.框架技术/06.RabbitMQ.md","RabbitMQ","/backend/afbo8k"]]},{title:"数据库",collapsable:!0,children:[["05.数据库/01.MySQL.md","MySQL","/backend/621sa1"],["05.数据库/02.JDBC.md","JDBC","/backend/0ygxqu"],["05.数据库/03.Hibernate.md","Hibernate","/backend/k5hxej"],["05.数据库/04.MyBatis.md","Mybatis","/backend/zi2hq0"],["05.数据库/05.Redis.md","Redis","/backend/ldn760"]]},{title:"数据结构",collapsable:!0,children:[["06.数据结构/01.队列.md","队列","/backend/iis6im"],["06.数据结构/02.二叉树.md","二叉树","/backend/7g3bqt"],["06.数据结构/03.栈.md","栈","/backend/2zy34y"],["06.数据结构/04.链表.md","链表","/backend/k43waq"]]},{title:"Spring",collapsable:!0,children:[["07.Spring/01.Spring概述.md","Spring","/backend/x1cuta"],["07.Spring/02.Spring核心Loc.md","SpringIOC","/backend/x1cutb"],["07.Spring/03.Spring核心AOP.md","SpringAOP","/backend/x1cutc"],["07.Spring/04.Spring拓展.md","Spring拓展","/backend/x1cutd"]]},{title:"SpringMVC",collapsable:!0,children:[["08.SpringMVC/01.认知应用.md","SpringMVC","/backend/t373xy"],["08.SpringMVC/02.访问静态资源.md","静态资源的访问","/backend/6nom7s"],["08.SpringMVC/03.传递参数.md","Spring MVC请求接收","/backend/pahdv0"],["08.SpringMVC/04.重定向和转发.md","SpringMVC 重定向和转发","/backend/8pqmjz"],["08.SpringMVC/05.异常.md","SpringMVC 异常","/backend/2sohbn"],["08.SpringMVC/06.拦截器.md","SpringMVC 拦截器","/backend/k8ocwe"],["08.SpringMVC/07.上传下载.md","SpringMVC 上传&下载","/backend/i3cqqj"],["08.SpringMVC/08.RESTful风格.md","SpringMVC RESTful API","/backend/ggmgk1"]]},{title:"SpringClound",collapsable:!0,children:[["09.SpringClound/01.概念.md","Spring Cloud 认知","/backend/ibtuuq"],["09.SpringClound/02.Eureka服务注册中心.md","Eureka 注册中心","/backend/wx8zdz"],["09.SpringClound/03.Ribbon负载均衡.md","Ribbon 负载均衡","/backend/s4wg1j"],["09.SpringClound/04.Hystrix熔断器.md","Hystrix 熔断器","/backend/ask5pn"],["09.SpringClound/05.Feign.md","Feign","/backend/kej3du"],["09.SpringClound/06.Gateway网关.md","Gateway 网关","/backend/y2b432"],["09.SpringClound/07.Config配置中心.md","Config 配置中心","/backend/4iocm4"],["09.SpringClound/08.Bus服务总线.md","Bus 服务总线","/backend/0qlndf"]]},{title:"Netty网络编程",collapsable:!0,children:[]}],"/02.前端/":[{title:"前端必备",collapsable:!0,children:[["01.前端必备/01.HTML.md","HTML","/web/1hg7aa"],["01.前端必备/02.CSS.md","CSS","/web/1hg7cw"],["01.前端必备/03.JavaScript.md","JavaScript","/web/1hg7aw"],["01.前端必备/04.ES6.md","ES6","/web/1hg7cd"],["01.前端必备/05.Git应用.md","Git","/web/1hg7sg"]]},{title:"技术拓展",collapsable:!0,children:[["02.技术拓展/01.Bootstrap.md","Bootstrap","/web/1hg7wa"],["02.技术拓展/02.JQuery.md","JQuery","/web/1hg7wv"],["02.技术拓展/03.TypeScript.md","TypeScript","/web/1hg7wc"],["02.技术拓展/04.Nginx.md","Nginx","/web/1hg7wd"]]},{title:"前端技巧",collapsable:!0,children:[["03.前端技巧/01.JavaScript进阶技巧.md","JavaScript进阶技巧","/web/1hg7ww"],["03.前端技巧/02.vue技巧功能.md","Vue技巧功能","/web/1hg7wq"]]}],"/03.技术/":[{title:"零碎",collapsable:!0,children:[]}],"/03.更多/":[{title:"博客相关",collapsable:!0,children:[["01.博客相关/01.Vdoing主题搭建.md","Vdoing 主题建站","/blog/1hg722"],["01.博客相关/02.Vdoing主题.md",'Vdoing主题 评论功能 <Badge text="转载" type="error" vertical="middle"/>',"/blog/2scac"],["01.博客相关/03.Markdown语法拓展.md","Markdown语法拓展","/blog/2ccess"]]},{title:"Linux",collapsable:!0,children:[["02.Linux/01.Linux常用手册.md","Linux基本操作篇","/other/183ssax"],["02.Linux/02.Linux文件管理.md","Linux文件管理","/other/122ssa"],["02.Linux/03.Linux框架搭建.md","Linux搭建","/other/cbba2"]]},{title:"零碎",collapsable:!0,children:[["99.零碎/01.Docker.md","Docker","/backend/1hg7cc"]]}],"/04.关于/":[["01.关于.md","关于","/about/"]]},author:{name:"柏竹",link:"https://github.com/Sanscan12"},blogger:{avatar:"https://image.bozhu12.cc/myblog/Essay/favicon.ico",name:"柏竹",slogan:"奋斗柏竹"},social:{icons:[{iconClass:"icon-weixin",title:"联系",link:"Sanscan12"},{iconClass:"icon-github",title:"GitHub",link:"https://github.com/Sasncan12"},{iconClass:"icon-erji",title:"听音乐",link:"https://music.163.com/#/user/home?id=448156561"}]},footer:{createYear:2019,copyrightInfo:' | <a href="https://beian.miit.gov.cn/">桂ICP备2022009417号-1</a>'},extendFrontmatter:{author:{name:"Sanscan12",link:"https://github.com/Sanscan12"}},htmlModules:{}},locales:{"/":{lang:"zh-CN",title:"柏竹",description:"学习足迹 , 记录生活!",path:"/"}}};var wl=t(96),Sl=t(97),jl=t(11);var kl={computed:{$filterPosts(){return this.$site.pages.filter(n=>{const{frontmatter:{pageComponent:e,article:t,home:a}}=n;return!(e||!1===t||!0===a)})},$sortPosts(){return(n=this.$filterPosts).sort((n,e)=>{const t=n.frontmatter.sticky,a=e.frontmatter.sticky;return t&&a?t==a?Object(jl.a)(n,e):t-a:t&&!a?-1:!t&&a?1:Object(jl.a)(n,e)}),n;var n},$sortPostsByDate(){return(n=this.$filterPosts).sort((n,e)=>Object(jl.a)(n,e)),n;var n},$groupPosts(){return function(n){const e={},t={};for(let a=0,r=n.length;a<r;a++){const{frontmatter:{categories:r,tags:i}}=n[a];"array"===Object(jl.n)(r)&&r.forEach(t=>{t&&(e[t]||(e[t]=[]),e[t].push(n[a]))}),"array"===Object(jl.n)(i)&&i.forEach(e=>{e&&(t[e]||(t[e]=[]),t[e].push(n[a]))})}return{categories:e,tags:t}}(this.$sortPosts)},$categoriesAndTags(){return function(n){const e=[],t=[];for(let t in n.categories)e.push({key:t,length:n.categories[t].length});for(let e in n.tags)t.push({key:e,length:n.tags[e].length});return{categories:e,tags:t}}(this.$groupPosts)}}};Gt.component(wl.default),Gt.component(Sl.default);function Tl(n){return n.toString().padStart(2,"0")}t(245);Gt.component("Badge",()=>Promise.all([t.e(0),t.e(3)]).then(t.bind(null,439))),Gt.component("CodeBlock",()=>Promise.resolve().then(t.bind(null,96))),Gt.component("CodeGroup",()=>Promise.resolve().then(t.bind(null,97)));t(246),t(247);var El=t(95),Il=t.n(El),Cl=t(17);let _l,Al,ql;var Ll;"valine"===(Ll="artalk")?t.e(106).then(t.t.bind(null,335,7)).then(n=>Al=n.default):"gitalk"===Ll?Promise.all([t.e(0),t.e(104)]).then(t.t.bind(null,336,7)).then(()=>t.e(102).then(t.t.bind(null,337,7))).then(n=>_l=n.default):"artalk"===Ll&&Promise.all([t.e(0),t.e(103)]).then(t.t.bind(null,338,7)).then(()=>Promise.all([t.e(0),t.e(105)]).then(t.t.bind(null,339,7))).then(()=>t.e(5).then(t.bind(null,340))).then(n=>ql=n.default);function Ml(n,e){const t={};return Reflect.ownKeys(n).forEach(a=>{if("string"==typeof n[a])try{t[a]=Il.a.render(n[a],e)}catch(e){console.warn(`Comment config option error at key named "${a}"`),console.warn("More info: "+e.message),t[a]=n[a]}else t[a]=n[a]}),t}function Dl(n,e){const t=document.querySelector(n);n&&t.classList.add(e)}console.log(`Current frontend version is ${Cl.dependencies.artalk} , plugin version is ${Cl.name}@v${Cl.version} , more details:`,Cl.homepage);const Ol={gitalk:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t);new _l(Ml({server:"https://comment.bozhu12.cc",site:"柏竹"},{frontmatter:n})).render(e)},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}},valine:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t),new Al({...Ml({server:"https://comment.bozhu12.cc",site:"柏竹"},{frontmatter:n}),el:"#"+e})},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}},artalk:{render(n,e){const t=document.createElement("div");t.id=e;document.querySelector("main.page").appendChild(t),new ql({el:"#"+e,pageKey:"",pageTitle:"",server:"https://comment.bozhu12.cc",site:"柏竹"}),function(){const n=setInterval((function(){const e=document.querySelectorAll(".atk-plug-btn");e&&e.length>0&&(3===e.length?(console.log("Artalk自带图片已开启"),{server:"https://comment.bozhu12.cc",site:"柏竹"}.disableEmotion&&Dl(".atk-plug-btn:nth-child(1)","atk-plug-btn-emo-hidden"),{server:"https://comment.bozhu12.cc",site:"柏竹"}.disablePicture&&Dl(".atk-plug-btn:nth-child(2)","atk-plug-btn-pic-hidden"),{server:"https://comment.bozhu12.cc",site:"柏竹"}.disablePreview&&Dl(".atk-plug-btn:nth-child(3)","atk-plug-btn-pre-hidden")):(console.log("Artalk自带图片已关闭"),{server:"https://comment.bozhu12.cc",site:"柏竹"}.disableEmotion&&Dl(".atk-plug-btn:nth-child(1)","atk-plug-btn-emo-hidden"),{server:"https://comment.bozhu12.cc",site:"柏竹"}.disablePreview&&Dl(".atk-plug-btn:nth-child(2)","atk-plug-btn-pre-hidden")),clearInterval(n))}),500)}()},clear(n){const e=document.querySelector("#"+n);return e&&e.remove(),!0}}},Rl="vuepress-plugin-vdoing-comment";let Pl=null;function Bl(n){return Ol.artalk.clear(Rl)}function zl(n){return!1!==n.comment&&!1!==n.comments}function Nl(n){clearTimeout(Pl);if(document.querySelector("main.page"))return Ol.artalk.render(n,Rl);Pl=setTimeout(()=>Nl(n),200)}var Ul={mounted(){Pl=setTimeout(()=>{const n={to:{},from:{},...this.$frontmatter};Bl()&&zl(n)&&Nl(n)},1e3),this.$router.afterEach((n,e)=>{if(n&&e&&n.path===e.path)return;const t={to:n,from:e,...this.$frontmatter};Bl()&&zl(t)&&Nl(t)})}},Fl=Object(vl.a)(Ul,(function(){return(0,this._self._c)("div")}),[],!1,null,null,null).exports,Jl=[({Vue:n,options:e,router:t,siteData:a})=>{},({Vue:n,options:e,router:t,siteData:a})=>{a.pages.map(n=>{const{frontmatter:{date:e,author:t}}=n;"string"==typeof e&&"Z"===e.charAt(e.length-1)&&(n.frontmatter.date=function(n){n instanceof Date||(n=new Date(n));return`${n.getUTCFullYear()}-${Tl(n.getUTCMonth()+1)}-${Tl(n.getUTCDate())} ${Tl(n.getUTCHours())}:${Tl(n.getUTCMinutes())}:${Tl(n.getUTCSeconds())}`}(e)),t?n.author=t:a.themeConfig.author&&(n.author=a.themeConfig.author)}),n.mixin(kl)},{},({Vue:n})=>{n.mixin({computed:{$dataBlock(){return this.$options.__data__block__}}})},{},{},({router:n})=>{"undefined"!=typeof window&&function(){var n=document.createElement("script"),e=window.location.protocol.split(":")[0];n.src="https"===e?"https://zz.bdstatic.com/linksubmit/push.js":"http://push.zhanzhang.baidu.com/push.js";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(n,t)}()},({router:n})=>{"undefined"!=typeof window&&(window._hmt=window._hmt||[],function(){var n=document.createElement("script");n.src="https://hm.baidu.com/hm.js?503f098e7e5b3a5b5d8c5fc2938af002";var e=document.getElementsByTagName("script")[0];e.parentNode.insertBefore(n,e)}(),n.afterEach((function(n){_hmt.push(["_trackPageview",n.fullPath])})))},({Vue:n})=>{n.component("Comment",Fl)}],$l=["Comment"];class Hl extends class{constructor(){this.store=new Gt({data:{state:{}}})}$get(n){return this.store.state[n]}$set(n,e){Gt.set(this.store.state,n,e)}$emit(...n){this.store.$emit(...n)}$on(...n){this.store.$on(...n)}}{}Object.assign(Hl.prototype,{getPageAsyncComponent:os,getLayoutAsyncComponent:ss,getAsyncComponent:ls,getVueComponent:cs});var Gl={install(n){const e=new Hl;n.$vuepress=e,n.prototype.$vuepress=e}};function Vl(n,e){const t=e.toLowerCase();return n.options.routes.some(n=>n.path.toLowerCase()===t)}var Wl={props:{pageKey:String,slotKey:{type:String,default:"default"}},render(n){const e=this.pageKey||this.$parent.$page.key;return ds("pageKey",e),Gt.component(e)||Gt.component(e,os(e)),Gt.component(e)?n(e):n("")}},Ql={functional:!0,props:{slotKey:String,required:!0},render:(n,{props:e,slots:t})=>n("div",{class:["content__"+e.slotKey]},t()[e.slotKey])},Xl={computed:{openInNewWindowTitle(){return this.$themeLocaleConfig.openNewWindowText||"(opens new window)"}}},Kl=(t(253),t(254),Object(vl.a)(Xl,(function(){var n=this._self._c;return n("span",[n("svg",{staticClass:"icon outbound",attrs:{xmlns:"http://www.w3.org/2000/svg","aria-hidden":"true",focusable:"false",x:"0px",y:"0px",viewBox:"0 0 100 100",width:"15",height:"15"}},[n("path",{attrs:{fill:"currentColor",d:"M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"}}),this._v(" "),n("polygon",{attrs:{fill:"currentColor",points:"45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"}})]),this._v(" "),n("span",{staticClass:"sr-only"},[this._v(this._s(this.openInNewWindowTitle))])])}),[],!1,null,null,null).exports),Yl={functional:!0,render(n,{parent:e,children:t}){if(e._isMounted)return t;e.$once("hook:mounted",()=>{e.$forceUpdate()})}};Gt.config.productionTip=!1,Gt.use($o),Gt.use(Gl),Gt.mixin(function(n,e,t=Gt){!function(n){n.locales&&Object.keys(n.locales).forEach(e=>{n.locales[e].path=e});Object.freeze(n)}(e),t.$vuepress.$set("siteData",e);const a=new(n(t.$vuepress.$get("siteData"))),r=Object.getOwnPropertyDescriptors(Object.getPrototypeOf(a)),i={};return Object.keys(r).reduce((n,e)=>(e.startsWith("$")&&(n[e]=r[e].get),n),i),{computed:i}}(n=>class{setPage(n){this.__page=n}get $site(){return n}get $themeConfig(){return this.$site.themeConfig}get $frontmatter(){return this.$page.frontmatter}get $localeConfig(){const{locales:n={}}=this.$site;let e,t;for(const a in n)"/"===a?t=n[a]:0===this.$page.path.indexOf(a)&&(e=n[a]);return e||t||{}}get $siteTitle(){return this.$localeConfig.title||this.$site.title||""}get $canonicalUrl(){const{canonicalUrl:n}=this.$page.frontmatter;return"string"==typeof n&&n}get $title(){const n=this.$page,{metaTitle:e}=this.$page.frontmatter;if("string"==typeof e)return e;const t=this.$siteTitle,a=n.frontmatter.home?null:n.frontmatter.title||n.title;return t?a?a+" | "+t:t:a||"VuePress"}get $description(){const n=function(n){if(n){const e=n.filter(n=>"description"===n.name)[0];if(e)return e.content}}(this.$page.frontmatter.meta);return n||(this.$page.frontmatter.description||this.$localeConfig.description||this.$site.description||"")}get $lang(){return this.$page.frontmatter.lang||this.$localeConfig.lang||"en-US"}get $localePath(){return this.$localeConfig.path||"/"}get $themeLocaleConfig(){return(this.$site.themeConfig.locales||{})[this.$localePath]||{}}get $page(){return this.__page?this.__page:function(n,e){for(let t=0;t<n.length;t++){const a=n[t];if(a.path.toLowerCase()===e.toLowerCase())return a}return{path:"",frontmatter:{}}}(this.$site.pages,this.$route.path)}},xl)),Gt.component("Content",Wl),Gt.component("ContentSlotsDistributor",Ql),Gt.component("OutboundLink",Kl),Gt.component("ClientOnly",Yl),Gt.component("Layout",ss("Layout")),Gt.component("NotFound",ss("NotFound")),Gt.prototype.$withBase=function(n){const e=this.$site.base;return"/"===n.charAt(0)?e+n.slice(1):n},window.__VUEPRESS__={version:"1.9.5",hash:"319ed33"},async function(n){const e="undefined"!=typeof window&&window.__VUEPRESS_ROUTER_BASE__?window.__VUEPRESS_ROUTER_BASE__:xl.routerBase||xl.base,t=new $o({base:e,mode:"history",fallback:!1,routes:yl,scrollBehavior:(n,e,t)=>t||(n.hash?!Gt.$vuepress.$get("disableScrollBehavior")&&{selector:decodeURIComponent(n.hash)}:{x:0,y:0})});!function(n){n.beforeEach((e,t,a)=>{if(Vl(n,e.path))a();else if(/(\/|\.html)$/.test(e.path))if(/\/$/.test(e.path)){const t=e.path.replace(/\/$/,"")+".html";Vl(n,t)?a(t):a()}else a();else{const t=e.path+"/",r=e.path+".html";Vl(n,r)?a(r):Vl(n,t)?a(t):a()}})}(t);const a={};try{await Promise.all(Jl.filter(n=>"function"==typeof n).map(e=>e({Vue:Gt,options:a,router:t,siteData:xl,isServer:n})))}catch(n){console.error(n)}return{app:new Gt(Object.assign(a,{router:t,render:n=>n("div",{attrs:{id:"app"}},[n("RouterView",{ref:"layout"}),n("div",{class:"global-ui"},$l.map(e=>n(e)))])})),router:t}}(!1).then(({app:n,router:e})=>{e.onReady(()=>{n.$mount("#app")})})}]);